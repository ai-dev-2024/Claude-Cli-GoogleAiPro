"use strict";
var qN = Object.create;
var ul = Object.defineProperty;
var zN = Object.getOwnPropertyDescriptor;
var BN = Object.getOwnPropertyNames;
var HN = Object.getPrototypeOf,
  VN = Object.prototype.hasOwnProperty;
var j = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports),
  Hp = (t, e) => {
    for (var r in e) ul(t, r, { get: e[r], enumerable: !0 });
  },
  rb = (t, e, r, n) => {
    if ((e && typeof e == "object") || typeof e == "function")
      for (let s of BN(e))
        !VN.call(t, s) &&
          s !== r &&
          ul(t, s, {
            get: () => e[s],
            enumerable: !(n = zN(e, s)) || n.enumerable,
          });
    return t;
  };
var le = (t, e, r) => (
    (r = t != null ? qN(HN(t)) : {}),
    rb(
      e || !t || !t.__esModule
        ? ul(r, "default", { value: t, enumerable: !0 })
        : r,
      t,
    )
  ),
  ZN = (t) => rb(ul({}, "__esModule", { value: !0 }), t);
var cb = j((kee, ob) => {
  ob.exports = ib;
  ib.sync = WN;
  var sb = require("fs");
  function GN(t, e) {
    var r = e.pathExt !== void 0 ? e.pathExt : process.env.PATHEXT;
    if (!r || ((r = r.split(";")), r.indexOf("") !== -1)) return !0;
    for (var n = 0; n < r.length; n++) {
      var s = r[n].toLowerCase();
      if (s && t.substr(-s.length).toLowerCase() === s) return !0;
    }
    return !1;
  }
  function ab(t, e, r) {
    return !t.isSymbolicLink() && !t.isFile() ? !1 : GN(e, r);
  }
  function ib(t, e, r) {
    sb.stat(t, function (n, s) {
      r(n, n ? !1 : ab(s, t, e));
    });
  }
  function WN(t, e) {
    return ab(sb.statSync(t), t, e);
  }
});
var fb = j((Ree, pb) => {
  pb.exports = ub;
  ub.sync = KN;
  var lb = require("fs");
  function ub(t, e, r) {
    lb.stat(t, function (n, s) {
      r(n, n ? !1 : db(s, e));
    });
  }
  function KN(t, e) {
    return db(lb.statSync(t), e);
  }
  function db(t, e) {
    return t.isFile() && JN(t, e);
  }
  function JN(t, e) {
    var r = t.mode,
      n = t.uid,
      s = t.gid,
      a = e.uid !== void 0 ? e.uid : process.getuid && process.getuid(),
      i = e.gid !== void 0 ? e.gid : process.getgid && process.getgid(),
      o = parseInt("100", 8),
      c = parseInt("010", 8),
      l = parseInt("001", 8),
      u = o | c,
      d =
        r & l || (r & c && s === i) || (r & o && n === a) || (r & u && a === 0);
    return d;
  }
});
var hb = j((Iee, mb) => {
  var Oee = require("fs"),
    dl;
  process.platform === "win32" || global.TESTING_WINDOWS
    ? (dl = cb())
    : (dl = fb());
  mb.exports = Vp;
  Vp.sync = XN;
  function Vp(t, e, r) {
    if ((typeof e == "function" && ((r = e), (e = {})), !r)) {
      if (typeof Promise != "function")
        throw new TypeError("callback not provided");
      return new Promise(function (n, s) {
        Vp(t, e || {}, function (a, i) {
          a ? s(a) : n(i);
        });
      });
    }
    dl(t, e || {}, function (n, s) {
      (n &&
        (n.code === "EACCES" || (e && e.ignoreErrors)) &&
        ((n = null), (s = !1)),
        r(n, s));
    });
  }
  function XN(t, e) {
    try {
      return dl.sync(t, e || {});
    } catch (r) {
      if ((e && e.ignoreErrors) || r.code === "EACCES") return !1;
      throw r;
    }
  }
});
var wb = j(($ee, xb) => {
  var Ka =
      process.platform === "win32" ||
      process.env.OSTYPE === "cygwin" ||
      process.env.OSTYPE === "msys",
    gb = require("path"),
    YN = Ka ? ";" : ":",
    vb = hb(),
    yb = (t) => Object.assign(new Error(`not found: ${t}`), { code: "ENOENT" }),
    bb = (t, e) => {
      let r = e.colon || YN,
        n =
          t.match(/\//) || (Ka && t.match(/\\/))
            ? [""]
            : [
                ...(Ka ? [process.cwd()] : []),
                ...(e.path || process.env.PATH || "").split(r),
              ],
        s = Ka ? e.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "",
        a = Ka ? s.split(r) : [""];
      return (
        Ka && t.indexOf(".") !== -1 && a[0] !== "" && a.unshift(""),
        { pathEnv: n, pathExt: a, pathExtExe: s }
      );
    },
    _b = (t, e, r) => {
      (typeof e == "function" && ((r = e), (e = {})), e || (e = {}));
      let { pathEnv: n, pathExt: s, pathExtExe: a } = bb(t, e),
        i = [],
        o = (l) =>
          new Promise((u, d) => {
            if (l === n.length) return e.all && i.length ? u(i) : d(yb(t));
            let m = n[l],
              p = /^".*"$/.test(m) ? m.slice(1, -1) : m,
              f = gb.join(p, t),
              y = !p && /^\.[\\\/]/.test(t) ? t.slice(0, 2) + f : f;
            u(c(y, l, 0));
          }),
        c = (l, u, d) =>
          new Promise((m, p) => {
            if (d === s.length) return m(o(u + 1));
            let f = s[d];
            vb(l + f, { pathExt: a }, (y, h) => {
              if (!y && h)
                if (e.all) i.push(l + f);
                else return m(l + f);
              return m(c(l, u, d + 1));
            });
          });
      return r ? o(0).then((l) => r(null, l), r) : o(0);
    },
    QN = (t, e) => {
      e = e || {};
      let { pathEnv: r, pathExt: n, pathExtExe: s } = bb(t, e),
        a = [];
      for (let i = 0; i < r.length; i++) {
        let o = r[i],
          c = /^".*"$/.test(o) ? o.slice(1, -1) : o,
          l = gb.join(c, t),
          u = !c && /^\.[\\\/]/.test(t) ? t.slice(0, 2) + l : l;
        for (let d = 0; d < n.length; d++) {
          let m = u + n[d];
          try {
            if (vb.sync(m, { pathExt: s }))
              if (e.all) a.push(m);
              else return m;
          } catch {}
        }
      }
      if (e.all && a.length) return a;
      if (e.nothrow) return null;
      throw yb(t);
    };
  xb.exports = _b;
  _b.sync = QN;
});
var Eb = j((Aee, Zp) => {
  "use strict";
  var Sb = (t = {}) => {
    let e = t.env || process.env;
    return (t.platform || process.platform) !== "win32"
      ? "PATH"
      : Object.keys(e)
          .reverse()
          .find((n) => n.toUpperCase() === "PATH") || "Path";
  };
  Zp.exports = Sb;
  Zp.exports.default = Sb;
});
var kb = j((Nee, Pb) => {
  "use strict";
  var Tb = require("path"),
    eD = wb(),
    tD = Eb();
  function Cb(t, e) {
    let r = t.options.env || process.env,
      n = process.cwd(),
      s = t.options.cwd != null,
      a = s && process.chdir !== void 0 && !process.chdir.disabled;
    if (a)
      try {
        process.chdir(t.options.cwd);
      } catch {}
    let i;
    try {
      i = eD.sync(t.command, {
        path: r[tD({ env: r })],
        pathExt: e ? Tb.delimiter : void 0,
      });
    } catch {
    } finally {
      a && process.chdir(n);
    }
    return (i && (i = Tb.resolve(s ? t.options.cwd : "", i)), i);
  }
  function rD(t) {
    return Cb(t) || Cb(t, !0);
  }
  Pb.exports = rD;
});
var Rb = j((Dee, Wp) => {
  "use strict";
  var Gp = /([()\][%!^"`<>&|;, *?])/g;
  function nD(t) {
    return ((t = t.replace(Gp, "^$1")), t);
  }
  function sD(t, e) {
    return (
      (t = `${t}`),
      (t = t.replace(/(?=(\\+?)?)\1"/g, '$1$1\\"')),
      (t = t.replace(/(?=(\\+?)?)\1$/, "$1$1")),
      (t = `"${t}"`),
      (t = t.replace(Gp, "^$1")),
      e && (t = t.replace(Gp, "^$1")),
      t
    );
  }
  Wp.exports.command = nD;
  Wp.exports.argument = sD;
});
var Ib = j((Lee, Ob) => {
  "use strict";
  Ob.exports = /^#!(.*)/;
});
var Ab = j((Mee, $b) => {
  "use strict";
  var aD = Ib();
  $b.exports = (t = "") => {
    let e = t.match(aD);
    if (!e) return null;
    let [r, n] = e[0].replace(/#! ?/, "").split(" "),
      s = r.split("/").pop();
    return s === "env" ? n : n ? `${s} ${n}` : s;
  };
});
var Db = j((jee, Nb) => {
  "use strict";
  var Kp = require("fs"),
    iD = Ab();
  function oD(t) {
    let r = Buffer.alloc(150),
      n;
    try {
      ((n = Kp.openSync(t, "r")),
        Kp.readSync(n, r, 0, 150, 0),
        Kp.closeSync(n));
    } catch {}
    return iD(r.toString());
  }
  Nb.exports = oD;
});
var Fb = j((Fee, jb) => {
  "use strict";
  var cD = require("path"),
    Lb = kb(),
    Mb = Rb(),
    lD = Db(),
    uD = process.platform === "win32",
    dD = /\.(?:com|exe)$/i,
    pD = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
  function fD(t) {
    t.file = Lb(t);
    let e = t.file && lD(t.file);
    return e ? (t.args.unshift(t.file), (t.command = e), Lb(t)) : t.file;
  }
  function mD(t) {
    if (!uD) return t;
    let e = fD(t),
      r = !dD.test(e);
    if (t.options.forceShell || r) {
      let n = pD.test(e);
      ((t.command = cD.normalize(t.command)),
        (t.command = Mb.command(t.command)),
        (t.args = t.args.map((a) => Mb.argument(a, n))));
      let s = [t.command].concat(t.args).join(" ");
      ((t.args = ["/d", "/s", "/c", `"${s}"`]),
        (t.command = process.env.comspec || "cmd.exe"),
        (t.options.windowsVerbatimArguments = !0));
    }
    return t;
  }
  function hD(t, e, r) {
    (e && !Array.isArray(e) && ((r = e), (e = null)),
      (e = e ? e.slice(0) : []),
      (r = Object.assign({}, r)));
    let n = {
      command: t,
      args: e,
      options: r,
      file: void 0,
      original: { command: t, args: e },
    };
    return r.shell ? n : mD(n);
  }
  jb.exports = hD;
});
var zb = j((Uee, qb) => {
  "use strict";
  var Jp = process.platform === "win32";
  function Xp(t, e) {
    return Object.assign(new Error(`${e} ${t.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${e} ${t.command}`,
      path: t.command,
      spawnargs: t.args,
    });
  }
  function gD(t, e) {
    if (!Jp) return;
    let r = t.emit;
    t.emit = function (n, s) {
      if (n === "exit") {
        let a = Ub(s, e);
        if (a) return r.call(t, "error", a);
      }
      return r.apply(t, arguments);
    };
  }
  function Ub(t, e) {
    return Jp && t === 1 && !e.file ? Xp(e.original, "spawn") : null;
  }
  function vD(t, e) {
    return Jp && t === 1 && !e.file ? Xp(e.original, "spawnSync") : null;
  }
  qb.exports = {
    hookChildProcess: gD,
    verifyENOENT: Ub,
    verifyENOENTSync: vD,
    notFoundError: Xp,
  };
});
var ef = j((qee, Ja) => {
  "use strict";
  var Bb = require("child_process"),
    Yp = Fb(),
    Qp = zb();
  function Hb(t, e, r) {
    let n = Yp(t, e, r),
      s = Bb.spawn(n.command, n.args, n.options);
    return (Qp.hookChildProcess(s, n), s);
  }
  function yD(t, e, r) {
    let n = Yp(t, e, r),
      s = Bb.spawnSync(n.command, n.args, n.options);
    return ((s.error = s.error || Qp.verifyENOENTSync(s.status, n)), s);
  }
  Ja.exports = Hb;
  Ja.exports.spawn = Hb;
  Ja.exports.sync = yD;
  Ja.exports._parse = Yp;
  Ja.exports._enoent = Qp;
});
var S_ = j((Lte, w_) => {
  "use strict";
  var { PassThrough: uL } = require("stream");
  w_.exports = function () {
    var t = [],
      e = new uL({ objectMode: !0 });
    return (
      e.setMaxListeners(0),
      (e.add = r),
      (e.isEmpty = n),
      e.on("unpipe", s),
      Array.prototype.slice.call(arguments).forEach(r),
      e
    );
    function r(a) {
      return Array.isArray(a)
        ? (a.forEach(r), this)
        : (t.push(a),
          a.once("end", s.bind(null, a)),
          a.once("error", e.emit.bind(e, "error")),
          a.pipe(e, { end: !1 }),
          this);
    }
    function n() {
      return t.length == 0;
    }
    function s(a) {
      ((t = t.filter(function (i) {
        return i !== a;
      })),
        !t.length && e.readable && e.end());
    }
  };
});
var Oo = j((sre, G_) => {
  "use strict";
  var EL = "2.0.0",
    TL = Number.MAX_SAFE_INTEGER || 9007199254740991,
    CL = 16,
    PL = 250,
    kL = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease",
    ];
  G_.exports = {
    MAX_LENGTH: 256,
    MAX_SAFE_COMPONENT_LENGTH: CL,
    MAX_SAFE_BUILD_LENGTH: PL,
    MAX_SAFE_INTEGER: TL,
    RELEASE_TYPES: kL,
    SEMVER_SPEC_VERSION: EL,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2,
  };
});
var Io = j((are, W_) => {
  "use strict";
  var RL =
    typeof process == "object" &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)
      ? (...t) => console.error("SEMVER", ...t)
      : () => {};
  W_.exports = RL;
});
var Ya = j((Cn, K_) => {
  "use strict";
  var {
      MAX_SAFE_COMPONENT_LENGTH: Cf,
      MAX_SAFE_BUILD_LENGTH: OL,
      MAX_LENGTH: IL,
    } = Oo(),
    $L = Io();
  Cn = K_.exports = {};
  var AL = (Cn.re = []),
    NL = (Cn.safeRe = []),
    be = (Cn.src = []),
    DL = (Cn.safeSrc = []),
    _e = (Cn.t = {}),
    LL = 0,
    Pf = "[a-zA-Z0-9-]",
    ML = [
      ["\\s", 1],
      ["\\d", IL],
      [Pf, OL],
    ],
    jL = (t) => {
      for (let [e, r] of ML)
        t = t
          .split(`${e}*`)
          .join(`${e}{0,${r}}`)
          .split(`${e}+`)
          .join(`${e}{1,${r}}`);
      return t;
    },
    qe = (t, e, r) => {
      let n = jL(e),
        s = LL++;
      ($L(t, s, e),
        (_e[t] = s),
        (be[s] = e),
        (DL[s] = n),
        (AL[s] = new RegExp(e, r ? "g" : void 0)),
        (NL[s] = new RegExp(n, r ? "g" : void 0)));
    };
  qe("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  qe("NUMERICIDENTIFIERLOOSE", "\\d+");
  qe("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${Pf}*`);
  qe(
    "MAINVERSION",
    `(${be[_e.NUMERICIDENTIFIER]})\\.(${be[_e.NUMERICIDENTIFIER]})\\.(${be[_e.NUMERICIDENTIFIER]})`,
  );
  qe(
    "MAINVERSIONLOOSE",
    `(${be[_e.NUMERICIDENTIFIERLOOSE]})\\.(${be[_e.NUMERICIDENTIFIERLOOSE]})\\.(${be[_e.NUMERICIDENTIFIERLOOSE]})`,
  );
  qe(
    "PRERELEASEIDENTIFIER",
    `(?:${be[_e.NONNUMERICIDENTIFIER]}|${be[_e.NUMERICIDENTIFIER]})`,
  );
  qe(
    "PRERELEASEIDENTIFIERLOOSE",
    `(?:${be[_e.NONNUMERICIDENTIFIER]}|${be[_e.NUMERICIDENTIFIERLOOSE]})`,
  );
  qe(
    "PRERELEASE",
    `(?:-(${be[_e.PRERELEASEIDENTIFIER]}(?:\\.${be[_e.PRERELEASEIDENTIFIER]})*))`,
  );
  qe(
    "PRERELEASELOOSE",
    `(?:-?(${be[_e.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${be[_e.PRERELEASEIDENTIFIERLOOSE]})*))`,
  );
  qe("BUILDIDENTIFIER", `${Pf}+`);
  qe(
    "BUILD",
    `(?:\\+(${be[_e.BUILDIDENTIFIER]}(?:\\.${be[_e.BUILDIDENTIFIER]})*))`,
  );
  qe(
    "FULLPLAIN",
    `v?${be[_e.MAINVERSION]}${be[_e.PRERELEASE]}?${be[_e.BUILD]}?`,
  );
  qe("FULL", `^${be[_e.FULLPLAIN]}$`);
  qe(
    "LOOSEPLAIN",
    `[v=\\s]*${be[_e.MAINVERSIONLOOSE]}${be[_e.PRERELEASELOOSE]}?${be[_e.BUILD]}?`,
  );
  qe("LOOSE", `^${be[_e.LOOSEPLAIN]}$`);
  qe("GTLT", "((?:<|>)?=?)");
  qe("XRANGEIDENTIFIERLOOSE", `${be[_e.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  qe("XRANGEIDENTIFIER", `${be[_e.NUMERICIDENTIFIER]}|x|X|\\*`);
  qe(
    "XRANGEPLAIN",
    `[v=\\s]*(${be[_e.XRANGEIDENTIFIER]})(?:\\.(${be[_e.XRANGEIDENTIFIER]})(?:\\.(${be[_e.XRANGEIDENTIFIER]})(?:${be[_e.PRERELEASE]})?${be[_e.BUILD]}?)?)?`,
  );
  qe(
    "XRANGEPLAINLOOSE",
    `[v=\\s]*(${be[_e.XRANGEIDENTIFIERLOOSE]})(?:\\.(${be[_e.XRANGEIDENTIFIERLOOSE]})(?:\\.(${be[_e.XRANGEIDENTIFIERLOOSE]})(?:${be[_e.PRERELEASELOOSE]})?${be[_e.BUILD]}?)?)?`,
  );
  qe("XRANGE", `^${be[_e.GTLT]}\\s*${be[_e.XRANGEPLAIN]}$`);
  qe("XRANGELOOSE", `^${be[_e.GTLT]}\\s*${be[_e.XRANGEPLAINLOOSE]}$`);
  qe(
    "COERCEPLAIN",
    `(^|[^\\d])(\\d{1,${Cf}})(?:\\.(\\d{1,${Cf}}))?(?:\\.(\\d{1,${Cf}}))?`,
  );
  qe("COERCE", `${be[_e.COERCEPLAIN]}(?:$|[^\\d])`);
  qe(
    "COERCEFULL",
    be[_e.COERCEPLAIN] +
      `(?:${be[_e.PRERELEASE]})?(?:${be[_e.BUILD]})?(?:$|[^\\d])`,
  );
  qe("COERCERTL", be[_e.COERCE], !0);
  qe("COERCERTLFULL", be[_e.COERCEFULL], !0);
  qe("LONETILDE", "(?:~>?)");
  qe("TILDETRIM", `(\\s*)${be[_e.LONETILDE]}\\s+`, !0);
  Cn.tildeTrimReplace = "$1~";
  qe("TILDE", `^${be[_e.LONETILDE]}${be[_e.XRANGEPLAIN]}$`);
  qe("TILDELOOSE", `^${be[_e.LONETILDE]}${be[_e.XRANGEPLAINLOOSE]}$`);
  qe("LONECARET", "(?:\\^)");
  qe("CARETTRIM", `(\\s*)${be[_e.LONECARET]}\\s+`, !0);
  Cn.caretTrimReplace = "$1^";
  qe("CARET", `^${be[_e.LONECARET]}${be[_e.XRANGEPLAIN]}$`);
  qe("CARETLOOSE", `^${be[_e.LONECARET]}${be[_e.XRANGEPLAINLOOSE]}$`);
  qe("COMPARATORLOOSE", `^${be[_e.GTLT]}\\s*(${be[_e.LOOSEPLAIN]})$|^$`);
  qe("COMPARATOR", `^${be[_e.GTLT]}\\s*(${be[_e.FULLPLAIN]})$|^$`);
  qe(
    "COMPARATORTRIM",
    `(\\s*)${be[_e.GTLT]}\\s*(${be[_e.LOOSEPLAIN]}|${be[_e.XRANGEPLAIN]})`,
    !0,
  );
  Cn.comparatorTrimReplace = "$1$2$3";
  qe(
    "HYPHENRANGE",
    `^\\s*(${be[_e.XRANGEPLAIN]})\\s+-\\s+(${be[_e.XRANGEPLAIN]})\\s*$`,
  );
  qe(
    "HYPHENRANGELOOSE",
    `^\\s*(${be[_e.XRANGEPLAINLOOSE]})\\s+-\\s+(${be[_e.XRANGEPLAINLOOSE]})\\s*$`,
  );
  qe("STAR", "(<|>)?=?\\s*\\*");
  qe("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  qe("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});
var Cl = j((ire, J_) => {
  "use strict";
  var FL = Object.freeze({ loose: !0 }),
    UL = Object.freeze({}),
    qL = (t) => (t ? (typeof t != "object" ? FL : t) : UL);
  J_.exports = qL;
});
var kf = j((ore, Q_) => {
  "use strict";
  var X_ = /^[0-9]+$/,
    Y_ = (t, e) => {
      let r = X_.test(t),
        n = X_.test(e);
      return (
        r && n && ((t = +t), (e = +e)),
        t === e ? 0 : r && !n ? -1 : n && !r ? 1 : t < e ? -1 : 1
      );
    },
    zL = (t, e) => Y_(e, t);
  Q_.exports = { compareIdentifiers: Y_, rcompareIdentifiers: zL };
});
var sr = j((cre, tx) => {
  "use strict";
  var Pl = Io(),
    { MAX_LENGTH: ex, MAX_SAFE_INTEGER: kl } = Oo(),
    { safeRe: Rl, t: Ol } = Ya(),
    BL = Cl(),
    { compareIdentifiers: Qa } = kf(),
    Rf = class t {
      constructor(e, r) {
        if (((r = BL(r)), e instanceof t)) {
          if (
            e.loose === !!r.loose &&
            e.includePrerelease === !!r.includePrerelease
          )
            return e;
          e = e.version;
        } else if (typeof e != "string")
          throw new TypeError(
            `Invalid version. Must be a string. Got type "${typeof e}".`,
          );
        if (e.length > ex)
          throw new TypeError(`version is longer than ${ex} characters`);
        (Pl("SemVer", e, r),
          (this.options = r),
          (this.loose = !!r.loose),
          (this.includePrerelease = !!r.includePrerelease));
        let n = e.trim().match(r.loose ? Rl[Ol.LOOSE] : Rl[Ol.FULL]);
        if (!n) throw new TypeError(`Invalid Version: ${e}`);
        if (
          ((this.raw = e),
          (this.major = +n[1]),
          (this.minor = +n[2]),
          (this.patch = +n[3]),
          this.major > kl || this.major < 0)
        )
          throw new TypeError("Invalid major version");
        if (this.minor > kl || this.minor < 0)
          throw new TypeError("Invalid minor version");
        if (this.patch > kl || this.patch < 0)
          throw new TypeError("Invalid patch version");
        (n[4]
          ? (this.prerelease = n[4].split(".").map((s) => {
              if (/^[0-9]+$/.test(s)) {
                let a = +s;
                if (a >= 0 && a < kl) return a;
              }
              return s;
            }))
          : (this.prerelease = []),
          (this.build = n[5] ? n[5].split(".") : []),
          this.format());
      }
      format() {
        return (
          (this.version = `${this.major}.${this.minor}.${this.patch}`),
          this.prerelease.length &&
            (this.version += `-${this.prerelease.join(".")}`),
          this.version
        );
      }
      toString() {
        return this.version;
      }
      compare(e) {
        if (
          (Pl("SemVer.compare", this.version, this.options, e),
          !(e instanceof t))
        ) {
          if (typeof e == "string" && e === this.version) return 0;
          e = new t(e, this.options);
        }
        return e.version === this.version
          ? 0
          : this.compareMain(e) || this.comparePre(e);
      }
      compareMain(e) {
        return (
          e instanceof t || (e = new t(e, this.options)),
          Qa(this.major, e.major) ||
            Qa(this.minor, e.minor) ||
            Qa(this.patch, e.patch)
        );
      }
      comparePre(e) {
        if (
          (e instanceof t || (e = new t(e, this.options)),
          this.prerelease.length && !e.prerelease.length)
        )
          return -1;
        if (!this.prerelease.length && e.prerelease.length) return 1;
        if (!this.prerelease.length && !e.prerelease.length) return 0;
        let r = 0;
        do {
          let n = this.prerelease[r],
            s = e.prerelease[r];
          if ((Pl("prerelease compare", r, n, s), n === void 0 && s === void 0))
            return 0;
          if (s === void 0) return 1;
          if (n === void 0) return -1;
          if (n === s) continue;
          return Qa(n, s);
        } while (++r);
      }
      compareBuild(e) {
        e instanceof t || (e = new t(e, this.options));
        let r = 0;
        do {
          let n = this.build[r],
            s = e.build[r];
          if ((Pl("build compare", r, n, s), n === void 0 && s === void 0))
            return 0;
          if (s === void 0) return 1;
          if (n === void 0) return -1;
          if (n === s) continue;
          return Qa(n, s);
        } while (++r);
      }
      inc(e, r, n) {
        if (e.startsWith("pre")) {
          if (!r && n === !1)
            throw new Error("invalid increment argument: identifier is empty");
          if (r) {
            let s = `-${r}`.match(
              this.options.loose ? Rl[Ol.PRERELEASELOOSE] : Rl[Ol.PRERELEASE],
            );
            if (!s || s[1] !== r) throw new Error(`invalid identifier: ${r}`);
          }
        }
        switch (e) {
          case "premajor":
            ((this.prerelease.length = 0),
              (this.patch = 0),
              (this.minor = 0),
              this.major++,
              this.inc("pre", r, n));
            break;
          case "preminor":
            ((this.prerelease.length = 0),
              (this.patch = 0),
              this.minor++,
              this.inc("pre", r, n));
            break;
          case "prepatch":
            ((this.prerelease.length = 0),
              this.inc("patch", r, n),
              this.inc("pre", r, n));
            break;
          case "prerelease":
            (this.prerelease.length === 0 && this.inc("patch", r, n),
              this.inc("pre", r, n));
            break;
          case "release":
            if (this.prerelease.length === 0)
              throw new Error(`version ${this.raw} is not a prerelease`);
            this.prerelease.length = 0;
            break;
          case "major":
            ((this.minor !== 0 ||
              this.patch !== 0 ||
              this.prerelease.length === 0) &&
              this.major++,
              (this.minor = 0),
              (this.patch = 0),
              (this.prerelease = []));
            break;
          case "minor":
            ((this.patch !== 0 || this.prerelease.length === 0) && this.minor++,
              (this.patch = 0),
              (this.prerelease = []));
            break;
          case "patch":
            (this.prerelease.length === 0 && this.patch++,
              (this.prerelease = []));
            break;
          case "pre": {
            let s = Number(n) ? 1 : 0;
            if (this.prerelease.length === 0) this.prerelease = [s];
            else {
              let a = this.prerelease.length;
              for (; --a >= 0; )
                typeof this.prerelease[a] == "number" &&
                  (this.prerelease[a]++, (a = -2));
              if (a === -1) {
                if (r === this.prerelease.join(".") && n === !1)
                  throw new Error(
                    "invalid increment argument: identifier already exists",
                  );
                this.prerelease.push(s);
              }
            }
            if (r) {
              let a = [r, s];
              (n === !1 && (a = [r]),
                Qa(this.prerelease[0], r) === 0
                  ? isNaN(this.prerelease[1]) && (this.prerelease = a)
                  : (this.prerelease = a));
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${e}`);
        }
        return (
          (this.raw = this.format()),
          this.build.length && (this.raw += `+${this.build.join(".")}`),
          this
        );
      }
    };
  tx.exports = Rf;
});
var Ks = j((lre, nx) => {
  "use strict";
  var rx = sr(),
    HL = (t, e, r = !1) => {
      if (t instanceof rx) return t;
      try {
        return new rx(t, e);
      } catch (n) {
        if (!r) return null;
        throw n;
      }
    };
  nx.exports = HL;
});
var ax = j((ure, sx) => {
  "use strict";
  var VL = Ks(),
    ZL = (t, e) => {
      let r = VL(t, e);
      return r ? r.version : null;
    };
  sx.exports = ZL;
});
var ox = j((dre, ix) => {
  "use strict";
  var GL = Ks(),
    WL = (t, e) => {
      let r = GL(t.trim().replace(/^[=v]+/, ""), e);
      return r ? r.version : null;
    };
  ix.exports = WL;
});
var ux = j((pre, lx) => {
  "use strict";
  var cx = sr(),
    KL = (t, e, r, n, s) => {
      typeof r == "string" && ((s = n), (n = r), (r = void 0));
      try {
        return new cx(t instanceof cx ? t.version : t, r).inc(e, n, s).version;
      } catch {
        return null;
      }
    };
  lx.exports = KL;
});
var fx = j((fre, px) => {
  "use strict";
  var dx = Ks(),
    JL = (t, e) => {
      let r = dx(t, null, !0),
        n = dx(e, null, !0),
        s = r.compare(n);
      if (s === 0) return null;
      let a = s > 0,
        i = a ? r : n,
        o = a ? n : r,
        c = !!i.prerelease.length;
      if (!!o.prerelease.length && !c) {
        if (!o.patch && !o.minor) return "major";
        if (o.compareMain(i) === 0)
          return o.minor && !o.patch ? "minor" : "patch";
      }
      let u = c ? "pre" : "";
      return r.major !== n.major
        ? u + "major"
        : r.minor !== n.minor
          ? u + "minor"
          : r.patch !== n.patch
            ? u + "patch"
            : "prerelease";
    };
  px.exports = JL;
});
var hx = j((mre, mx) => {
  "use strict";
  var XL = sr(),
    YL = (t, e) => new XL(t, e).major;
  mx.exports = YL;
});
var vx = j((hre, gx) => {
  "use strict";
  var QL = sr(),
    eM = (t, e) => new QL(t, e).minor;
  gx.exports = eM;
});
var bx = j((gre, yx) => {
  "use strict";
  var tM = sr(),
    rM = (t, e) => new tM(t, e).patch;
  yx.exports = rM;
});
var xx = j((vre, _x) => {
  "use strict";
  var nM = Ks(),
    sM = (t, e) => {
      let r = nM(t, e);
      return r && r.prerelease.length ? r.prerelease : null;
    };
  _x.exports = sM;
});
var Vr = j((yre, Sx) => {
  "use strict";
  var wx = sr(),
    aM = (t, e, r) => new wx(t, r).compare(new wx(e, r));
  Sx.exports = aM;
});
var Tx = j((bre, Ex) => {
  "use strict";
  var iM = Vr(),
    oM = (t, e, r) => iM(e, t, r);
  Ex.exports = oM;
});
var Px = j((_re, Cx) => {
  "use strict";
  var cM = Vr(),
    lM = (t, e) => cM(t, e, !0);
  Cx.exports = lM;
});
var Il = j((xre, Rx) => {
  "use strict";
  var kx = sr(),
    uM = (t, e, r) => {
      let n = new kx(t, r),
        s = new kx(e, r);
      return n.compare(s) || n.compareBuild(s);
    };
  Rx.exports = uM;
});
var Ix = j((wre, Ox) => {
  "use strict";
  var dM = Il(),
    pM = (t, e) => t.sort((r, n) => dM(r, n, e));
  Ox.exports = pM;
});
var Ax = j((Sre, $x) => {
  "use strict";
  var fM = Il(),
    mM = (t, e) => t.sort((r, n) => fM(n, r, e));
  $x.exports = mM;
});
var $o = j((Ere, Nx) => {
  "use strict";
  var hM = Vr(),
    gM = (t, e, r) => hM(t, e, r) > 0;
  Nx.exports = gM;
});
var $l = j((Tre, Dx) => {
  "use strict";
  var vM = Vr(),
    yM = (t, e, r) => vM(t, e, r) < 0;
  Dx.exports = yM;
});
var Of = j((Cre, Lx) => {
  "use strict";
  var bM = Vr(),
    _M = (t, e, r) => bM(t, e, r) === 0;
  Lx.exports = _M;
});
var If = j((Pre, Mx) => {
  "use strict";
  var xM = Vr(),
    wM = (t, e, r) => xM(t, e, r) !== 0;
  Mx.exports = wM;
});
var Al = j((kre, jx) => {
  "use strict";
  var SM = Vr(),
    EM = (t, e, r) => SM(t, e, r) >= 0;
  jx.exports = EM;
});
var Nl = j((Rre, Fx) => {
  "use strict";
  var TM = Vr(),
    CM = (t, e, r) => TM(t, e, r) <= 0;
  Fx.exports = CM;
});
var $f = j((Ore, Ux) => {
  "use strict";
  var PM = Of(),
    kM = If(),
    RM = $o(),
    OM = Al(),
    IM = $l(),
    $M = Nl(),
    AM = (t, e, r, n) => {
      switch (e) {
        case "===":
          return (
            typeof t == "object" && (t = t.version),
            typeof r == "object" && (r = r.version),
            t === r
          );
        case "!==":
          return (
            typeof t == "object" && (t = t.version),
            typeof r == "object" && (r = r.version),
            t !== r
          );
        case "":
        case "=":
        case "==":
          return PM(t, r, n);
        case "!=":
          return kM(t, r, n);
        case ">":
          return RM(t, r, n);
        case ">=":
          return OM(t, r, n);
        case "<":
          return IM(t, r, n);
        case "<=":
          return $M(t, r, n);
        default:
          throw new TypeError(`Invalid operator: ${e}`);
      }
    };
  Ux.exports = AM;
});
var zx = j((Ire, qx) => {
  "use strict";
  var NM = sr(),
    DM = Ks(),
    { safeRe: Dl, t: Ll } = Ya(),
    LM = (t, e) => {
      if (t instanceof NM) return t;
      if ((typeof t == "number" && (t = String(t)), typeof t != "string"))
        return null;
      e = e || {};
      let r = null;
      if (!e.rtl)
        r = t.match(e.includePrerelease ? Dl[Ll.COERCEFULL] : Dl[Ll.COERCE]);
      else {
        let c = e.includePrerelease ? Dl[Ll.COERCERTLFULL] : Dl[Ll.COERCERTL],
          l;
        for (; (l = c.exec(t)) && (!r || r.index + r[0].length !== t.length); )
          ((!r || l.index + l[0].length !== r.index + r[0].length) && (r = l),
            (c.lastIndex = l.index + l[1].length + l[2].length));
        c.lastIndex = -1;
      }
      if (r === null) return null;
      let n = r[2],
        s = r[3] || "0",
        a = r[4] || "0",
        i = e.includePrerelease && r[5] ? `-${r[5]}` : "",
        o = e.includePrerelease && r[6] ? `+${r[6]}` : "";
      return DM(`${n}.${s}.${a}${i}${o}`, e);
    };
  qx.exports = LM;
});
var Hx = j(($re, Bx) => {
  "use strict";
  var Af = class {
    constructor() {
      ((this.max = 1e3), (this.map = new Map()));
    }
    get(e) {
      let r = this.map.get(e);
      if (r !== void 0) return (this.map.delete(e), this.map.set(e, r), r);
    }
    delete(e) {
      return this.map.delete(e);
    }
    set(e, r) {
      if (!this.delete(e) && r !== void 0) {
        if (this.map.size >= this.max) {
          let s = this.map.keys().next().value;
          this.delete(s);
        }
        this.map.set(e, r);
      }
      return this;
    }
  };
  Bx.exports = Af;
});
var Zr = j((Are, Wx) => {
  "use strict";
  var MM = /\s+/g,
    Nf = class t {
      constructor(e, r) {
        if (((r = FM(r)), e instanceof t))
          return e.loose === !!r.loose &&
            e.includePrerelease === !!r.includePrerelease
            ? e
            : new t(e.raw, r);
        if (e instanceof Df)
          return (
            (this.raw = e.value),
            (this.set = [[e]]),
            (this.formatted = void 0),
            this
          );
        if (
          ((this.options = r),
          (this.loose = !!r.loose),
          (this.includePrerelease = !!r.includePrerelease),
          (this.raw = e.trim().replace(MM, " ")),
          (this.set = this.raw
            .split("||")
            .map((n) => this.parseRange(n.trim()))
            .filter((n) => n.length)),
          !this.set.length)
        )
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        if (this.set.length > 1) {
          let n = this.set[0];
          if (
            ((this.set = this.set.filter((s) => !Zx(s[0]))),
            this.set.length === 0)
          )
            this.set = [n];
          else if (this.set.length > 1) {
            for (let s of this.set)
              if (s.length === 1 && ZM(s[0])) {
                this.set = [s];
                break;
              }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let e = 0; e < this.set.length; e++) {
            e > 0 && (this.formatted += "||");
            let r = this.set[e];
            for (let n = 0; n < r.length; n++)
              (n > 0 && (this.formatted += " "),
                (this.formatted += r[n].toString().trim()));
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(e) {
        let n =
            ((this.options.includePrerelease && HM) |
              (this.options.loose && VM)) +
            ":" +
            e,
          s = Vx.get(n);
        if (s) return s;
        let a = this.options.loose,
          i = a ? gr[ur.HYPHENRANGELOOSE] : gr[ur.HYPHENRANGE];
        ((e = e.replace(i, rj(this.options.includePrerelease))),
          St("hyphen replace", e),
          (e = e.replace(gr[ur.COMPARATORTRIM], qM)),
          St("comparator trim", e),
          (e = e.replace(gr[ur.TILDETRIM], zM)),
          St("tilde trim", e),
          (e = e.replace(gr[ur.CARETTRIM], BM)),
          St("caret trim", e));
        let o = e
          .split(" ")
          .map((d) => GM(d, this.options))
          .join(" ")
          .split(/\s+/)
          .map((d) => tj(d, this.options));
        (a &&
          (o = o.filter(
            (d) => (
              St("loose invalid filter", d, this.options),
              !!d.match(gr[ur.COMPARATORLOOSE])
            ),
          )),
          St("range list", o));
        let c = new Map(),
          l = o.map((d) => new Df(d, this.options));
        for (let d of l) {
          if (Zx(d)) return [d];
          c.set(d.value, d);
        }
        c.size > 1 && c.has("") && c.delete("");
        let u = [...c.values()];
        return (Vx.set(n, u), u);
      }
      intersects(e, r) {
        if (!(e instanceof t)) throw new TypeError("a Range is required");
        return this.set.some(
          (n) =>
            Gx(n, r) &&
            e.set.some(
              (s) =>
                Gx(s, r) && n.every((a) => s.every((i) => a.intersects(i, r))),
            ),
        );
      }
      test(e) {
        if (!e) return !1;
        if (typeof e == "string")
          try {
            e = new UM(e, this.options);
          } catch {
            return !1;
          }
        for (let r = 0; r < this.set.length; r++)
          if (nj(this.set[r], e, this.options)) return !0;
        return !1;
      }
    };
  Wx.exports = Nf;
  var jM = Hx(),
    Vx = new jM(),
    FM = Cl(),
    Df = Ao(),
    St = Io(),
    UM = sr(),
    {
      safeRe: gr,
      t: ur,
      comparatorTrimReplace: qM,
      tildeTrimReplace: zM,
      caretTrimReplace: BM,
    } = Ya(),
    { FLAG_INCLUDE_PRERELEASE: HM, FLAG_LOOSE: VM } = Oo(),
    Zx = (t) => t.value === "<0.0.0-0",
    ZM = (t) => t.value === "",
    Gx = (t, e) => {
      let r = !0,
        n = t.slice(),
        s = n.pop();
      for (; r && n.length; )
        ((r = n.every((a) => s.intersects(a, e))), (s = n.pop()));
      return r;
    },
    GM = (t, e) => (
      St("comp", t, e),
      (t = JM(t, e)),
      St("caret", t),
      (t = WM(t, e)),
      St("tildes", t),
      (t = YM(t, e)),
      St("xrange", t),
      (t = ej(t, e)),
      St("stars", t),
      t
    ),
    dr = (t) => !t || t.toLowerCase() === "x" || t === "*",
    WM = (t, e) =>
      t
        .trim()
        .split(/\s+/)
        .map((r) => KM(r, e))
        .join(" "),
    KM = (t, e) => {
      let r = e.loose ? gr[ur.TILDELOOSE] : gr[ur.TILDE];
      return t.replace(r, (n, s, a, i, o) => {
        St("tilde", t, n, s, a, i, o);
        let c;
        return (
          dr(s)
            ? (c = "")
            : dr(a)
              ? (c = `>=${s}.0.0 <${+s + 1}.0.0-0`)
              : dr(i)
                ? (c = `>=${s}.${a}.0 <${s}.${+a + 1}.0-0`)
                : o
                  ? (St("replaceTilde pr", o),
                    (c = `>=${s}.${a}.${i}-${o} <${s}.${+a + 1}.0-0`))
                  : (c = `>=${s}.${a}.${i} <${s}.${+a + 1}.0-0`),
          St("tilde return", c),
          c
        );
      });
    },
    JM = (t, e) =>
      t
        .trim()
        .split(/\s+/)
        .map((r) => XM(r, e))
        .join(" "),
    XM = (t, e) => {
      St("caret", t, e);
      let r = e.loose ? gr[ur.CARETLOOSE] : gr[ur.CARET],
        n = e.includePrerelease ? "-0" : "";
      return t.replace(r, (s, a, i, o, c) => {
        St("caret", t, s, a, i, o, c);
        let l;
        return (
          dr(a)
            ? (l = "")
            : dr(i)
              ? (l = `>=${a}.0.0${n} <${+a + 1}.0.0-0`)
              : dr(o)
                ? a === "0"
                  ? (l = `>=${a}.${i}.0${n} <${a}.${+i + 1}.0-0`)
                  : (l = `>=${a}.${i}.0${n} <${+a + 1}.0.0-0`)
                : c
                  ? (St("replaceCaret pr", c),
                    a === "0"
                      ? i === "0"
                        ? (l = `>=${a}.${i}.${o}-${c} <${a}.${i}.${+o + 1}-0`)
                        : (l = `>=${a}.${i}.${o}-${c} <${a}.${+i + 1}.0-0`)
                      : (l = `>=${a}.${i}.${o}-${c} <${+a + 1}.0.0-0`))
                  : (St("no pr"),
                    a === "0"
                      ? i === "0"
                        ? (l = `>=${a}.${i}.${o}${n} <${a}.${i}.${+o + 1}-0`)
                        : (l = `>=${a}.${i}.${o}${n} <${a}.${+i + 1}.0-0`)
                      : (l = `>=${a}.${i}.${o} <${+a + 1}.0.0-0`)),
          St("caret return", l),
          l
        );
      });
    },
    YM = (t, e) => (
      St("replaceXRanges", t, e),
      t
        .split(/\s+/)
        .map((r) => QM(r, e))
        .join(" ")
    ),
    QM = (t, e) => {
      t = t.trim();
      let r = e.loose ? gr[ur.XRANGELOOSE] : gr[ur.XRANGE];
      return t.replace(r, (n, s, a, i, o, c) => {
        St("xRange", t, n, s, a, i, o, c);
        let l = dr(a),
          u = l || dr(i),
          d = u || dr(o),
          m = d;
        return (
          s === "=" && m && (s = ""),
          (c = e.includePrerelease ? "-0" : ""),
          l
            ? s === ">" || s === "<"
              ? (n = "<0.0.0-0")
              : (n = "*")
            : s && m
              ? (u && (i = 0),
                (o = 0),
                s === ">"
                  ? ((s = ">="),
                    u
                      ? ((a = +a + 1), (i = 0), (o = 0))
                      : ((i = +i + 1), (o = 0)))
                  : s === "<=" && ((s = "<"), u ? (a = +a + 1) : (i = +i + 1)),
                s === "<" && (c = "-0"),
                (n = `${s + a}.${i}.${o}${c}`))
              : u
                ? (n = `>=${a}.0.0${c} <${+a + 1}.0.0-0`)
                : d && (n = `>=${a}.${i}.0${c} <${a}.${+i + 1}.0-0`),
          St("xRange return", n),
          n
        );
      });
    },
    ej = (t, e) => (
      St("replaceStars", t, e),
      t.trim().replace(gr[ur.STAR], "")
    ),
    tj = (t, e) => (
      St("replaceGTE0", t, e),
      t.trim().replace(gr[e.includePrerelease ? ur.GTE0PRE : ur.GTE0], "")
    ),
    rj = (t) => (e, r, n, s, a, i, o, c, l, u, d, m) => (
      dr(n)
        ? (r = "")
        : dr(s)
          ? (r = `>=${n}.0.0${t ? "-0" : ""}`)
          : dr(a)
            ? (r = `>=${n}.${s}.0${t ? "-0" : ""}`)
            : i
              ? (r = `>=${r}`)
              : (r = `>=${r}${t ? "-0" : ""}`),
      dr(l)
        ? (c = "")
        : dr(u)
          ? (c = `<${+l + 1}.0.0-0`)
          : dr(d)
            ? (c = `<${l}.${+u + 1}.0-0`)
            : m
              ? (c = `<=${l}.${u}.${d}-${m}`)
              : t
                ? (c = `<${l}.${u}.${+d + 1}-0`)
                : (c = `<=${c}`),
      `${r} ${c}`.trim()
    ),
    nj = (t, e, r) => {
      for (let n = 0; n < t.length; n++) if (!t[n].test(e)) return !1;
      if (e.prerelease.length && !r.includePrerelease) {
        for (let n = 0; n < t.length; n++)
          if (
            (St(t[n].semver),
            t[n].semver !== Df.ANY && t[n].semver.prerelease.length > 0)
          ) {
            let s = t[n].semver;
            if (
              s.major === e.major &&
              s.minor === e.minor &&
              s.patch === e.patch
            )
              return !0;
          }
        return !1;
      }
      return !0;
    };
});
var Ao = j((Nre, ew) => {
  "use strict";
  var No = Symbol("SemVer ANY"),
    jf = class t {
      static get ANY() {
        return No;
      }
      constructor(e, r) {
        if (((r = Kx(r)), e instanceof t)) {
          if (e.loose === !!r.loose) return e;
          e = e.value;
        }
        ((e = e.trim().split(/\s+/).join(" ")),
          Mf("comparator", e, r),
          (this.options = r),
          (this.loose = !!r.loose),
          this.parse(e),
          this.semver === No
            ? (this.value = "")
            : (this.value = this.operator + this.semver.version),
          Mf("comp", this));
      }
      parse(e) {
        let r = this.options.loose ? Jx[Xx.COMPARATORLOOSE] : Jx[Xx.COMPARATOR],
          n = e.match(r);
        if (!n) throw new TypeError(`Invalid comparator: ${e}`);
        ((this.operator = n[1] !== void 0 ? n[1] : ""),
          this.operator === "=" && (this.operator = ""),
          n[2]
            ? (this.semver = new Yx(n[2], this.options.loose))
            : (this.semver = No));
      }
      toString() {
        return this.value;
      }
      test(e) {
        if (
          (Mf("Comparator.test", e, this.options.loose),
          this.semver === No || e === No)
        )
          return !0;
        if (typeof e == "string")
          try {
            e = new Yx(e, this.options);
          } catch {
            return !1;
          }
        return Lf(e, this.operator, this.semver, this.options);
      }
      intersects(e, r) {
        if (!(e instanceof t)) throw new TypeError("a Comparator is required");
        return this.operator === ""
          ? this.value === ""
            ? !0
            : new Qx(e.value, r).test(this.value)
          : e.operator === ""
            ? e.value === ""
              ? !0
              : new Qx(this.value, r).test(e.semver)
            : ((r = Kx(r)),
              (r.includePrerelease &&
                (this.value === "<0.0.0-0" || e.value === "<0.0.0-0")) ||
              (!r.includePrerelease &&
                (this.value.startsWith("<0.0.0") ||
                  e.value.startsWith("<0.0.0")))
                ? !1
                : !!(
                    (this.operator.startsWith(">") &&
                      e.operator.startsWith(">")) ||
                    (this.operator.startsWith("<") &&
                      e.operator.startsWith("<")) ||
                    (this.semver.version === e.semver.version &&
                      this.operator.includes("=") &&
                      e.operator.includes("=")) ||
                    (Lf(this.semver, "<", e.semver, r) &&
                      this.operator.startsWith(">") &&
                      e.operator.startsWith("<")) ||
                    (Lf(this.semver, ">", e.semver, r) &&
                      this.operator.startsWith("<") &&
                      e.operator.startsWith(">"))
                  ));
      }
    };
  ew.exports = jf;
  var Kx = Cl(),
    { safeRe: Jx, t: Xx } = Ya(),
    Lf = $f(),
    Mf = Io(),
    Yx = sr(),
    Qx = Zr();
});
var Do = j((Dre, tw) => {
  "use strict";
  var sj = Zr(),
    aj = (t, e, r) => {
      try {
        e = new sj(e, r);
      } catch {
        return !1;
      }
      return e.test(t);
    };
  tw.exports = aj;
});
var nw = j((Lre, rw) => {
  "use strict";
  var ij = Zr(),
    oj = (t, e) =>
      new ij(t, e).set.map((r) =>
        r
          .map((n) => n.value)
          .join(" ")
          .trim()
          .split(" "),
      );
  rw.exports = oj;
});
var aw = j((Mre, sw) => {
  "use strict";
  var cj = sr(),
    lj = Zr(),
    uj = (t, e, r) => {
      let n = null,
        s = null,
        a = null;
      try {
        a = new lj(e, r);
      } catch {
        return null;
      }
      return (
        t.forEach((i) => {
          a.test(i) &&
            (!n || s.compare(i) === -1) &&
            ((n = i), (s = new cj(n, r)));
        }),
        n
      );
    };
  sw.exports = uj;
});
var ow = j((jre, iw) => {
  "use strict";
  var dj = sr(),
    pj = Zr(),
    fj = (t, e, r) => {
      let n = null,
        s = null,
        a = null;
      try {
        a = new pj(e, r);
      } catch {
        return null;
      }
      return (
        t.forEach((i) => {
          a.test(i) &&
            (!n || s.compare(i) === 1) &&
            ((n = i), (s = new dj(n, r)));
        }),
        n
      );
    };
  iw.exports = fj;
});
var uw = j((Fre, lw) => {
  "use strict";
  var Ff = sr(),
    mj = Zr(),
    cw = $o(),
    hj = (t, e) => {
      t = new mj(t, e);
      let r = new Ff("0.0.0");
      if (t.test(r) || ((r = new Ff("0.0.0-0")), t.test(r))) return r;
      r = null;
      for (let n = 0; n < t.set.length; ++n) {
        let s = t.set[n],
          a = null;
        (s.forEach((i) => {
          let o = new Ff(i.semver.version);
          switch (i.operator) {
            case ">":
              (o.prerelease.length === 0 ? o.patch++ : o.prerelease.push(0),
                (o.raw = o.format()));
            case "":
            case ">=":
              (!a || cw(o, a)) && (a = o);
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${i.operator}`);
          }
        }),
          a && (!r || cw(r, a)) && (r = a));
      }
      return r && t.test(r) ? r : null;
    };
  lw.exports = hj;
});
var pw = j((Ure, dw) => {
  "use strict";
  var gj = Zr(),
    vj = (t, e) => {
      try {
        return new gj(t, e).range || "*";
      } catch {
        return null;
      }
    };
  dw.exports = vj;
});
var Ml = j((qre, gw) => {
  "use strict";
  var yj = sr(),
    hw = Ao(),
    { ANY: bj } = hw,
    _j = Zr(),
    xj = Do(),
    fw = $o(),
    mw = $l(),
    wj = Nl(),
    Sj = Al(),
    Ej = (t, e, r, n) => {
      ((t = new yj(t, n)), (e = new _j(e, n)));
      let s, a, i, o, c;
      switch (r) {
        case ">":
          ((s = fw), (a = wj), (i = mw), (o = ">"), (c = ">="));
          break;
        case "<":
          ((s = mw), (a = Sj), (i = fw), (o = "<"), (c = "<="));
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (xj(t, e, n)) return !1;
      for (let l = 0; l < e.set.length; ++l) {
        let u = e.set[l],
          d = null,
          m = null;
        if (
          (u.forEach((p) => {
            (p.semver === bj && (p = new hw(">=0.0.0")),
              (d = d || p),
              (m = m || p),
              s(p.semver, d.semver, n)
                ? (d = p)
                : i(p.semver, m.semver, n) && (m = p));
          }),
          d.operator === o ||
            d.operator === c ||
            ((!m.operator || m.operator === o) && a(t, m.semver)))
        )
          return !1;
        if (m.operator === c && i(t, m.semver)) return !1;
      }
      return !0;
    };
  gw.exports = Ej;
});
var yw = j((zre, vw) => {
  "use strict";
  var Tj = Ml(),
    Cj = (t, e, r) => Tj(t, e, ">", r);
  vw.exports = Cj;
});
var _w = j((Bre, bw) => {
  "use strict";
  var Pj = Ml(),
    kj = (t, e, r) => Pj(t, e, "<", r);
  bw.exports = kj;
});
var Sw = j((Hre, ww) => {
  "use strict";
  var xw = Zr(),
    Rj = (t, e, r) => (
      (t = new xw(t, r)),
      (e = new xw(e, r)),
      t.intersects(e, r)
    );
  ww.exports = Rj;
});
var Tw = j((Vre, Ew) => {
  "use strict";
  var Oj = Do(),
    Ij = Vr();
  Ew.exports = (t, e, r) => {
    let n = [],
      s = null,
      a = null,
      i = t.sort((u, d) => Ij(u, d, r));
    for (let u of i)
      Oj(u, e, r)
        ? ((a = u), s || (s = u))
        : (a && n.push([s, a]), (a = null), (s = null));
    s && n.push([s, null]);
    let o = [];
    for (let [u, d] of n)
      u === d
        ? o.push(u)
        : !d && u === i[0]
          ? o.push("*")
          : d
            ? u === i[0]
              ? o.push(`<=${d}`)
              : o.push(`${u} - ${d}`)
            : o.push(`>=${u}`);
    let c = o.join(" || "),
      l = typeof e.raw == "string" ? e.raw : String(e);
    return c.length < l.length ? c : e;
  };
});
var Iw = j((Zre, Ow) => {
  "use strict";
  var Cw = Zr(),
    qf = Ao(),
    { ANY: Uf } = qf,
    Lo = Do(),
    zf = Vr(),
    $j = (t, e, r = {}) => {
      if (t === e) return !0;
      ((t = new Cw(t, r)), (e = new Cw(e, r)));
      let n = !1;
      e: for (let s of t.set) {
        for (let a of e.set) {
          let i = Nj(s, a, r);
          if (((n = n || i !== null), i)) continue e;
        }
        if (n) return !1;
      }
      return !0;
    },
    Aj = [new qf(">=0.0.0-0")],
    Pw = [new qf(">=0.0.0")],
    Nj = (t, e, r) => {
      if (t === e) return !0;
      if (t.length === 1 && t[0].semver === Uf) {
        if (e.length === 1 && e[0].semver === Uf) return !0;
        r.includePrerelease ? (t = Aj) : (t = Pw);
      }
      if (e.length === 1 && e[0].semver === Uf) {
        if (r.includePrerelease) return !0;
        e = Pw;
      }
      let n = new Set(),
        s,
        a;
      for (let p of t)
        p.operator === ">" || p.operator === ">="
          ? (s = kw(s, p, r))
          : p.operator === "<" || p.operator === "<="
            ? (a = Rw(a, p, r))
            : n.add(p.semver);
      if (n.size > 1) return null;
      let i;
      if (s && a) {
        if (((i = zf(s.semver, a.semver, r)), i > 0)) return null;
        if (i === 0 && (s.operator !== ">=" || a.operator !== "<="))
          return null;
      }
      for (let p of n) {
        if ((s && !Lo(p, String(s), r)) || (a && !Lo(p, String(a), r)))
          return null;
        for (let f of e) if (!Lo(p, String(f), r)) return !1;
        return !0;
      }
      let o,
        c,
        l,
        u,
        d =
          a && !r.includePrerelease && a.semver.prerelease.length
            ? a.semver
            : !1,
        m =
          s && !r.includePrerelease && s.semver.prerelease.length
            ? s.semver
            : !1;
      d &&
        d.prerelease.length === 1 &&
        a.operator === "<" &&
        d.prerelease[0] === 0 &&
        (d = !1);
      for (let p of e) {
        if (
          ((u = u || p.operator === ">" || p.operator === ">="),
          (l = l || p.operator === "<" || p.operator === "<="),
          s)
        ) {
          if (
            (m &&
              p.semver.prerelease &&
              p.semver.prerelease.length &&
              p.semver.major === m.major &&
              p.semver.minor === m.minor &&
              p.semver.patch === m.patch &&
              (m = !1),
            p.operator === ">" || p.operator === ">=")
          ) {
            if (((o = kw(s, p, r)), o === p && o !== s)) return !1;
          } else if (s.operator === ">=" && !Lo(s.semver, String(p), r))
            return !1;
        }
        if (a) {
          if (
            (d &&
              p.semver.prerelease &&
              p.semver.prerelease.length &&
              p.semver.major === d.major &&
              p.semver.minor === d.minor &&
              p.semver.patch === d.patch &&
              (d = !1),
            p.operator === "<" || p.operator === "<=")
          ) {
            if (((c = Rw(a, p, r)), c === p && c !== a)) return !1;
          } else if (a.operator === "<=" && !Lo(a.semver, String(p), r))
            return !1;
        }
        if (!p.operator && (a || s) && i !== 0) return !1;
      }
      return !(
        (s && l && !a && i !== 0) ||
        (a && u && !s && i !== 0) ||
        m ||
        d
      );
    },
    kw = (t, e, r) => {
      if (!t) return e;
      let n = zf(t.semver, e.semver, r);
      return n > 0
        ? t
        : n < 0 || (e.operator === ">" && t.operator === ">=")
          ? e
          : t;
    },
    Rw = (t, e, r) => {
      if (!t) return e;
      let n = zf(t.semver, e.semver, r);
      return n < 0
        ? t
        : n > 0 || (e.operator === "<" && t.operator === "<=")
          ? e
          : t;
    };
  Ow.exports = $j;
});
var Hf = j((Gre, Nw) => {
  "use strict";
  var Bf = Ya(),
    $w = Oo(),
    Dj = sr(),
    Aw = kf(),
    Lj = Ks(),
    Mj = ax(),
    jj = ox(),
    Fj = ux(),
    Uj = fx(),
    qj = hx(),
    zj = vx(),
    Bj = bx(),
    Hj = xx(),
    Vj = Vr(),
    Zj = Tx(),
    Gj = Px(),
    Wj = Il(),
    Kj = Ix(),
    Jj = Ax(),
    Xj = $o(),
    Yj = $l(),
    Qj = Of(),
    eF = If(),
    tF = Al(),
    rF = Nl(),
    nF = $f(),
    sF = zx(),
    aF = Ao(),
    iF = Zr(),
    oF = Do(),
    cF = nw(),
    lF = aw(),
    uF = ow(),
    dF = uw(),
    pF = pw(),
    fF = Ml(),
    mF = yw(),
    hF = _w(),
    gF = Sw(),
    vF = Tw(),
    yF = Iw();
  Nw.exports = {
    parse: Lj,
    valid: Mj,
    clean: jj,
    inc: Fj,
    diff: Uj,
    major: qj,
    minor: zj,
    patch: Bj,
    prerelease: Hj,
    compare: Vj,
    rcompare: Zj,
    compareLoose: Gj,
    compareBuild: Wj,
    sort: Kj,
    rsort: Jj,
    gt: Xj,
    lt: Yj,
    eq: Qj,
    neq: eF,
    gte: tF,
    lte: rF,
    cmp: nF,
    coerce: sF,
    Comparator: aF,
    Range: iF,
    satisfies: oF,
    toComparators: cF,
    maxSatisfying: lF,
    minSatisfying: uF,
    minVersion: dF,
    validRange: pF,
    outside: fF,
    gtr: mF,
    ltr: hF,
    intersects: gF,
    simplifyRange: vF,
    subset: yF,
    SemVer: Dj,
    re: Bf.re,
    src: Bf.src,
    tokens: Bf.t,
    SEMVER_SPEC_VERSION: $w.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: $w.RELEASE_TYPES,
    compareIdentifiers: Aw.compareIdentifiers,
    rcompareIdentifiers: Aw.rcompareIdentifiers,
  };
});
var VT = j((Die, HT) => {
  "use strict";
  HT.exports = function (e) {
    return e
      .map(function (r) {
        return r === ""
          ? "''"
          : r && typeof r == "object"
            ? r.op.replace(/(.)/g, "\\$1")
            : /["\s\\]/.test(r) && !/'/.test(r)
              ? "'" + r.replace(/(['])/g, "\\$1") + "'"
              : /["'\s]/.test(r)
                ? '"' + r.replace(/(["\\$`!])/g, "\\$1") + '"'
                : String(r).replace(
                    /([A-Za-z]:)?([#!"$&'()*,:;<=>?@[\\\]^`{|}])/g,
                    "$1\\$2",
                  );
      })
      .join(" ");
  };
});
var YT = j((Lie, XT) => {
  "use strict";
  var JT =
      "(?:" +
      [
        "\\|\\|",
        "\\&\\&",
        ";;",
        "\\|\\&",
        "\\<\\(",
        "\\<\\<\\<",
        ">>",
        ">\\&",
        "<\\&",
        "[&;()|<>]",
      ].join("|") +
      ")",
    ZT = new RegExp("^" + JT + "$"),
    GT = "|&;()<> \\t",
    nW = '"((\\\\"|[^"])*?)"',
    sW = "'((\\\\'|[^'])*?)'",
    aW = /^#$/,
    WT = "'",
    KT = '"',
    zh = "$",
    xa = "",
    iW = 4294967296;
  for (Bh = 0; Bh < 4; Bh++) xa += (iW * Math.random()).toString(16);
  var Bh,
    oW = new RegExp("^" + xa);
  function cW(t, e) {
    for (var r = e.lastIndex, n = [], s; (s = e.exec(t)); )
      (n.push(s), e.lastIndex === s.index && (e.lastIndex += 1));
    return ((e.lastIndex = r), n);
  }
  function lW(t, e, r) {
    var n = typeof t == "function" ? t(r) : t[r];
    return (
      typeof n > "u" && r != "" ? (n = "") : typeof n > "u" && (n = "$"),
      typeof n == "object" ? e + xa + JSON.stringify(n) + xa : e + n
    );
  }
  function uW(t, e, r) {
    r || (r = {});
    var n = r.escape || "\\",
      s = "(\\" + n + `['"` + GT + `]|[^\\s'"` + GT + "])+",
      a = new RegExp(
        ["(" + JT + ")", "(" + s + "|" + nW + "|" + sW + ")+"].join("|"),
        "g",
      ),
      i = cW(t, a);
    if (i.length === 0) return [];
    e || (e = {});
    var o = !1;
    return i
      .map(function (c) {
        var l = c[0];
        if (!l || o) return;
        if (ZT.test(l)) return { op: l };
        var u = !1,
          d = !1,
          m = "",
          p = !1,
          f;
        function y() {
          f += 1;
          var _,
            v,
            b = l.charAt(f);
          if (b === "{") {
            if (((f += 1), l.charAt(f) === "}"))
              throw new Error("Bad substitution: " + l.slice(f - 2, f + 1));
            if (((_ = l.indexOf("}", f)), _ < 0))
              throw new Error("Bad substitution: " + l.slice(f));
            ((v = l.slice(f, _)), (f = _));
          } else if (/[*@#?$!_-]/.test(b)) ((v = b), (f += 1));
          else {
            var x = l.slice(f);
            ((_ = x.match(/[^\w\d_]/)),
              _
                ? ((v = x.slice(0, _.index)), (f += _.index - 1))
                : ((v = x), (f = l.length)));
          }
          return lW(e, "", v);
        }
        for (f = 0; f < l.length; f++) {
          var h = l.charAt(f);
          if (((p = p || (!u && (h === "*" || h === "?"))), d))
            ((m += h), (d = !1));
          else if (u)
            h === u
              ? (u = !1)
              : u == WT
                ? (m += h)
                : h === n
                  ? ((f += 1),
                    (h = l.charAt(f)),
                    h === KT || h === n || h === zh ? (m += h) : (m += n + h))
                  : h === zh
                    ? (m += y())
                    : (m += h);
          else if (h === KT || h === WT) u = h;
          else {
            if (ZT.test(h)) return { op: l };
            if (aW.test(h)) {
              o = !0;
              var g = { comment: t.slice(c.index + f + 1) };
              return m.length ? [m, g] : [g];
            } else h === n ? (d = !0) : h === zh ? (m += y()) : (m += h);
          }
        }
        return p ? { op: "glob", pattern: m } : m;
      })
      .reduce(function (c, l) {
        return typeof l > "u" ? c : c.concat(l);
      }, []);
  }
  XT.exports = function (e, r, n) {
    var s = uW(e, r, n);
    return typeof r != "function"
      ? s
      : s.reduce(function (a, i) {
          if (typeof i == "object") return a.concat(i);
          var o = i.split(RegExp("(" + xa + ".*?" + xa + ")", "g"));
          return o.length === 1
            ? a.concat(o[0])
            : a.concat(
                o.filter(Boolean).map(function (c) {
                  return oW.test(c) ? JSON.parse(c.split(xa)[1]) : c;
                }),
              );
        }, []);
  };
});
var Vh = j((Hh) => {
  "use strict";
  Hh.quote = VT();
  Hh.parse = YT();
});
var OC = j((ioe, RC) => {
  var kC = require("stream").Stream,
    g5 = require("util");
  RC.exports = yn;
  function yn() {
    ((this.source = null),
      (this.dataSize = 0),
      (this.maxDataSize = 1024 * 1024),
      (this.pauseStream = !0),
      (this._maxDataSizeExceeded = !1),
      (this._released = !1),
      (this._bufferedEvents = []));
  }
  g5.inherits(yn, kC);
  yn.create = function (t, e) {
    var r = new this();
    e = e || {};
    for (var n in e) r[n] = e[n];
    r.source = t;
    var s = t.emit;
    return (
      (t.emit = function () {
        return (r._handleEmit(arguments), s.apply(t, arguments));
      }),
      t.on("error", function () {}),
      r.pauseStream && t.pause(),
      r
    );
  };
  Object.defineProperty(yn.prototype, "readable", {
    configurable: !0,
    enumerable: !0,
    get: function () {
      return this.source.readable;
    },
  });
  yn.prototype.setEncoding = function () {
    return this.source.setEncoding.apply(this.source, arguments);
  };
  yn.prototype.resume = function () {
    (this._released || this.release(), this.source.resume());
  };
  yn.prototype.pause = function () {
    this.source.pause();
  };
  yn.prototype.release = function () {
    ((this._released = !0),
      this._bufferedEvents.forEach(
        function (t) {
          this.emit.apply(this, t);
        }.bind(this),
      ),
      (this._bufferedEvents = []));
  };
  yn.prototype.pipe = function () {
    var t = kC.prototype.pipe.apply(this, arguments);
    return (this.resume(), t);
  };
  yn.prototype._handleEmit = function (t) {
    if (this._released) {
      this.emit.apply(this, t);
      return;
    }
    (t[0] === "data" &&
      ((this.dataSize += t[1].length), this._checkIfMaxDataSizeExceeded()),
      this._bufferedEvents.push(t));
  };
  yn.prototype._checkIfMaxDataSizeExceeded = function () {
    if (!this._maxDataSizeExceeded && !(this.dataSize <= this.maxDataSize)) {
      this._maxDataSizeExceeded = !0;
      var t =
        "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(t));
    }
  };
});
var NC = j((ooe, AC) => {
  var v5 = require("util"),
    $C = require("stream").Stream,
    IC = OC();
  AC.exports = Lt;
  function Lt() {
    ((this.writable = !1),
      (this.readable = !0),
      (this.dataSize = 0),
      (this.maxDataSize = 2 * 1024 * 1024),
      (this.pauseStreams = !0),
      (this._released = !1),
      (this._streams = []),
      (this._currentStream = null),
      (this._insideLoop = !1),
      (this._pendingNext = !1));
  }
  v5.inherits(Lt, $C);
  Lt.create = function (t) {
    var e = new this();
    t = t || {};
    for (var r in t) e[r] = t[r];
    return e;
  };
  Lt.isStreamLike = function (t) {
    return (
      typeof t != "function" &&
      typeof t != "string" &&
      typeof t != "boolean" &&
      typeof t != "number" &&
      !Buffer.isBuffer(t)
    );
  };
  Lt.prototype.append = function (t) {
    var e = Lt.isStreamLike(t);
    if (e) {
      if (!(t instanceof IC)) {
        var r = IC.create(t, {
          maxDataSize: 1 / 0,
          pauseStream: this.pauseStreams,
        });
        (t.on("data", this._checkDataSize.bind(this)), (t = r));
      }
      (this._handleErrors(t), this.pauseStreams && t.pause());
    }
    return (this._streams.push(t), this);
  };
  Lt.prototype.pipe = function (t, e) {
    return ($C.prototype.pipe.call(this, t, e), this.resume(), t);
  };
  Lt.prototype._getNext = function () {
    if (((this._currentStream = null), this._insideLoop)) {
      this._pendingNext = !0;
      return;
    }
    this._insideLoop = !0;
    try {
      do ((this._pendingNext = !1), this._realGetNext());
      while (this._pendingNext);
    } finally {
      this._insideLoop = !1;
    }
  };
  Lt.prototype._realGetNext = function () {
    var t = this._streams.shift();
    if (typeof t > "u") {
      this.end();
      return;
    }
    if (typeof t != "function") {
      this._pipeNext(t);
      return;
    }
    var e = t;
    e(
      function (r) {
        var n = Lt.isStreamLike(r);
        (n &&
          (r.on("data", this._checkDataSize.bind(this)), this._handleErrors(r)),
          this._pipeNext(r));
      }.bind(this),
    );
  };
  Lt.prototype._pipeNext = function (t) {
    this._currentStream = t;
    var e = Lt.isStreamLike(t);
    if (e) {
      (t.on("end", this._getNext.bind(this)), t.pipe(this, { end: !1 }));
      return;
    }
    var r = t;
    (this.write(r), this._getNext());
  };
  Lt.prototype._handleErrors = function (t) {
    var e = this;
    t.on("error", function (r) {
      e._emitError(r);
    });
  };
  Lt.prototype.write = function (t) {
    this.emit("data", t);
  };
  Lt.prototype.pause = function () {
    this.pauseStreams &&
      (this.pauseStreams &&
        this._currentStream &&
        typeof this._currentStream.pause == "function" &&
        this._currentStream.pause(),
      this.emit("pause"));
  };
  Lt.prototype.resume = function () {
    (this._released ||
      ((this._released = !0), (this.writable = !0), this._getNext()),
      this.pauseStreams &&
        this._currentStream &&
        typeof this._currentStream.resume == "function" &&
        this._currentStream.resume(),
      this.emit("resume"));
  };
  Lt.prototype.end = function () {
    (this._reset(), this.emit("end"));
  };
  Lt.prototype.destroy = function () {
    (this._reset(), this.emit("close"));
  };
  Lt.prototype._reset = function () {
    ((this.writable = !1), (this._streams = []), (this._currentStream = null));
  };
  Lt.prototype._checkDataSize = function () {
    if ((this._updateDataSize(), !(this.dataSize <= this.maxDataSize))) {
      var t =
        "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(t));
    }
  };
  Lt.prototype._updateDataSize = function () {
    this.dataSize = 0;
    var t = this;
    (this._streams.forEach(function (e) {
      e.dataSize && (t.dataSize += e.dataSize);
    }),
      this._currentStream &&
        this._currentStream.dataSize &&
        (this.dataSize += this._currentStream.dataSize));
  };
  Lt.prototype._emitError = function (t) {
    (this._reset(), this.emit("error", t));
  };
});
var DC = j((coe, y5) => {
  y5.exports = {
    "application/1d-interleaved-parityfec": { source: "iana" },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
    },
    "application/3gpp-ims+xml": { source: "iana", compressible: !0 },
    "application/3gpphal+json": { source: "iana", compressible: !0 },
    "application/3gpphalforms+json": { source: "iana", compressible: !0 },
    "application/a2l": { source: "iana" },
    "application/ace+cbor": { source: "iana" },
    "application/activemessage": { source: "iana" },
    "application/activity+json": { source: "iana", compressible: !0 },
    "application/alto-costmap+json": { source: "iana", compressible: !0 },
    "application/alto-costmapfilter+json": { source: "iana", compressible: !0 },
    "application/alto-directory+json": { source: "iana", compressible: !0 },
    "application/alto-endpointcost+json": { source: "iana", compressible: !0 },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: !0,
    },
    "application/alto-endpointprop+json": { source: "iana", compressible: !0 },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: !0,
    },
    "application/alto-error+json": { source: "iana", compressible: !0 },
    "application/alto-networkmap+json": { source: "iana", compressible: !0 },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: !0,
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: !0,
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: !0,
    },
    "application/aml": { source: "iana" },
    "application/andrew-inset": { source: "iana", extensions: ["ez"] },
    "application/applefile": { source: "iana" },
    "application/applixware": { source: "apache", extensions: ["aw"] },
    "application/at+jwt": { source: "iana" },
    "application/atf": { source: "iana" },
    "application/atfx": { source: "iana" },
    "application/atom+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["atom"],
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["atomcat"],
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["atomdeleted"],
    },
    "application/atomicmail": { source: "iana" },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["atomsvc"],
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["dwd"],
    },
    "application/atsc-dynamic-event-message": { source: "iana" },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["held"],
    },
    "application/atsc-rdt+json": { source: "iana", compressible: !0 },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rsat"],
    },
    "application/atxml": { source: "iana" },
    "application/auth-policy+xml": { source: "iana", compressible: !0 },
    "application/bacnet-xdd+zip": { source: "iana", compressible: !1 },
    "application/batch-smtp": { source: "iana" },
    "application/bdoc": { compressible: !1, extensions: ["bdoc"] },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
    },
    "application/calendar+json": { source: "iana", compressible: !0 },
    "application/calendar+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xcs"],
    },
    "application/call-completion": { source: "iana" },
    "application/cals-1840": { source: "iana" },
    "application/captive+json": { source: "iana", compressible: !0 },
    "application/cbor": { source: "iana" },
    "application/cbor-seq": { source: "iana" },
    "application/cccex": { source: "iana" },
    "application/ccmp+xml": { source: "iana", compressible: !0 },
    "application/ccxml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["ccxml"],
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["cdfx"],
    },
    "application/cdmi-capability": { source: "iana", extensions: ["cdmia"] },
    "application/cdmi-container": { source: "iana", extensions: ["cdmic"] },
    "application/cdmi-domain": { source: "iana", extensions: ["cdmid"] },
    "application/cdmi-object": { source: "iana", extensions: ["cdmio"] },
    "application/cdmi-queue": { source: "iana", extensions: ["cdmiq"] },
    "application/cdni": { source: "iana" },
    "application/cea": { source: "iana" },
    "application/cea-2018+xml": { source: "iana", compressible: !0 },
    "application/cellml+xml": { source: "iana", compressible: !0 },
    "application/cfw": { source: "iana" },
    "application/city+json": { source: "iana", compressible: !0 },
    "application/clr": { source: "iana" },
    "application/clue+xml": { source: "iana", compressible: !0 },
    "application/clue_info+xml": { source: "iana", compressible: !0 },
    "application/cms": { source: "iana" },
    "application/cnrp+xml": { source: "iana", compressible: !0 },
    "application/coap-group+json": { source: "iana", compressible: !0 },
    "application/coap-payload": { source: "iana" },
    "application/commonground": { source: "iana" },
    "application/conference-info+xml": { source: "iana", compressible: !0 },
    "application/cose": { source: "iana" },
    "application/cose-key": { source: "iana" },
    "application/cose-key-set": { source: "iana" },
    "application/cpl+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["cpl"],
    },
    "application/csrattrs": { source: "iana" },
    "application/csta+xml": { source: "iana", compressible: !0 },
    "application/cstadata+xml": { source: "iana", compressible: !0 },
    "application/csvm+json": { source: "iana", compressible: !0 },
    "application/cu-seeme": { source: "apache", extensions: ["cu"] },
    "application/cwt": { source: "iana" },
    "application/cybercash": { source: "iana" },
    "application/dart": { compressible: !0 },
    "application/dash+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mpd"],
    },
    "application/dash-patch+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mpp"],
    },
    "application/dashdelta": { source: "iana" },
    "application/davmount+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["davmount"],
    },
    "application/dca-rft": { source: "iana" },
    "application/dcd": { source: "iana" },
    "application/dec-dx": { source: "iana" },
    "application/dialog-info+xml": { source: "iana", compressible: !0 },
    "application/dicom": { source: "iana" },
    "application/dicom+json": { source: "iana", compressible: !0 },
    "application/dicom+xml": { source: "iana", compressible: !0 },
    "application/dii": { source: "iana" },
    "application/dit": { source: "iana" },
    "application/dns": { source: "iana" },
    "application/dns+json": { source: "iana", compressible: !0 },
    "application/dns-message": { source: "iana" },
    "application/docbook+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["dbk"],
    },
    "application/dots+cbor": { source: "iana" },
    "application/dskpp+xml": { source: "iana", compressible: !0 },
    "application/dssc+der": { source: "iana", extensions: ["dssc"] },
    "application/dssc+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xdssc"],
    },
    "application/dvcs": { source: "iana" },
    "application/ecmascript": {
      source: "iana",
      compressible: !0,
      extensions: ["es", "ecma"],
    },
    "application/edi-consent": { source: "iana" },
    "application/edi-x12": { source: "iana", compressible: !1 },
    "application/edifact": { source: "iana", compressible: !1 },
    "application/efi": { source: "iana" },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
    },
    "application/elm+xml": { source: "iana", compressible: !0 },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/emergencycalldata.ecall.msd": { source: "iana" },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/emma+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["emma"],
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["emotionml"],
    },
    "application/encaprtp": { source: "iana" },
    "application/epp+xml": { source: "iana", compressible: !0 },
    "application/epub+zip": {
      source: "iana",
      compressible: !1,
      extensions: ["epub"],
    },
    "application/eshop": { source: "iana" },
    "application/exi": { source: "iana", extensions: ["exi"] },
    "application/expect-ct-report+json": { source: "iana", compressible: !0 },
    "application/express": { source: "iana", extensions: ["exp"] },
    "application/fastinfoset": { source: "iana" },
    "application/fastsoap": { source: "iana" },
    "application/fdt+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["fdt"],
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
    },
    "application/fido.trusted-apps+json": { compressible: !0 },
    "application/fits": { source: "iana" },
    "application/flexfec": { source: "iana" },
    "application/font-sfnt": { source: "iana" },
    "application/font-tdpfr": { source: "iana", extensions: ["pfr"] },
    "application/font-woff": { source: "iana", compressible: !1 },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/geo+json": {
      source: "iana",
      compressible: !0,
      extensions: ["geojson"],
    },
    "application/geo+json-seq": { source: "iana" },
    "application/geopackage+sqlite3": { source: "iana" },
    "application/geoxacml+xml": { source: "iana", compressible: !0 },
    "application/gltf-buffer": { source: "iana" },
    "application/gml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["gml"],
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["gpx"],
    },
    "application/gxf": { source: "apache", extensions: ["gxf"] },
    "application/gzip": {
      source: "iana",
      compressible: !1,
      extensions: ["gz"],
    },
    "application/h224": { source: "iana" },
    "application/held+xml": { source: "iana", compressible: !0 },
    "application/hjson": { extensions: ["hjson"] },
    "application/http": { source: "iana" },
    "application/hyperstudio": { source: "iana", extensions: ["stk"] },
    "application/ibe-key-request+xml": { source: "iana", compressible: !0 },
    "application/ibe-pkg-reply+xml": { source: "iana", compressible: !0 },
    "application/ibe-pp-data": { source: "iana" },
    "application/iges": { source: "iana" },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
    },
    "application/index": { source: "iana" },
    "application/index.cmd": { source: "iana" },
    "application/index.obj": { source: "iana" },
    "application/index.response": { source: "iana" },
    "application/index.vnd": { source: "iana" },
    "application/inkml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["ink", "inkml"],
    },
    "application/iotp": { source: "iana" },
    "application/ipfix": { source: "iana", extensions: ["ipfix"] },
    "application/ipp": { source: "iana" },
    "application/isup": { source: "iana" },
    "application/its+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["its"],
    },
    "application/java-archive": {
      source: "apache",
      compressible: !1,
      extensions: ["jar", "war", "ear"],
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: !1,
      extensions: ["ser"],
    },
    "application/java-vm": {
      source: "apache",
      compressible: !1,
      extensions: ["class"],
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["js", "mjs"],
    },
    "application/jf2feed+json": { source: "iana", compressible: !0 },
    "application/jose": { source: "iana" },
    "application/jose+json": { source: "iana", compressible: !0 },
    "application/jrd+json": { source: "iana", compressible: !0 },
    "application/jscalendar+json": { source: "iana", compressible: !0 },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["json", "map"],
    },
    "application/json-patch+json": { source: "iana", compressible: !0 },
    "application/json-seq": { source: "iana" },
    "application/json5": { extensions: ["json5"] },
    "application/jsonml+json": {
      source: "apache",
      compressible: !0,
      extensions: ["jsonml"],
    },
    "application/jwk+json": { source: "iana", compressible: !0 },
    "application/jwk-set+json": { source: "iana", compressible: !0 },
    "application/jwt": { source: "iana" },
    "application/kpml-request+xml": { source: "iana", compressible: !0 },
    "application/kpml-response+xml": { source: "iana", compressible: !0 },
    "application/ld+json": {
      source: "iana",
      compressible: !0,
      extensions: ["jsonld"],
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["lgr"],
    },
    "application/link-format": { source: "iana" },
    "application/load-control+xml": { source: "iana", compressible: !0 },
    "application/lost+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["lostxml"],
    },
    "application/lostsync+xml": { source: "iana", compressible: !0 },
    "application/lpf+zip": { source: "iana", compressible: !1 },
    "application/lxf": { source: "iana" },
    "application/mac-binhex40": { source: "iana", extensions: ["hqx"] },
    "application/mac-compactpro": { source: "apache", extensions: ["cpt"] },
    "application/macwriteii": { source: "iana" },
    "application/mads+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mads"],
    },
    "application/manifest+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["webmanifest"],
    },
    "application/marc": { source: "iana", extensions: ["mrc"] },
    "application/marcxml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mrcx"],
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"],
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mathml"],
    },
    "application/mathml-content+xml": { source: "iana", compressible: !0 },
    "application/mathml-presentation+xml": { source: "iana", compressible: !0 },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/mbms-deregister+xml": { source: "iana", compressible: !0 },
    "application/mbms-envelope+xml": { source: "iana", compressible: !0 },
    "application/mbms-msk+xml": { source: "iana", compressible: !0 },
    "application/mbms-msk-response+xml": { source: "iana", compressible: !0 },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/mbms-register+xml": { source: "iana", compressible: !0 },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/mbms-schedule+xml": { source: "iana", compressible: !0 },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/mbox": { source: "iana", extensions: ["mbox"] },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mpf"],
    },
    "application/media_control+xml": { source: "iana", compressible: !0 },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mscml"],
    },
    "application/merge-patch+json": { source: "iana", compressible: !0 },
    "application/metalink+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["metalink"],
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["meta4"],
    },
    "application/mets+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mets"],
    },
    "application/mf4": { source: "iana" },
    "application/mikey": { source: "iana" },
    "application/mipc": { source: "iana" },
    "application/missing-blocks+cbor-seq": { source: "iana" },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["maei"],
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["musd"],
    },
    "application/mods+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mods"],
    },
    "application/moss-keys": { source: "iana" },
    "application/moss-signature": { source: "iana" },
    "application/mosskey-data": { source: "iana" },
    "application/mosskey-request": { source: "iana" },
    "application/mp21": { source: "iana", extensions: ["m21", "mp21"] },
    "application/mp4": { source: "iana", extensions: ["mp4s", "m4p"] },
    "application/mpeg4-generic": { source: "iana" },
    "application/mpeg4-iod": { source: "iana" },
    "application/mpeg4-iod-xmt": { source: "iana" },
    "application/mrb-consumer+xml": { source: "iana", compressible: !0 },
    "application/mrb-publish+xml": { source: "iana", compressible: !0 },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
    },
    "application/msword": {
      source: "iana",
      compressible: !1,
      extensions: ["doc", "dot"],
    },
    "application/mud+json": { source: "iana", compressible: !0 },
    "application/multipart-core": { source: "iana" },
    "application/mxf": { source: "iana", extensions: ["mxf"] },
    "application/n-quads": { source: "iana", extensions: ["nq"] },
    "application/n-triples": { source: "iana", extensions: ["nt"] },
    "application/nasdata": { source: "iana" },
    "application/news-checkgroups": { source: "iana", charset: "US-ASCII" },
    "application/news-groupinfo": { source: "iana", charset: "US-ASCII" },
    "application/news-transmission": { source: "iana" },
    "application/nlsml+xml": { source: "iana", compressible: !0 },
    "application/node": { source: "iana", extensions: ["cjs"] },
    "application/nss": { source: "iana" },
    "application/oauth-authz-req+jwt": { source: "iana" },
    "application/oblivious-dns-message": { source: "iana" },
    "application/ocsp-request": { source: "iana" },
    "application/ocsp-response": { source: "iana" },
    "application/octet-stream": {
      source: "iana",
      compressible: !1,
      extensions: [
        "bin",
        "dms",
        "lrf",
        "mar",
        "so",
        "dist",
        "distz",
        "pkg",
        "bpk",
        "dump",
        "elc",
        "deploy",
        "exe",
        "dll",
        "deb",
        "dmg",
        "iso",
        "img",
        "msi",
        "msp",
        "msm",
        "buffer",
      ],
    },
    "application/oda": { source: "iana", extensions: ["oda"] },
    "application/odm+xml": { source: "iana", compressible: !0 },
    "application/odx": { source: "iana" },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["opf"],
    },
    "application/ogg": {
      source: "iana",
      compressible: !1,
      extensions: ["ogx"],
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["omdoc"],
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"],
    },
    "application/opc-nodeset+xml": { source: "iana", compressible: !0 },
    "application/oscore": { source: "iana" },
    "application/oxps": { source: "iana", extensions: ["oxps"] },
    "application/p21": { source: "iana" },
    "application/p21+zip": { source: "iana", compressible: !1 },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["relo"],
    },
    "application/parityfec": { source: "iana" },
    "application/passport": { source: "iana" },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xer"],
    },
    "application/pdf": {
      source: "iana",
      compressible: !1,
      extensions: ["pdf"],
    },
    "application/pdx": { source: "iana" },
    "application/pem-certificate-chain": { source: "iana" },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: !1,
      extensions: ["pgp"],
    },
    "application/pgp-keys": { source: "iana", extensions: ["asc"] },
    "application/pgp-signature": { source: "iana", extensions: ["asc", "sig"] },
    "application/pics-rules": { source: "apache", extensions: ["prf"] },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
    },
    "application/pkcs10": { source: "iana", extensions: ["p10"] },
    "application/pkcs12": { source: "iana" },
    "application/pkcs7-mime": { source: "iana", extensions: ["p7m", "p7c"] },
    "application/pkcs7-signature": { source: "iana", extensions: ["p7s"] },
    "application/pkcs8": { source: "iana", extensions: ["p8"] },
    "application/pkcs8-encrypted": { source: "iana" },
    "application/pkix-attr-cert": { source: "iana", extensions: ["ac"] },
    "application/pkix-cert": { source: "iana", extensions: ["cer"] },
    "application/pkix-crl": { source: "iana", extensions: ["crl"] },
    "application/pkix-pkipath": { source: "iana", extensions: ["pkipath"] },
    "application/pkixcmp": { source: "iana", extensions: ["pki"] },
    "application/pls+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["pls"],
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
    },
    "application/postscript": {
      source: "iana",
      compressible: !0,
      extensions: ["ai", "eps", "ps"],
    },
    "application/ppsp-tracker+json": { source: "iana", compressible: !0 },
    "application/problem+json": { source: "iana", compressible: !0 },
    "application/problem+xml": { source: "iana", compressible: !0 },
    "application/provenance+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["provx"],
    },
    "application/prs.alvestrand.titrax-sheet": { source: "iana" },
    "application/prs.cww": { source: "iana", extensions: ["cww"] },
    "application/prs.cyn": { source: "iana", charset: "7-BIT" },
    "application/prs.hpub+zip": { source: "iana", compressible: !1 },
    "application/prs.nprend": { source: "iana" },
    "application/prs.plucker": { source: "iana" },
    "application/prs.rdf-xml-crypt": { source: "iana" },
    "application/prs.xsf+xml": { source: "iana", compressible: !0 },
    "application/pskc+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["pskcxml"],
    },
    "application/pvd+json": { source: "iana", compressible: !0 },
    "application/qsig": { source: "iana" },
    "application/raml+yaml": { compressible: !0, extensions: ["raml"] },
    "application/raptorfec": { source: "iana" },
    "application/rdap+json": { source: "iana", compressible: !0 },
    "application/rdf+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rdf", "owl"],
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rif"],
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"],
    },
    "application/remote-printing": { source: "iana" },
    "application/reputon+json": { source: "iana", compressible: !0 },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rl"],
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rld"],
    },
    "application/rfc+xml": { source: "iana", compressible: !0 },
    "application/riscos": { source: "iana" },
    "application/rlmi+xml": { source: "iana", compressible: !0 },
    "application/rls-services+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rs"],
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rapd"],
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["sls"],
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rusd"],
    },
    "application/rpki-ghostbusters": { source: "iana", extensions: ["gbr"] },
    "application/rpki-manifest": { source: "iana", extensions: ["mft"] },
    "application/rpki-publication": { source: "iana" },
    "application/rpki-roa": { source: "iana", extensions: ["roa"] },
    "application/rpki-updown": { source: "iana" },
    "application/rsd+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["rsd"],
    },
    "application/rss+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["rss"],
    },
    "application/rtf": {
      source: "iana",
      compressible: !0,
      extensions: ["rtf"],
    },
    "application/rtploopback": { source: "iana" },
    "application/rtx": { source: "iana" },
    "application/samlassertion+xml": { source: "iana", compressible: !0 },
    "application/samlmetadata+xml": { source: "iana", compressible: !0 },
    "application/sarif+json": { source: "iana", compressible: !0 },
    "application/sarif-external-properties+json": {
      source: "iana",
      compressible: !0,
    },
    "application/sbe": { source: "iana" },
    "application/sbml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["sbml"],
    },
    "application/scaip+xml": { source: "iana", compressible: !0 },
    "application/scim+json": { source: "iana", compressible: !0 },
    "application/scvp-cv-request": { source: "iana", extensions: ["scq"] },
    "application/scvp-cv-response": { source: "iana", extensions: ["scs"] },
    "application/scvp-vp-request": { source: "iana", extensions: ["spq"] },
    "application/scvp-vp-response": { source: "iana", extensions: ["spp"] },
    "application/sdp": { source: "iana", extensions: ["sdp"] },
    "application/secevent+jwt": { source: "iana" },
    "application/senml+cbor": { source: "iana" },
    "application/senml+json": { source: "iana", compressible: !0 },
    "application/senml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["senmlx"],
    },
    "application/senml-etch+cbor": { source: "iana" },
    "application/senml-etch+json": { source: "iana", compressible: !0 },
    "application/senml-exi": { source: "iana" },
    "application/sensml+cbor": { source: "iana" },
    "application/sensml+json": { source: "iana", compressible: !0 },
    "application/sensml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["sensmlx"],
    },
    "application/sensml-exi": { source: "iana" },
    "application/sep+xml": { source: "iana", compressible: !0 },
    "application/sep-exi": { source: "iana" },
    "application/session-info": { source: "iana" },
    "application/set-payment": { source: "iana" },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"],
    },
    "application/set-registration": { source: "iana" },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"],
    },
    "application/sgml": { source: "iana" },
    "application/sgml-open-catalog": { source: "iana" },
    "application/shf+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["shf"],
    },
    "application/sieve": { source: "iana", extensions: ["siv", "sieve"] },
    "application/simple-filter+xml": { source: "iana", compressible: !0 },
    "application/simple-message-summary": { source: "iana" },
    "application/simplesymbolcontainer": { source: "iana" },
    "application/sipc": { source: "iana" },
    "application/slate": { source: "iana" },
    "application/smil": { source: "iana" },
    "application/smil+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["smi", "smil"],
    },
    "application/smpte336m": { source: "iana" },
    "application/soap+fastinfoset": { source: "iana" },
    "application/soap+xml": { source: "iana", compressible: !0 },
    "application/sparql-query": { source: "iana", extensions: ["rq"] },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["srx"],
    },
    "application/spdx+json": { source: "iana", compressible: !0 },
    "application/spirits-event+xml": { source: "iana", compressible: !0 },
    "application/sql": { source: "iana" },
    "application/srgs": { source: "iana", extensions: ["gram"] },
    "application/srgs+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["grxml"],
    },
    "application/sru+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["sru"],
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["ssdl"],
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["ssml"],
    },
    "application/stix+json": { source: "iana", compressible: !0 },
    "application/swid+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["swidtag"],
    },
    "application/tamp-apex-update": { source: "iana" },
    "application/tamp-apex-update-confirm": { source: "iana" },
    "application/tamp-community-update": { source: "iana" },
    "application/tamp-community-update-confirm": { source: "iana" },
    "application/tamp-error": { source: "iana" },
    "application/tamp-sequence-adjust": { source: "iana" },
    "application/tamp-sequence-adjust-confirm": { source: "iana" },
    "application/tamp-status-query": { source: "iana" },
    "application/tamp-status-response": { source: "iana" },
    "application/tamp-update": { source: "iana" },
    "application/tamp-update-confirm": { source: "iana" },
    "application/tar": { compressible: !0 },
    "application/taxii+json": { source: "iana", compressible: !0 },
    "application/td+json": { source: "iana", compressible: !0 },
    "application/tei+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["tei", "teicorpus"],
    },
    "application/tetra_isi": { source: "iana" },
    "application/thraud+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["tfi"],
    },
    "application/timestamp-query": { source: "iana" },
    "application/timestamp-reply": { source: "iana" },
    "application/timestamped-data": { source: "iana", extensions: ["tsd"] },
    "application/tlsrpt+gzip": { source: "iana" },
    "application/tlsrpt+json": { source: "iana", compressible: !0 },
    "application/tnauthlist": { source: "iana" },
    "application/token-introspection+jwt": { source: "iana" },
    "application/toml": { compressible: !0, extensions: ["toml"] },
    "application/trickle-ice-sdpfrag": { source: "iana" },
    "application/trig": { source: "iana", extensions: ["trig"] },
    "application/ttml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["ttml"],
    },
    "application/tve-trigger": { source: "iana" },
    "application/tzif": { source: "iana" },
    "application/tzif-leap": { source: "iana" },
    "application/ubjson": { compressible: !1, extensions: ["ubj"] },
    "application/ulpfec": { source: "iana" },
    "application/urc-grpsheet+xml": { source: "iana", compressible: !0 },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rsheet"],
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["td"],
    },
    "application/urc-uisocketdesc+xml": { source: "iana", compressible: !0 },
    "application/vcard+json": { source: "iana", compressible: !0 },
    "application/vcard+xml": { source: "iana", compressible: !0 },
    "application/vemmi": { source: "iana" },
    "application/vividence.scriptfile": { source: "apache" },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["1km"],
    },
    "application/vnd.3gpp-prose+xml": { source: "iana", compressible: !0 },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp-v2x-local-service-information": { source: "iana" },
    "application/vnd.3gpp.5gnas": { source: "iana" },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.bsf+xml": { source: "iana", compressible: !0 },
    "application/vnd.3gpp.gmop+xml": { source: "iana", compressible: !0 },
    "application/vnd.3gpp.gtpc": { source: "iana" },
    "application/vnd.3gpp.interworking-data": { source: "iana" },
    "application/vnd.3gpp.lpp": { source: "iana" },
    "application/vnd.3gpp.mc-signalling-ear": { source: "iana" },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcdata-payload": { source: "iana" },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcdata-signalling": { source: "iana" },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcptt-info+xml": { source: "iana", compressible: !0 },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.mid-call+xml": { source: "iana", compressible: !0 },
    "application/vnd.3gpp.ngap": { source: "iana" },
    "application/vnd.3gpp.pfcp": { source: "iana" },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"],
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"],
    },
    "application/vnd.3gpp.pic-bw-var": { source: "iana", extensions: ["pvb"] },
    "application/vnd.3gpp.s1ap": { source: "iana" },
    "application/vnd.3gpp.sms": { source: "iana" },
    "application/vnd.3gpp.sms+xml": { source: "iana", compressible: !0 },
    "application/vnd.3gpp.srvcc-ext+xml": { source: "iana", compressible: !0 },
    "application/vnd.3gpp.srvcc-info+xml": { source: "iana", compressible: !0 },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.3gpp.ussd+xml": { source: "iana", compressible: !0 },
    "application/vnd.3gpp2.bcmcsinfo+xml": { source: "iana", compressible: !0 },
    "application/vnd.3gpp2.sms": { source: "iana" },
    "application/vnd.3gpp2.tcap": { source: "iana", extensions: ["tcap"] },
    "application/vnd.3lightssoftware.imagescal": { source: "iana" },
    "application/vnd.3m.post-it-notes": { source: "iana", extensions: ["pwn"] },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"],
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"],
    },
    "application/vnd.acucobol": { source: "iana", extensions: ["acu"] },
    "application/vnd.acucorp": { source: "iana", extensions: ["atc", "acutc"] },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: !1,
      extensions: ["air"],
    },
    "application/vnd.adobe.flash.movie": { source: "iana" },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"],
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"],
    },
    "application/vnd.adobe.partial-upload": { source: "iana" },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xdp"],
    },
    "application/vnd.adobe.xfdf": { source: "iana", extensions: ["xfdf"] },
    "application/vnd.aether.imp": { source: "iana" },
    "application/vnd.afpc.afplinedata": { source: "iana" },
    "application/vnd.afpc.afplinedata-pagedef": { source: "iana" },
    "application/vnd.afpc.cmoca-cmresource": { source: "iana" },
    "application/vnd.afpc.foca-charset": { source: "iana" },
    "application/vnd.afpc.foca-codedfont": { source: "iana" },
    "application/vnd.afpc.foca-codepage": { source: "iana" },
    "application/vnd.afpc.modca": { source: "iana" },
    "application/vnd.afpc.modca-cmtable": { source: "iana" },
    "application/vnd.afpc.modca-formdef": { source: "iana" },
    "application/vnd.afpc.modca-mediummap": { source: "iana" },
    "application/vnd.afpc.modca-objectcontainer": { source: "iana" },
    "application/vnd.afpc.modca-overlay": { source: "iana" },
    "application/vnd.afpc.modca-pagesegment": { source: "iana" },
    "application/vnd.age": { source: "iana", extensions: ["age"] },
    "application/vnd.ah-barcode": { source: "iana" },
    "application/vnd.ahead.space": { source: "iana", extensions: ["ahead"] },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"],
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"],
    },
    "application/vnd.amadeus+json": { source: "iana", compressible: !0 },
    "application/vnd.amazon.ebook": { source: "apache", extensions: ["azw"] },
    "application/vnd.amazon.mobi8-ebook": { source: "iana" },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"],
    },
    "application/vnd.amiga.ami": { source: "iana", extensions: ["ami"] },
    "application/vnd.amundsen.maze+xml": { source: "iana", compressible: !0 },
    "application/vnd.android.ota": { source: "iana" },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: !1,
      extensions: ["apk"],
    },
    "application/vnd.anki": { source: "iana" },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"],
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"],
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"],
    },
    "application/vnd.apache.arrow.file": { source: "iana" },
    "application/vnd.apache.arrow.stream": { source: "iana" },
    "application/vnd.apache.thrift.binary": { source: "iana" },
    "application/vnd.apache.thrift.compact": { source: "iana" },
    "application/vnd.apache.thrift.json": { source: "iana" },
    "application/vnd.api+json": { source: "iana", compressible: !0 },
    "application/vnd.aplextor.warrp+json": { source: "iana", compressible: !0 },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mpkg"],
    },
    "application/vnd.apple.keynote": { source: "iana", extensions: ["key"] },
    "application/vnd.apple.mpegurl": { source: "iana", extensions: ["m3u8"] },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"],
    },
    "application/vnd.apple.pages": { source: "iana", extensions: ["pages"] },
    "application/vnd.apple.pkpass": {
      compressible: !1,
      extensions: ["pkpass"],
    },
    "application/vnd.arastra.swi": { source: "iana" },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"],
    },
    "application/vnd.artisan+json": { source: "iana", compressible: !0 },
    "application/vnd.artsquare": { source: "iana" },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"],
    },
    "application/vnd.audiograph": { source: "iana", extensions: ["aep"] },
    "application/vnd.autopackage": { source: "iana" },
    "application/vnd.avalon+json": { source: "iana", compressible: !0 },
    "application/vnd.avistar+xml": { source: "iana", compressible: !0 },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["bmml"],
    },
    "application/vnd.balsamiq.bmpr": { source: "iana" },
    "application/vnd.banana-accounting": { source: "iana" },
    "application/vnd.bbf.usp.error": { source: "iana" },
    "application/vnd.bbf.usp.msg": { source: "iana" },
    "application/vnd.bbf.usp.msg+json": { source: "iana", compressible: !0 },
    "application/vnd.bekitzur-stech+json": { source: "iana", compressible: !0 },
    "application/vnd.bint.med-content": { source: "iana" },
    "application/vnd.biopax.rdf+xml": { source: "iana", compressible: !0 },
    "application/vnd.blink-idb-value-wrapper": { source: "iana" },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"],
    },
    "application/vnd.bluetooth.ep.oob": { source: "iana" },
    "application/vnd.bluetooth.le.oob": { source: "iana" },
    "application/vnd.bmi": { source: "iana", extensions: ["bmi"] },
    "application/vnd.bpf": { source: "iana" },
    "application/vnd.bpf3": { source: "iana" },
    "application/vnd.businessobjects": { source: "iana", extensions: ["rep"] },
    "application/vnd.byu.uapi+json": { source: "iana", compressible: !0 },
    "application/vnd.cab-jscript": { source: "iana" },
    "application/vnd.canon-cpdl": { source: "iana" },
    "application/vnd.canon-lips": { source: "iana" },
    "application/vnd.capasystems-pg+json": { source: "iana", compressible: !0 },
    "application/vnd.cendio.thinlinc.clientconf": { source: "iana" },
    "application/vnd.century-systems.tcp_stream": { source: "iana" },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["cdxml"],
    },
    "application/vnd.chess-pgn": { source: "iana" },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"],
    },
    "application/vnd.ciedi": { source: "iana" },
    "application/vnd.cinderella": { source: "iana", extensions: ["cdy"] },
    "application/vnd.cirpack.isdn-ext": { source: "iana" },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["csl"],
    },
    "application/vnd.claymore": { source: "iana", extensions: ["cla"] },
    "application/vnd.cloanto.rp9": { source: "iana", extensions: ["rp9"] },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"],
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"],
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"],
    },
    "application/vnd.coffeescript": { source: "iana" },
    "application/vnd.collabio.xodocuments.document": { source: "iana" },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana",
    },
    "application/vnd.collabio.xodocuments.presentation": { source: "iana" },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana",
    },
    "application/vnd.collabio.xodocuments.spreadsheet": { source: "iana" },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana",
    },
    "application/vnd.collection+json": { source: "iana", compressible: !0 },
    "application/vnd.collection.doc+json": { source: "iana", compressible: !0 },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.comicbook+zip": { source: "iana", compressible: !1 },
    "application/vnd.comicbook-rar": { source: "iana" },
    "application/vnd.commerce-battelle": { source: "iana" },
    "application/vnd.commonspace": { source: "iana", extensions: ["csp"] },
    "application/vnd.contact.cmsg": { source: "iana", extensions: ["cdbcmsg"] },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.cosmocaller": { source: "iana", extensions: ["cmc"] },
    "application/vnd.crick.clicker": { source: "iana", extensions: ["clkx"] },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"],
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"],
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"],
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"],
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["wbs"],
    },
    "application/vnd.cryptii.pipe+json": { source: "iana", compressible: !0 },
    "application/vnd.crypto-shade-file": { source: "iana" },
    "application/vnd.cryptomator.encrypted": { source: "iana" },
    "application/vnd.cryptomator.vault": { source: "iana" },
    "application/vnd.ctc-posml": { source: "iana", extensions: ["pml"] },
    "application/vnd.ctct.ws+xml": { source: "iana", compressible: !0 },
    "application/vnd.cups-pdf": { source: "iana" },
    "application/vnd.cups-postscript": { source: "iana" },
    "application/vnd.cups-ppd": { source: "iana", extensions: ["ppd"] },
    "application/vnd.cups-raster": { source: "iana" },
    "application/vnd.cups-raw": { source: "iana" },
    "application/vnd.curl": { source: "iana" },
    "application/vnd.curl.car": { source: "apache", extensions: ["car"] },
    "application/vnd.curl.pcurl": { source: "apache", extensions: ["pcurl"] },
    "application/vnd.cyan.dean.root+xml": { source: "iana", compressible: !0 },
    "application/vnd.cybank": { source: "iana" },
    "application/vnd.cyclonedx+json": { source: "iana", compressible: !0 },
    "application/vnd.cyclonedx+xml": { source: "iana", compressible: !0 },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: !1,
    },
    "application/vnd.d3m-dataset": { source: "iana" },
    "application/vnd.d3m-problem": { source: "iana" },
    "application/vnd.dart": {
      source: "iana",
      compressible: !0,
      extensions: ["dart"],
    },
    "application/vnd.data-vision.rdz": { source: "iana", extensions: ["rdz"] },
    "application/vnd.datapackage+json": { source: "iana", compressible: !0 },
    "application/vnd.dataresource+json": { source: "iana", compressible: !0 },
    "application/vnd.dbf": { source: "iana", extensions: ["dbf"] },
    "application/vnd.debian.binary-package": { source: "iana" },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"],
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["uvt", "uvvt"],
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"],
    },
    "application/vnd.dece.zip": { source: "iana", extensions: ["uvz", "uvvz"] },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"],
    },
    "application/vnd.desmume.movie": { source: "iana" },
    "application/vnd.dir-bi.plate-dl-nosuffix": { source: "iana" },
    "application/vnd.dm.delegation+xml": { source: "iana", compressible: !0 },
    "application/vnd.dna": { source: "iana", extensions: ["dna"] },
    "application/vnd.document+json": { source: "iana", compressible: !0 },
    "application/vnd.dolby.mlp": { source: "apache", extensions: ["mlp"] },
    "application/vnd.dolby.mobile.1": { source: "iana" },
    "application/vnd.dolby.mobile.2": { source: "iana" },
    "application/vnd.doremir.scorecloud-binary-document": { source: "iana" },
    "application/vnd.dpgraph": { source: "iana", extensions: ["dpg"] },
    "application/vnd.dreamfactory": { source: "iana", extensions: ["dfac"] },
    "application/vnd.drive+json": { source: "iana", compressible: !0 },
    "application/vnd.ds-keypoint": { source: "apache", extensions: ["kpxx"] },
    "application/vnd.dtg.local": { source: "iana" },
    "application/vnd.dtg.local.flash": { source: "iana" },
    "application/vnd.dtg.local.html": { source: "iana" },
    "application/vnd.dvb.ait": { source: "iana", extensions: ["ait"] },
    "application/vnd.dvb.dvbisl+xml": { source: "iana", compressible: !0 },
    "application/vnd.dvb.dvbj": { source: "iana" },
    "application/vnd.dvb.esgcontainer": { source: "iana" },
    "application/vnd.dvb.ipdcdftnotifaccess": { source: "iana" },
    "application/vnd.dvb.ipdcesgaccess": { source: "iana" },
    "application/vnd.dvb.ipdcesgaccess2": { source: "iana" },
    "application/vnd.dvb.ipdcesgpdd": { source: "iana" },
    "application/vnd.dvb.ipdcroaming": { source: "iana" },
    "application/vnd.dvb.iptv.alfec-base": { source: "iana" },
    "application/vnd.dvb.iptv.alfec-enhancement": { source: "iana" },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.dvb.notif-init+xml": { source: "iana", compressible: !0 },
    "application/vnd.dvb.pfr": { source: "iana" },
    "application/vnd.dvb.service": { source: "iana", extensions: ["svc"] },
    "application/vnd.dxr": { source: "iana" },
    "application/vnd.dynageo": { source: "iana", extensions: ["geo"] },
    "application/vnd.dzr": { source: "iana" },
    "application/vnd.easykaraoke.cdgdownload": { source: "iana" },
    "application/vnd.ecdis-update": { source: "iana" },
    "application/vnd.ecip.rlp": { source: "iana" },
    "application/vnd.eclipse.ditto+json": { source: "iana", compressible: !0 },
    "application/vnd.ecowin.chart": { source: "iana", extensions: ["mag"] },
    "application/vnd.ecowin.filerequest": { source: "iana" },
    "application/vnd.ecowin.fileupdate": { source: "iana" },
    "application/vnd.ecowin.series": { source: "iana" },
    "application/vnd.ecowin.seriesrequest": { source: "iana" },
    "application/vnd.ecowin.seriesupdate": { source: "iana" },
    "application/vnd.efi.img": { source: "iana" },
    "application/vnd.efi.iso": { source: "iana" },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.enliven": { source: "iana", extensions: ["nml"] },
    "application/vnd.enphase.envoy": { source: "iana" },
    "application/vnd.eprints.data+xml": { source: "iana", compressible: !0 },
    "application/vnd.epson.esf": { source: "iana", extensions: ["esf"] },
    "application/vnd.epson.msf": { source: "iana", extensions: ["msf"] },
    "application/vnd.epson.quickanime": { source: "iana", extensions: ["qam"] },
    "application/vnd.epson.salt": { source: "iana", extensions: ["slt"] },
    "application/vnd.epson.ssf": { source: "iana", extensions: ["ssf"] },
    "application/vnd.ericsson.quickcall": { source: "iana" },
    "application/vnd.espass-espass+zip": { source: "iana", compressible: !1 },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["es3", "et3"],
    },
    "application/vnd.etsi.aoc+xml": { source: "iana", compressible: !0 },
    "application/vnd.etsi.asic-e+zip": { source: "iana", compressible: !1 },
    "application/vnd.etsi.asic-s+zip": { source: "iana", compressible: !1 },
    "application/vnd.etsi.cug+xml": { source: "iana", compressible: !0 },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.etsi.iptvsad-bc+xml": { source: "iana", compressible: !0 },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.etsi.iptvsync+xml": { source: "iana", compressible: !0 },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.etsi.mcid+xml": { source: "iana", compressible: !0 },
    "application/vnd.etsi.mheg5": { source: "iana" },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.etsi.pstn+xml": { source: "iana", compressible: !0 },
    "application/vnd.etsi.sci+xml": { source: "iana", compressible: !0 },
    "application/vnd.etsi.simservs+xml": { source: "iana", compressible: !0 },
    "application/vnd.etsi.timestamp-token": { source: "iana" },
    "application/vnd.etsi.tsl+xml": { source: "iana", compressible: !0 },
    "application/vnd.etsi.tsl.der": { source: "iana" },
    "application/vnd.eu.kasparian.car+json": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.eudora.data": { source: "iana" },
    "application/vnd.evolv.ecig.profile": { source: "iana" },
    "application/vnd.evolv.ecig.settings": { source: "iana" },
    "application/vnd.evolv.ecig.theme": { source: "iana" },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: !1,
    },
    "application/vnd.exstream-package": { source: "iana" },
    "application/vnd.ezpix-album": { source: "iana", extensions: ["ez2"] },
    "application/vnd.ezpix-package": { source: "iana", extensions: ["ez3"] },
    "application/vnd.f-secure.mobile": { source: "iana" },
    "application/vnd.familysearch.gedcom+zip": {
      source: "iana",
      compressible: !1,
    },
    "application/vnd.fastcopy-disk-image": { source: "iana" },
    "application/vnd.fdf": { source: "iana", extensions: ["fdf"] },
    "application/vnd.fdsn.mseed": { source: "iana", extensions: ["mseed"] },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"],
    },
    "application/vnd.ffsns": { source: "iana" },
    "application/vnd.ficlab.flb+zip": { source: "iana", compressible: !1 },
    "application/vnd.filmit.zfc": { source: "iana" },
    "application/vnd.fints": { source: "iana" },
    "application/vnd.firemonkeys.cloudcell": { source: "iana" },
    "application/vnd.flographit": { source: "iana", extensions: ["gph"] },
    "application/vnd.fluxtime.clip": { source: "iana", extensions: ["ftc"] },
    "application/vnd.font-fontforge-sfd": { source: "iana" },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"],
    },
    "application/vnd.frogans.fnc": { source: "iana", extensions: ["fnc"] },
    "application/vnd.frogans.ltf": { source: "iana", extensions: ["ltf"] },
    "application/vnd.fsc.weblaunch": { source: "iana", extensions: ["fsc"] },
    "application/vnd.fujifilm.fb.docuworks": { source: "iana" },
    "application/vnd.fujifilm.fb.docuworks.binder": { source: "iana" },
    "application/vnd.fujifilm.fb.docuworks.container": { source: "iana" },
    "application/vnd.fujifilm.fb.jfi+xml": { source: "iana", compressible: !0 },
    "application/vnd.fujitsu.oasys": { source: "iana", extensions: ["oas"] },
    "application/vnd.fujitsu.oasys2": { source: "iana", extensions: ["oa2"] },
    "application/vnd.fujitsu.oasys3": { source: "iana", extensions: ["oa3"] },
    "application/vnd.fujitsu.oasysgp": { source: "iana", extensions: ["fg5"] },
    "application/vnd.fujitsu.oasysprs": { source: "iana", extensions: ["bh2"] },
    "application/vnd.fujixerox.art-ex": { source: "iana" },
    "application/vnd.fujixerox.art4": { source: "iana" },
    "application/vnd.fujixerox.ddd": { source: "iana", extensions: ["ddd"] },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"],
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"],
    },
    "application/vnd.fujixerox.docuworks.container": { source: "iana" },
    "application/vnd.fujixerox.hbpl": { source: "iana" },
    "application/vnd.fut-misnet": { source: "iana" },
    "application/vnd.futoin+cbor": { source: "iana" },
    "application/vnd.futoin+json": { source: "iana", compressible: !0 },
    "application/vnd.fuzzysheet": { source: "iana", extensions: ["fzs"] },
    "application/vnd.genomatix.tuxedo": { source: "iana", extensions: ["txd"] },
    "application/vnd.gentics.grd+json": { source: "iana", compressible: !0 },
    "application/vnd.geo+json": { source: "iana", compressible: !0 },
    "application/vnd.geocube+xml": { source: "iana", compressible: !0 },
    "application/vnd.geogebra.file": { source: "iana", extensions: ["ggb"] },
    "application/vnd.geogebra.slides": { source: "iana" },
    "application/vnd.geogebra.tool": { source: "iana", extensions: ["ggt"] },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"],
    },
    "application/vnd.geonext": { source: "iana", extensions: ["gxt"] },
    "application/vnd.geoplan": { source: "iana", extensions: ["g2w"] },
    "application/vnd.geospace": { source: "iana", extensions: ["g3w"] },
    "application/vnd.gerber": { source: "iana" },
    "application/vnd.globalplatform.card-content-mgt": { source: "iana" },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana",
    },
    "application/vnd.gmx": { source: "iana", extensions: ["gmx"] },
    "application/vnd.google-apps.document": {
      compressible: !1,
      extensions: ["gdoc"],
    },
    "application/vnd.google-apps.presentation": {
      compressible: !1,
      extensions: ["gslides"],
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: !1,
      extensions: ["gsheet"],
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["kml"],
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: !1,
      extensions: ["kmz"],
    },
    "application/vnd.gov.sk.e-form+xml": { source: "iana", compressible: !0 },
    "application/vnd.gov.sk.e-form+zip": { source: "iana", compressible: !1 },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.grafeq": { source: "iana", extensions: ["gqf", "gqs"] },
    "application/vnd.gridmp": { source: "iana" },
    "application/vnd.groove-account": { source: "iana", extensions: ["gac"] },
    "application/vnd.groove-help": { source: "iana", extensions: ["ghf"] },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"],
    },
    "application/vnd.groove-injector": { source: "iana", extensions: ["grv"] },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"],
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"],
    },
    "application/vnd.groove-vcard": { source: "iana", extensions: ["vcg"] },
    "application/vnd.hal+json": { source: "iana", compressible: !0 },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["hal"],
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["zmm"],
    },
    "application/vnd.hbci": { source: "iana", extensions: ["hbci"] },
    "application/vnd.hc+json": { source: "iana", compressible: !0 },
    "application/vnd.hcl-bireports": { source: "iana" },
    "application/vnd.hdt": { source: "iana" },
    "application/vnd.heroku+json": { source: "iana", compressible: !0 },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"],
    },
    "application/vnd.hl7cda+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
    },
    "application/vnd.hl7v2+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
    },
    "application/vnd.hp-hpgl": { source: "iana", extensions: ["hpgl"] },
    "application/vnd.hp-hpid": { source: "iana", extensions: ["hpid"] },
    "application/vnd.hp-hps": { source: "iana", extensions: ["hps"] },
    "application/vnd.hp-jlyt": { source: "iana", extensions: ["jlt"] },
    "application/vnd.hp-pcl": { source: "iana", extensions: ["pcl"] },
    "application/vnd.hp-pclxl": { source: "iana", extensions: ["pclxl"] },
    "application/vnd.httphone": { source: "iana" },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"],
    },
    "application/vnd.hyper+json": { source: "iana", compressible: !0 },
    "application/vnd.hyper-item+json": { source: "iana", compressible: !0 },
    "application/vnd.hyperdrive+json": { source: "iana", compressible: !0 },
    "application/vnd.hzn-3d-crossword": { source: "iana" },
    "application/vnd.ibm.afplinedata": { source: "iana" },
    "application/vnd.ibm.electronic-media": { source: "iana" },
    "application/vnd.ibm.minipay": { source: "iana", extensions: ["mpy"] },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"],
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"],
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"],
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"],
    },
    "application/vnd.ieee.1905": { source: "iana" },
    "application/vnd.igloader": { source: "iana", extensions: ["igl"] },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: !1,
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: !1,
    },
    "application/vnd.immervision-ivp": { source: "iana", extensions: ["ivp"] },
    "application/vnd.immervision-ivu": { source: "iana", extensions: ["ivu"] },
    "application/vnd.ims.imsccv1p1": { source: "iana" },
    "application/vnd.ims.imsccv1p2": { source: "iana" },
    "application/vnd.ims.imsccv1p3": { source: "iana" },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.informix-visionary": { source: "iana" },
    "application/vnd.infotech.project": { source: "iana" },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.innopath.wamp.notification": { source: "iana" },
    "application/vnd.insors.igm": { source: "iana", extensions: ["igm"] },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"],
    },
    "application/vnd.intergeo": { source: "iana", extensions: ["i2g"] },
    "application/vnd.intertrust.digibox": { source: "iana" },
    "application/vnd.intertrust.nncp": { source: "iana" },
    "application/vnd.intu.qbo": { source: "iana", extensions: ["qbo"] },
    "application/vnd.intu.qfx": { source: "iana", extensions: ["qfx"] },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"],
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["irp"],
    },
    "application/vnd.is-xpr": { source: "iana", extensions: ["xpr"] },
    "application/vnd.isac.fcs": { source: "iana", extensions: ["fcs"] },
    "application/vnd.iso11783-10+zip": { source: "iana", compressible: !1 },
    "application/vnd.jam": { source: "iana", extensions: ["jam"] },
    "application/vnd.japannet-directory-service": { source: "iana" },
    "application/vnd.japannet-jpnstore-wakeup": { source: "iana" },
    "application/vnd.japannet-payment-wakeup": { source: "iana" },
    "application/vnd.japannet-registration": { source: "iana" },
    "application/vnd.japannet-registration-wakeup": { source: "iana" },
    "application/vnd.japannet-setstore-wakeup": { source: "iana" },
    "application/vnd.japannet-verification": { source: "iana" },
    "application/vnd.japannet-verification-wakeup": { source: "iana" },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"],
    },
    "application/vnd.jisp": { source: "iana", extensions: ["jisp"] },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"],
    },
    "application/vnd.jsk.isdn-ngn": { source: "iana" },
    "application/vnd.kahootz": { source: "iana", extensions: ["ktz", "ktr"] },
    "application/vnd.kde.karbon": { source: "iana", extensions: ["karbon"] },
    "application/vnd.kde.kchart": { source: "iana", extensions: ["chrt"] },
    "application/vnd.kde.kformula": { source: "iana", extensions: ["kfo"] },
    "application/vnd.kde.kivio": { source: "iana", extensions: ["flw"] },
    "application/vnd.kde.kontour": { source: "iana", extensions: ["kon"] },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"],
    },
    "application/vnd.kde.kspread": { source: "iana", extensions: ["ksp"] },
    "application/vnd.kde.kword": { source: "iana", extensions: ["kwd", "kwt"] },
    "application/vnd.kenameaapp": { source: "iana", extensions: ["htke"] },
    "application/vnd.kidspiration": { source: "iana", extensions: ["kia"] },
    "application/vnd.kinar": { source: "iana", extensions: ["kne", "knp"] },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"],
    },
    "application/vnd.kodak-descriptor": { source: "iana", extensions: ["sse"] },
    "application/vnd.las": { source: "iana" },
    "application/vnd.las.las+json": { source: "iana", compressible: !0 },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["lasxml"],
    },
    "application/vnd.laszip": { source: "iana" },
    "application/vnd.leap+json": { source: "iana", compressible: !0 },
    "application/vnd.liberty-request+xml": { source: "iana", compressible: !0 },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"],
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["lbe"],
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: !1,
    },
    "application/vnd.loom": { source: "iana" },
    "application/vnd.lotus-1-2-3": { source: "iana", extensions: ["123"] },
    "application/vnd.lotus-approach": { source: "iana", extensions: ["apr"] },
    "application/vnd.lotus-freelance": { source: "iana", extensions: ["pre"] },
    "application/vnd.lotus-notes": { source: "iana", extensions: ["nsf"] },
    "application/vnd.lotus-organizer": { source: "iana", extensions: ["org"] },
    "application/vnd.lotus-screencam": { source: "iana", extensions: ["scm"] },
    "application/vnd.lotus-wordpro": { source: "iana", extensions: ["lwp"] },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"],
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana",
      extensions: ["mvt"],
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.marlin.drm.mdcf": { source: "iana" },
    "application/vnd.mason+json": { source: "iana", compressible: !0 },
    "application/vnd.maxar.archive.3tz+zip": {
      source: "iana",
      compressible: !1,
    },
    "application/vnd.maxmind.maxmind-db": { source: "iana" },
    "application/vnd.mcd": { source: "iana", extensions: ["mcd"] },
    "application/vnd.medcalcdata": { source: "iana", extensions: ["mc1"] },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"],
    },
    "application/vnd.meridian-slingshot": { source: "iana" },
    "application/vnd.mfer": { source: "iana", extensions: ["mwf"] },
    "application/vnd.mfmp": { source: "iana", extensions: ["mfm"] },
    "application/vnd.micro+json": { source: "iana", compressible: !0 },
    "application/vnd.micrografx.flo": { source: "iana", extensions: ["flo"] },
    "application/vnd.micrografx.igx": { source: "iana", extensions: ["igx"] },
    "application/vnd.microsoft.portable-executable": { source: "iana" },
    "application/vnd.microsoft.windows.thumbnail-cache": { source: "iana" },
    "application/vnd.miele+json": { source: "iana", compressible: !0 },
    "application/vnd.mif": { source: "iana", extensions: ["mif"] },
    "application/vnd.minisoft-hp3000-save": { source: "iana" },
    "application/vnd.mitsubishi.misty-guard.trustweb": { source: "iana" },
    "application/vnd.mobius.daf": { source: "iana", extensions: ["daf"] },
    "application/vnd.mobius.dis": { source: "iana", extensions: ["dis"] },
    "application/vnd.mobius.mbk": { source: "iana", extensions: ["mbk"] },
    "application/vnd.mobius.mqy": { source: "iana", extensions: ["mqy"] },
    "application/vnd.mobius.msl": { source: "iana", extensions: ["msl"] },
    "application/vnd.mobius.plc": { source: "iana", extensions: ["plc"] },
    "application/vnd.mobius.txf": { source: "iana", extensions: ["txf"] },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"],
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"],
    },
    "application/vnd.motorola.flexsuite": { source: "iana" },
    "application/vnd.motorola.flexsuite.adsi": { source: "iana" },
    "application/vnd.motorola.flexsuite.fis": { source: "iana" },
    "application/vnd.motorola.flexsuite.gotap": { source: "iana" },
    "application/vnd.motorola.flexsuite.kmr": { source: "iana" },
    "application/vnd.motorola.flexsuite.ttc": { source: "iana" },
    "application/vnd.motorola.flexsuite.wem": { source: "iana" },
    "application/vnd.motorola.iprm": { source: "iana" },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xul"],
    },
    "application/vnd.ms-3mfdocument": { source: "iana" },
    "application/vnd.ms-artgalry": { source: "iana", extensions: ["cil"] },
    "application/vnd.ms-asf": { source: "iana" },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"],
    },
    "application/vnd.ms-color.iccprofile": { source: "apache" },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: !1,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"],
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"],
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"],
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"],
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"],
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: !0,
      extensions: ["eot"],
    },
    "application/vnd.ms-htmlhelp": { source: "iana", extensions: ["chm"] },
    "application/vnd.ms-ims": { source: "iana", extensions: ["ims"] },
    "application/vnd.ms-lrm": { source: "iana", extensions: ["lrm"] },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.ms-officetheme": { source: "iana", extensions: ["thmx"] },
    "application/vnd.ms-opentype": { source: "apache", compressible: !0 },
    "application/vnd.ms-outlook": { compressible: !1, extensions: ["msg"] },
    "application/vnd.ms-package.obfuscated-opentype": { source: "apache" },
    "application/vnd.ms-pki.seccat": { source: "apache", extensions: ["cat"] },
    "application/vnd.ms-pki.stl": { source: "apache", extensions: ["stl"] },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: !1,
      extensions: ["ppt", "pps", "pot"],
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"],
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"],
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"],
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"],
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"],
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: !0,
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"],
    },
    "application/vnd.ms-tnef": { source: "iana" },
    "application/vnd.ms-windows.devicepairing": { source: "iana" },
    "application/vnd.ms-windows.nwprinting.oob": { source: "iana" },
    "application/vnd.ms-windows.printerpairing": { source: "iana" },
    "application/vnd.ms-windows.wsd.oob": { source: "iana" },
    "application/vnd.ms-wmdrm.lic-chlg-req": { source: "iana" },
    "application/vnd.ms-wmdrm.lic-resp": { source: "iana" },
    "application/vnd.ms-wmdrm.meter-chlg-req": { source: "iana" },
    "application/vnd.ms-wmdrm.meter-resp": { source: "iana" },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"],
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"],
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"],
    },
    "application/vnd.ms-wpl": { source: "iana", extensions: ["wpl"] },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: !1,
      extensions: ["xps"],
    },
    "application/vnd.msa-disk-image": { source: "iana" },
    "application/vnd.mseq": { source: "iana", extensions: ["mseq"] },
    "application/vnd.msign": { source: "iana" },
    "application/vnd.multiad.creator": { source: "iana" },
    "application/vnd.multiad.creator.cif": { source: "iana" },
    "application/vnd.music-niff": { source: "iana" },
    "application/vnd.musician": { source: "iana", extensions: ["mus"] },
    "application/vnd.muvee.style": { source: "iana", extensions: ["msty"] },
    "application/vnd.mynfc": { source: "iana", extensions: ["taglet"] },
    "application/vnd.nacamar.ybrid+json": { source: "iana", compressible: !0 },
    "application/vnd.ncd.control": { source: "iana" },
    "application/vnd.ncd.reference": { source: "iana" },
    "application/vnd.nearst.inv+json": { source: "iana", compressible: !0 },
    "application/vnd.nebumind.line": { source: "iana" },
    "application/vnd.nervana": { source: "iana" },
    "application/vnd.netfpx": { source: "iana" },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"],
    },
    "application/vnd.nimn": { source: "iana" },
    "application/vnd.nintendo.nitro.rom": { source: "iana" },
    "application/vnd.nintendo.snes.rom": { source: "iana" },
    "application/vnd.nitf": { source: "iana", extensions: ["ntf", "nitf"] },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"],
    },
    "application/vnd.noblenet-sealer": { source: "iana", extensions: ["nns"] },
    "application/vnd.noblenet-web": { source: "iana", extensions: ["nnw"] },
    "application/vnd.nokia.catalogs": { source: "iana" },
    "application/vnd.nokia.conml+wbxml": { source: "iana" },
    "application/vnd.nokia.conml+xml": { source: "iana", compressible: !0 },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.nokia.isds-radio-presets": { source: "iana" },
    "application/vnd.nokia.landmark+wbxml": { source: "iana" },
    "application/vnd.nokia.landmark+xml": { source: "iana", compressible: !0 },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["ac"],
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"],
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"],
    },
    "application/vnd.nokia.ncd": { source: "iana" },
    "application/vnd.nokia.pcd+wbxml": { source: "iana" },
    "application/vnd.nokia.pcd+xml": { source: "iana", compressible: !0 },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"],
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"],
    },
    "application/vnd.novadigm.edm": { source: "iana", extensions: ["edm"] },
    "application/vnd.novadigm.edx": { source: "iana", extensions: ["edx"] },
    "application/vnd.novadigm.ext": { source: "iana", extensions: ["ext"] },
    "application/vnd.ntt-local.content-share": { source: "iana" },
    "application/vnd.ntt-local.file-transfer": { source: "iana" },
    "application/vnd.ntt-local.ogw_remote-access": { source: "iana" },
    "application/vnd.ntt-local.sip-ta_remote": { source: "iana" },
    "application/vnd.ntt-local.sip-ta_tcp_stream": { source: "iana" },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"],
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"],
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"],
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"],
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"],
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: !1,
      extensions: ["odg"],
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"],
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"],
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"],
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: !1,
      extensions: ["odp"],
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"],
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: !1,
      extensions: ["ods"],
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"],
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: !1,
      extensions: ["odt"],
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"],
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"],
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"],
    },
    "application/vnd.obn": { source: "iana" },
    "application/vnd.ocf+cbor": { source: "iana" },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.oftn.l10n+json": { source: "iana", compressible: !0 },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.oipf.cspg-hexbinary": { source: "iana" },
    "application/vnd.oipf.dae.svg+xml": { source: "iana", compressible: !0 },
    "application/vnd.oipf.dae.xhtml+xml": { source: "iana", compressible: !0 },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.oipf.pae.gem": { source: "iana" },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.oipf.spdlist+xml": { source: "iana", compressible: !0 },
    "application/vnd.oipf.ueprofile+xml": { source: "iana", compressible: !0 },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.olpc-sugar": { source: "iana", extensions: ["xo"] },
    "application/vnd.oma-scws-config": { source: "iana" },
    "application/vnd.oma-scws-http-request": { source: "iana" },
    "application/vnd.oma-scws-http-response": { source: "iana" },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.oma.bcast.imd+xml": { source: "iana", compressible: !0 },
    "application/vnd.oma.bcast.ltkm": { source: "iana" },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.oma.bcast.provisioningtrigger": { source: "iana" },
    "application/vnd.oma.bcast.sgboot": { source: "iana" },
    "application/vnd.oma.bcast.sgdd+xml": { source: "iana", compressible: !0 },
    "application/vnd.oma.bcast.sgdu": { source: "iana" },
    "application/vnd.oma.bcast.simple-symbol-container": { source: "iana" },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.oma.bcast.sprov+xml": { source: "iana", compressible: !0 },
    "application/vnd.oma.bcast.stkm": { source: "iana" },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.oma.cab-pcc+xml": { source: "iana", compressible: !0 },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.oma.dcd": { source: "iana" },
    "application/vnd.oma.dcdc": { source: "iana" },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["dd2"],
    },
    "application/vnd.oma.drm.risd+xml": { source: "iana", compressible: !0 },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.oma.lwm2m+cbor": { source: "iana" },
    "application/vnd.oma.lwm2m+json": { source: "iana", compressible: !0 },
    "application/vnd.oma.lwm2m+tlv": { source: "iana" },
    "application/vnd.oma.pal+xml": { source: "iana", compressible: !0 },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.oma.poc.groups+xml": { source: "iana", compressible: !0 },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.oma.push": { source: "iana" },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
    },
    "application/vnd.omaloc-supl-init": { source: "iana" },
    "application/vnd.onepager": { source: "iana" },
    "application/vnd.onepagertamp": { source: "iana" },
    "application/vnd.onepagertamx": { source: "iana" },
    "application/vnd.onepagertat": { source: "iana" },
    "application/vnd.onepagertatp": { source: "iana" },
    "application/vnd.onepagertatx": { source: "iana" },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["obgx"],
    },
    "application/vnd.openblox.game-binary": { source: "iana" },
    "application/vnd.openeye.oeb": { source: "iana" },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"],
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["osm"],
    },
    "application/vnd.opentimestamps.ots": { source: "iana" },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation":
      { source: "iana", compressible: !1, extensions: ["pptx"] },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"],
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"],
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"],
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: !1,
      extensions: ["xlsx"],
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"],
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana",
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: !1,
      extensions: ["docx"],
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"],
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":
      { source: "iana", compressible: !0 },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.orange.indata": { source: "iana" },
    "application/vnd.osa.netdeploy": { source: "iana" },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"],
    },
    "application/vnd.osgi.bundle": { source: "iana" },
    "application/vnd.osgi.dp": { source: "iana", extensions: ["dp"] },
    "application/vnd.osgi.subsystem": { source: "iana", extensions: ["esa"] },
    "application/vnd.otps.ct-kip+xml": { source: "iana", compressible: !0 },
    "application/vnd.oxli.countgraph": { source: "iana" },
    "application/vnd.pagerduty+json": { source: "iana", compressible: !0 },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"],
    },
    "application/vnd.panoply": { source: "iana" },
    "application/vnd.paos.xml": { source: "iana" },
    "application/vnd.patentdive": { source: "iana" },
    "application/vnd.patientecommsdoc": { source: "iana" },
    "application/vnd.pawaafile": { source: "iana", extensions: ["paw"] },
    "application/vnd.pcos": { source: "iana" },
    "application/vnd.pg.format": { source: "iana", extensions: ["str"] },
    "application/vnd.pg.osasli": { source: "iana", extensions: ["ei6"] },
    "application/vnd.piaccess.application-licence": { source: "iana" },
    "application/vnd.picsel": { source: "iana", extensions: ["efif"] },
    "application/vnd.pmi.widget": { source: "iana", extensions: ["wg"] },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.pocketlearn": { source: "iana", extensions: ["plf"] },
    "application/vnd.powerbuilder6": { source: "iana", extensions: ["pbd"] },
    "application/vnd.powerbuilder6-s": { source: "iana" },
    "application/vnd.powerbuilder7": { source: "iana" },
    "application/vnd.powerbuilder7-s": { source: "iana" },
    "application/vnd.powerbuilder75": { source: "iana" },
    "application/vnd.powerbuilder75-s": { source: "iana" },
    "application/vnd.preminet": { source: "iana" },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"],
    },
    "application/vnd.proteus.magazine": { source: "iana", extensions: ["mgz"] },
    "application/vnd.psfs": { source: "iana" },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"],
    },
    "application/vnd.pvi.ptid1": { source: "iana", extensions: ["ptid"] },
    "application/vnd.pwg-multiplexed": { source: "iana" },
    "application/vnd.pwg-xhtml-print+xml": { source: "iana", compressible: !0 },
    "application/vnd.qualcomm.brew-app-res": { source: "iana" },
    "application/vnd.quarantainenet": { source: "iana" },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"],
    },
    "application/vnd.quobject-quoxdocument": { source: "iana" },
    "application/vnd.radisys.moml+xml": { source: "iana", compressible: !0 },
    "application/vnd.radisys.msml+xml": { source: "iana", compressible: !0 },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.rainstor.data": { source: "iana" },
    "application/vnd.rapid": { source: "iana" },
    "application/vnd.rar": { source: "iana", extensions: ["rar"] },
    "application/vnd.realvnc.bed": { source: "iana", extensions: ["bed"] },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"],
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["musicxml"],
    },
    "application/vnd.renlearn.rlprint": { source: "iana" },
    "application/vnd.resilient.logic": { source: "iana" },
    "application/vnd.restful+json": { source: "iana", compressible: !0 },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"],
    },
    "application/vnd.rim.cod": { source: "apache", extensions: ["cod"] },
    "application/vnd.rn-realmedia": { source: "apache", extensions: ["rm"] },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"],
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["link66"],
    },
    "application/vnd.rs-274x": { source: "iana" },
    "application/vnd.ruckus.download": { source: "iana" },
    "application/vnd.s3sms": { source: "iana" },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"],
    },
    "application/vnd.sar": { source: "iana" },
    "application/vnd.sbm.cid": { source: "iana" },
    "application/vnd.sbm.mid2": { source: "iana" },
    "application/vnd.scribus": { source: "iana" },
    "application/vnd.sealed.3df": { source: "iana" },
    "application/vnd.sealed.csf": { source: "iana" },
    "application/vnd.sealed.doc": { source: "iana" },
    "application/vnd.sealed.eml": { source: "iana" },
    "application/vnd.sealed.mht": { source: "iana" },
    "application/vnd.sealed.net": { source: "iana" },
    "application/vnd.sealed.ppt": { source: "iana" },
    "application/vnd.sealed.tiff": { source: "iana" },
    "application/vnd.sealed.xls": { source: "iana" },
    "application/vnd.sealedmedia.softseal.html": { source: "iana" },
    "application/vnd.sealedmedia.softseal.pdf": { source: "iana" },
    "application/vnd.seemail": { source: "iana", extensions: ["see"] },
    "application/vnd.seis+json": { source: "iana", compressible: !0 },
    "application/vnd.sema": { source: "iana", extensions: ["sema"] },
    "application/vnd.semd": { source: "iana", extensions: ["semd"] },
    "application/vnd.semf": { source: "iana", extensions: ["semf"] },
    "application/vnd.shade-save-file": { source: "iana" },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"],
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"],
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"],
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"],
    },
    "application/vnd.shootproof+json": { source: "iana", compressible: !0 },
    "application/vnd.shopkick+json": { source: "iana", compressible: !0 },
    "application/vnd.shp": { source: "iana" },
    "application/vnd.shx": { source: "iana" },
    "application/vnd.sigrok.session": { source: "iana" },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"],
    },
    "application/vnd.siren+json": { source: "iana", compressible: !0 },
    "application/vnd.smaf": { source: "iana", extensions: ["mmf"] },
    "application/vnd.smart.notebook": { source: "iana" },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"],
    },
    "application/vnd.snesdev-page-table": { source: "iana" },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["fo"],
    },
    "application/vnd.software602.filler.form-xml-zip": { source: "iana" },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["sdkm", "sdkd"],
    },
    "application/vnd.spotfire.dxp": { source: "iana", extensions: ["dxp"] },
    "application/vnd.spotfire.sfs": { source: "iana", extensions: ["sfs"] },
    "application/vnd.sqlite3": { source: "iana" },
    "application/vnd.sss-cod": { source: "iana" },
    "application/vnd.sss-dtf": { source: "iana" },
    "application/vnd.sss-ntf": { source: "iana" },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"],
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"],
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"],
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"],
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"],
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"],
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"],
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"],
    },
    "application/vnd.street-stream": { source: "iana" },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["wadl"],
    },
    "application/vnd.sun.xml.calc": { source: "apache", extensions: ["sxc"] },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"],
    },
    "application/vnd.sun.xml.draw": { source: "apache", extensions: ["sxd"] },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"],
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"],
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"],
    },
    "application/vnd.sun.xml.math": { source: "apache", extensions: ["sxm"] },
    "application/vnd.sun.xml.writer": { source: "apache", extensions: ["sxw"] },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"],
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"],
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"],
    },
    "application/vnd.svd": { source: "iana", extensions: ["svd"] },
    "application/vnd.swiftview-ics": { source: "iana" },
    "application/vnd.sycle+xml": { source: "iana", compressible: !0 },
    "application/vnd.syft+json": { source: "iana", compressible: !0 },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"],
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["xsm"],
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"],
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["xdm"],
    },
    "application/vnd.syncml.dm.notification": { source: "iana" },
    "application/vnd.syncml.dmddf+wbxml": { source: "iana" },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["ddf"],
    },
    "application/vnd.syncml.dmtnds+wbxml": { source: "iana" },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
    },
    "application/vnd.syncml.ds.notification": { source: "iana" },
    "application/vnd.tableschema+json": { source: "iana", compressible: !0 },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"],
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"],
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/vnd.tml": { source: "iana" },
    "application/vnd.tmobile-livetv": { source: "iana", extensions: ["tmo"] },
    "application/vnd.tri.onesource": { source: "iana" },
    "application/vnd.trid.tpt": { source: "iana", extensions: ["tpt"] },
    "application/vnd.triscape.mxs": { source: "iana", extensions: ["mxs"] },
    "application/vnd.trueapp": { source: "iana", extensions: ["tra"] },
    "application/vnd.truedoc": { source: "iana" },
    "application/vnd.ubisoft.webplayer": { source: "iana" },
    "application/vnd.ufdl": { source: "iana", extensions: ["ufd", "ufdl"] },
    "application/vnd.uiq.theme": { source: "iana", extensions: ["utz"] },
    "application/vnd.umajin": { source: "iana", extensions: ["umj"] },
    "application/vnd.unity": { source: "iana", extensions: ["unityweb"] },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["uoml"],
    },
    "application/vnd.uplanet.alert": { source: "iana" },
    "application/vnd.uplanet.alert-wbxml": { source: "iana" },
    "application/vnd.uplanet.bearer-choice": { source: "iana" },
    "application/vnd.uplanet.bearer-choice-wbxml": { source: "iana" },
    "application/vnd.uplanet.cacheop": { source: "iana" },
    "application/vnd.uplanet.cacheop-wbxml": { source: "iana" },
    "application/vnd.uplanet.channel": { source: "iana" },
    "application/vnd.uplanet.channel-wbxml": { source: "iana" },
    "application/vnd.uplanet.list": { source: "iana" },
    "application/vnd.uplanet.list-wbxml": { source: "iana" },
    "application/vnd.uplanet.listcmd": { source: "iana" },
    "application/vnd.uplanet.listcmd-wbxml": { source: "iana" },
    "application/vnd.uplanet.signal": { source: "iana" },
    "application/vnd.uri-map": { source: "iana" },
    "application/vnd.valve.source.material": { source: "iana" },
    "application/vnd.vcx": { source: "iana", extensions: ["vcx"] },
    "application/vnd.vd-study": { source: "iana" },
    "application/vnd.vectorworks": { source: "iana" },
    "application/vnd.vel+json": { source: "iana", compressible: !0 },
    "application/vnd.verimatrix.vcas": { source: "iana" },
    "application/vnd.veritone.aion+json": { source: "iana", compressible: !0 },
    "application/vnd.veryant.thin": { source: "iana" },
    "application/vnd.ves.encrypted": { source: "iana" },
    "application/vnd.vidsoft.vidconference": { source: "iana" },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"],
    },
    "application/vnd.visionary": { source: "iana", extensions: ["vis"] },
    "application/vnd.vividence.scriptfile": { source: "iana" },
    "application/vnd.vsf": { source: "iana", extensions: ["vsf"] },
    "application/vnd.wap.sic": { source: "iana" },
    "application/vnd.wap.slc": { source: "iana" },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"],
    },
    "application/vnd.wap.wmlc": { source: "iana", extensions: ["wmlc"] },
    "application/vnd.wap.wmlscriptc": { source: "iana", extensions: ["wmlsc"] },
    "application/vnd.webturbo": { source: "iana", extensions: ["wtb"] },
    "application/vnd.wfa.dpp": { source: "iana" },
    "application/vnd.wfa.p2p": { source: "iana" },
    "application/vnd.wfa.wsc": { source: "iana" },
    "application/vnd.windows.devicepairing": { source: "iana" },
    "application/vnd.wmc": { source: "iana" },
    "application/vnd.wmf.bootstrap": { source: "iana" },
    "application/vnd.wolfram.mathematica": { source: "iana" },
    "application/vnd.wolfram.mathematica.package": { source: "iana" },
    "application/vnd.wolfram.player": { source: "iana", extensions: ["nbp"] },
    "application/vnd.wordperfect": { source: "iana", extensions: ["wpd"] },
    "application/vnd.wqd": { source: "iana", extensions: ["wqd"] },
    "application/vnd.wrq-hp3000-labelled": { source: "iana" },
    "application/vnd.wt.stf": { source: "iana", extensions: ["stf"] },
    "application/vnd.wv.csp+wbxml": { source: "iana" },
    "application/vnd.wv.csp+xml": { source: "iana", compressible: !0 },
    "application/vnd.wv.ssp+xml": { source: "iana", compressible: !0 },
    "application/vnd.xacml+json": { source: "iana", compressible: !0 },
    "application/vnd.xara": { source: "iana", extensions: ["xar"] },
    "application/vnd.xfdl": { source: "iana", extensions: ["xfdl"] },
    "application/vnd.xfdl.webform": { source: "iana" },
    "application/vnd.xmi+xml": { source: "iana", compressible: !0 },
    "application/vnd.xmpie.cpkg": { source: "iana" },
    "application/vnd.xmpie.dpkg": { source: "iana" },
    "application/vnd.xmpie.plan": { source: "iana" },
    "application/vnd.xmpie.ppkg": { source: "iana" },
    "application/vnd.xmpie.xlim": { source: "iana" },
    "application/vnd.yamaha.hv-dic": { source: "iana", extensions: ["hvd"] },
    "application/vnd.yamaha.hv-script": { source: "iana", extensions: ["hvs"] },
    "application/vnd.yamaha.hv-voice": { source: "iana", extensions: ["hvp"] },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"],
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["osfpvg"],
    },
    "application/vnd.yamaha.remote-setup": { source: "iana" },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"],
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"],
    },
    "application/vnd.yamaha.through-ngn": { source: "iana" },
    "application/vnd.yamaha.tunnel-udpencap": { source: "iana" },
    "application/vnd.yaoweme": { source: "iana" },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"],
    },
    "application/vnd.youtube.yt": { source: "iana" },
    "application/vnd.zul": { source: "iana", extensions: ["zir", "zirz"] },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["zaz"],
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["vxml"],
    },
    "application/voucher-cms+json": { source: "iana", compressible: !0 },
    "application/vq-rtcpxr": { source: "iana" },
    "application/wasm": {
      source: "iana",
      compressible: !0,
      extensions: ["wasm"],
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["wif"],
    },
    "application/webpush-options+json": { source: "iana", compressible: !0 },
    "application/whoispp-query": { source: "iana" },
    "application/whoispp-response": { source: "iana" },
    "application/widget": { source: "iana", extensions: ["wgt"] },
    "application/winhlp": { source: "apache", extensions: ["hlp"] },
    "application/wita": { source: "iana" },
    "application/wordperfect5.1": { source: "iana" },
    "application/wsdl+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["wsdl"],
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["wspolicy"],
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: !1,
      extensions: ["7z"],
    },
    "application/x-abiword": { source: "apache", extensions: ["abw"] },
    "application/x-ace-compressed": { source: "apache", extensions: ["ace"] },
    "application/x-amf": { source: "apache" },
    "application/x-apple-diskimage": { source: "apache", extensions: ["dmg"] },
    "application/x-arj": { compressible: !1, extensions: ["arj"] },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"],
    },
    "application/x-authorware-map": { source: "apache", extensions: ["aam"] },
    "application/x-authorware-seg": { source: "apache", extensions: ["aas"] },
    "application/x-bcpio": { source: "apache", extensions: ["bcpio"] },
    "application/x-bdoc": { compressible: !1, extensions: ["bdoc"] },
    "application/x-bittorrent": { source: "apache", extensions: ["torrent"] },
    "application/x-blorb": { source: "apache", extensions: ["blb", "blorb"] },
    "application/x-bzip": {
      source: "apache",
      compressible: !1,
      extensions: ["bz"],
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: !1,
      extensions: ["bz2", "boz"],
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"],
    },
    "application/x-cdlink": { source: "apache", extensions: ["vcd"] },
    "application/x-cfs-compressed": { source: "apache", extensions: ["cfs"] },
    "application/x-chat": { source: "apache", extensions: ["chat"] },
    "application/x-chess-pgn": { source: "apache", extensions: ["pgn"] },
    "application/x-chrome-extension": { extensions: ["crx"] },
    "application/x-cocoa": { source: "nginx", extensions: ["cco"] },
    "application/x-compress": { source: "apache" },
    "application/x-conference": { source: "apache", extensions: ["nsc"] },
    "application/x-cpio": { source: "apache", extensions: ["cpio"] },
    "application/x-csh": { source: "apache", extensions: ["csh"] },
    "application/x-deb": { compressible: !1 },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"],
    },
    "application/x-dgc-compressed": { source: "apache", extensions: ["dgc"] },
    "application/x-director": {
      source: "apache",
      extensions: [
        "dir",
        "dcr",
        "dxr",
        "cst",
        "cct",
        "cxt",
        "w3d",
        "fgd",
        "swa",
      ],
    },
    "application/x-doom": { source: "apache", extensions: ["wad"] },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["ncx"],
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["dtb"],
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["res"],
    },
    "application/x-dvi": {
      source: "apache",
      compressible: !1,
      extensions: ["dvi"],
    },
    "application/x-envoy": { source: "apache", extensions: ["evy"] },
    "application/x-eva": { source: "apache", extensions: ["eva"] },
    "application/x-font-bdf": { source: "apache", extensions: ["bdf"] },
    "application/x-font-dos": { source: "apache" },
    "application/x-font-framemaker": { source: "apache" },
    "application/x-font-ghostscript": { source: "apache", extensions: ["gsf"] },
    "application/x-font-libgrx": { source: "apache" },
    "application/x-font-linux-psf": { source: "apache", extensions: ["psf"] },
    "application/x-font-pcf": { source: "apache", extensions: ["pcf"] },
    "application/x-font-snf": { source: "apache", extensions: ["snf"] },
    "application/x-font-speedo": { source: "apache" },
    "application/x-font-sunos-news": { source: "apache" },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"],
    },
    "application/x-font-vfont": { source: "apache" },
    "application/x-freearc": { source: "apache", extensions: ["arc"] },
    "application/x-futuresplash": { source: "apache", extensions: ["spl"] },
    "application/x-gca-compressed": { source: "apache", extensions: ["gca"] },
    "application/x-glulx": { source: "apache", extensions: ["ulx"] },
    "application/x-gnumeric": { source: "apache", extensions: ["gnumeric"] },
    "application/x-gramps-xml": { source: "apache", extensions: ["gramps"] },
    "application/x-gtar": { source: "apache", extensions: ["gtar"] },
    "application/x-gzip": { source: "apache" },
    "application/x-hdf": { source: "apache", extensions: ["hdf"] },
    "application/x-httpd-php": { compressible: !0, extensions: ["php"] },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"],
    },
    "application/x-iso9660-image": { source: "apache", extensions: ["iso"] },
    "application/x-iwork-keynote-sffkey": { extensions: ["key"] },
    "application/x-iwork-numbers-sffnumbers": { extensions: ["numbers"] },
    "application/x-iwork-pages-sffpages": { extensions: ["pages"] },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"],
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: !1,
      extensions: ["jnlp"],
    },
    "application/x-javascript": { compressible: !0 },
    "application/x-keepass2": { extensions: ["kdbx"] },
    "application/x-latex": {
      source: "apache",
      compressible: !1,
      extensions: ["latex"],
    },
    "application/x-lua-bytecode": { extensions: ["luac"] },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"],
    },
    "application/x-makeself": { source: "nginx", extensions: ["run"] },
    "application/x-mie": { source: "apache", extensions: ["mie"] },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"],
    },
    "application/x-mpegurl": { compressible: !1 },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"],
    },
    "application/x-ms-shortcut": { source: "apache", extensions: ["lnk"] },
    "application/x-ms-wmd": { source: "apache", extensions: ["wmd"] },
    "application/x-ms-wmz": { source: "apache", extensions: ["wmz"] },
    "application/x-ms-xbap": { source: "apache", extensions: ["xbap"] },
    "application/x-msaccess": { source: "apache", extensions: ["mdb"] },
    "application/x-msbinder": { source: "apache", extensions: ["obd"] },
    "application/x-mscardfile": { source: "apache", extensions: ["crd"] },
    "application/x-msclip": { source: "apache", extensions: ["clp"] },
    "application/x-msdos-program": { extensions: ["exe"] },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"],
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"],
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"],
    },
    "application/x-msmoney": { source: "apache", extensions: ["mny"] },
    "application/x-mspublisher": { source: "apache", extensions: ["pub"] },
    "application/x-msschedule": { source: "apache", extensions: ["scd"] },
    "application/x-msterminal": { source: "apache", extensions: ["trm"] },
    "application/x-mswrite": { source: "apache", extensions: ["wri"] },
    "application/x-netcdf": { source: "apache", extensions: ["nc", "cdf"] },
    "application/x-ns-proxy-autoconfig": {
      compressible: !0,
      extensions: ["pac"],
    },
    "application/x-nzb": { source: "apache", extensions: ["nzb"] },
    "application/x-perl": { source: "nginx", extensions: ["pl", "pm"] },
    "application/x-pilot": { source: "nginx", extensions: ["prc", "pdb"] },
    "application/x-pkcs12": {
      source: "apache",
      compressible: !1,
      extensions: ["p12", "pfx"],
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"],
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"],
    },
    "application/x-pki-message": { source: "iana" },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: !1,
      extensions: ["rar"],
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"],
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"],
    },
    "application/x-sea": { source: "nginx", extensions: ["sea"] },
    "application/x-sh": {
      source: "apache",
      compressible: !0,
      extensions: ["sh"],
    },
    "application/x-shar": { source: "apache", extensions: ["shar"] },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: !1,
      extensions: ["swf"],
    },
    "application/x-silverlight-app": { source: "apache", extensions: ["xap"] },
    "application/x-sql": { source: "apache", extensions: ["sql"] },
    "application/x-stuffit": {
      source: "apache",
      compressible: !1,
      extensions: ["sit"],
    },
    "application/x-stuffitx": { source: "apache", extensions: ["sitx"] },
    "application/x-subrip": { source: "apache", extensions: ["srt"] },
    "application/x-sv4cpio": { source: "apache", extensions: ["sv4cpio"] },
    "application/x-sv4crc": { source: "apache", extensions: ["sv4crc"] },
    "application/x-t3vm-image": { source: "apache", extensions: ["t3"] },
    "application/x-tads": { source: "apache", extensions: ["gam"] },
    "application/x-tar": {
      source: "apache",
      compressible: !0,
      extensions: ["tar"],
    },
    "application/x-tcl": { source: "apache", extensions: ["tcl", "tk"] },
    "application/x-tex": { source: "apache", extensions: ["tex"] },
    "application/x-tex-tfm": { source: "apache", extensions: ["tfm"] },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"],
    },
    "application/x-tgif": { source: "apache", extensions: ["obj"] },
    "application/x-ustar": { source: "apache", extensions: ["ustar"] },
    "application/x-virtualbox-hdd": { compressible: !0, extensions: ["hdd"] },
    "application/x-virtualbox-ova": { compressible: !0, extensions: ["ova"] },
    "application/x-virtualbox-ovf": { compressible: !0, extensions: ["ovf"] },
    "application/x-virtualbox-vbox": { compressible: !0, extensions: ["vbox"] },
    "application/x-virtualbox-vbox-extpack": {
      compressible: !1,
      extensions: ["vbox-extpack"],
    },
    "application/x-virtualbox-vdi": { compressible: !0, extensions: ["vdi"] },
    "application/x-virtualbox-vhd": { compressible: !0, extensions: ["vhd"] },
    "application/x-virtualbox-vmdk": { compressible: !0, extensions: ["vmdk"] },
    "application/x-wais-source": { source: "apache", extensions: ["src"] },
    "application/x-web-app-manifest+json": {
      compressible: !0,
      extensions: ["webapp"],
    },
    "application/x-www-form-urlencoded": { source: "iana", compressible: !0 },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"],
    },
    "application/x-x509-ca-ra-cert": { source: "iana" },
    "application/x-x509-next-ca-cert": { source: "iana" },
    "application/x-xfig": { source: "apache", extensions: ["fig"] },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["xlf"],
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: !1,
      extensions: ["xpi"],
    },
    "application/x-xz": { source: "apache", extensions: ["xz"] },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"],
    },
    "application/x400-bp": { source: "iana" },
    "application/xacml+xml": { source: "iana", compressible: !0 },
    "application/xaml+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["xaml"],
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xav"],
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xca"],
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xdf"],
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xel"],
    },
    "application/xcap-error+xml": { source: "iana", compressible: !0 },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xns"],
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: !0,
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xenc"],
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xhtml", "xht"],
    },
    "application/xhtml-voice+xml": { source: "apache", compressible: !0 },
    "application/xliff+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xlf"],
    },
    "application/xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xml", "xsl", "xsd", "rng"],
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: !0,
      extensions: ["dtd"],
    },
    "application/xml-external-parsed-entity": { source: "iana" },
    "application/xml-patch+xml": { source: "iana", compressible: !0 },
    "application/xmpp+xml": { source: "iana", compressible: !0 },
    "application/xop+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xop"],
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["xpl"],
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xsl", "xslt"],
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["xspf"],
    },
    "application/xv+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mxml", "xhvml", "xvml", "xvm"],
    },
    "application/yang": { source: "iana", extensions: ["yang"] },
    "application/yang-data+json": { source: "iana", compressible: !0 },
    "application/yang-data+xml": { source: "iana", compressible: !0 },
    "application/yang-patch+json": { source: "iana", compressible: !0 },
    "application/yang-patch+xml": { source: "iana", compressible: !0 },
    "application/yin+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["yin"],
    },
    "application/zip": {
      source: "iana",
      compressible: !1,
      extensions: ["zip"],
    },
    "application/zlib": { source: "iana" },
    "application/zstd": { source: "iana" },
    "audio/1d-interleaved-parityfec": { source: "iana" },
    "audio/32kadpcm": { source: "iana" },
    "audio/3gpp": { source: "iana", compressible: !1, extensions: ["3gpp"] },
    "audio/3gpp2": { source: "iana" },
    "audio/aac": { source: "iana" },
    "audio/ac3": { source: "iana" },
    "audio/adpcm": { source: "apache", extensions: ["adp"] },
    "audio/amr": { source: "iana", extensions: ["amr"] },
    "audio/amr-wb": { source: "iana" },
    "audio/amr-wb+": { source: "iana" },
    "audio/aptx": { source: "iana" },
    "audio/asc": { source: "iana" },
    "audio/atrac-advanced-lossless": { source: "iana" },
    "audio/atrac-x": { source: "iana" },
    "audio/atrac3": { source: "iana" },
    "audio/basic": {
      source: "iana",
      compressible: !1,
      extensions: ["au", "snd"],
    },
    "audio/bv16": { source: "iana" },
    "audio/bv32": { source: "iana" },
    "audio/clearmode": { source: "iana" },
    "audio/cn": { source: "iana" },
    "audio/dat12": { source: "iana" },
    "audio/dls": { source: "iana" },
    "audio/dsr-es201108": { source: "iana" },
    "audio/dsr-es202050": { source: "iana" },
    "audio/dsr-es202211": { source: "iana" },
    "audio/dsr-es202212": { source: "iana" },
    "audio/dv": { source: "iana" },
    "audio/dvi4": { source: "iana" },
    "audio/eac3": { source: "iana" },
    "audio/encaprtp": { source: "iana" },
    "audio/evrc": { source: "iana" },
    "audio/evrc-qcp": { source: "iana" },
    "audio/evrc0": { source: "iana" },
    "audio/evrc1": { source: "iana" },
    "audio/evrcb": { source: "iana" },
    "audio/evrcb0": { source: "iana" },
    "audio/evrcb1": { source: "iana" },
    "audio/evrcnw": { source: "iana" },
    "audio/evrcnw0": { source: "iana" },
    "audio/evrcnw1": { source: "iana" },
    "audio/evrcwb": { source: "iana" },
    "audio/evrcwb0": { source: "iana" },
    "audio/evrcwb1": { source: "iana" },
    "audio/evs": { source: "iana" },
    "audio/flexfec": { source: "iana" },
    "audio/fwdred": { source: "iana" },
    "audio/g711-0": { source: "iana" },
    "audio/g719": { source: "iana" },
    "audio/g722": { source: "iana" },
    "audio/g7221": { source: "iana" },
    "audio/g723": { source: "iana" },
    "audio/g726-16": { source: "iana" },
    "audio/g726-24": { source: "iana" },
    "audio/g726-32": { source: "iana" },
    "audio/g726-40": { source: "iana" },
    "audio/g728": { source: "iana" },
    "audio/g729": { source: "iana" },
    "audio/g7291": { source: "iana" },
    "audio/g729d": { source: "iana" },
    "audio/g729e": { source: "iana" },
    "audio/gsm": { source: "iana" },
    "audio/gsm-efr": { source: "iana" },
    "audio/gsm-hr-08": { source: "iana" },
    "audio/ilbc": { source: "iana" },
    "audio/ip-mr_v2.5": { source: "iana" },
    "audio/isac": { source: "apache" },
    "audio/l16": { source: "iana" },
    "audio/l20": { source: "iana" },
    "audio/l24": { source: "iana", compressible: !1 },
    "audio/l8": { source: "iana" },
    "audio/lpc": { source: "iana" },
    "audio/melp": { source: "iana" },
    "audio/melp1200": { source: "iana" },
    "audio/melp2400": { source: "iana" },
    "audio/melp600": { source: "iana" },
    "audio/mhas": { source: "iana" },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"],
    },
    "audio/mobile-xmf": { source: "iana", extensions: ["mxmf"] },
    "audio/mp3": { compressible: !1, extensions: ["mp3"] },
    "audio/mp4": {
      source: "iana",
      compressible: !1,
      extensions: ["m4a", "mp4a"],
    },
    "audio/mp4a-latm": { source: "iana" },
    "audio/mpa": { source: "iana" },
    "audio/mpa-robust": { source: "iana" },
    "audio/mpeg": {
      source: "iana",
      compressible: !1,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
    },
    "audio/mpeg4-generic": { source: "iana" },
    "audio/musepack": { source: "apache" },
    "audio/ogg": {
      source: "iana",
      compressible: !1,
      extensions: ["oga", "ogg", "spx", "opus"],
    },
    "audio/opus": { source: "iana" },
    "audio/parityfec": { source: "iana" },
    "audio/pcma": { source: "iana" },
    "audio/pcma-wb": { source: "iana" },
    "audio/pcmu": { source: "iana" },
    "audio/pcmu-wb": { source: "iana" },
    "audio/prs.sid": { source: "iana" },
    "audio/qcelp": { source: "iana" },
    "audio/raptorfec": { source: "iana" },
    "audio/red": { source: "iana" },
    "audio/rtp-enc-aescm128": { source: "iana" },
    "audio/rtp-midi": { source: "iana" },
    "audio/rtploopback": { source: "iana" },
    "audio/rtx": { source: "iana" },
    "audio/s3m": { source: "apache", extensions: ["s3m"] },
    "audio/scip": { source: "iana" },
    "audio/silk": { source: "apache", extensions: ["sil"] },
    "audio/smv": { source: "iana" },
    "audio/smv-qcp": { source: "iana" },
    "audio/smv0": { source: "iana" },
    "audio/sofa": { source: "iana" },
    "audio/sp-midi": { source: "iana" },
    "audio/speex": { source: "iana" },
    "audio/t140c": { source: "iana" },
    "audio/t38": { source: "iana" },
    "audio/telephone-event": { source: "iana" },
    "audio/tetra_acelp": { source: "iana" },
    "audio/tetra_acelp_bb": { source: "iana" },
    "audio/tone": { source: "iana" },
    "audio/tsvcis": { source: "iana" },
    "audio/uemclip": { source: "iana" },
    "audio/ulpfec": { source: "iana" },
    "audio/usac": { source: "iana" },
    "audio/vdvi": { source: "iana" },
    "audio/vmr-wb": { source: "iana" },
    "audio/vnd.3gpp.iufp": { source: "iana" },
    "audio/vnd.4sb": { source: "iana" },
    "audio/vnd.audiokoz": { source: "iana" },
    "audio/vnd.celp": { source: "iana" },
    "audio/vnd.cisco.nse": { source: "iana" },
    "audio/vnd.cmles.radio-events": { source: "iana" },
    "audio/vnd.cns.anp1": { source: "iana" },
    "audio/vnd.cns.inf1": { source: "iana" },
    "audio/vnd.dece.audio": { source: "iana", extensions: ["uva", "uvva"] },
    "audio/vnd.digital-winds": { source: "iana", extensions: ["eol"] },
    "audio/vnd.dlna.adts": { source: "iana" },
    "audio/vnd.dolby.heaac.1": { source: "iana" },
    "audio/vnd.dolby.heaac.2": { source: "iana" },
    "audio/vnd.dolby.mlp": { source: "iana" },
    "audio/vnd.dolby.mps": { source: "iana" },
    "audio/vnd.dolby.pl2": { source: "iana" },
    "audio/vnd.dolby.pl2x": { source: "iana" },
    "audio/vnd.dolby.pl2z": { source: "iana" },
    "audio/vnd.dolby.pulse.1": { source: "iana" },
    "audio/vnd.dra": { source: "iana", extensions: ["dra"] },
    "audio/vnd.dts": { source: "iana", extensions: ["dts"] },
    "audio/vnd.dts.hd": { source: "iana", extensions: ["dtshd"] },
    "audio/vnd.dts.uhd": { source: "iana" },
    "audio/vnd.dvb.file": { source: "iana" },
    "audio/vnd.everad.plj": { source: "iana" },
    "audio/vnd.hns.audio": { source: "iana" },
    "audio/vnd.lucent.voice": { source: "iana", extensions: ["lvp"] },
    "audio/vnd.ms-playready.media.pya": { source: "iana", extensions: ["pya"] },
    "audio/vnd.nokia.mobile-xmf": { source: "iana" },
    "audio/vnd.nortel.vbk": { source: "iana" },
    "audio/vnd.nuera.ecelp4800": { source: "iana", extensions: ["ecelp4800"] },
    "audio/vnd.nuera.ecelp7470": { source: "iana", extensions: ["ecelp7470"] },
    "audio/vnd.nuera.ecelp9600": { source: "iana", extensions: ["ecelp9600"] },
    "audio/vnd.octel.sbc": { source: "iana" },
    "audio/vnd.presonus.multitrack": { source: "iana" },
    "audio/vnd.qcelp": { source: "iana" },
    "audio/vnd.rhetorex.32kadpcm": { source: "iana" },
    "audio/vnd.rip": { source: "iana", extensions: ["rip"] },
    "audio/vnd.rn-realaudio": { compressible: !1 },
    "audio/vnd.sealedmedia.softseal.mpeg": { source: "iana" },
    "audio/vnd.vmx.cvsd": { source: "iana" },
    "audio/vnd.wave": { compressible: !1 },
    "audio/vorbis": { source: "iana", compressible: !1 },
    "audio/vorbis-config": { source: "iana" },
    "audio/wav": { compressible: !1, extensions: ["wav"] },
    "audio/wave": { compressible: !1, extensions: ["wav"] },
    "audio/webm": { source: "apache", compressible: !1, extensions: ["weba"] },
    "audio/x-aac": { source: "apache", compressible: !1, extensions: ["aac"] },
    "audio/x-aiff": { source: "apache", extensions: ["aif", "aiff", "aifc"] },
    "audio/x-caf": { source: "apache", compressible: !1, extensions: ["caf"] },
    "audio/x-flac": { source: "apache", extensions: ["flac"] },
    "audio/x-m4a": { source: "nginx", extensions: ["m4a"] },
    "audio/x-matroska": { source: "apache", extensions: ["mka"] },
    "audio/x-mpegurl": { source: "apache", extensions: ["m3u"] },
    "audio/x-ms-wax": { source: "apache", extensions: ["wax"] },
    "audio/x-ms-wma": { source: "apache", extensions: ["wma"] },
    "audio/x-pn-realaudio": { source: "apache", extensions: ["ram", "ra"] },
    "audio/x-pn-realaudio-plugin": { source: "apache", extensions: ["rmp"] },
    "audio/x-realaudio": { source: "nginx", extensions: ["ra"] },
    "audio/x-tta": { source: "apache" },
    "audio/x-wav": { source: "apache", extensions: ["wav"] },
    "audio/xm": { source: "apache", extensions: ["xm"] },
    "chemical/x-cdx": { source: "apache", extensions: ["cdx"] },
    "chemical/x-cif": { source: "apache", extensions: ["cif"] },
    "chemical/x-cmdf": { source: "apache", extensions: ["cmdf"] },
    "chemical/x-cml": { source: "apache", extensions: ["cml"] },
    "chemical/x-csml": { source: "apache", extensions: ["csml"] },
    "chemical/x-pdb": { source: "apache" },
    "chemical/x-xyz": { source: "apache", extensions: ["xyz"] },
    "font/collection": { source: "iana", extensions: ["ttc"] },
    "font/otf": { source: "iana", compressible: !0, extensions: ["otf"] },
    "font/sfnt": { source: "iana" },
    "font/ttf": { source: "iana", compressible: !0, extensions: ["ttf"] },
    "font/woff": { source: "iana", extensions: ["woff"] },
    "font/woff2": { source: "iana", extensions: ["woff2"] },
    "image/aces": { source: "iana", extensions: ["exr"] },
    "image/apng": { compressible: !1, extensions: ["apng"] },
    "image/avci": { source: "iana", extensions: ["avci"] },
    "image/avcs": { source: "iana", extensions: ["avcs"] },
    "image/avif": { source: "iana", compressible: !1, extensions: ["avif"] },
    "image/bmp": { source: "iana", compressible: !0, extensions: ["bmp"] },
    "image/cgm": { source: "iana", extensions: ["cgm"] },
    "image/dicom-rle": { source: "iana", extensions: ["drle"] },
    "image/emf": { source: "iana", extensions: ["emf"] },
    "image/fits": { source: "iana", extensions: ["fits"] },
    "image/g3fax": { source: "iana", extensions: ["g3"] },
    "image/gif": { source: "iana", compressible: !1, extensions: ["gif"] },
    "image/heic": { source: "iana", extensions: ["heic"] },
    "image/heic-sequence": { source: "iana", extensions: ["heics"] },
    "image/heif": { source: "iana", extensions: ["heif"] },
    "image/heif-sequence": { source: "iana", extensions: ["heifs"] },
    "image/hej2k": { source: "iana", extensions: ["hej2"] },
    "image/hsj2": { source: "iana", extensions: ["hsj2"] },
    "image/ief": { source: "iana", extensions: ["ief"] },
    "image/jls": { source: "iana", extensions: ["jls"] },
    "image/jp2": {
      source: "iana",
      compressible: !1,
      extensions: ["jp2", "jpg2"],
    },
    "image/jpeg": {
      source: "iana",
      compressible: !1,
      extensions: ["jpeg", "jpg", "jpe"],
    },
    "image/jph": { source: "iana", extensions: ["jph"] },
    "image/jphc": { source: "iana", extensions: ["jhc"] },
    "image/jpm": { source: "iana", compressible: !1, extensions: ["jpm"] },
    "image/jpx": {
      source: "iana",
      compressible: !1,
      extensions: ["jpx", "jpf"],
    },
    "image/jxr": { source: "iana", extensions: ["jxr"] },
    "image/jxra": { source: "iana", extensions: ["jxra"] },
    "image/jxrs": { source: "iana", extensions: ["jxrs"] },
    "image/jxs": { source: "iana", extensions: ["jxs"] },
    "image/jxsc": { source: "iana", extensions: ["jxsc"] },
    "image/jxsi": { source: "iana", extensions: ["jxsi"] },
    "image/jxss": { source: "iana", extensions: ["jxss"] },
    "image/ktx": { source: "iana", extensions: ["ktx"] },
    "image/ktx2": { source: "iana", extensions: ["ktx2"] },
    "image/naplps": { source: "iana" },
    "image/pjpeg": { compressible: !1 },
    "image/png": { source: "iana", compressible: !1, extensions: ["png"] },
    "image/prs.btif": { source: "iana", extensions: ["btif"] },
    "image/prs.pti": { source: "iana", extensions: ["pti"] },
    "image/pwg-raster": { source: "iana" },
    "image/sgi": { source: "apache", extensions: ["sgi"] },
    "image/svg+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["svg", "svgz"],
    },
    "image/t38": { source: "iana", extensions: ["t38"] },
    "image/tiff": {
      source: "iana",
      compressible: !1,
      extensions: ["tif", "tiff"],
    },
    "image/tiff-fx": { source: "iana", extensions: ["tfx"] },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: !0,
      extensions: ["psd"],
    },
    "image/vnd.airzip.accelerator.azv": { source: "iana", extensions: ["azv"] },
    "image/vnd.cns.inf2": { source: "iana" },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"],
    },
    "image/vnd.djvu": { source: "iana", extensions: ["djvu", "djv"] },
    "image/vnd.dvb.subtitle": { source: "iana", extensions: ["sub"] },
    "image/vnd.dwg": { source: "iana", extensions: ["dwg"] },
    "image/vnd.dxf": { source: "iana", extensions: ["dxf"] },
    "image/vnd.fastbidsheet": { source: "iana", extensions: ["fbs"] },
    "image/vnd.fpx": { source: "iana", extensions: ["fpx"] },
    "image/vnd.fst": { source: "iana", extensions: ["fst"] },
    "image/vnd.fujixerox.edmics-mmr": { source: "iana", extensions: ["mmr"] },
    "image/vnd.fujixerox.edmics-rlc": { source: "iana", extensions: ["rlc"] },
    "image/vnd.globalgraphics.pgb": { source: "iana" },
    "image/vnd.microsoft.icon": {
      source: "iana",
      compressible: !0,
      extensions: ["ico"],
    },
    "image/vnd.mix": { source: "iana" },
    "image/vnd.mozilla.apng": { source: "iana" },
    "image/vnd.ms-dds": { compressible: !0, extensions: ["dds"] },
    "image/vnd.ms-modi": { source: "iana", extensions: ["mdi"] },
    "image/vnd.ms-photo": { source: "apache", extensions: ["wdp"] },
    "image/vnd.net-fpx": { source: "iana", extensions: ["npx"] },
    "image/vnd.pco.b16": { source: "iana", extensions: ["b16"] },
    "image/vnd.radiance": { source: "iana" },
    "image/vnd.sealed.png": { source: "iana" },
    "image/vnd.sealedmedia.softseal.gif": { source: "iana" },
    "image/vnd.sealedmedia.softseal.jpg": { source: "iana" },
    "image/vnd.svf": { source: "iana" },
    "image/vnd.tencent.tap": { source: "iana", extensions: ["tap"] },
    "image/vnd.valve.source.texture": { source: "iana", extensions: ["vtf"] },
    "image/vnd.wap.wbmp": { source: "iana", extensions: ["wbmp"] },
    "image/vnd.xiff": { source: "iana", extensions: ["xif"] },
    "image/vnd.zbrush.pcx": { source: "iana", extensions: ["pcx"] },
    "image/webp": { source: "apache", extensions: ["webp"] },
    "image/wmf": { source: "iana", extensions: ["wmf"] },
    "image/x-3ds": { source: "apache", extensions: ["3ds"] },
    "image/x-cmu-raster": { source: "apache", extensions: ["ras"] },
    "image/x-cmx": { source: "apache", extensions: ["cmx"] },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"],
    },
    "image/x-icon": { source: "apache", compressible: !0, extensions: ["ico"] },
    "image/x-jng": { source: "nginx", extensions: ["jng"] },
    "image/x-mrsid-image": { source: "apache", extensions: ["sid"] },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: !0,
      extensions: ["bmp"],
    },
    "image/x-pcx": { source: "apache", extensions: ["pcx"] },
    "image/x-pict": { source: "apache", extensions: ["pic", "pct"] },
    "image/x-portable-anymap": { source: "apache", extensions: ["pnm"] },
    "image/x-portable-bitmap": { source: "apache", extensions: ["pbm"] },
    "image/x-portable-graymap": { source: "apache", extensions: ["pgm"] },
    "image/x-portable-pixmap": { source: "apache", extensions: ["ppm"] },
    "image/x-rgb": { source: "apache", extensions: ["rgb"] },
    "image/x-tga": { source: "apache", extensions: ["tga"] },
    "image/x-xbitmap": { source: "apache", extensions: ["xbm"] },
    "image/x-xcf": { compressible: !1 },
    "image/x-xpixmap": { source: "apache", extensions: ["xpm"] },
    "image/x-xwindowdump": { source: "apache", extensions: ["xwd"] },
    "message/cpim": { source: "iana" },
    "message/delivery-status": { source: "iana" },
    "message/disposition-notification": {
      source: "iana",
      extensions: ["disposition-notification"],
    },
    "message/external-body": { source: "iana" },
    "message/feedback-report": { source: "iana" },
    "message/global": { source: "iana", extensions: ["u8msg"] },
    "message/global-delivery-status": { source: "iana", extensions: ["u8dsn"] },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"],
    },
    "message/global-headers": { source: "iana", extensions: ["u8hdr"] },
    "message/http": { source: "iana", compressible: !1 },
    "message/imdn+xml": { source: "iana", compressible: !0 },
    "message/news": { source: "iana" },
    "message/partial": { source: "iana", compressible: !1 },
    "message/rfc822": {
      source: "iana",
      compressible: !0,
      extensions: ["eml", "mime"],
    },
    "message/s-http": { source: "iana" },
    "message/sip": { source: "iana" },
    "message/sipfrag": { source: "iana" },
    "message/tracking-status": { source: "iana" },
    "message/vnd.si.simp": { source: "iana" },
    "message/vnd.wfa.wsc": { source: "iana", extensions: ["wsc"] },
    "model/3mf": { source: "iana", extensions: ["3mf"] },
    "model/e57": { source: "iana" },
    "model/gltf+json": {
      source: "iana",
      compressible: !0,
      extensions: ["gltf"],
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: !0,
      extensions: ["glb"],
    },
    "model/iges": {
      source: "iana",
      compressible: !1,
      extensions: ["igs", "iges"],
    },
    "model/mesh": {
      source: "iana",
      compressible: !1,
      extensions: ["msh", "mesh", "silo"],
    },
    "model/mtl": { source: "iana", extensions: ["mtl"] },
    "model/obj": { source: "iana", extensions: ["obj"] },
    "model/step": { source: "iana" },
    "model/step+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["stpx"],
    },
    "model/step+zip": {
      source: "iana",
      compressible: !1,
      extensions: ["stpz"],
    },
    "model/step-xml+zip": {
      source: "iana",
      compressible: !1,
      extensions: ["stpxz"],
    },
    "model/stl": { source: "iana", extensions: ["stl"] },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["dae"],
    },
    "model/vnd.dwf": { source: "iana", extensions: ["dwf"] },
    "model/vnd.flatland.3dml": { source: "iana" },
    "model/vnd.gdl": { source: "iana", extensions: ["gdl"] },
    "model/vnd.gs-gdl": { source: "apache" },
    "model/vnd.gs.gdl": { source: "iana" },
    "model/vnd.gtw": { source: "iana", extensions: ["gtw"] },
    "model/vnd.moml+xml": { source: "iana", compressible: !0 },
    "model/vnd.mts": { source: "iana", extensions: ["mts"] },
    "model/vnd.opengex": { source: "iana", extensions: ["ogex"] },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"],
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"],
    },
    "model/vnd.pytha.pyox": { source: "iana" },
    "model/vnd.rosette.annotated-data-model": { source: "iana" },
    "model/vnd.sap.vds": { source: "iana", extensions: ["vds"] },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: !1,
      extensions: ["usdz"],
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"],
    },
    "model/vnd.vtu": { source: "iana", extensions: ["vtu"] },
    "model/vrml": {
      source: "iana",
      compressible: !1,
      extensions: ["wrl", "vrml"],
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: !1,
      extensions: ["x3db", "x3dbz"],
    },
    "model/x3d+fastinfoset": { source: "iana", extensions: ["x3db"] },
    "model/x3d+vrml": {
      source: "apache",
      compressible: !1,
      extensions: ["x3dv", "x3dvz"],
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["x3d", "x3dz"],
    },
    "model/x3d-vrml": { source: "iana", extensions: ["x3dv"] },
    "multipart/alternative": { source: "iana", compressible: !1 },
    "multipart/appledouble": { source: "iana" },
    "multipart/byteranges": { source: "iana" },
    "multipart/digest": { source: "iana" },
    "multipart/encrypted": { source: "iana", compressible: !1 },
    "multipart/form-data": { source: "iana", compressible: !1 },
    "multipart/header-set": { source: "iana" },
    "multipart/mixed": { source: "iana" },
    "multipart/multilingual": { source: "iana" },
    "multipart/parallel": { source: "iana" },
    "multipart/related": { source: "iana", compressible: !1 },
    "multipart/report": { source: "iana" },
    "multipart/signed": { source: "iana", compressible: !1 },
    "multipart/vnd.bint.med-plus": { source: "iana" },
    "multipart/voice-message": { source: "iana" },
    "multipart/x-mixed-replace": { source: "iana" },
    "text/1d-interleaved-parityfec": { source: "iana" },
    "text/cache-manifest": {
      source: "iana",
      compressible: !0,
      extensions: ["appcache", "manifest"],
    },
    "text/calendar": { source: "iana", extensions: ["ics", "ifb"] },
    "text/calender": { compressible: !0 },
    "text/cmd": { compressible: !0 },
    "text/coffeescript": { extensions: ["coffee", "litcoffee"] },
    "text/cql": { source: "iana" },
    "text/cql-expression": { source: "iana" },
    "text/cql-identifier": { source: "iana" },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["css"],
    },
    "text/csv": { source: "iana", compressible: !0, extensions: ["csv"] },
    "text/csv-schema": { source: "iana" },
    "text/directory": { source: "iana" },
    "text/dns": { source: "iana" },
    "text/ecmascript": { source: "iana" },
    "text/encaprtp": { source: "iana" },
    "text/enriched": { source: "iana" },
    "text/fhirpath": { source: "iana" },
    "text/flexfec": { source: "iana" },
    "text/fwdred": { source: "iana" },
    "text/gff3": { source: "iana" },
    "text/grammar-ref-list": { source: "iana" },
    "text/html": {
      source: "iana",
      compressible: !0,
      extensions: ["html", "htm", "shtml"],
    },
    "text/jade": { extensions: ["jade"] },
    "text/javascript": { source: "iana", compressible: !0 },
    "text/jcr-cnd": { source: "iana" },
    "text/jsx": { compressible: !0, extensions: ["jsx"] },
    "text/less": { compressible: !0, extensions: ["less"] },
    "text/markdown": {
      source: "iana",
      compressible: !0,
      extensions: ["markdown", "md"],
    },
    "text/mathml": { source: "nginx", extensions: ["mml"] },
    "text/mdx": { compressible: !0, extensions: ["mdx"] },
    "text/mizar": { source: "iana" },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["n3"],
    },
    "text/parameters": { source: "iana", charset: "UTF-8" },
    "text/parityfec": { source: "iana" },
    "text/plain": {
      source: "iana",
      compressible: !0,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
    },
    "text/provenance-notation": { source: "iana", charset: "UTF-8" },
    "text/prs.fallenstein.rst": { source: "iana" },
    "text/prs.lines.tag": { source: "iana", extensions: ["dsc"] },
    "text/prs.prop.logic": { source: "iana" },
    "text/raptorfec": { source: "iana" },
    "text/red": { source: "iana" },
    "text/rfc822-headers": { source: "iana" },
    "text/richtext": { source: "iana", compressible: !0, extensions: ["rtx"] },
    "text/rtf": { source: "iana", compressible: !0, extensions: ["rtf"] },
    "text/rtp-enc-aescm128": { source: "iana" },
    "text/rtploopback": { source: "iana" },
    "text/rtx": { source: "iana" },
    "text/sgml": { source: "iana", extensions: ["sgml", "sgm"] },
    "text/shaclc": { source: "iana" },
    "text/shex": { source: "iana", extensions: ["shex"] },
    "text/slim": { extensions: ["slim", "slm"] },
    "text/spdx": { source: "iana", extensions: ["spdx"] },
    "text/strings": { source: "iana" },
    "text/stylus": { extensions: ["stylus", "styl"] },
    "text/t140": { source: "iana" },
    "text/tab-separated-values": {
      source: "iana",
      compressible: !0,
      extensions: ["tsv"],
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"],
    },
    "text/turtle": { source: "iana", charset: "UTF-8", extensions: ["ttl"] },
    "text/ulpfec": { source: "iana" },
    "text/uri-list": {
      source: "iana",
      compressible: !0,
      extensions: ["uri", "uris", "urls"],
    },
    "text/vcard": { source: "iana", compressible: !0, extensions: ["vcard"] },
    "text/vnd.a": { source: "iana" },
    "text/vnd.abc": { source: "iana" },
    "text/vnd.ascii-art": { source: "iana" },
    "text/vnd.curl": { source: "iana", extensions: ["curl"] },
    "text/vnd.curl.dcurl": { source: "apache", extensions: ["dcurl"] },
    "text/vnd.curl.mcurl": { source: "apache", extensions: ["mcurl"] },
    "text/vnd.curl.scurl": { source: "apache", extensions: ["scurl"] },
    "text/vnd.debian.copyright": { source: "iana", charset: "UTF-8" },
    "text/vnd.dmclientscript": { source: "iana" },
    "text/vnd.dvb.subtitle": { source: "iana", extensions: ["sub"] },
    "text/vnd.esmertec.theme-descriptor": { source: "iana", charset: "UTF-8" },
    "text/vnd.familysearch.gedcom": { source: "iana", extensions: ["ged"] },
    "text/vnd.ficlab.flt": { source: "iana" },
    "text/vnd.fly": { source: "iana", extensions: ["fly"] },
    "text/vnd.fmi.flexstor": { source: "iana", extensions: ["flx"] },
    "text/vnd.gml": { source: "iana" },
    "text/vnd.graphviz": { source: "iana", extensions: ["gv"] },
    "text/vnd.hans": { source: "iana" },
    "text/vnd.hgl": { source: "iana" },
    "text/vnd.in3d.3dml": { source: "iana", extensions: ["3dml"] },
    "text/vnd.in3d.spot": { source: "iana", extensions: ["spot"] },
    "text/vnd.iptc.newsml": { source: "iana" },
    "text/vnd.iptc.nitf": { source: "iana" },
    "text/vnd.latex-z": { source: "iana" },
    "text/vnd.motorola.reflex": { source: "iana" },
    "text/vnd.ms-mediapackage": { source: "iana" },
    "text/vnd.net2phone.commcenter.command": { source: "iana" },
    "text/vnd.radisys.msml-basic-layout": { source: "iana" },
    "text/vnd.senx.warpscript": { source: "iana" },
    "text/vnd.si.uricatalogue": { source: "iana" },
    "text/vnd.sosi": { source: "iana" },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"],
    },
    "text/vnd.trolltech.linguist": { source: "iana", charset: "UTF-8" },
    "text/vnd.wap.si": { source: "iana" },
    "text/vnd.wap.sl": { source: "iana" },
    "text/vnd.wap.wml": { source: "iana", extensions: ["wml"] },
    "text/vnd.wap.wmlscript": { source: "iana", extensions: ["wmls"] },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["vtt"],
    },
    "text/x-asm": { source: "apache", extensions: ["s", "asm"] },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"],
    },
    "text/x-component": { source: "nginx", extensions: ["htc"] },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"],
    },
    "text/x-gwt-rpc": { compressible: !0 },
    "text/x-handlebars-template": { extensions: ["hbs"] },
    "text/x-java-source": { source: "apache", extensions: ["java"] },
    "text/x-jquery-tmpl": { compressible: !0 },
    "text/x-lua": { extensions: ["lua"] },
    "text/x-markdown": { compressible: !0, extensions: ["mkd"] },
    "text/x-nfo": { source: "apache", extensions: ["nfo"] },
    "text/x-opml": { source: "apache", extensions: ["opml"] },
    "text/x-org": { compressible: !0, extensions: ["org"] },
    "text/x-pascal": { source: "apache", extensions: ["p", "pas"] },
    "text/x-processing": { compressible: !0, extensions: ["pde"] },
    "text/x-sass": { extensions: ["sass"] },
    "text/x-scss": { extensions: ["scss"] },
    "text/x-setext": { source: "apache", extensions: ["etx"] },
    "text/x-sfv": { source: "apache", extensions: ["sfv"] },
    "text/x-suse-ymp": { compressible: !0, extensions: ["ymp"] },
    "text/x-uuencode": { source: "apache", extensions: ["uu"] },
    "text/x-vcalendar": { source: "apache", extensions: ["vcs"] },
    "text/x-vcard": { source: "apache", extensions: ["vcf"] },
    "text/xml": { source: "iana", compressible: !0, extensions: ["xml"] },
    "text/xml-external-parsed-entity": { source: "iana" },
    "text/yaml": { compressible: !0, extensions: ["yaml", "yml"] },
    "video/1d-interleaved-parityfec": { source: "iana" },
    "video/3gpp": { source: "iana", extensions: ["3gp", "3gpp"] },
    "video/3gpp-tt": { source: "iana" },
    "video/3gpp2": { source: "iana", extensions: ["3g2"] },
    "video/av1": { source: "iana" },
    "video/bmpeg": { source: "iana" },
    "video/bt656": { source: "iana" },
    "video/celb": { source: "iana" },
    "video/dv": { source: "iana" },
    "video/encaprtp": { source: "iana" },
    "video/ffv1": { source: "iana" },
    "video/flexfec": { source: "iana" },
    "video/h261": { source: "iana", extensions: ["h261"] },
    "video/h263": { source: "iana", extensions: ["h263"] },
    "video/h263-1998": { source: "iana" },
    "video/h263-2000": { source: "iana" },
    "video/h264": { source: "iana", extensions: ["h264"] },
    "video/h264-rcdo": { source: "iana" },
    "video/h264-svc": { source: "iana" },
    "video/h265": { source: "iana" },
    "video/iso.segment": { source: "iana", extensions: ["m4s"] },
    "video/jpeg": { source: "iana", extensions: ["jpgv"] },
    "video/jpeg2000": { source: "iana" },
    "video/jpm": { source: "apache", extensions: ["jpm", "jpgm"] },
    "video/jxsv": { source: "iana" },
    "video/mj2": { source: "iana", extensions: ["mj2", "mjp2"] },
    "video/mp1s": { source: "iana" },
    "video/mp2p": { source: "iana" },
    "video/mp2t": { source: "iana", extensions: ["ts"] },
    "video/mp4": {
      source: "iana",
      compressible: !1,
      extensions: ["mp4", "mp4v", "mpg4"],
    },
    "video/mp4v-es": { source: "iana" },
    "video/mpeg": {
      source: "iana",
      compressible: !1,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"],
    },
    "video/mpeg4-generic": { source: "iana" },
    "video/mpv": { source: "iana" },
    "video/nv": { source: "iana" },
    "video/ogg": { source: "iana", compressible: !1, extensions: ["ogv"] },
    "video/parityfec": { source: "iana" },
    "video/pointer": { source: "iana" },
    "video/quicktime": {
      source: "iana",
      compressible: !1,
      extensions: ["qt", "mov"],
    },
    "video/raptorfec": { source: "iana" },
    "video/raw": { source: "iana" },
    "video/rtp-enc-aescm128": { source: "iana" },
    "video/rtploopback": { source: "iana" },
    "video/rtx": { source: "iana" },
    "video/scip": { source: "iana" },
    "video/smpte291": { source: "iana" },
    "video/smpte292m": { source: "iana" },
    "video/ulpfec": { source: "iana" },
    "video/vc1": { source: "iana" },
    "video/vc2": { source: "iana" },
    "video/vnd.cctv": { source: "iana" },
    "video/vnd.dece.hd": { source: "iana", extensions: ["uvh", "uvvh"] },
    "video/vnd.dece.mobile": { source: "iana", extensions: ["uvm", "uvvm"] },
    "video/vnd.dece.mp4": { source: "iana" },
    "video/vnd.dece.pd": { source: "iana", extensions: ["uvp", "uvvp"] },
    "video/vnd.dece.sd": { source: "iana", extensions: ["uvs", "uvvs"] },
    "video/vnd.dece.video": { source: "iana", extensions: ["uvv", "uvvv"] },
    "video/vnd.directv.mpeg": { source: "iana" },
    "video/vnd.directv.mpeg-tts": { source: "iana" },
    "video/vnd.dlna.mpeg-tts": { source: "iana" },
    "video/vnd.dvb.file": { source: "iana", extensions: ["dvb"] },
    "video/vnd.fvt": { source: "iana", extensions: ["fvt"] },
    "video/vnd.hns.video": { source: "iana" },
    "video/vnd.iptvforum.1dparityfec-1010": { source: "iana" },
    "video/vnd.iptvforum.1dparityfec-2005": { source: "iana" },
    "video/vnd.iptvforum.2dparityfec-1010": { source: "iana" },
    "video/vnd.iptvforum.2dparityfec-2005": { source: "iana" },
    "video/vnd.iptvforum.ttsavc": { source: "iana" },
    "video/vnd.iptvforum.ttsmpeg2": { source: "iana" },
    "video/vnd.motorola.video": { source: "iana" },
    "video/vnd.motorola.videop": { source: "iana" },
    "video/vnd.mpegurl": { source: "iana", extensions: ["mxu", "m4u"] },
    "video/vnd.ms-playready.media.pyv": { source: "iana", extensions: ["pyv"] },
    "video/vnd.nokia.interleaved-multimedia": { source: "iana" },
    "video/vnd.nokia.mp4vr": { source: "iana" },
    "video/vnd.nokia.videovoip": { source: "iana" },
    "video/vnd.objectvideo": { source: "iana" },
    "video/vnd.radgamettools.bink": { source: "iana" },
    "video/vnd.radgamettools.smacker": { source: "iana" },
    "video/vnd.sealed.mpeg1": { source: "iana" },
    "video/vnd.sealed.mpeg4": { source: "iana" },
    "video/vnd.sealed.swf": { source: "iana" },
    "video/vnd.sealedmedia.softseal.mov": { source: "iana" },
    "video/vnd.uvvu.mp4": { source: "iana", extensions: ["uvu", "uvvu"] },
    "video/vnd.vivo": { source: "iana", extensions: ["viv"] },
    "video/vnd.youtube.yt": { source: "iana" },
    "video/vp8": { source: "iana" },
    "video/vp9": { source: "iana" },
    "video/webm": { source: "apache", compressible: !1, extensions: ["webm"] },
    "video/x-f4v": { source: "apache", extensions: ["f4v"] },
    "video/x-fli": { source: "apache", extensions: ["fli"] },
    "video/x-flv": { source: "apache", compressible: !1, extensions: ["flv"] },
    "video/x-m4v": { source: "apache", extensions: ["m4v"] },
    "video/x-matroska": {
      source: "apache",
      compressible: !1,
      extensions: ["mkv", "mk3d", "mks"],
    },
    "video/x-mng": { source: "apache", extensions: ["mng"] },
    "video/x-ms-asf": { source: "apache", extensions: ["asf", "asx"] },
    "video/x-ms-vob": { source: "apache", extensions: ["vob"] },
    "video/x-ms-wm": { source: "apache", extensions: ["wm"] },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: !1,
      extensions: ["wmv"],
    },
    "video/x-ms-wmx": { source: "apache", extensions: ["wmx"] },
    "video/x-ms-wvx": { source: "apache", extensions: ["wvx"] },
    "video/x-msvideo": { source: "apache", extensions: ["avi"] },
    "video/x-sgi-movie": { source: "apache", extensions: ["movie"] },
    "video/x-smv": { source: "apache", extensions: ["smv"] },
    "x-conference/x-cooltalk": { source: "apache", extensions: ["ice"] },
    "x-shader/x-fragment": { compressible: !0 },
    "x-shader/x-vertex": { compressible: !0 },
  };
});
var MC = j((loe, LC) => {
  LC.exports = DC();
});
var UC = j((Er) => {
  "use strict";
  var Xu = MC(),
    b5 = require("path").extname,
    jC = /^\s*([^;\s]*)(?:;|\s|$)/,
    _5 = /^text\//i;
  Er.charset = FC;
  Er.charsets = { lookup: FC };
  Er.contentType = x5;
  Er.extension = w5;
  Er.extensions = Object.create(null);
  Er.lookup = S5;
  Er.types = Object.create(null);
  E5(Er.extensions, Er.types);
  function FC(t) {
    if (!t || typeof t != "string") return !1;
    var e = jC.exec(t),
      r = e && Xu[e[1].toLowerCase()];
    return r && r.charset ? r.charset : e && _5.test(e[1]) ? "UTF-8" : !1;
  }
  function x5(t) {
    if (!t || typeof t != "string") return !1;
    var e = t.indexOf("/") === -1 ? Er.lookup(t) : t;
    if (!e) return !1;
    if (e.indexOf("charset") === -1) {
      var r = Er.charset(e);
      r && (e += "; charset=" + r.toLowerCase());
    }
    return e;
  }
  function w5(t) {
    if (!t || typeof t != "string") return !1;
    var e = jC.exec(t),
      r = e && Er.extensions[e[1].toLowerCase()];
    return !r || !r.length ? !1 : r[0];
  }
  function S5(t) {
    if (!t || typeof t != "string") return !1;
    var e = b5("x." + t)
      .toLowerCase()
      .substr(1);
    return (e && Er.types[e]) || !1;
  }
  function E5(t, e) {
    var r = ["nginx", "apache", void 0, "iana"];
    Object.keys(Xu).forEach(function (s) {
      var a = Xu[s],
        i = a.extensions;
      if (!(!i || !i.length)) {
        t[s] = i;
        for (var o = 0; o < i.length; o++) {
          var c = i[o];
          if (e[c]) {
            var l = r.indexOf(Xu[e[c]].source),
              u = r.indexOf(a.source);
            if (
              e[c] !== "application/octet-stream" &&
              (l > u || (l === u && e[c].substr(0, 12) === "application/"))
            )
              continue;
          }
          e[c] = s;
        }
      }
    });
  }
});
var zC = j((doe, qC) => {
  qC.exports = T5;
  function T5(t) {
    var e =
      typeof setImmediate == "function"
        ? setImmediate
        : typeof process == "object" && typeof process.nextTick == "function"
          ? process.nextTick
          : null;
    e ? e(t) : setTimeout(t, 0);
  }
});
var rg = j((poe, HC) => {
  var BC = zC();
  HC.exports = C5;
  function C5(t) {
    var e = !1;
    return (
      BC(function () {
        e = !0;
      }),
      function (n, s) {
        e
          ? t(n, s)
          : BC(function () {
              t(n, s);
            });
      }
    );
  }
});
var ng = j((foe, VC) => {
  VC.exports = P5;
  function P5(t) {
    (Object.keys(t.jobs).forEach(k5.bind(t)), (t.jobs = {}));
  }
  function k5(t) {
    typeof this.jobs[t] == "function" && this.jobs[t]();
  }
});
var sg = j((moe, GC) => {
  var ZC = rg(),
    R5 = ng();
  GC.exports = O5;
  function O5(t, e, r, n) {
    var s = r.keyedList ? r.keyedList[r.index] : r.index;
    r.jobs[s] = I5(e, s, t[s], function (a, i) {
      s in r.jobs &&
        (delete r.jobs[s], a ? R5(r) : (r.results[s] = i), n(a, r.results));
    });
  }
  function I5(t, e, r, n) {
    var s;
    return (t.length == 2 ? (s = t(r, ZC(n))) : (s = t(r, e, ZC(n))), s);
  }
});
var ag = j((hoe, WC) => {
  WC.exports = $5;
  function $5(t, e) {
    var r = !Array.isArray(t),
      n = {
        index: 0,
        keyedList: r || e ? Object.keys(t) : null,
        jobs: {},
        results: r ? {} : [],
        size: r ? Object.keys(t).length : t.length,
      };
    return (
      e &&
        n.keyedList.sort(
          r
            ? e
            : function (s, a) {
                return e(t[s], t[a]);
              },
        ),
      n
    );
  }
});
var ig = j((goe, KC) => {
  var A5 = ng(),
    N5 = rg();
  KC.exports = D5;
  function D5(t) {
    Object.keys(this.jobs).length &&
      ((this.index = this.size), A5(this), N5(t)(null, this.results));
  }
});
var XC = j((voe, JC) => {
  var L5 = sg(),
    M5 = ag(),
    j5 = ig();
  JC.exports = F5;
  function F5(t, e, r) {
    for (var n = M5(t); n.index < (n.keyedList || t).length; )
      (L5(t, e, n, function (s, a) {
        if (s) {
          r(s, a);
          return;
        }
        if (Object.keys(n.jobs).length === 0) {
          r(null, n.results);
          return;
        }
      }),
        n.index++);
    return j5.bind(n, r);
  }
});
var og = j((yoe, Yu) => {
  var YC = sg(),
    U5 = ag(),
    q5 = ig();
  Yu.exports = z5;
  Yu.exports.ascending = QC;
  Yu.exports.descending = B5;
  function z5(t, e, r, n) {
    var s = U5(t, r);
    return (
      YC(t, e, s, function a(i, o) {
        if (i) {
          n(i, o);
          return;
        }
        if ((s.index++, s.index < (s.keyedList || t).length)) {
          YC(t, e, s, a);
          return;
        }
        n(null, s.results);
      }),
      q5.bind(s, n)
    );
  }
  function QC(t, e) {
    return t < e ? -1 : t > e ? 1 : 0;
  }
  function B5(t, e) {
    return -1 * QC(t, e);
  }
});
var tP = j((boe, eP) => {
  var H5 = og();
  eP.exports = V5;
  function V5(t, e, r) {
    return H5(t, e, null, r);
  }
});
var nP = j((_oe, rP) => {
  rP.exports = { parallel: XC(), serial: tP(), serialOrdered: og() };
});
var cg = j((xoe, sP) => {
  "use strict";
  sP.exports = Object;
});
var iP = j((woe, aP) => {
  "use strict";
  aP.exports = Error;
});
var cP = j((Soe, oP) => {
  "use strict";
  oP.exports = EvalError;
});
var uP = j((Eoe, lP) => {
  "use strict";
  lP.exports = RangeError;
});
var pP = j((Toe, dP) => {
  "use strict";
  dP.exports = ReferenceError;
});
var mP = j((Coe, fP) => {
  "use strict";
  fP.exports = SyntaxError;
});
var Qu = j((Poe, hP) => {
  "use strict";
  hP.exports = TypeError;
});
var vP = j((koe, gP) => {
  "use strict";
  gP.exports = URIError;
});
var bP = j((Roe, yP) => {
  "use strict";
  yP.exports = Math.abs;
});
var xP = j((Ooe, _P) => {
  "use strict";
  _P.exports = Math.floor;
});
var SP = j((Ioe, wP) => {
  "use strict";
  wP.exports = Math.max;
});
var TP = j(($oe, EP) => {
  "use strict";
  EP.exports = Math.min;
});
var PP = j((Aoe, CP) => {
  "use strict";
  CP.exports = Math.pow;
});
var RP = j((Noe, kP) => {
  "use strict";
  kP.exports = Math.round;
});
var IP = j((Doe, OP) => {
  "use strict";
  OP.exports =
    Number.isNaN ||
    function (e) {
      return e !== e;
    };
});
var AP = j((Loe, $P) => {
  "use strict";
  var Z5 = IP();
  $P.exports = function (e) {
    return Z5(e) || e === 0 ? e : e < 0 ? -1 : 1;
  };
});
var DP = j((Moe, NP) => {
  "use strict";
  NP.exports = Object.getOwnPropertyDescriptor;
});
var lg = j((joe, LP) => {
  "use strict";
  var ed = DP();
  if (ed)
    try {
      ed([], "length");
    } catch {
      ed = null;
    }
  LP.exports = ed;
});
var jP = j((Foe, MP) => {
  "use strict";
  var td = Object.defineProperty || !1;
  if (td)
    try {
      td({}, "a", { value: 1 });
    } catch {
      td = !1;
    }
  MP.exports = td;
});
var ug = j((Uoe, FP) => {
  "use strict";
  FP.exports = function () {
    if (
      typeof Symbol != "function" ||
      typeof Object.getOwnPropertySymbols != "function"
    )
      return !1;
    if (typeof Symbol.iterator == "symbol") return !0;
    var e = {},
      r = Symbol("test"),
      n = Object(r);
    if (
      typeof r == "string" ||
      Object.prototype.toString.call(r) !== "[object Symbol]" ||
      Object.prototype.toString.call(n) !== "[object Symbol]"
    )
      return !1;
    var s = 42;
    e[r] = s;
    for (var a in e) return !1;
    if (
      (typeof Object.keys == "function" && Object.keys(e).length !== 0) ||
      (typeof Object.getOwnPropertyNames == "function" &&
        Object.getOwnPropertyNames(e).length !== 0)
    )
      return !1;
    var i = Object.getOwnPropertySymbols(e);
    if (
      i.length !== 1 ||
      i[0] !== r ||
      !Object.prototype.propertyIsEnumerable.call(e, r)
    )
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var o = Object.getOwnPropertyDescriptor(e, r);
      if (o.value !== s || o.enumerable !== !0) return !1;
    }
    return !0;
  };
});
var zP = j((qoe, qP) => {
  "use strict";
  var UP = typeof Symbol < "u" && Symbol,
    G5 = ug();
  qP.exports = function () {
    return typeof UP != "function" ||
      typeof Symbol != "function" ||
      typeof UP("foo") != "symbol" ||
      typeof Symbol("bar") != "symbol"
      ? !1
      : G5();
  };
});
var dg = j((zoe, BP) => {
  "use strict";
  BP.exports = (typeof Reflect < "u" && Reflect.getPrototypeOf) || null;
});
var pg = j((Boe, HP) => {
  "use strict";
  var W5 = cg();
  HP.exports = W5.getPrototypeOf || null;
});
var GP = j((Hoe, ZP) => {
  "use strict";
  var K5 = "Function.prototype.bind called on incompatible ",
    J5 = Object.prototype.toString,
    X5 = Math.max,
    Y5 = "[object Function]",
    VP = function (e, r) {
      for (var n = [], s = 0; s < e.length; s += 1) n[s] = e[s];
      for (var a = 0; a < r.length; a += 1) n[a + e.length] = r[a];
      return n;
    },
    Q5 = function (e, r) {
      for (var n = [], s = r || 0, a = 0; s < e.length; s += 1, a += 1)
        n[a] = e[s];
      return n;
    },
    e8 = function (t, e) {
      for (var r = "", n = 0; n < t.length; n += 1)
        ((r += t[n]), n + 1 < t.length && (r += e));
      return r;
    };
  ZP.exports = function (e) {
    var r = this;
    if (typeof r != "function" || J5.apply(r) !== Y5)
      throw new TypeError(K5 + r);
    for (
      var n = Q5(arguments, 1),
        s,
        a = function () {
          if (this instanceof s) {
            var u = r.apply(this, VP(n, arguments));
            return Object(u) === u ? u : this;
          }
          return r.apply(e, VP(n, arguments));
        },
        i = X5(0, r.length - n.length),
        o = [],
        c = 0;
      c < i;
      c++
    )
      o[c] = "$" + c;
    if (
      ((s = Function(
        "binder",
        "return function (" +
          e8(o, ",") +
          "){ return binder.apply(this,arguments); }",
      )(a)),
      r.prototype)
    ) {
      var l = function () {};
      ((l.prototype = r.prototype),
        (s.prototype = new l()),
        (l.prototype = null));
    }
    return s;
  };
});
var Ec = j((Voe, WP) => {
  "use strict";
  var t8 = GP();
  WP.exports = Function.prototype.bind || t8;
});
var rd = j((Zoe, KP) => {
  "use strict";
  KP.exports = Function.prototype.call;
});
var fg = j((Goe, JP) => {
  "use strict";
  JP.exports = Function.prototype.apply;
});
var YP = j((Woe, XP) => {
  "use strict";
  XP.exports = typeof Reflect < "u" && Reflect && Reflect.apply;
});
var ek = j((Koe, QP) => {
  "use strict";
  var r8 = Ec(),
    n8 = fg(),
    s8 = rd(),
    a8 = YP();
  QP.exports = a8 || r8.call(s8, n8);
});
var rk = j((Joe, tk) => {
  "use strict";
  var i8 = Ec(),
    o8 = Qu(),
    c8 = rd(),
    l8 = ek();
  tk.exports = function (e) {
    if (e.length < 1 || typeof e[0] != "function")
      throw new o8("a function is required");
    return l8(i8, c8, e);
  };
});
var ck = j((Xoe, ok) => {
  "use strict";
  var u8 = rk(),
    nk = lg(),
    ak;
  try {
    ak = [].__proto__ === Array.prototype;
  } catch (t) {
    if (
      !t ||
      typeof t != "object" ||
      !("code" in t) ||
      t.code !== "ERR_PROTO_ACCESS"
    )
      throw t;
  }
  var mg = !!ak && nk && nk(Object.prototype, "__proto__"),
    ik = Object,
    sk = ik.getPrototypeOf;
  ok.exports =
    mg && typeof mg.get == "function"
      ? u8([mg.get])
      : typeof sk == "function"
        ? function (e) {
            return sk(e == null ? e : ik(e));
          }
        : !1;
});
var fk = j((Yoe, pk) => {
  "use strict";
  var lk = dg(),
    uk = pg(),
    dk = ck();
  pk.exports = lk
    ? function (e) {
        return lk(e);
      }
    : uk
      ? function (e) {
          if (!e || (typeof e != "object" && typeof e != "function"))
            throw new TypeError("getProto: not an object");
          return uk(e);
        }
      : dk
        ? function (e) {
            return dk(e);
          }
        : null;
});
var hg = j((Qoe, mk) => {
  "use strict";
  var d8 = Function.prototype.call,
    p8 = Object.prototype.hasOwnProperty,
    f8 = Ec();
  mk.exports = f8.call(d8, p8);
});
var xk = j((ece, _k) => {
  "use strict";
  var Ke,
    m8 = cg(),
    h8 = iP(),
    g8 = cP(),
    v8 = uP(),
    y8 = pP(),
    Zi = mP(),
    Vi = Qu(),
    b8 = vP(),
    _8 = bP(),
    x8 = xP(),
    w8 = SP(),
    S8 = TP(),
    E8 = PP(),
    T8 = RP(),
    C8 = AP(),
    yk = Function,
    gg = function (t) {
      try {
        return yk('"use strict"; return (' + t + ").constructor;")();
      } catch {}
    },
    Tc = lg(),
    P8 = jP(),
    vg = function () {
      throw new Vi();
    },
    k8 = Tc
      ? (function () {
          try {
            return (arguments.callee, vg);
          } catch {
            try {
              return Tc(arguments, "callee").get;
            } catch {
              return vg;
            }
          }
        })()
      : vg,
    Bi = zP()(),
    Kt = fk(),
    R8 = pg(),
    O8 = dg(),
    bk = fg(),
    Cc = rd(),
    Hi = {},
    I8 = typeof Uint8Array > "u" || !Kt ? Ke : Kt(Uint8Array),
    Ea = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError > "u" ? Ke : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Ke : ArrayBuffer,
      "%ArrayIteratorPrototype%": Bi && Kt ? Kt([][Symbol.iterator]()) : Ke,
      "%AsyncFromSyncIteratorPrototype%": Ke,
      "%AsyncFunction%": Hi,
      "%AsyncGenerator%": Hi,
      "%AsyncGeneratorFunction%": Hi,
      "%AsyncIteratorPrototype%": Hi,
      "%Atomics%": typeof Atomics > "u" ? Ke : Atomics,
      "%BigInt%": typeof BigInt > "u" ? Ke : BigInt,
      "%BigInt64Array%": typeof BigInt64Array > "u" ? Ke : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array > "u" ? Ke : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView > "u" ? Ke : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": h8,
      "%eval%": eval,
      "%EvalError%": g8,
      "%Float16Array%": typeof Float16Array > "u" ? Ke : Float16Array,
      "%Float32Array%": typeof Float32Array > "u" ? Ke : Float32Array,
      "%Float64Array%": typeof Float64Array > "u" ? Ke : Float64Array,
      "%FinalizationRegistry%":
        typeof FinalizationRegistry > "u" ? Ke : FinalizationRegistry,
      "%Function%": yk,
      "%GeneratorFunction%": Hi,
      "%Int8Array%": typeof Int8Array > "u" ? Ke : Int8Array,
      "%Int16Array%": typeof Int16Array > "u" ? Ke : Int16Array,
      "%Int32Array%": typeof Int32Array > "u" ? Ke : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": Bi && Kt ? Kt(Kt([][Symbol.iterator]())) : Ke,
      "%JSON%": typeof JSON == "object" ? JSON : Ke,
      "%Map%": typeof Map > "u" ? Ke : Map,
      "%MapIteratorPrototype%":
        typeof Map > "u" || !Bi || !Kt ? Ke : Kt(new Map()[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": m8,
      "%Object.getOwnPropertyDescriptor%": Tc,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise > "u" ? Ke : Promise,
      "%Proxy%": typeof Proxy > "u" ? Ke : Proxy,
      "%RangeError%": v8,
      "%ReferenceError%": y8,
      "%Reflect%": typeof Reflect > "u" ? Ke : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set > "u" ? Ke : Set,
      "%SetIteratorPrototype%":
        typeof Set > "u" || !Bi || !Kt ? Ke : Kt(new Set()[Symbol.iterator]()),
      "%SharedArrayBuffer%":
        typeof SharedArrayBuffer > "u" ? Ke : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": Bi && Kt ? Kt(""[Symbol.iterator]()) : Ke,
      "%Symbol%": Bi ? Symbol : Ke,
      "%SyntaxError%": Zi,
      "%ThrowTypeError%": k8,
      "%TypedArray%": I8,
      "%TypeError%": Vi,
      "%Uint8Array%": typeof Uint8Array > "u" ? Ke : Uint8Array,
      "%Uint8ClampedArray%":
        typeof Uint8ClampedArray > "u" ? Ke : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array > "u" ? Ke : Uint16Array,
      "%Uint32Array%": typeof Uint32Array > "u" ? Ke : Uint32Array,
      "%URIError%": b8,
      "%WeakMap%": typeof WeakMap > "u" ? Ke : WeakMap,
      "%WeakRef%": typeof WeakRef > "u" ? Ke : WeakRef,
      "%WeakSet%": typeof WeakSet > "u" ? Ke : WeakSet,
      "%Function.prototype.call%": Cc,
      "%Function.prototype.apply%": bk,
      "%Object.defineProperty%": P8,
      "%Object.getPrototypeOf%": R8,
      "%Math.abs%": _8,
      "%Math.floor%": x8,
      "%Math.max%": w8,
      "%Math.min%": S8,
      "%Math.pow%": E8,
      "%Math.round%": T8,
      "%Math.sign%": C8,
      "%Reflect.getPrototypeOf%": O8,
    };
  if (Kt)
    try {
      null.error;
    } catch (t) {
      ((hk = Kt(Kt(t))), (Ea["%Error.prototype%"] = hk));
    }
  var hk,
    $8 = function t(e) {
      var r;
      if (e === "%AsyncFunction%") r = gg("async function () {}");
      else if (e === "%GeneratorFunction%") r = gg("function* () {}");
      else if (e === "%AsyncGeneratorFunction%")
        r = gg("async function* () {}");
      else if (e === "%AsyncGenerator%") {
        var n = t("%AsyncGeneratorFunction%");
        n && (r = n.prototype);
      } else if (e === "%AsyncIteratorPrototype%") {
        var s = t("%AsyncGenerator%");
        s && Kt && (r = Kt(s.prototype));
      }
      return ((Ea[e] = r), r);
    },
    gk = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": [
        "AsyncGeneratorFunction",
        "prototype",
        "prototype",
      ],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"],
    },
    Pc = Ec(),
    nd = hg(),
    A8 = Pc.call(Cc, Array.prototype.concat),
    N8 = Pc.call(bk, Array.prototype.splice),
    vk = Pc.call(Cc, String.prototype.replace),
    sd = Pc.call(Cc, String.prototype.slice),
    D8 = Pc.call(Cc, RegExp.prototype.exec),
    L8 =
      /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
    M8 = /\\(\\)?/g,
    j8 = function (e) {
      var r = sd(e, 0, 1),
        n = sd(e, -1);
      if (r === "%" && n !== "%")
        throw new Zi("invalid intrinsic syntax, expected closing `%`");
      if (n === "%" && r !== "%")
        throw new Zi("invalid intrinsic syntax, expected opening `%`");
      var s = [];
      return (
        vk(e, L8, function (a, i, o, c) {
          s[s.length] = o ? vk(c, M8, "$1") : i || a;
        }),
        s
      );
    },
    F8 = function (e, r) {
      var n = e,
        s;
      if ((nd(gk, n) && ((s = gk[n]), (n = "%" + s[0] + "%")), nd(Ea, n))) {
        var a = Ea[n];
        if ((a === Hi && (a = $8(n)), typeof a > "u" && !r))
          throw new Vi(
            "intrinsic " +
              e +
              " exists, but is not available. Please file an issue!",
          );
        return { alias: s, name: n, value: a };
      }
      throw new Zi("intrinsic " + e + " does not exist!");
    };
  _k.exports = function (e, r) {
    if (typeof e != "string" || e.length === 0)
      throw new Vi("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof r != "boolean")
      throw new Vi('"allowMissing" argument must be a boolean');
    if (D8(/^%?[^%]*%?$/, e) === null)
      throw new Zi(
        "`%` may not be present anywhere but at the beginning and end of the intrinsic name",
      );
    var n = j8(e),
      s = n.length > 0 ? n[0] : "",
      a = F8("%" + s + "%", r),
      i = a.name,
      o = a.value,
      c = !1,
      l = a.alias;
    l && ((s = l[0]), N8(n, A8([0, 1], l)));
    for (var u = 1, d = !0; u < n.length; u += 1) {
      var m = n[u],
        p = sd(m, 0, 1),
        f = sd(m, -1);
      if (
        (p === '"' ||
          p === "'" ||
          p === "`" ||
          f === '"' ||
          f === "'" ||
          f === "`") &&
        p !== f
      )
        throw new Zi("property names with quotes must have matching quotes");
      if (
        ((m === "constructor" || !d) && (c = !0),
        (s += "." + m),
        (i = "%" + s + "%"),
        nd(Ea, i))
      )
        o = Ea[i];
      else if (o != null) {
        if (!(m in o)) {
          if (!r)
            throw new Vi(
              "base intrinsic for " +
                e +
                " exists, but the property is not available.",
            );
          return;
        }
        if (Tc && u + 1 >= n.length) {
          var y = Tc(o, m);
          ((d = !!y),
            d && "get" in y && !("originalValue" in y.get)
              ? (o = y.get)
              : (o = o[m]));
        } else ((d = nd(o, m)), (o = o[m]));
        d && !c && (Ea[i] = o);
      }
    }
    return o;
  };
});
var Sk = j((tce, wk) => {
  "use strict";
  var U8 = ug();
  wk.exports = function () {
    return U8() && !!Symbol.toStringTag;
  };
});
var Ck = j((rce, Tk) => {
  "use strict";
  var q8 = xk(),
    Ek = q8("%Object.defineProperty%", !0),
    z8 = Sk()(),
    B8 = hg(),
    H8 = Qu(),
    ad = z8 ? Symbol.toStringTag : null;
  Tk.exports = function (e, r) {
    var n = arguments.length > 2 && !!arguments[2] && arguments[2].force,
      s =
        arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
    if (
      (typeof n < "u" && typeof n != "boolean") ||
      (typeof s < "u" && typeof s != "boolean")
    )
      throw new H8(
        "if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans",
      );
    ad &&
      (n || !B8(e, ad)) &&
      (Ek
        ? Ek(e, ad, {
            configurable: !s,
            enumerable: !1,
            value: r,
            writable: !1,
          })
        : (e[ad] = r));
  };
});
var kk = j((nce, Pk) => {
  Pk.exports = function (t, e) {
    return (
      Object.keys(e).forEach(function (r) {
        t[r] = t[r] || e[r];
      }),
      t
    );
  };
});
var Ok = j((sce, Rk) => {
  var xg = NC(),
    V8 = require("util"),
    yg = require("path"),
    Z8 = require("http"),
    G8 = require("https"),
    W8 = require("url").parse,
    K8 = require("fs"),
    J8 = require("stream").Stream,
    bg = UC(),
    X8 = nP(),
    Y8 = Ck(),
    _g = kk();
  Rk.exports = Qe;
  V8.inherits(Qe, xg);
  function Qe(t) {
    if (!(this instanceof Qe)) return new Qe(t);
    ((this._overheadLength = 0),
      (this._valueLength = 0),
      (this._valuesToMeasure = []),
      xg.call(this),
      (t = t || {}));
    for (var e in t) this[e] = t[e];
  }
  Qe.LINE_BREAK = `\r
`;
  Qe.DEFAULT_CONTENT_TYPE = "application/octet-stream";
  Qe.prototype.append = function (t, e, r) {
    ((r = r || {}), typeof r == "string" && (r = { filename: r }));
    var n = xg.prototype.append.bind(this);
    if ((typeof e == "number" && (e = "" + e), Array.isArray(e))) {
      this._error(new Error("Arrays are not supported."));
      return;
    }
    var s = this._multiPartHeader(t, e, r),
      a = this._multiPartFooter();
    (n(s), n(e), n(a), this._trackLength(s, e, r));
  };
  Qe.prototype._trackLength = function (t, e, r) {
    var n = 0;
    (r.knownLength != null
      ? (n += +r.knownLength)
      : Buffer.isBuffer(e)
        ? (n = e.length)
        : typeof e == "string" && (n = Buffer.byteLength(e)),
      (this._valueLength += n),
      (this._overheadLength += Buffer.byteLength(t) + Qe.LINE_BREAK.length),
      !(
        !e ||
        (!e.path &&
          !(
            e.readable && Object.prototype.hasOwnProperty.call(e, "httpVersion")
          ) &&
          !(e instanceof J8))
      ) &&
        (r.knownLength || this._valuesToMeasure.push(e)));
  };
  Qe.prototype._lengthRetriever = function (t, e) {
    Object.prototype.hasOwnProperty.call(t, "fd")
      ? t.end != null && t.end != 1 / 0 && t.start != null
        ? e(null, t.end + 1 - (t.start ? t.start : 0))
        : K8.stat(t.path, function (r, n) {
            var s;
            if (r) {
              e(r);
              return;
            }
            ((s = n.size - (t.start ? t.start : 0)), e(null, s));
          })
      : Object.prototype.hasOwnProperty.call(t, "httpVersion")
        ? e(null, +t.headers["content-length"])
        : Object.prototype.hasOwnProperty.call(t, "httpModule")
          ? (t.on("response", function (r) {
              (t.pause(), e(null, +r.headers["content-length"]));
            }),
            t.resume())
          : e("Unknown stream");
  };
  Qe.prototype._multiPartHeader = function (t, e, r) {
    if (typeof r.header == "string") return r.header;
    var n = this._getContentDisposition(e, r),
      s = this._getContentType(e, r),
      a = "",
      i = {
        "Content-Disposition": ["form-data", 'name="' + t + '"'].concat(
          n || [],
        ),
        "Content-Type": [].concat(s || []),
      };
    typeof r.header == "object" && _g(i, r.header);
    var o;
    for (var c in i)
      if (Object.prototype.hasOwnProperty.call(i, c)) {
        if (((o = i[c]), o == null)) continue;
        (Array.isArray(o) || (o = [o]),
          o.length && (a += c + ": " + o.join("; ") + Qe.LINE_BREAK));
      }
    return "--" + this.getBoundary() + Qe.LINE_BREAK + a + Qe.LINE_BREAK;
  };
  Qe.prototype._getContentDisposition = function (t, e) {
    var r, n;
    return (
      typeof e.filepath == "string"
        ? (r = yg.normalize(e.filepath).replace(/\\/g, "/"))
        : e.filename || t.name || t.path
          ? (r = yg.basename(e.filename || t.name || t.path))
          : t.readable &&
            Object.prototype.hasOwnProperty.call(t, "httpVersion") &&
            (r = yg.basename(t.client._httpMessage.path || "")),
      r && (n = 'filename="' + r + '"'),
      n
    );
  };
  Qe.prototype._getContentType = function (t, e) {
    var r = e.contentType;
    return (
      !r && t.name && (r = bg.lookup(t.name)),
      !r && t.path && (r = bg.lookup(t.path)),
      !r &&
        t.readable &&
        Object.prototype.hasOwnProperty.call(t, "httpVersion") &&
        (r = t.headers["content-type"]),
      !r &&
        (e.filepath || e.filename) &&
        (r = bg.lookup(e.filepath || e.filename)),
      !r && typeof t == "object" && (r = Qe.DEFAULT_CONTENT_TYPE),
      r
    );
  };
  Qe.prototype._multiPartFooter = function () {
    return function (t) {
      var e = Qe.LINE_BREAK,
        r = this._streams.length === 0;
      (r && (e += this._lastBoundary()), t(e));
    }.bind(this);
  };
  Qe.prototype._lastBoundary = function () {
    return "--" + this.getBoundary() + "--" + Qe.LINE_BREAK;
  };
  Qe.prototype.getHeaders = function (t) {
    var e,
      r = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary(),
      };
    for (e in t)
      Object.prototype.hasOwnProperty.call(t, e) && (r[e.toLowerCase()] = t[e]);
    return r;
  };
  Qe.prototype.setBoundary = function (t) {
    this._boundary = t;
  };
  Qe.prototype.getBoundary = function () {
    return (this._boundary || this._generateBoundary(), this._boundary);
  };
  Qe.prototype.getBuffer = function () {
    for (
      var t = new Buffer.alloc(0),
        e = this.getBoundary(),
        r = 0,
        n = this._streams.length;
      r < n;
      r++
    )
      typeof this._streams[r] != "function" &&
        (Buffer.isBuffer(this._streams[r])
          ? (t = Buffer.concat([t, this._streams[r]]))
          : (t = Buffer.concat([t, Buffer.from(this._streams[r])])),
        (typeof this._streams[r] != "string" ||
          this._streams[r].substring(2, e.length + 2) !== e) &&
          (t = Buffer.concat([t, Buffer.from(Qe.LINE_BREAK)])));
    return Buffer.concat([t, Buffer.from(this._lastBoundary())]);
  };
  Qe.prototype._generateBoundary = function () {
    for (var t = "--------------------------", e = 0; e < 24; e++)
      t += Math.floor(Math.random() * 10).toString(16);
    this._boundary = t;
  };
  Qe.prototype.getLengthSync = function () {
    var t = this._overheadLength + this._valueLength;
    return (
      this._streams.length && (t += this._lastBoundary().length),
      this.hasKnownLength() ||
        this._error(
          new Error("Cannot calculate proper length in synchronous way."),
        ),
      t
    );
  };
  Qe.prototype.hasKnownLength = function () {
    var t = !0;
    return (this._valuesToMeasure.length && (t = !1), t);
  };
  Qe.prototype.getLength = function (t) {
    var e = this._overheadLength + this._valueLength;
    if (
      (this._streams.length && (e += this._lastBoundary().length),
      !this._valuesToMeasure.length)
    ) {
      process.nextTick(t.bind(this, null, e));
      return;
    }
    X8.parallel(this._valuesToMeasure, this._lengthRetriever, function (r, n) {
      if (r) {
        t(r);
        return;
      }
      (n.forEach(function (s) {
        e += s;
      }),
        t(null, e));
    });
  };
  Qe.prototype.submit = function (t, e) {
    var r,
      n,
      s = { method: "post" };
    return (
      typeof t == "string"
        ? ((t = W8(t)),
          (n = _g(
            {
              port: t.port,
              path: t.pathname,
              host: t.hostname,
              protocol: t.protocol,
            },
            s,
          )))
        : ((n = _g(t, s)),
          n.port || (n.port = n.protocol == "https:" ? 443 : 80)),
      (n.headers = this.getHeaders(t.headers)),
      n.protocol == "https:" ? (r = G8.request(n)) : (r = Z8.request(n)),
      this.getLength(
        function (a, i) {
          if (a && a !== "Unknown stream") {
            this._error(a);
            return;
          }
          if ((i && r.setHeader("Content-Length", i), this.pipe(r), e)) {
            var o,
              c = function (l, u) {
                return (
                  r.removeListener("error", c),
                  r.removeListener("response", o),
                  e.call(this, l, u)
                );
              };
            ((o = c.bind(this, null)), r.on("error", c), r.on("response", o));
          }
        }.bind(this),
      ),
      r
    );
  };
  Qe.prototype._error = function (t) {
    this.error || ((this.error = t), this.pause(), this.emit("error", t));
  };
  Qe.prototype.toString = function () {
    return "[object FormData]";
  };
  Y8(Qe, "FormData");
});
var Wk = j((Gk) => {
  "use strict";
  var gK = require("url").parse,
    vK = { ftp: 21, gopher: 70, http: 80, https: 443, ws: 80, wss: 443 },
    yK =
      String.prototype.endsWith ||
      function (t) {
        return (
          t.length <= this.length &&
          this.indexOf(t, this.length - t.length) !== -1
        );
      };
  function bK(t) {
    var e = typeof t == "string" ? gK(t) : t || {},
      r = e.protocol,
      n = e.host,
      s = e.port;
    if (
      typeof n != "string" ||
      !n ||
      typeof r != "string" ||
      ((r = r.split(":", 1)[0]),
      (n = n.replace(/:\d*$/, "")),
      (s = parseInt(s) || vK[r] || 0),
      !_K(n, s))
    )
      return "";
    var a =
      Ji("npm_config_" + r + "_proxy") ||
      Ji(r + "_proxy") ||
      Ji("npm_config_proxy") ||
      Ji("all_proxy");
    return (a && a.indexOf("://") === -1 && (a = r + "://" + a), a);
  }
  function _K(t, e) {
    var r = (Ji("npm_config_no_proxy") || Ji("no_proxy")).toLowerCase();
    return r
      ? r === "*"
        ? !1
        : r.split(/[,\s]/).every(function (n) {
            if (!n) return !0;
            var s = n.match(/^(.+):(\d+)$/),
              a = s ? s[1] : n,
              i = s ? parseInt(s[2]) : 0;
            return i && i !== e
              ? !0
              : /^[.*]/.test(a)
                ? (a.charAt(0) === "*" && (a = a.slice(1)), !yK.call(t, a))
                : t !== a;
          })
      : !0;
  }
  function Ji(t) {
    return process.env[t.toLowerCase()] || process.env[t.toUpperCase()] || "";
  }
  Gk.getProxyForUrl = bK;
});
var Jk = j((ale, Kk) => {
  var Xi = 1e3,
    Yi = Xi * 60,
    Qi = Yi * 60,
    Pa = Qi * 24,
    xK = Pa * 7,
    wK = Pa * 365.25;
  Kk.exports = function (t, e) {
    e = e || {};
    var r = typeof t;
    if (r === "string" && t.length > 0) return SK(t);
    if (r === "number" && isFinite(t)) return e.long ? TK(t) : EK(t);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" +
        JSON.stringify(t),
    );
  };
  function SK(t) {
    if (((t = String(t)), !(t.length > 100))) {
      var e =
        /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          t,
        );
      if (e) {
        var r = parseFloat(e[1]),
          n = (e[2] || "ms").toLowerCase();
        switch (n) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return r * wK;
          case "weeks":
          case "week":
          case "w":
            return r * xK;
          case "days":
          case "day":
          case "d":
            return r * Pa;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return r * Qi;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return r * Yi;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return r * Xi;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return r;
          default:
            return;
        }
      }
    }
  }
  function EK(t) {
    var e = Math.abs(t);
    return e >= Pa
      ? Math.round(t / Pa) + "d"
      : e >= Qi
        ? Math.round(t / Qi) + "h"
        : e >= Yi
          ? Math.round(t / Yi) + "m"
          : e >= Xi
            ? Math.round(t / Xi) + "s"
            : t + "ms";
  }
  function TK(t) {
    var e = Math.abs(t);
    return e >= Pa
      ? ld(t, e, Pa, "day")
      : e >= Qi
        ? ld(t, e, Qi, "hour")
        : e >= Yi
          ? ld(t, e, Yi, "minute")
          : e >= Xi
            ? ld(t, e, Xi, "second")
            : t + " ms";
  }
  function ld(t, e, r, n) {
    var s = e >= r * 1.5;
    return Math.round(t / r) + " " + n + (s ? "s" : "");
  }
});
var Ng = j((ile, Xk) => {
  function CK(t) {
    ((r.debug = r),
      (r.default = r),
      (r.coerce = c),
      (r.disable = i),
      (r.enable = s),
      (r.enabled = o),
      (r.humanize = Jk()),
      (r.destroy = l),
      Object.keys(t).forEach((u) => {
        r[u] = t[u];
      }),
      (r.names = []),
      (r.skips = []),
      (r.formatters = {}));
    function e(u) {
      let d = 0;
      for (let m = 0; m < u.length; m++)
        ((d = (d << 5) - d + u.charCodeAt(m)), (d |= 0));
      return r.colors[Math.abs(d) % r.colors.length];
    }
    r.selectColor = e;
    function r(u) {
      let d,
        m = null,
        p,
        f;
      function y(...h) {
        if (!y.enabled) return;
        let g = y,
          _ = Number(new Date()),
          v = _ - (d || _);
        ((g.diff = v),
          (g.prev = d),
          (g.curr = _),
          (d = _),
          (h[0] = r.coerce(h[0])),
          typeof h[0] != "string" && h.unshift("%O"));
        let b = 0;
        ((h[0] = h[0].replace(/%([a-zA-Z%])/g, (w, S) => {
          if (w === "%%") return "%";
          b++;
          let C = r.formatters[S];
          if (typeof C == "function") {
            let P = h[b];
            ((w = C.call(g, P)), h.splice(b, 1), b--);
          }
          return w;
        })),
          r.formatArgs.call(g, h),
          (g.log || r.log).apply(g, h));
      }
      return (
        (y.namespace = u),
        (y.useColors = r.useColors()),
        (y.color = r.selectColor(u)),
        (y.extend = n),
        (y.destroy = r.destroy),
        Object.defineProperty(y, "enabled", {
          enumerable: !0,
          configurable: !1,
          get: () =>
            m !== null
              ? m
              : (p !== r.namespaces && ((p = r.namespaces), (f = r.enabled(u))),
                f),
          set: (h) => {
            m = h;
          },
        }),
        typeof r.init == "function" && r.init(y),
        y
      );
    }
    function n(u, d) {
      let m = r(this.namespace + (typeof d > "u" ? ":" : d) + u);
      return ((m.log = this.log), m);
    }
    function s(u) {
      (r.save(u), (r.namespaces = u), (r.names = []), (r.skips = []));
      let d = (typeof u == "string" ? u : "")
        .trim()
        .replace(" ", ",")
        .split(",")
        .filter(Boolean);
      for (let m of d)
        m[0] === "-" ? r.skips.push(m.slice(1)) : r.names.push(m);
    }
    function a(u, d) {
      let m = 0,
        p = 0,
        f = -1,
        y = 0;
      for (; m < u.length; )
        if (p < d.length && (d[p] === u[m] || d[p] === "*"))
          d[p] === "*" ? ((f = p), (y = m), p++) : (m++, p++);
        else if (f !== -1) ((p = f + 1), y++, (m = y));
        else return !1;
      for (; p < d.length && d[p] === "*"; ) p++;
      return p === d.length;
    }
    function i() {
      let u = [...r.names, ...r.skips.map((d) => "-" + d)].join(",");
      return (r.enable(""), u);
    }
    function o(u) {
      for (let d of r.skips) if (a(u, d)) return !1;
      for (let d of r.names) if (a(u, d)) return !0;
      return !1;
    }
    function c(u) {
      return u instanceof Error ? u.stack || u.message : u;
    }
    function l() {
      console.warn(
        "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
      );
    }
    return (r.enable(r.load()), r);
  }
  Xk.exports = CK;
});
var Yk = j((qr, ud) => {
  qr.formatArgs = kK;
  qr.save = RK;
  qr.load = OK;
  qr.useColors = PK;
  qr.storage = IK();
  qr.destroy = (() => {
    let t = !1;
    return () => {
      t ||
        ((t = !0),
        console.warn(
          "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
        ));
    };
  })();
  qr.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33",
  ];
  function PK() {
    if (
      typeof window < "u" &&
      window.process &&
      (window.process.type === "renderer" || window.process.__nwjs)
    )
      return !0;
    if (
      typeof navigator < "u" &&
      navigator.userAgent &&
      navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
    )
      return !1;
    let t;
    return (
      (typeof document < "u" &&
        document.documentElement &&
        document.documentElement.style &&
        document.documentElement.style.WebkitAppearance) ||
      (typeof window < "u" &&
        window.console &&
        (window.console.firebug ||
          (window.console.exception && window.console.table))) ||
      (typeof navigator < "u" &&
        navigator.userAgent &&
        (t = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) &&
        parseInt(t[1], 10) >= 31) ||
      (typeof navigator < "u" &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
    );
  }
  function kK(t) {
    if (
      ((t[0] =
        (this.useColors ? "%c" : "") +
        this.namespace +
        (this.useColors ? " %c" : " ") +
        t[0] +
        (this.useColors ? "%c " : " ") +
        "+" +
        ud.exports.humanize(this.diff)),
      !this.useColors)
    )
      return;
    let e = "color: " + this.color;
    t.splice(1, 0, e, "color: inherit");
    let r = 0,
      n = 0;
    (t[0].replace(/%[a-zA-Z%]/g, (s) => {
      s !== "%%" && (r++, s === "%c" && (n = r));
    }),
      t.splice(n, 0, e));
  }
  qr.log = console.debug || console.log || (() => {});
  function RK(t) {
    try {
      t ? qr.storage.setItem("debug", t) : qr.storage.removeItem("debug");
    } catch {}
  }
  function OK() {
    let t;
    try {
      t = qr.storage.getItem("debug");
    } catch {}
    return (
      !t && typeof process < "u" && "env" in process && (t = process.env.DEBUG),
      t
    );
  }
  function IK() {
    try {
      return localStorage;
    } catch {}
  }
  ud.exports = Ng()(qr);
  var { formatters: $K } = ud.exports;
  $K.j = function (t) {
    try {
      return JSON.stringify(t);
    } catch (e) {
      return "[UnexpectedJSONParseError]: " + e.message;
    }
  };
});
var eR = j((ole, Qk) => {
  "use strict";
  Qk.exports = (t, e = process.argv) => {
    let r = t.startsWith("-") ? "" : t.length === 1 ? "-" : "--",
      n = e.indexOf(r + t),
      s = e.indexOf("--");
    return n !== -1 && (s === -1 || n < s);
  };
});
var nR = j((cle, rR) => {
  "use strict";
  var AK = require("os"),
    tR = require("tty"),
    Qr = eR(),
    { env: Jt } = process,
    dd;
  Qr("no-color") || Qr("no-colors") || Qr("color=false") || Qr("color=never")
    ? (dd = 0)
    : (Qr("color") || Qr("colors") || Qr("color=true") || Qr("color=always")) &&
      (dd = 1);
  function NK() {
    if ("FORCE_COLOR" in Jt)
      return Jt.FORCE_COLOR === "true"
        ? 1
        : Jt.FORCE_COLOR === "false"
          ? 0
          : Jt.FORCE_COLOR.length === 0
            ? 1
            : Math.min(Number.parseInt(Jt.FORCE_COLOR, 10), 3);
  }
  function DK(t) {
    return t === 0
      ? !1
      : { level: t, hasBasic: !0, has256: t >= 2, has16m: t >= 3 };
  }
  function LK(t, { streamIsTTY: e, sniffFlags: r = !0 } = {}) {
    let n = NK();
    n !== void 0 && (dd = n);
    let s = r ? dd : n;
    if (s === 0) return 0;
    if (r) {
      if (Qr("color=16m") || Qr("color=full") || Qr("color=truecolor"))
        return 3;
      if (Qr("color=256")) return 2;
    }
    if (t && !e && s === void 0) return 0;
    let a = s || 0;
    if (Jt.TERM === "dumb") return a;
    if (process.platform === "win32") {
      let i = AK.release().split(".");
      return Number(i[0]) >= 10 && Number(i[2]) >= 10586
        ? Number(i[2]) >= 14931
          ? 3
          : 2
        : 1;
    }
    if ("CI" in Jt)
      return [
        "TRAVIS",
        "CIRCLECI",
        "APPVEYOR",
        "GITLAB_CI",
        "GITHUB_ACTIONS",
        "BUILDKITE",
        "DRONE",
      ].some((i) => i in Jt) || Jt.CI_NAME === "codeship"
        ? 1
        : a;
    if ("TEAMCITY_VERSION" in Jt)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Jt.TEAMCITY_VERSION) ? 1 : 0;
    if (Jt.COLORTERM === "truecolor") return 3;
    if ("TERM_PROGRAM" in Jt) {
      let i = Number.parseInt(
        (Jt.TERM_PROGRAM_VERSION || "").split(".")[0],
        10,
      );
      switch (Jt.TERM_PROGRAM) {
        case "iTerm.app":
          return i >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(Jt.TERM)
      ? 2
      : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(
            Jt.TERM,
          ) || "COLORTERM" in Jt
        ? 1
        : a;
  }
  function Dg(t, e = {}) {
    let r = LK(t, { streamIsTTY: t && t.isTTY, ...e });
    return DK(r);
  }
  rR.exports = {
    supportsColor: Dg,
    stdout: Dg({ isTTY: tR.isatty(1) }),
    stderr: Dg({ isTTY: tR.isatty(2) }),
  };
});
var aR = j((Xt, fd) => {
  var MK = require("tty"),
    pd = require("util");
  Xt.init = HK;
  Xt.log = qK;
  Xt.formatArgs = FK;
  Xt.save = zK;
  Xt.load = BK;
  Xt.useColors = jK;
  Xt.destroy = pd.deprecate(
    () => {},
    "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
  );
  Xt.colors = [6, 2, 3, 4, 5, 1];
  try {
    let t = nR();
    t &&
      (t.stderr || t).level >= 2 &&
      (Xt.colors = [
        20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63,
        68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128,
        129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168,
        169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200,
        201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221,
      ]);
  } catch {}
  Xt.inspectOpts = Object.keys(process.env)
    .filter((t) => /^debug_/i.test(t))
    .reduce((t, e) => {
      let r = e
          .substring(6)
          .toLowerCase()
          .replace(/_([a-z])/g, (s, a) => a.toUpperCase()),
        n = process.env[e];
      return (
        /^(yes|on|true|enabled)$/i.test(n)
          ? (n = !0)
          : /^(no|off|false|disabled)$/i.test(n)
            ? (n = !1)
            : n === "null"
              ? (n = null)
              : (n = Number(n)),
        (t[r] = n),
        t
      );
    }, {});
  function jK() {
    return "colors" in Xt.inspectOpts
      ? !!Xt.inspectOpts.colors
      : MK.isatty(process.stderr.fd);
  }
  function FK(t) {
    let { namespace: e, useColors: r } = this;
    if (r) {
      let n = this.color,
        s = "\x1B[3" + (n < 8 ? n : "8;5;" + n),
        a = `  ${s};1m${e} \x1B[0m`;
      ((t[0] =
        a +
        t[0]
          .split(
            `
`,
          )
          .join(
            `
` + a,
          )),
        t.push(s + "m+" + fd.exports.humanize(this.diff) + "\x1B[0m"));
    } else t[0] = UK() + e + " " + t[0];
  }
  function UK() {
    return Xt.inspectOpts.hideDate ? "" : new Date().toISOString() + " ";
  }
  function qK(...t) {
    return process.stderr.write(
      pd.formatWithOptions(Xt.inspectOpts, ...t) +
        `
`,
    );
  }
  function zK(t) {
    t ? (process.env.DEBUG = t) : delete process.env.DEBUG;
  }
  function BK() {
    return process.env.DEBUG;
  }
  function HK(t) {
    t.inspectOpts = {};
    let e = Object.keys(Xt.inspectOpts);
    for (let r = 0; r < e.length; r++)
      t.inspectOpts[e[r]] = Xt.inspectOpts[e[r]];
  }
  fd.exports = Ng()(Xt);
  var { formatters: sR } = fd.exports;
  sR.o = function (t) {
    return (
      (this.inspectOpts.colors = this.useColors),
      pd
        .inspect(t, this.inspectOpts)
        .split(
          `
`,
        )
        .map((e) => e.trim())
        .join(" ")
    );
  };
  sR.O = function (t) {
    return (
      (this.inspectOpts.colors = this.useColors),
      pd.inspect(t, this.inspectOpts)
    );
  };
});
var iR = j((lle, Lg) => {
  typeof process > "u" ||
  process.type === "renderer" ||
  process.browser === !0 ||
  process.__nwjs
    ? (Lg.exports = Yk())
    : (Lg.exports = aR());
});
var cR = j((ule, oR) => {
  var Ic;
  oR.exports = function () {
    if (!Ic) {
      try {
        Ic = iR()("follow-redirects");
      } catch {}
      typeof Ic != "function" && (Ic = function () {});
    }
    Ic.apply(null, arguments);
  };
});
var fR = j((dle, Wg) => {
  var Ac = require("url"),
    $c = Ac.URL,
    VK = require("http"),
    ZK = require("https"),
    qg = require("stream").Writable,
    zg = require("assert"),
    lR = cR();
  (function () {
    var e = typeof process < "u",
      r = typeof window < "u" && typeof document < "u",
      n = Ra(Error.captureStackTrace);
    !e &&
      (r || !n) &&
      console.warn(
        "The follow-redirects package should be excluded from browser builds.",
      );
  })();
  var Bg = !1;
  try {
    zg(new $c(""));
  } catch (t) {
    Bg = t.code === "ERR_INVALID_URL";
  }
  var GK = [
      "auth",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "hash",
    ],
    Hg = ["abort", "aborted", "connect", "error", "socket", "timeout"],
    Vg = Object.create(null);
  Hg.forEach(function (t) {
    Vg[t] = function (e, r, n) {
      this._redirectable.emit(t, e, r, n);
    };
  });
  var jg = Nc("ERR_INVALID_URL", "Invalid URL", TypeError),
    Fg = Nc("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed"),
    WK = Nc(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded",
      Fg,
    ),
    KK = Nc(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit",
    ),
    JK = Nc("ERR_STREAM_WRITE_AFTER_END", "write after end"),
    XK = qg.prototype.destroy || dR;
  function Tr(t, e) {
    (qg.call(this),
      this._sanitizeOptions(t),
      (this._options = t),
      (this._ended = !1),
      (this._ending = !1),
      (this._redirectCount = 0),
      (this._redirects = []),
      (this._requestBodyLength = 0),
      (this._requestBodyBuffers = []),
      e && this.on("response", e));
    var r = this;
    ((this._onNativeResponse = function (n) {
      try {
        r._processResponse(n);
      } catch (s) {
        r.emit("error", s instanceof Fg ? s : new Fg({ cause: s }));
      }
    }),
      this._performRequest());
  }
  Tr.prototype = Object.create(qg.prototype);
  Tr.prototype.abort = function () {
    (Gg(this._currentRequest),
      this._currentRequest.abort(),
      this.emit("abort"));
  };
  Tr.prototype.destroy = function (t) {
    return (Gg(this._currentRequest, t), XK.call(this, t), this);
  };
  Tr.prototype.write = function (t, e, r) {
    if (this._ending) throw new JK();
    if (!ka(t) && !eJ(t))
      throw new TypeError("data should be a string, Buffer or Uint8Array");
    if ((Ra(e) && ((r = e), (e = null)), t.length === 0)) {
      r && r();
      return;
    }
    this._requestBodyLength + t.length <= this._options.maxBodyLength
      ? ((this._requestBodyLength += t.length),
        this._requestBodyBuffers.push({ data: t, encoding: e }),
        this._currentRequest.write(t, e, r))
      : (this.emit("error", new KK()), this.abort());
  };
  Tr.prototype.end = function (t, e, r) {
    if (
      (Ra(t) ? ((r = t), (t = e = null)) : Ra(e) && ((r = e), (e = null)), !t)
    )
      ((this._ended = this._ending = !0),
        this._currentRequest.end(null, null, r));
    else {
      var n = this,
        s = this._currentRequest;
      (this.write(t, e, function () {
        ((n._ended = !0), s.end(null, null, r));
      }),
        (this._ending = !0));
    }
  };
  Tr.prototype.setHeader = function (t, e) {
    ((this._options.headers[t] = e), this._currentRequest.setHeader(t, e));
  };
  Tr.prototype.removeHeader = function (t) {
    (delete this._options.headers[t], this._currentRequest.removeHeader(t));
  };
  Tr.prototype.setTimeout = function (t, e) {
    var r = this;
    function n(i) {
      (i.setTimeout(t),
        i.removeListener("timeout", i.destroy),
        i.addListener("timeout", i.destroy));
    }
    function s(i) {
      (r._timeout && clearTimeout(r._timeout),
        (r._timeout = setTimeout(function () {
          (r.emit("timeout"), a());
        }, t)),
        n(i));
    }
    function a() {
      (r._timeout && (clearTimeout(r._timeout), (r._timeout = null)),
        r.removeListener("abort", a),
        r.removeListener("error", a),
        r.removeListener("response", a),
        r.removeListener("close", a),
        e && r.removeListener("timeout", e),
        r.socket || r._currentRequest.removeListener("socket", s));
    }
    return (
      e && this.on("timeout", e),
      this.socket ? s(this.socket) : this._currentRequest.once("socket", s),
      this.on("socket", n),
      this.on("abort", a),
      this.on("error", a),
      this.on("response", a),
      this.on("close", a),
      this
    );
  };
  ["flushHeaders", "getHeader", "setNoDelay", "setSocketKeepAlive"].forEach(
    function (t) {
      Tr.prototype[t] = function (e, r) {
        return this._currentRequest[t](e, r);
      };
    },
  );
  ["aborted", "connection", "socket"].forEach(function (t) {
    Object.defineProperty(Tr.prototype, t, {
      get: function () {
        return this._currentRequest[t];
      },
    });
  });
  Tr.prototype._sanitizeOptions = function (t) {
    if (
      (t.headers || (t.headers = {}),
      t.host && (t.hostname || (t.hostname = t.host), delete t.host),
      !t.pathname && t.path)
    ) {
      var e = t.path.indexOf("?");
      e < 0
        ? (t.pathname = t.path)
        : ((t.pathname = t.path.substring(0, e)),
          (t.search = t.path.substring(e)));
    }
  };
  Tr.prototype._performRequest = function () {
    var t = this._options.protocol,
      e = this._options.nativeProtocols[t];
    if (!e) throw new TypeError("Unsupported protocol " + t);
    if (this._options.agents) {
      var r = t.slice(0, -1);
      this._options.agent = this._options.agents[r];
    }
    var n = (this._currentRequest = e.request(
      this._options,
      this._onNativeResponse,
    ));
    n._redirectable = this;
    for (var s of Hg) n.on(s, Vg[s]);
    if (
      ((this._currentUrl = /^\//.test(this._options.path)
        ? Ac.format(this._options)
        : this._options.path),
      this._isRedirect)
    ) {
      var a = 0,
        i = this,
        o = this._requestBodyBuffers;
      (function c(l) {
        if (n === i._currentRequest)
          if (l) i.emit("error", l);
          else if (a < o.length) {
            var u = o[a++];
            n.finished || n.write(u.data, u.encoding, c);
          } else i._ended && n.end();
      })();
    }
  };
  Tr.prototype._processResponse = function (t) {
    var e = t.statusCode;
    this._options.trackRedirects &&
      this._redirects.push({
        url: this._currentUrl,
        headers: t.headers,
        statusCode: e,
      });
    var r = t.headers.location;
    if (!r || this._options.followRedirects === !1 || e < 300 || e >= 400) {
      ((t.responseUrl = this._currentUrl),
        (t.redirects = this._redirects),
        this.emit("response", t),
        (this._requestBodyBuffers = []));
      return;
    }
    if (
      (Gg(this._currentRequest),
      t.destroy(),
      ++this._redirectCount > this._options.maxRedirects)
    )
      throw new WK();
    var n,
      s = this._options.beforeRedirect;
    s &&
      (n = Object.assign(
        { Host: t.req.getHeader("host") },
        this._options.headers,
      ));
    var a = this._options.method;
    (((e === 301 || e === 302) && this._options.method === "POST") ||
      (e === 303 && !/^(?:GET|HEAD)$/.test(this._options.method))) &&
      ((this._options.method = "GET"),
      (this._requestBodyBuffers = []),
      Mg(/^content-/i, this._options.headers));
    var i = Mg(/^host$/i, this._options.headers),
      o = Zg(this._currentUrl),
      c = i || o.host,
      l = /^\w+:/.test(r)
        ? this._currentUrl
        : Ac.format(Object.assign(o, { host: c })),
      u = YK(r, l);
    if (
      (lR("redirecting to", u.href),
      (this._isRedirect = !0),
      Ug(u, this._options),
      ((u.protocol !== o.protocol && u.protocol !== "https:") ||
        (u.host !== c && !QK(u.host, c))) &&
        Mg(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers),
      Ra(s))
    ) {
      var d = { headers: t.headers, statusCode: e },
        m = { url: l, method: a, headers: n };
      (s(this._options, d, m), this._sanitizeOptions(this._options));
    }
    this._performRequest();
  };
  function uR(t) {
    var e = { maxRedirects: 21, maxBodyLength: 10485760 },
      r = {};
    return (
      Object.keys(t).forEach(function (n) {
        var s = n + ":",
          a = (r[s] = t[n]),
          i = (e[n] = Object.create(a));
        function o(l, u, d) {
          return (
            tJ(l)
              ? (l = Ug(l))
              : ka(l)
                ? (l = Ug(Zg(l)))
                : ((d = u), (u = pR(l)), (l = { protocol: s })),
            Ra(u) && ((d = u), (u = null)),
            (u = Object.assign(
              { maxRedirects: e.maxRedirects, maxBodyLength: e.maxBodyLength },
              l,
              u,
            )),
            (u.nativeProtocols = r),
            !ka(u.host) && !ka(u.hostname) && (u.hostname = "::1"),
            zg.equal(u.protocol, s, "protocol mismatch"),
            lR("options", u),
            new Tr(u, d)
          );
        }
        function c(l, u, d) {
          var m = i.request(l, u, d);
          return (m.end(), m);
        }
        Object.defineProperties(i, {
          request: { value: o, configurable: !0, enumerable: !0, writable: !0 },
          get: { value: c, configurable: !0, enumerable: !0, writable: !0 },
        });
      }),
      e
    );
  }
  function dR() {}
  function Zg(t) {
    var e;
    if (Bg) e = new $c(t);
    else if (((e = pR(Ac.parse(t))), !ka(e.protocol)))
      throw new jg({ input: t });
    return e;
  }
  function YK(t, e) {
    return Bg ? new $c(t, e) : Zg(Ac.resolve(e, t));
  }
  function pR(t) {
    if (/^\[/.test(t.hostname) && !/^\[[:0-9a-f]+\]$/i.test(t.hostname))
      throw new jg({ input: t.href || t });
    if (/^\[/.test(t.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(t.host))
      throw new jg({ input: t.href || t });
    return t;
  }
  function Ug(t, e) {
    var r = e || {};
    for (var n of GK) r[n] = t[n];
    return (
      r.hostname.startsWith("[") && (r.hostname = r.hostname.slice(1, -1)),
      r.port !== "" && (r.port = Number(r.port)),
      (r.path = r.search ? r.pathname + r.search : r.pathname),
      r
    );
  }
  function Mg(t, e) {
    var r;
    for (var n in e) t.test(n) && ((r = e[n]), delete e[n]);
    return r === null || typeof r > "u" ? void 0 : String(r).trim();
  }
  function Nc(t, e, r) {
    function n(s) {
      (Ra(Error.captureStackTrace) &&
        Error.captureStackTrace(this, this.constructor),
        Object.assign(this, s || {}),
        (this.code = t),
        (this.message = this.cause ? e + ": " + this.cause.message : e));
    }
    return (
      (n.prototype = new (r || Error)()),
      Object.defineProperties(n.prototype, {
        constructor: { value: n, enumerable: !1 },
        name: { value: "Error [" + t + "]", enumerable: !1 },
      }),
      n
    );
  }
  function Gg(t, e) {
    for (var r of Hg) t.removeListener(r, Vg[r]);
    (t.on("error", dR), t.destroy(e));
  }
  function QK(t, e) {
    zg(ka(t) && ka(e));
    var r = t.length - e.length - 1;
    return r > 0 && t[r] === "." && t.endsWith(e);
  }
  function ka(t) {
    return typeof t == "string" || t instanceof String;
  }
  function Ra(t) {
    return typeof t == "function";
  }
  function eJ(t) {
    return typeof t == "object" && "length" in t;
  }
  function tJ(t) {
    return $c && t instanceof $c;
  }
  Wg.exports = uR({ http: VK, https: ZK });
  Wg.exports.wrap = uR;
});
var VO = j((Vd, HO) => {
  (function (t, e) {
    typeof Vd == "object" && typeof HO < "u"
      ? e(Vd)
      : typeof define == "function" && define.amd
        ? define(["exports"], e)
        : e((t.URI = t.URI || {}));
  })(Vd, function (t) {
    "use strict";
    function e() {
      for (var N = arguments.length, k = Array(N), M = 0; M < N; M++)
        k[M] = arguments[M];
      if (k.length > 1) {
        k[0] = k[0].slice(0, -1);
        for (var V = k.length - 1, W = 1; W < V; ++W) k[W] = k[W].slice(1, -1);
        return ((k[V] = k[V].slice(1)), k.join(""));
      } else return k[0];
    }
    function r(N) {
      return "(?:" + N + ")";
    }
    function n(N) {
      return N === void 0
        ? "undefined"
        : N === null
          ? "null"
          : Object.prototype.toString
              .call(N)
              .split(" ")
              .pop()
              .split("]")
              .shift()
              .toLowerCase();
    }
    function s(N) {
      return N.toUpperCase();
    }
    function a(N) {
      return N != null
        ? N instanceof Array
          ? N
          : typeof N.length != "number" || N.split || N.setInterval || N.call
            ? [N]
            : Array.prototype.slice.call(N)
        : [];
    }
    function i(N, k) {
      var M = N;
      if (k) for (var V in k) M[V] = k[V];
      return M;
    }
    function o(N) {
      var k = "[A-Za-z]",
        M = "[\\x0D]",
        V = "[0-9]",
        W = "[\\x22]",
        ye = e(V, "[A-Fa-f]"),
        Ve = "[\\x0A]",
        tt = "[\\x20]",
        ct = r(
          r("%[EFef]" + ye + "%" + ye + ye + "%" + ye + ye) +
            "|" +
            r("%[89A-Fa-f]" + ye + "%" + ye + ye) +
            "|" +
            r("%" + ye + ye),
        ),
        qt = "[\\:\\/\\?\\#\\[\\]\\@]",
        Xe = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
        Rt = e(qt, Xe),
        zt = N
          ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]"
          : "[]",
        Tt = N ? "[\\uE000-\\uF8FF]" : "[]",
        nt = e(k, V, "[\\-\\.\\_\\~]", zt),
        Ot = r(k + e(k, V, "[\\+\\-\\.]") + "*"),
        mt = r(r(ct + "|" + e(nt, Xe, "[\\:]")) + "*"),
        Vs = r(
          r("25[0-5]") +
            "|" +
            r("2[0-4]" + V) +
            "|" +
            r("1" + V + V) +
            "|" +
            r("[1-9]" + V) +
            "|" +
            V,
        ),
        Ir = r(
          r("25[0-5]") +
            "|" +
            r("2[0-4]" + V) +
            "|" +
            r("1" + V + V) +
            "|" +
            r("0?[1-9]" + V) +
            "|0?0?" +
            V,
        ),
        Br = r(Ir + "\\." + Ir + "\\." + Ir + "\\." + Ir),
        yt = r(ye + "{1,4}"),
        $r = r(r(yt + "\\:" + yt) + "|" + Br),
        Hr = r(r(yt + "\\:") + "{6}" + $r),
        Tn = r("\\:\\:" + r(yt + "\\:") + "{5}" + $r),
        Zs = r(r(yt) + "?\\:\\:" + r(yt + "\\:") + "{4}" + $r),
        Un = r(
          r(r(yt + "\\:") + "{0,1}" + yt) +
            "?\\:\\:" +
            r(yt + "\\:") +
            "{3}" +
            $r,
        ),
        _o = r(
          r(r(yt + "\\:") + "{0,2}" + yt) +
            "?\\:\\:" +
            r(yt + "\\:") +
            "{2}" +
            $r,
        ),
        ol = r(r(r(yt + "\\:") + "{0,3}" + yt) + "?\\:\\:" + yt + "\\:" + $r),
        cl = r(r(r(yt + "\\:") + "{0,4}" + yt) + "?\\:\\:" + $r),
        Ba = r(r(r(yt + "\\:") + "{0,5}" + yt) + "?\\:\\:" + yt),
        Ha = r(r(r(yt + "\\:") + "{0,6}" + yt) + "?\\:\\:"),
        qn = r([Hr, Tn, Zs, Un, _o, ol, cl, Ba, Ha].join("|")),
        Va = r(r(nt + "|" + ct) + "+"),
        zp = r(qn + "\\%25" + Va),
        Gs = r(qn + r("\\%25|\\%(?!" + ye + "{2})") + Va),
        NN = r("[vV]" + ye + "+\\." + e(nt, Xe, "[\\:]") + "+"),
        DN = r("\\[" + r(Gs + "|" + qn + "|" + NN) + "\\]"),
        Yy = r(r(ct + "|" + e(nt, Xe)) + "*"),
        xo = r(DN + "|" + Br + "(?!" + Yy + ")|" + Yy),
        wo = r(V + "*"),
        Qy = r(r(mt + "@") + "?" + xo + r("\\:" + wo) + "?"),
        So = r(ct + "|" + e(nt, Xe, "[\\:\\@]")),
        LN = r(So + "*"),
        eb = r(So + "+"),
        MN = r(r(ct + "|" + e(nt, Xe, "[\\@]")) + "+"),
        zn = r(r("\\/" + LN) + "*"),
        Za = r("\\/" + r(eb + zn) + "?"),
        Bp = r(MN + zn),
        ll = r(eb + zn),
        Ga = "(?!" + So + ")",
        yee = r(zn + "|" + Za + "|" + Bp + "|" + ll + "|" + Ga),
        Wa = r(r(So + "|" + e("[\\/\\?]", Tt)) + "*"),
        Eo = r(r(So + "|[\\/\\?]") + "*"),
        tb = r(r("\\/\\/" + Qy + zn) + "|" + Za + "|" + ll + "|" + Ga),
        jN = r(Ot + "\\:" + tb + r("\\?" + Wa) + "?" + r("\\#" + Eo) + "?"),
        FN = r(r("\\/\\/" + Qy + zn) + "|" + Za + "|" + Bp + "|" + Ga),
        UN = r(FN + r("\\?" + Wa) + "?" + r("\\#" + Eo) + "?"),
        bee = r(jN + "|" + UN),
        _ee = r(Ot + "\\:" + tb + r("\\?" + Wa) + "?"),
        xee =
          "^(" +
          Ot +
          ")\\:" +
          r(
            r(
              "\\/\\/(" +
                r("(" + mt + ")@") +
                "?(" +
                xo +
                ")" +
                r("\\:(" + wo + ")") +
                "?)",
            ) +
              "?(" +
              zn +
              "|" +
              Za +
              "|" +
              ll +
              "|" +
              Ga +
              ")",
          ) +
          r("\\?(" + Wa + ")") +
          "?" +
          r("\\#(" + Eo + ")") +
          "?$",
        wee =
          "^(){0}" +
          r(
            r(
              "\\/\\/(" +
                r("(" + mt + ")@") +
                "?(" +
                xo +
                ")" +
                r("\\:(" + wo + ")") +
                "?)",
            ) +
              "?(" +
              zn +
              "|" +
              Za +
              "|" +
              Bp +
              "|" +
              Ga +
              ")",
          ) +
          r("\\?(" + Wa + ")") +
          "?" +
          r("\\#(" + Eo + ")") +
          "?$",
        See =
          "^(" +
          Ot +
          ")\\:" +
          r(
            r(
              "\\/\\/(" +
                r("(" + mt + ")@") +
                "?(" +
                xo +
                ")" +
                r("\\:(" + wo + ")") +
                "?)",
            ) +
              "?(" +
              zn +
              "|" +
              Za +
              "|" +
              ll +
              "|" +
              Ga +
              ")",
          ) +
          r("\\?(" + Wa + ")") +
          "?$",
        Eee = "^" + r("\\#(" + Eo + ")") + "?$",
        Tee =
          "^" +
          r("(" + mt + ")@") +
          "?(" +
          xo +
          ")" +
          r("\\:(" + wo + ")") +
          "?$";
      return {
        NOT_SCHEME: new RegExp(e("[^]", k, V, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(e("[^\\%\\:]", nt, Xe), "g"),
        NOT_HOST: new RegExp(e("[^\\%\\[\\]\\:]", nt, Xe), "g"),
        NOT_PATH: new RegExp(e("[^\\%\\/\\:\\@]", nt, Xe), "g"),
        NOT_PATH_NOSCHEME: new RegExp(e("[^\\%\\/\\@]", nt, Xe), "g"),
        NOT_QUERY: new RegExp(e("[^\\%]", nt, Xe, "[\\:\\@\\/\\?]", Tt), "g"),
        NOT_FRAGMENT: new RegExp(e("[^\\%]", nt, Xe, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(e("[^]", nt, Xe), "g"),
        UNRESERVED: new RegExp(nt, "g"),
        OTHER_CHARS: new RegExp(e("[^\\%]", nt, Rt), "g"),
        PCT_ENCODED: new RegExp(ct, "g"),
        IPV4ADDRESS: new RegExp("^(" + Br + ")$"),
        IPV6ADDRESS: new RegExp(
          "^\\[?(" +
            qn +
            ")" +
            r(r("\\%25|\\%(?!" + ye + "{2})") + "(" + Va + ")") +
            "?\\]?$",
        ),
      };
    }
    var c = o(!1),
      l = o(!0),
      u = (function () {
        function N(k, M) {
          var V = [],
            W = !0,
            ye = !1,
            Ve = void 0;
          try {
            for (
              var tt = k[Symbol.iterator](), ct;
              !(W = (ct = tt.next()).done) &&
              (V.push(ct.value), !(M && V.length === M));
              W = !0
            );
          } catch (qt) {
            ((ye = !0), (Ve = qt));
          } finally {
            try {
              !W && tt.return && tt.return();
            } finally {
              if (ye) throw Ve;
            }
          }
          return V;
        }
        return function (k, M) {
          if (Array.isArray(k)) return k;
          if (Symbol.iterator in Object(k)) return N(k, M);
          throw new TypeError(
            "Invalid attempt to destructure non-iterable instance",
          );
        };
      })(),
      d = function (N) {
        if (Array.isArray(N)) {
          for (var k = 0, M = Array(N.length); k < N.length; k++) M[k] = N[k];
          return M;
        } else return Array.from(N);
      },
      m = 2147483647,
      p = 36,
      f = 1,
      y = 26,
      h = 38,
      g = 700,
      _ = 72,
      v = 128,
      b = "-",
      x = /^xn--/,
      w = /[^\0-\x7E]/,
      S = /[\x2E\u3002\uFF0E\uFF61]/g,
      C = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input",
      },
      P = p - f,
      A = Math.floor,
      R = String.fromCharCode;
    function D(N) {
      throw new RangeError(C[N]);
    }
    function F(N, k) {
      for (var M = [], V = N.length; V--; ) M[V] = k(N[V]);
      return M;
    }
    function I(N, k) {
      var M = N.split("@"),
        V = "";
      (M.length > 1 && ((V = M[0] + "@"), (N = M[1])), (N = N.replace(S, ".")));
      var W = N.split("."),
        ye = F(W, k).join(".");
      return V + ye;
    }
    function K(N) {
      for (var k = [], M = 0, V = N.length; M < V; ) {
        var W = N.charCodeAt(M++);
        if (W >= 55296 && W <= 56319 && M < V) {
          var ye = N.charCodeAt(M++);
          (ye & 64512) == 56320
            ? k.push(((W & 1023) << 10) + (ye & 1023) + 65536)
            : (k.push(W), M--);
        } else k.push(W);
      }
      return k;
    }
    var ee = function (k) {
        return String.fromCodePoint.apply(String, d(k));
      },
      Y = function (k) {
        return k - 48 < 10
          ? k - 22
          : k - 65 < 26
            ? k - 65
            : k - 97 < 26
              ? k - 97
              : p;
      },
      Q = function (k, M) {
        return k + 22 + 75 * (k < 26) - ((M != 0) << 5);
      },
      ae = function (k, M, V) {
        var W = 0;
        for (k = V ? A(k / g) : k >> 1, k += A(k / M); k > (P * y) >> 1; W += p)
          k = A(k / P);
        return A(W + ((P + 1) * k) / (k + h));
      },
      B = function (k) {
        var M = [],
          V = k.length,
          W = 0,
          ye = v,
          Ve = _,
          tt = k.lastIndexOf(b);
        tt < 0 && (tt = 0);
        for (var ct = 0; ct < tt; ++ct)
          (k.charCodeAt(ct) >= 128 && D("not-basic"), M.push(k.charCodeAt(ct)));
        for (var qt = tt > 0 ? tt + 1 : 0; qt < V; ) {
          for (var Xe = W, Rt = 1, zt = p; ; zt += p) {
            qt >= V && D("invalid-input");
            var Tt = Y(k.charCodeAt(qt++));
            ((Tt >= p || Tt > A((m - W) / Rt)) && D("overflow"),
              (W += Tt * Rt));
            var nt = zt <= Ve ? f : zt >= Ve + y ? y : zt - Ve;
            if (Tt < nt) break;
            var Ot = p - nt;
            (Rt > A(m / Ot) && D("overflow"), (Rt *= Ot));
          }
          var mt = M.length + 1;
          ((Ve = ae(W - Xe, mt, Xe == 0)),
            A(W / mt) > m - ye && D("overflow"),
            (ye += A(W / mt)),
            (W %= mt),
            M.splice(W++, 0, ye));
        }
        return String.fromCodePoint.apply(String, M);
      },
      $ = function (k) {
        var M = [];
        k = K(k);
        var V = k.length,
          W = v,
          ye = 0,
          Ve = _,
          tt = !0,
          ct = !1,
          qt = void 0;
        try {
          for (
            var Xe = k[Symbol.iterator](), Rt;
            !(tt = (Rt = Xe.next()).done);
            tt = !0
          ) {
            var zt = Rt.value;
            zt < 128 && M.push(R(zt));
          }
        } catch (Gs) {
          ((ct = !0), (qt = Gs));
        } finally {
          try {
            !tt && Xe.return && Xe.return();
          } finally {
            if (ct) throw qt;
          }
        }
        var Tt = M.length,
          nt = Tt;
        for (Tt && M.push(b); nt < V; ) {
          var Ot = m,
            mt = !0,
            Vs = !1,
            Ir = void 0;
          try {
            for (
              var Br = k[Symbol.iterator](), yt;
              !(mt = (yt = Br.next()).done);
              mt = !0
            ) {
              var $r = yt.value;
              $r >= W && $r < Ot && (Ot = $r);
            }
          } catch (Gs) {
            ((Vs = !0), (Ir = Gs));
          } finally {
            try {
              !mt && Br.return && Br.return();
            } finally {
              if (Vs) throw Ir;
            }
          }
          var Hr = nt + 1;
          (Ot - W > A((m - ye) / Hr) && D("overflow"),
            (ye += (Ot - W) * Hr),
            (W = Ot));
          var Tn = !0,
            Zs = !1,
            Un = void 0;
          try {
            for (
              var _o = k[Symbol.iterator](), ol;
              !(Tn = (ol = _o.next()).done);
              Tn = !0
            ) {
              var cl = ol.value;
              if ((cl < W && ++ye > m && D("overflow"), cl == W)) {
                for (var Ba = ye, Ha = p; ; Ha += p) {
                  var qn = Ha <= Ve ? f : Ha >= Ve + y ? y : Ha - Ve;
                  if (Ba < qn) break;
                  var Va = Ba - qn,
                    zp = p - qn;
                  (M.push(R(Q(qn + (Va % zp), 0))), (Ba = A(Va / zp)));
                }
                (M.push(R(Q(Ba, 0))),
                  (Ve = ae(ye, Hr, nt == Tt)),
                  (ye = 0),
                  ++nt);
              }
            }
          } catch (Gs) {
            ((Zs = !0), (Un = Gs));
          } finally {
            try {
              !Tn && _o.return && _o.return();
            } finally {
              if (Zs) throw Un;
            }
          }
          (++ye, ++W);
        }
        return M.join("");
      },
      G = function (k) {
        return I(k, function (M) {
          return x.test(M) ? B(M.slice(4).toLowerCase()) : M;
        });
      },
      U = function (k) {
        return I(k, function (M) {
          return w.test(M) ? "xn--" + $(M) : M;
        });
      },
      T = {
        version: "2.1.0",
        ucs2: { decode: K, encode: ee },
        decode: B,
        encode: $,
        toASCII: U,
        toUnicode: G,
      },
      O = {};
    function H(N) {
      var k = N.charCodeAt(0),
        M = void 0;
      return (
        k < 16
          ? (M = "%0" + k.toString(16).toUpperCase())
          : k < 128
            ? (M = "%" + k.toString(16).toUpperCase())
            : k < 2048
              ? (M =
                  "%" +
                  ((k >> 6) | 192).toString(16).toUpperCase() +
                  "%" +
                  ((k & 63) | 128).toString(16).toUpperCase())
              : (M =
                  "%" +
                  ((k >> 12) | 224).toString(16).toUpperCase() +
                  "%" +
                  (((k >> 6) & 63) | 128).toString(16).toUpperCase() +
                  "%" +
                  ((k & 63) | 128).toString(16).toUpperCase()),
        M
      );
    }
    function ce(N) {
      for (var k = "", M = 0, V = N.length; M < V; ) {
        var W = parseInt(N.substr(M + 1, 2), 16);
        if (W < 128) ((k += String.fromCharCode(W)), (M += 3));
        else if (W >= 194 && W < 224) {
          if (V - M >= 6) {
            var ye = parseInt(N.substr(M + 4, 2), 16);
            k += String.fromCharCode(((W & 31) << 6) | (ye & 63));
          } else k += N.substr(M, 6);
          M += 6;
        } else if (W >= 224) {
          if (V - M >= 9) {
            var Ve = parseInt(N.substr(M + 4, 2), 16),
              tt = parseInt(N.substr(M + 7, 2), 16);
            k += String.fromCharCode(
              ((W & 15) << 12) | ((Ve & 63) << 6) | (tt & 63),
            );
          } else k += N.substr(M, 9);
          M += 9;
        } else ((k += N.substr(M, 3)), (M += 3));
      }
      return k;
    }
    function oe(N, k) {
      function M(V) {
        var W = ce(V);
        return W.match(k.UNRESERVED) ? W : V;
      }
      return (
        N.scheme &&
          (N.scheme = String(N.scheme)
            .replace(k.PCT_ENCODED, M)
            .toLowerCase()
            .replace(k.NOT_SCHEME, "")),
        N.userinfo !== void 0 &&
          (N.userinfo = String(N.userinfo)
            .replace(k.PCT_ENCODED, M)
            .replace(k.NOT_USERINFO, H)
            .replace(k.PCT_ENCODED, s)),
        N.host !== void 0 &&
          (N.host = String(N.host)
            .replace(k.PCT_ENCODED, M)
            .toLowerCase()
            .replace(k.NOT_HOST, H)
            .replace(k.PCT_ENCODED, s)),
        N.path !== void 0 &&
          (N.path = String(N.path)
            .replace(k.PCT_ENCODED, M)
            .replace(N.scheme ? k.NOT_PATH : k.NOT_PATH_NOSCHEME, H)
            .replace(k.PCT_ENCODED, s)),
        N.query !== void 0 &&
          (N.query = String(N.query)
            .replace(k.PCT_ENCODED, M)
            .replace(k.NOT_QUERY, H)
            .replace(k.PCT_ENCODED, s)),
        N.fragment !== void 0 &&
          (N.fragment = String(N.fragment)
            .replace(k.PCT_ENCODED, M)
            .replace(k.NOT_FRAGMENT, H)
            .replace(k.PCT_ENCODED, s)),
        N
      );
    }
    function Fe(N) {
      return N.replace(/^0*(.*)/, "$1") || "0";
    }
    function Ee(N, k) {
      var M = N.match(k.IPV4ADDRESS) || [],
        V = u(M, 2),
        W = V[1];
      return W ? W.split(".").map(Fe).join(".") : N;
    }
    function Me(N, k) {
      var M = N.match(k.IPV6ADDRESS) || [],
        V = u(M, 3),
        W = V[1],
        ye = V[2];
      if (W) {
        for (
          var Ve = W.toLowerCase().split("::").reverse(),
            tt = u(Ve, 2),
            ct = tt[0],
            qt = tt[1],
            Xe = qt ? qt.split(":").map(Fe) : [],
            Rt = ct.split(":").map(Fe),
            zt = k.IPV4ADDRESS.test(Rt[Rt.length - 1]),
            Tt = zt ? 7 : 8,
            nt = Rt.length - Tt,
            Ot = Array(Tt),
            mt = 0;
          mt < Tt;
          ++mt
        )
          Ot[mt] = Xe[mt] || Rt[nt + mt] || "";
        zt && (Ot[Tt - 1] = Ee(Ot[Tt - 1], k));
        var Vs = Ot.reduce(function (Hr, Tn, Zs) {
            if (!Tn || Tn === "0") {
              var Un = Hr[Hr.length - 1];
              Un && Un.index + Un.length === Zs
                ? Un.length++
                : Hr.push({ index: Zs, length: 1 });
            }
            return Hr;
          }, []),
          Ir = Vs.sort(function (Hr, Tn) {
            return Tn.length - Hr.length;
          })[0],
          Br = void 0;
        if (Ir && Ir.length > 1) {
          var yt = Ot.slice(0, Ir.index),
            $r = Ot.slice(Ir.index + Ir.length);
          Br = yt.join(":") + "::" + $r.join(":");
        } else Br = Ot.join(":");
        return (ye && (Br += "%" + ye), Br);
      } else return N;
    }
    var q =
        /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i,
      z = "".match(/(){0}/)[1] === void 0;
    function Z(N) {
      var k =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        M = {},
        V = k.iri !== !1 ? l : c;
      k.reference === "suffix" &&
        (N = (k.scheme ? k.scheme + ":" : "") + "//" + N);
      var W = N.match(q);
      if (W) {
        (z
          ? ((M.scheme = W[1]),
            (M.userinfo = W[3]),
            (M.host = W[4]),
            (M.port = parseInt(W[5], 10)),
            (M.path = W[6] || ""),
            (M.query = W[7]),
            (M.fragment = W[8]),
            isNaN(M.port) && (M.port = W[5]))
          : ((M.scheme = W[1] || void 0),
            (M.userinfo = N.indexOf("@") !== -1 ? W[3] : void 0),
            (M.host = N.indexOf("//") !== -1 ? W[4] : void 0),
            (M.port = parseInt(W[5], 10)),
            (M.path = W[6] || ""),
            (M.query = N.indexOf("?") !== -1 ? W[7] : void 0),
            (M.fragment = N.indexOf("#") !== -1 ? W[8] : void 0),
            isNaN(M.port) &&
              (M.port = N.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/)
                ? W[4]
                : void 0)),
          M.host && (M.host = Me(Ee(M.host, V), V)),
          M.scheme === void 0 &&
          M.userinfo === void 0 &&
          M.host === void 0 &&
          M.port === void 0 &&
          !M.path &&
          M.query === void 0
            ? (M.reference = "same-document")
            : M.scheme === void 0
              ? (M.reference = "relative")
              : M.fragment === void 0
                ? (M.reference = "absolute")
                : (M.reference = "uri"),
          k.reference &&
            k.reference !== "suffix" &&
            k.reference !== M.reference &&
            (M.error =
              M.error || "URI is not a " + k.reference + " reference."));
        var ye = O[(k.scheme || M.scheme || "").toLowerCase()];
        if (!k.unicodeSupport && (!ye || !ye.unicodeSupport)) {
          if (M.host && (k.domainHost || (ye && ye.domainHost)))
            try {
              M.host = T.toASCII(
                M.host.replace(V.PCT_ENCODED, ce).toLowerCase(),
              );
            } catch (Ve) {
              M.error =
                M.error ||
                "Host's domain name can not be converted to ASCII via punycode: " +
                  Ve;
            }
          oe(M, c);
        } else oe(M, V);
        ye && ye.parse && ye.parse(M, k);
      } else M.error = M.error || "URI can not be parsed.";
      return M;
    }
    function te(N, k) {
      var M = k.iri !== !1 ? l : c,
        V = [];
      return (
        N.userinfo !== void 0 && (V.push(N.userinfo), V.push("@")),
        N.host !== void 0 &&
          V.push(
            Me(Ee(String(N.host), M), M).replace(
              M.IPV6ADDRESS,
              function (W, ye, Ve) {
                return "[" + ye + (Ve ? "%25" + Ve : "") + "]";
              },
            ),
          ),
        (typeof N.port == "number" || typeof N.port == "string") &&
          (V.push(":"), V.push(String(N.port))),
        V.length ? V.join("") : void 0
      );
    }
    var fe = /^\.\.?\//,
      je = /^\/\.(\/|$)/,
      wt = /^\/\.\.(\/|$)/,
      dt = /^\/?(?:.|\n)*?(?=\/|$)/;
    function vt(N) {
      for (var k = []; N.length; )
        if (N.match(fe)) N = N.replace(fe, "");
        else if (N.match(je)) N = N.replace(je, "/");
        else if (N.match(wt)) ((N = N.replace(wt, "/")), k.pop());
        else if (N === "." || N === "..") N = "";
        else {
          var M = N.match(dt);
          if (M) {
            var V = M[0];
            ((N = N.slice(V.length)), k.push(V));
          } else throw new Error("Unexpected dot segment condition");
        }
      return k.join("");
    }
    function pt(N) {
      var k =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        M = k.iri ? l : c,
        V = [],
        W = O[(k.scheme || N.scheme || "").toLowerCase()];
      if (
        (W && W.serialize && W.serialize(N, k),
        N.host && !M.IPV6ADDRESS.test(N.host))
      ) {
        if (k.domainHost || (W && W.domainHost))
          try {
            N.host = k.iri
              ? T.toUnicode(N.host)
              : T.toASCII(N.host.replace(M.PCT_ENCODED, ce).toLowerCase());
          } catch (tt) {
            N.error =
              N.error ||
              "Host's domain name can not be converted to " +
                (k.iri ? "Unicode" : "ASCII") +
                " via punycode: " +
                tt;
          }
      }
      (oe(N, M),
        k.reference !== "suffix" &&
          N.scheme &&
          (V.push(N.scheme), V.push(":")));
      var ye = te(N, k);
      if (
        (ye !== void 0 &&
          (k.reference !== "suffix" && V.push("//"),
          V.push(ye),
          N.path && N.path.charAt(0) !== "/" && V.push("/")),
        N.path !== void 0)
      ) {
        var Ve = N.path;
        (!k.absolutePath && (!W || !W.absolutePath) && (Ve = vt(Ve)),
          ye === void 0 && (Ve = Ve.replace(/^\/\//, "/%2F")),
          V.push(Ve));
      }
      return (
        N.query !== void 0 && (V.push("?"), V.push(N.query)),
        N.fragment !== void 0 && (V.push("#"), V.push(N.fragment)),
        V.join("")
      );
    }
    function et(N, k) {
      var M =
          arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
        V = arguments[3],
        W = {};
      return (
        V || ((N = Z(pt(N, M), M)), (k = Z(pt(k, M), M))),
        (M = M || {}),
        !M.tolerant && k.scheme
          ? ((W.scheme = k.scheme),
            (W.userinfo = k.userinfo),
            (W.host = k.host),
            (W.port = k.port),
            (W.path = vt(k.path || "")),
            (W.query = k.query))
          : (k.userinfo !== void 0 || k.host !== void 0 || k.port !== void 0
              ? ((W.userinfo = k.userinfo),
                (W.host = k.host),
                (W.port = k.port),
                (W.path = vt(k.path || "")),
                (W.query = k.query))
              : (k.path
                  ? (k.path.charAt(0) === "/"
                      ? (W.path = vt(k.path))
                      : ((N.userinfo !== void 0 ||
                          N.host !== void 0 ||
                          N.port !== void 0) &&
                        !N.path
                          ? (W.path = "/" + k.path)
                          : N.path
                            ? (W.path =
                                N.path.slice(0, N.path.lastIndexOf("/") + 1) +
                                k.path)
                            : (W.path = k.path),
                        (W.path = vt(W.path))),
                    (W.query = k.query))
                  : ((W.path = N.path),
                    k.query !== void 0
                      ? (W.query = k.query)
                      : (W.query = N.query)),
                (W.userinfo = N.userinfo),
                (W.host = N.host),
                (W.port = N.port)),
            (W.scheme = N.scheme)),
        (W.fragment = k.fragment),
        W
      );
    }
    function er(N, k, M) {
      var V = i({ scheme: "null" }, M);
      return pt(et(Z(N, V), Z(k, V), V, !0), V);
    }
    function bt(N, k) {
      return (
        typeof N == "string"
          ? (N = pt(Z(N, k), k))
          : n(N) === "object" && (N = Z(pt(N, k), k)),
        N
      );
    }
    function hs(N, k, M) {
      return (
        typeof N == "string"
          ? (N = pt(Z(N, M), M))
          : n(N) === "object" && (N = pt(N, M)),
        typeof k == "string"
          ? (k = pt(Z(k, M), M))
          : n(k) === "object" && (k = pt(k, M)),
        N === k
      );
    }
    function Fn(N, k) {
      return N && N.toString().replace(!k || !k.iri ? c.ESCAPE : l.ESCAPE, H);
    }
    function lr(N, k) {
      return (
        N &&
        N.toString().replace(!k || !k.iri ? c.PCT_ENCODED : l.PCT_ENCODED, ce)
      );
    }
    var gs = {
        scheme: "http",
        domainHost: !0,
        parse: function (k, M) {
          return (
            k.host || (k.error = k.error || "HTTP URIs must have a host."),
            k
          );
        },
        serialize: function (k, M) {
          var V = String(k.scheme).toLowerCase() === "https";
          return (
            (k.port === (V ? 443 : 80) || k.port === "") && (k.port = void 0),
            k.path || (k.path = "/"),
            k
          );
        },
      },
      yo = {
        scheme: "https",
        domainHost: gs.domainHost,
        parse: gs.parse,
        serialize: gs.serialize,
      };
    function il(N) {
      return typeof N.secure == "boolean"
        ? N.secure
        : String(N.scheme).toLowerCase() === "wss";
    }
    var bo = {
        scheme: "ws",
        domainHost: !0,
        parse: function (k, M) {
          var V = k;
          return (
            (V.secure = il(V)),
            (V.resourceName = (V.path || "/") + (V.query ? "?" + V.query : "")),
            (V.path = void 0),
            (V.query = void 0),
            V
          );
        },
        serialize: function (k, M) {
          if (
            ((k.port === (il(k) ? 443 : 80) || k.port === "") &&
              (k.port = void 0),
            typeof k.secure == "boolean" &&
              ((k.scheme = k.secure ? "wss" : "ws"), (k.secure = void 0)),
            k.resourceName)
          ) {
            var V = k.resourceName.split("?"),
              W = u(V, 2),
              ye = W[0],
              Ve = W[1];
            ((k.path = ye && ye !== "/" ? ye : void 0),
              (k.query = Ve),
              (k.resourceName = void 0));
          }
          return ((k.fragment = void 0), k);
        },
      },
      Zy = {
        scheme: "wss",
        domainHost: bo.domainHost,
        parse: bo.parse,
        serialize: bo.serialize,
      },
      wN = {},
      SN = !0,
      Gy =
        "[A-Za-z0-9\\-\\.\\_\\~" +
        (SN
          ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF"
          : "") +
        "]",
      En = "[0-9A-Fa-f]",
      EN = r(
        r("%[EFef]" + En + "%" + En + En + "%" + En + En) +
          "|" +
          r("%[89A-Fa-f]" + En + "%" + En + En) +
          "|" +
          r("%" + En + En),
      ),
      TN = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]",
      CN = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]",
      PN = e(CN, '[\\"\\\\]'),
      kN = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]",
      RN = new RegExp(Gy, "g"),
      za = new RegExp(EN, "g"),
      ON = new RegExp(e("[^]", TN, "[\\.]", '[\\"]', PN), "g"),
      Wy = new RegExp(e("[^]", Gy, kN), "g"),
      IN = Wy;
    function qp(N) {
      var k = ce(N);
      return k.match(RN) ? k : N;
    }
    var Ky = {
        scheme: "mailto",
        parse: function (k, M) {
          var V = k,
            W = (V.to = V.path ? V.path.split(",") : []);
          if (((V.path = void 0), V.query)) {
            for (
              var ye = !1,
                Ve = {},
                tt = V.query.split("&"),
                ct = 0,
                qt = tt.length;
              ct < qt;
              ++ct
            ) {
              var Xe = tt[ct].split("=");
              switch (Xe[0]) {
                case "to":
                  for (
                    var Rt = Xe[1].split(","), zt = 0, Tt = Rt.length;
                    zt < Tt;
                    ++zt
                  )
                    W.push(Rt[zt]);
                  break;
                case "subject":
                  V.subject = lr(Xe[1], M);
                  break;
                case "body":
                  V.body = lr(Xe[1], M);
                  break;
                default:
                  ((ye = !0), (Ve[lr(Xe[0], M)] = lr(Xe[1], M)));
                  break;
              }
            }
            ye && (V.headers = Ve);
          }
          V.query = void 0;
          for (var nt = 0, Ot = W.length; nt < Ot; ++nt) {
            var mt = W[nt].split("@");
            if (((mt[0] = lr(mt[0])), M.unicodeSupport))
              mt[1] = lr(mt[1], M).toLowerCase();
            else
              try {
                mt[1] = T.toASCII(lr(mt[1], M).toLowerCase());
              } catch (Vs) {
                V.error =
                  V.error ||
                  "Email address's domain name can not be converted to ASCII via punycode: " +
                    Vs;
              }
            W[nt] = mt.join("@");
          }
          return V;
        },
        serialize: function (k, M) {
          var V = k,
            W = a(k.to);
          if (W) {
            for (var ye = 0, Ve = W.length; ye < Ve; ++ye) {
              var tt = String(W[ye]),
                ct = tt.lastIndexOf("@"),
                qt = tt
                  .slice(0, ct)
                  .replace(za, qp)
                  .replace(za, s)
                  .replace(ON, H),
                Xe = tt.slice(ct + 1);
              try {
                Xe = M.iri
                  ? T.toUnicode(Xe)
                  : T.toASCII(lr(Xe, M).toLowerCase());
              } catch (nt) {
                V.error =
                  V.error ||
                  "Email address's domain name can not be converted to " +
                    (M.iri ? "Unicode" : "ASCII") +
                    " via punycode: " +
                    nt;
              }
              W[ye] = qt + "@" + Xe;
            }
            V.path = W.join(",");
          }
          var Rt = (k.headers = k.headers || {});
          (k.subject && (Rt.subject = k.subject), k.body && (Rt.body = k.body));
          var zt = [];
          for (var Tt in Rt)
            Rt[Tt] !== wN[Tt] &&
              zt.push(
                Tt.replace(za, qp).replace(za, s).replace(Wy, H) +
                  "=" +
                  Rt[Tt].replace(za, qp).replace(za, s).replace(IN, H),
              );
          return (zt.length && (V.query = zt.join("&")), V);
        },
      },
      $N = /^([^\:]+)\:(.*)/,
      Jy = {
        scheme: "urn",
        parse: function (k, M) {
          var V = k.path && k.path.match($N),
            W = k;
          if (V) {
            var ye = M.scheme || W.scheme || "urn",
              Ve = V[1].toLowerCase(),
              tt = V[2],
              ct = ye + ":" + (M.nid || Ve),
              qt = O[ct];
            ((W.nid = Ve),
              (W.nss = tt),
              (W.path = void 0),
              qt && (W = qt.parse(W, M)));
          } else W.error = W.error || "URN can not be parsed.";
          return W;
        },
        serialize: function (k, M) {
          var V = M.scheme || k.scheme || "urn",
            W = k.nid,
            ye = V + ":" + (M.nid || W),
            Ve = O[ye];
          Ve && (k = Ve.serialize(k, M));
          var tt = k,
            ct = k.nss;
          return ((tt.path = (W || M.nid) + ":" + ct), tt);
        },
      },
      AN = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/,
      Xy = {
        scheme: "urn:uuid",
        parse: function (k, M) {
          var V = k;
          return (
            (V.uuid = V.nss),
            (V.nss = void 0),
            !M.tolerant &&
              (!V.uuid || !V.uuid.match(AN)) &&
              (V.error = V.error || "UUID is not valid."),
            V
          );
        },
        serialize: function (k, M) {
          var V = k;
          return ((V.nss = (k.uuid || "").toLowerCase()), V);
        },
      };
    ((O[gs.scheme] = gs),
      (O[yo.scheme] = yo),
      (O[bo.scheme] = bo),
      (O[Zy.scheme] = Zy),
      (O[Ky.scheme] = Ky),
      (O[Jy.scheme] = Jy),
      (O[Xy.scheme] = Xy),
      (t.SCHEMES = O),
      (t.pctEncChar = H),
      (t.pctDecChars = ce),
      (t.parse = Z),
      (t.removeDotSegments = vt),
      (t.serialize = pt),
      (t.resolveComponents = et),
      (t.resolve = er),
      (t.normalize = bt),
      (t.equal = hs),
      (t.escapeComponent = Fn),
      (t.unescapeComponent = lr),
      Object.defineProperty(t, "__esModule", { value: !0 }));
  });
});
var Zd = j((vfe, ZO) => {
  "use strict";
  ZO.exports = function t(e, r) {
    if (e === r) return !0;
    if (e && r && typeof e == "object" && typeof r == "object") {
      if (e.constructor !== r.constructor) return !1;
      var n, s, a;
      if (Array.isArray(e)) {
        if (((n = e.length), n != r.length)) return !1;
        for (s = n; s-- !== 0; ) if (!t(e[s], r[s])) return !1;
        return !0;
      }
      if (e.constructor === RegExp)
        return e.source === r.source && e.flags === r.flags;
      if (e.valueOf !== Object.prototype.valueOf)
        return e.valueOf() === r.valueOf();
      if (e.toString !== Object.prototype.toString)
        return e.toString() === r.toString();
      if (((a = Object.keys(e)), (n = a.length), n !== Object.keys(r).length))
        return !1;
      for (s = n; s-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(r, a[s])) return !1;
      for (s = n; s-- !== 0; ) {
        var i = a[s];
        if (!t(e[i], r[i])) return !1;
      }
      return !0;
    }
    return e !== e && r !== r;
  };
});
var WO = j((yfe, GO) => {
  "use strict";
  GO.exports = function (e) {
    for (var r = 0, n = e.length, s = 0, a; s < n; )
      (r++,
        (a = e.charCodeAt(s++)),
        a >= 55296 &&
          a <= 56319 &&
          s < n &&
          ((a = e.charCodeAt(s)), (a & 64512) == 56320 && s++));
    return r;
  };
});
var Da = j((bfe, XO) => {
  "use strict";
  XO.exports = {
    copy: O7,
    checkDataType: Nv,
    checkDataTypes: I7,
    coerceToTypes: $7,
    toHash: Lv,
    getProperty: Mv,
    escapeQuotes: jv,
    equal: Zd(),
    ucs2length: WO(),
    varOccurences: D7,
    varReplace: L7,
    schemaHasRules: M7,
    schemaHasRulesExcept: j7,
    schemaUnknownRules: F7,
    toQuotedString: Dv,
    getPathExpr: U7,
    getPath: q7,
    getData: H7,
    unescapeFragment: V7,
    unescapeJsonPointer: Uv,
    escapeFragment: Z7,
    escapeJsonPointer: Fv,
  };
  function O7(t, e) {
    e = e || {};
    for (var r in t) e[r] = t[r];
    return e;
  }
  function Nv(t, e, r, n) {
    var s = n ? " !== " : " === ",
      a = n ? " || " : " && ",
      i = n ? "!" : "",
      o = n ? "" : "!";
    switch (t) {
      case "null":
        return e + s + "null";
      case "array":
        return i + "Array.isArray(" + e + ")";
      case "object":
        return (
          "(" +
          i +
          e +
          a +
          "typeof " +
          e +
          s +
          '"object"' +
          a +
          o +
          "Array.isArray(" +
          e +
          "))"
        );
      case "integer":
        return (
          "(typeof " +
          e +
          s +
          '"number"' +
          a +
          o +
          "(" +
          e +
          " % 1)" +
          a +
          e +
          s +
          e +
          (r ? a + i + "isFinite(" + e + ")" : "") +
          ")"
        );
      case "number":
        return (
          "(typeof " +
          e +
          s +
          '"' +
          t +
          '"' +
          (r ? a + i + "isFinite(" + e + ")" : "") +
          ")"
        );
      default:
        return "typeof " + e + s + '"' + t + '"';
    }
  }
  function I7(t, e, r) {
    switch (t.length) {
      case 1:
        return Nv(t[0], e, r, !0);
      default:
        var n = "",
          s = Lv(t);
        (s.array &&
          s.object &&
          ((n = s.null ? "(" : "(!" + e + " || "),
          (n += "typeof " + e + ' !== "object")'),
          delete s.null,
          delete s.array,
          delete s.object),
          s.number && delete s.integer);
        for (var a in s) n += (n ? " && " : "") + Nv(a, e, r, !0);
        return n;
    }
  }
  var KO = Lv(["string", "number", "integer", "boolean", "null"]);
  function $7(t, e) {
    if (Array.isArray(e)) {
      for (var r = [], n = 0; n < e.length; n++) {
        var s = e[n];
        (KO[s] || (t === "array" && s === "array")) && (r[r.length] = s);
      }
      if (r.length) return r;
    } else {
      if (KO[e]) return [e];
      if (t === "array" && e === "array") return ["array"];
    }
  }
  function Lv(t) {
    for (var e = {}, r = 0; r < t.length; r++) e[t[r]] = !0;
    return e;
  }
  var A7 = /^[a-z$_][a-z$_0-9]*$/i,
    N7 = /'|\\/g;
  function Mv(t) {
    return typeof t == "number"
      ? "[" + t + "]"
      : A7.test(t)
        ? "." + t
        : "['" + jv(t) + "']";
  }
  function jv(t) {
    return t
      .replace(N7, "\\$&")
      .replace(/\n/g, "\\n")
      .replace(/\r/g, "\\r")
      .replace(/\f/g, "\\f")
      .replace(/\t/g, "\\t");
  }
  function D7(t, e) {
    e += "[^0-9]";
    var r = t.match(new RegExp(e, "g"));
    return r ? r.length : 0;
  }
  function L7(t, e, r) {
    return (
      (e += "([^0-9])"),
      (r = r.replace(/\$/g, "$$$$")),
      t.replace(new RegExp(e, "g"), r + "$1")
    );
  }
  function M7(t, e) {
    if (typeof t == "boolean") return !t;
    for (var r in t) if (e[r]) return !0;
  }
  function j7(t, e, r) {
    if (typeof t == "boolean") return !t && r != "not";
    for (var n in t) if (n != r && e[n]) return !0;
  }
  function F7(t, e) {
    if (typeof t != "boolean") {
      for (var r in t) if (!e[r]) return r;
    }
  }
  function Dv(t) {
    return "'" + jv(t) + "'";
  }
  function U7(t, e, r, n) {
    var s = r
      ? "'/' + " + e + (n ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')")
      : n
        ? "'[' + " + e + " + ']'"
        : "'[\\'' + " + e + " + '\\']'";
    return JO(t, s);
  }
  function q7(t, e, r) {
    var n = Dv(r ? "/" + Fv(e) : Mv(e));
    return JO(t, n);
  }
  var z7 = /^\/(?:[^~]|~0|~1)*$/,
    B7 = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function H7(t, e, r) {
    var n, s, a, i;
    if (t === "") return "rootData";
    if (t[0] == "/") {
      if (!z7.test(t)) throw new Error("Invalid JSON-pointer: " + t);
      ((s = t), (a = "rootData"));
    } else {
      if (((i = t.match(B7)), !i))
        throw new Error("Invalid JSON-pointer: " + t);
      if (((n = +i[1]), (s = i[2]), s == "#")) {
        if (n >= e)
          throw new Error(
            "Cannot access property/index " +
              n +
              " levels up, current level is " +
              e,
          );
        return r[e - n];
      }
      if (n > e)
        throw new Error(
          "Cannot access data " + n + " levels up, current level is " + e,
        );
      if (((a = "data" + (e - n || "")), !s)) return a;
    }
    for (var o = a, c = s.split("/"), l = 0; l < c.length; l++) {
      var u = c[l];
      u && ((a += Mv(Uv(u))), (o += " && " + a));
    }
    return o;
  }
  function JO(t, e) {
    return t == '""' ? e : (t + " + " + e).replace(/([^\\])' \+ '/g, "$1");
  }
  function V7(t) {
    return Uv(decodeURIComponent(t));
  }
  function Z7(t) {
    return encodeURIComponent(Fv(t));
  }
  function Fv(t) {
    return t.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function Uv(t) {
    return t.replace(/~1/g, "/").replace(/~0/g, "~");
  }
});
var qv = j((_fe, YO) => {
  "use strict";
  var G7 = Da();
  YO.exports = W7;
  function W7(t) {
    G7.copy(t, this);
  }
});
var eI = j((xfe, QO) => {
  "use strict";
  var js = (QO.exports = function (t, e, r) {
    (typeof e == "function" && ((r = e), (e = {})), (r = e.cb || r));
    var n = typeof r == "function" ? r : r.pre || function () {},
      s = r.post || function () {};
    Gd(e, n, s, t, "", t);
  });
  js.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0,
  };
  js.arrayKeywords = { items: !0, allOf: !0, anyOf: !0, oneOf: !0 };
  js.propsKeywords = {
    definitions: !0,
    properties: !0,
    patternProperties: !0,
    dependencies: !0,
  };
  js.skipKeywords = {
    default: !0,
    enum: !0,
    const: !0,
    required: !0,
    maximum: !0,
    minimum: !0,
    exclusiveMaximum: !0,
    exclusiveMinimum: !0,
    multipleOf: !0,
    maxLength: !0,
    minLength: !0,
    pattern: !0,
    format: !0,
    maxItems: !0,
    minItems: !0,
    uniqueItems: !0,
    maxProperties: !0,
    minProperties: !0,
  };
  function Gd(t, e, r, n, s, a, i, o, c, l) {
    if (n && typeof n == "object" && !Array.isArray(n)) {
      e(n, s, a, i, o, c, l);
      for (var u in n) {
        var d = n[u];
        if (Array.isArray(d)) {
          if (u in js.arrayKeywords)
            for (var m = 0; m < d.length; m++)
              Gd(t, e, r, d[m], s + "/" + u + "/" + m, a, s, u, n, m);
        } else if (u in js.propsKeywords) {
          if (d && typeof d == "object")
            for (var p in d)
              Gd(t, e, r, d[p], s + "/" + u + "/" + K7(p), a, s, u, n, p);
        } else
          (u in js.keywords || (t.allKeys && !(u in js.skipKeywords))) &&
            Gd(t, e, r, d, s + "/" + u, a, s, u, n);
      }
      r(n, s, a, i, o, c, l);
    }
  }
  function K7(t) {
    return t.replace(/~/g, "~0").replace(/\//g, "~1");
  }
});
var Qd = j((wfe, sI) => {
  "use strict";
  var Hc = VO(),
    tI = Zd(),
    Xd = Da(),
    Wd = qv(),
    J7 = eI();
  sI.exports = Us;
  Us.normalizeId = Fs;
  Us.fullPath = Kd;
  Us.url = Jd;
  Us.ids = tX;
  Us.inlineRef = zv;
  Us.schema = Yd;
  function Us(t, e, r) {
    var n = this._refs[r];
    if (typeof n == "string")
      if (this._refs[n]) n = this._refs[n];
      else return Us.call(this, t, e, n);
    if (((n = n || this._schemas[r]), n instanceof Wd))
      return zv(n.schema, this._opts.inlineRefs)
        ? n.schema
        : n.validate || this._compile(n);
    var s = Yd.call(this, e, r),
      a,
      i,
      o;
    return (
      s && ((a = s.schema), (e = s.root), (o = s.baseId)),
      a instanceof Wd
        ? (i = a.validate || t.call(this, a.schema, e, void 0, o))
        : a !== void 0 &&
          (i = zv(a, this._opts.inlineRefs)
            ? a
            : t.call(this, a, e, void 0, o)),
      i
    );
  }
  function Yd(t, e) {
    var r = Hc.parse(e),
      n = nI(r),
      s = Kd(this._getId(t.schema));
    if (Object.keys(t.schema).length === 0 || n !== s) {
      var a = Fs(n),
        i = this._refs[a];
      if (typeof i == "string") return X7.call(this, t, i, r);
      if (i instanceof Wd) (i.validate || this._compile(i), (t = i));
      else if (((i = this._schemas[a]), i instanceof Wd)) {
        if ((i.validate || this._compile(i), a == Fs(e)))
          return { schema: i, root: t, baseId: s };
        t = i;
      } else return;
      if (!t.schema) return;
      s = Kd(this._getId(t.schema));
    }
    return rI.call(this, r, s, t.schema, t);
  }
  function X7(t, e, r) {
    var n = Yd.call(this, t, e);
    if (n) {
      var s = n.schema,
        a = n.baseId;
      t = n.root;
      var i = this._getId(s);
      return (i && (a = Jd(a, i)), rI.call(this, r, a, s, t));
    }
  }
  var Y7 = Xd.toHash([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions",
  ]);
  function rI(t, e, r, n) {
    if (((t.fragment = t.fragment || ""), t.fragment.slice(0, 1) == "/")) {
      for (var s = t.fragment.split("/"), a = 1; a < s.length; a++) {
        var i = s[a];
        if (i) {
          if (((i = Xd.unescapeFragment(i)), (r = r[i]), r === void 0)) break;
          var o;
          if (!Y7[i] && ((o = this._getId(r)), o && (e = Jd(e, o)), r.$ref)) {
            var c = Jd(e, r.$ref),
              l = Yd.call(this, n, c);
            l && ((r = l.schema), (n = l.root), (e = l.baseId));
          }
        }
      }
      if (r !== void 0 && r !== n.schema)
        return { schema: r, root: n, baseId: e };
    }
  }
  var Q7 = Xd.toHash([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
  ]);
  function zv(t, e) {
    if (e === !1) return !1;
    if (e === void 0 || e === !0) return Bv(t);
    if (e) return Hv(t) <= e;
  }
  function Bv(t) {
    var e;
    if (Array.isArray(t)) {
      for (var r = 0; r < t.length; r++)
        if (((e = t[r]), typeof e == "object" && !Bv(e))) return !1;
    } else
      for (var n in t)
        if (n == "$ref" || ((e = t[n]), typeof e == "object" && !Bv(e)))
          return !1;
    return !0;
  }
  function Hv(t) {
    var e = 0,
      r;
    if (Array.isArray(t)) {
      for (var n = 0; n < t.length; n++)
        if (((r = t[n]), typeof r == "object" && (e += Hv(r)), e == 1 / 0))
          return 1 / 0;
    } else
      for (var s in t) {
        if (s == "$ref") return 1 / 0;
        if (Q7[s]) e++;
        else if (
          ((r = t[s]), typeof r == "object" && (e += Hv(r) + 1), e == 1 / 0)
        )
          return 1 / 0;
      }
    return e;
  }
  function Kd(t, e) {
    e !== !1 && (t = Fs(t));
    var r = Hc.parse(t);
    return nI(r);
  }
  function nI(t) {
    return Hc.serialize(t).split("#")[0] + "#";
  }
  var eX = /#\/?$/;
  function Fs(t) {
    return t ? t.replace(eX, "") : "";
  }
  function Jd(t, e) {
    return ((e = Fs(e)), Hc.resolve(t, e));
  }
  function tX(t) {
    var e = Fs(this._getId(t)),
      r = { "": e },
      n = { "": Kd(e, !1) },
      s = {},
      a = this;
    return (
      J7(t, { allKeys: !0 }, function (i, o, c, l, u, d, m) {
        if (o !== "") {
          var p = a._getId(i),
            f = r[l],
            y = n[l] + "/" + u;
          if (
            (m !== void 0 &&
              (y += "/" + (typeof m == "number" ? m : Xd.escapeFragment(m))),
            typeof p == "string")
          ) {
            p = f = Fs(f ? Hc.resolve(f, p) : p);
            var h = a._refs[p];
            if ((typeof h == "string" && (h = a._refs[h]), h && h.schema)) {
              if (!tI(i, h.schema))
                throw new Error(
                  'id "' + p + '" resolves to more than one schema',
                );
            } else if (p != Fs(y))
              if (p[0] == "#") {
                if (s[p] && !tI(i, s[p]))
                  throw new Error(
                    'id "' + p + '" resolves to more than one schema',
                  );
                s[p] = i;
              } else a._refs[p] = y;
          }
          ((r[o] = f), (n[o] = y));
        }
      }),
      s
    );
  }
});
var ep = j((Sfe, iI) => {
  "use strict";
  var Vv = Qd();
  iI.exports = { Validation: aI(rX), MissingRef: aI(Zv) };
  function rX(t) {
    ((this.message = "validation failed"),
      (this.errors = t),
      (this.ajv = this.validation = !0));
  }
  Zv.message = function (t, e) {
    return "can't resolve reference " + e + " from id " + t;
  };
  function Zv(t, e, r) {
    ((this.message = r || Zv.message(t, e)),
      (this.missingRef = Vv.url(t, e)),
      (this.missingSchema = Vv.normalizeId(Vv.fullPath(this.missingRef))));
  }
  function aI(t) {
    return (
      (t.prototype = Object.create(Error.prototype)),
      (t.prototype.constructor = t),
      t
    );
  }
});
var Gv = j((Efe, oI) => {
  "use strict";
  oI.exports = function (t, e) {
    (e || (e = {}), typeof e == "function" && (e = { cmp: e }));
    var r = typeof e.cycles == "boolean" ? e.cycles : !1,
      n =
        e.cmp &&
        (function (a) {
          return function (i) {
            return function (o, c) {
              var l = { key: o, value: i[o] },
                u = { key: c, value: i[c] };
              return a(l, u);
            };
          };
        })(e.cmp),
      s = [];
    return (function a(i) {
      if (
        (i && i.toJSON && typeof i.toJSON == "function" && (i = i.toJSON()),
        i !== void 0)
      ) {
        if (typeof i == "number") return isFinite(i) ? "" + i : "null";
        if (typeof i != "object") return JSON.stringify(i);
        var o, c;
        if (Array.isArray(i)) {
          for (c = "[", o = 0; o < i.length; o++)
            (o && (c += ","), (c += a(i[o]) || "null"));
          return c + "]";
        }
        if (i === null) return "null";
        if (s.indexOf(i) !== -1) {
          if (r) return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var l = s.push(i) - 1,
          u = Object.keys(i).sort(n && n(i));
        for (c = "", o = 0; o < u.length; o++) {
          var d = u[o],
            m = a(i[d]);
          m && (c && (c += ","), (c += JSON.stringify(d) + ":" + m));
        }
        return (s.splice(l, 1), "{" + c + "}");
      }
    })(t);
  };
});
var Wv = j((Tfe, cI) => {
  "use strict";
  cI.exports = function (e, r, n) {
    var s = "",
      a = e.schema.$async === !0,
      i = e.util.schemaHasRulesExcept(e.schema, e.RULES.all, "$ref"),
      o = e.self._getId(e.schema);
    if (e.opts.strictKeywords) {
      var c = e.util.schemaUnknownRules(e.schema, e.RULES.keywords);
      if (c) {
        var l = "unknown keyword: " + c;
        if (e.opts.strictKeywords === "log") e.logger.warn(l);
        else throw new Error(l);
      }
    }
    if (
      (e.isTop &&
        ((s += " var validate = "),
        a && ((e.async = !0), (s += "async ")),
        (s +=
          "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; "),
        o &&
          (e.opts.sourceCode || e.opts.processCode) &&
          (s += " " + ("/*# sourceURL=" + o + " */") + " ")),
      typeof e.schema == "boolean" || !(i || e.schema.$ref))
    ) {
      var r = "false schema",
        u = e.level,
        d = e.dataLevel,
        m = e.schema[r],
        p = e.schemaPath + e.util.getProperty(r),
        f = e.errSchemaPath + "/" + r,
        x = !e.opts.allErrors,
        C,
        y = "data" + (d || ""),
        b = "valid" + u;
      if (e.schema === !1) {
        e.isTop ? (x = !0) : (s += " var " + b + " = false; ");
        var h = h || [];
        (h.push(s),
          (s = ""),
          e.createErrors !== !1
            ? ((s +=
                " { keyword: '" +
                (C || "false schema") +
                "' , dataPath: (dataPath || '') + " +
                e.errorPath +
                " , schemaPath: " +
                e.util.toQuotedString(f) +
                " , params: {} "),
              e.opts.messages !== !1 &&
                (s += " , message: 'boolean schema is false' "),
              e.opts.verbose &&
                (s +=
                  " , schema: false , parentSchema: validate.schema" +
                  e.schemaPath +
                  " , data: " +
                  y +
                  " "),
              (s += " } "))
            : (s += " {} "));
        var g = s;
        ((s = h.pop()),
          !e.compositeRule && x
            ? e.async
              ? (s += " throw new ValidationError([" + g + "]); ")
              : (s += " validate.errors = [" + g + "]; return false; ")
            : (s +=
                " var err = " +
                g +
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "));
      } else
        e.isTop
          ? a
            ? (s += " return data; ")
            : (s += " validate.errors = null; return true; ")
          : (s += " var " + b + " = true; ");
      return (e.isTop && (s += " }; return validate; "), s);
    }
    if (e.isTop) {
      var _ = e.isTop,
        u = (e.level = 0),
        d = (e.dataLevel = 0),
        y = "data";
      if (
        ((e.rootId = e.resolve.fullPath(e.self._getId(e.root.schema))),
        (e.baseId = e.baseId || e.rootId),
        delete e.isTop,
        (e.dataPathArr = [""]),
        e.schema.default !== void 0 &&
          e.opts.useDefaults &&
          e.opts.strictDefaults)
      ) {
        var v = "default is ignored in the schema root";
        if (e.opts.strictDefaults === "log") e.logger.warn(v);
        else throw new Error(v);
      }
      ((s += " var vErrors = null; "),
        (s += " var errors = 0;     "),
        (s += " if (rootData === undefined) rootData = data; "));
    } else {
      var u = e.level,
        d = e.dataLevel,
        y = "data" + (d || "");
      if ((o && (e.baseId = e.resolve.url(e.baseId, o)), a && !e.async))
        throw new Error("async schema in sync schema");
      s += " var errs_" + u + " = errors;";
    }
    var b = "valid" + u,
      x = !e.opts.allErrors,
      w = "",
      S = "",
      C,
      P = e.schema.type,
      A = Array.isArray(P);
    if (
      (P &&
        e.opts.nullable &&
        e.schema.nullable === !0 &&
        (A
          ? P.indexOf("null") == -1 && (P = P.concat("null"))
          : P != "null" && ((P = [P, "null"]), (A = !0))),
      A && P.length == 1 && ((P = P[0]), (A = !1)),
      e.schema.$ref && i)
    ) {
      if (e.opts.extendRefs == "fail")
        throw new Error(
          '$ref: validation keywords used in schema at path "' +
            e.errSchemaPath +
            '" (see option extendRefs)',
        );
      e.opts.extendRefs !== !0 &&
        ((i = !1),
        e.logger.warn(
          '$ref: keywords ignored in schema at path "' + e.errSchemaPath + '"',
        ));
    }
    if (
      (e.schema.$comment &&
        e.opts.$comment &&
        (s += " " + e.RULES.all.$comment.code(e, "$comment")),
      P)
    ) {
      if (e.opts.coerceTypes)
        var R = e.util.coerceToTypes(e.opts.coerceTypes, P);
      var D = e.RULES.types[P];
      if (R || A || D === !0 || (D && !dt(D))) {
        var p = e.schemaPath + ".type",
          f = e.errSchemaPath + "/type",
          p = e.schemaPath + ".type",
          f = e.errSchemaPath + "/type",
          F = A ? "checkDataTypes" : "checkDataType";
        if (
          ((s += " if (" + e.util[F](P, y, e.opts.strictNumbers, !0) + ") { "),
          R)
        ) {
          var I = "dataType" + u,
            K = "coerced" + u;
          ((s +=
            " var " + I + " = typeof " + y + "; var " + K + " = undefined; "),
            e.opts.coerceTypes == "array" &&
              (s +=
                " if (" +
                I +
                " == 'object' && Array.isArray(" +
                y +
                ") && " +
                y +
                ".length == 1) { " +
                y +
                " = " +
                y +
                "[0]; " +
                I +
                " = typeof " +
                y +
                "; if (" +
                e.util.checkDataType(e.schema.type, y, e.opts.strictNumbers) +
                ") " +
                K +
                " = " +
                y +
                "; } "),
            (s += " if (" + K + " !== undefined) ; "));
          var ee = R;
          if (ee)
            for (var Y, Q = -1, ae = ee.length - 1; Q < ae; )
              ((Y = ee[(Q += 1)]),
                Y == "string"
                  ? (s +=
                      " else if (" +
                      I +
                      " == 'number' || " +
                      I +
                      " == 'boolean') " +
                      K +
                      " = '' + " +
                      y +
                      "; else if (" +
                      y +
                      " === null) " +
                      K +
                      " = ''; ")
                  : Y == "number" || Y == "integer"
                    ? ((s +=
                        " else if (" +
                        I +
                        " == 'boolean' || " +
                        y +
                        " === null || (" +
                        I +
                        " == 'string' && " +
                        y +
                        " && " +
                        y +
                        " == +" +
                        y +
                        " "),
                      Y == "integer" && (s += " && !(" + y + " % 1)"),
                      (s += ")) " + K + " = +" + y + "; "))
                    : Y == "boolean"
                      ? (s +=
                          " else if (" +
                          y +
                          " === 'false' || " +
                          y +
                          " === 0 || " +
                          y +
                          " === null) " +
                          K +
                          " = false; else if (" +
                          y +
                          " === 'true' || " +
                          y +
                          " === 1) " +
                          K +
                          " = true; ")
                      : Y == "null"
                        ? (s +=
                            " else if (" +
                            y +
                            " === '' || " +
                            y +
                            " === 0 || " +
                            y +
                            " === false) " +
                            K +
                            " = null; ")
                        : e.opts.coerceTypes == "array" &&
                          Y == "array" &&
                          (s +=
                            " else if (" +
                            I +
                            " == 'string' || " +
                            I +
                            " == 'number' || " +
                            I +
                            " == 'boolean' || " +
                            y +
                            " == null) " +
                            K +
                            " = [" +
                            y +
                            "]; "));
          s += " else {   ";
          var h = h || [];
          (h.push(s),
            (s = ""),
            e.createErrors !== !1
              ? ((s +=
                  " { keyword: '" +
                  (C || "type") +
                  "' , dataPath: (dataPath || '') + " +
                  e.errorPath +
                  " , schemaPath: " +
                  e.util.toQuotedString(f) +
                  " , params: { type: '"),
                A ? (s += "" + P.join(",")) : (s += "" + P),
                (s += "' } "),
                e.opts.messages !== !1 &&
                  ((s += " , message: 'should be "),
                  A ? (s += "" + P.join(",")) : (s += "" + P),
                  (s += "' ")),
                e.opts.verbose &&
                  (s +=
                    " , schema: validate.schema" +
                    p +
                    " , parentSchema: validate.schema" +
                    e.schemaPath +
                    " , data: " +
                    y +
                    " "),
                (s += " } "))
              : (s += " {} "));
          var g = s;
          ((s = h.pop()),
            !e.compositeRule && x
              ? e.async
                ? (s += " throw new ValidationError([" + g + "]); ")
                : (s += " validate.errors = [" + g + "]; return false; ")
              : (s +=
                  " var err = " +
                  g +
                  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
            (s += " } if (" + K + " !== undefined) {  "));
          var B = d ? "data" + (d - 1 || "") : "parentData",
            $ = d ? e.dataPathArr[d] : "parentDataProperty";
          ((s += " " + y + " = " + K + "; "),
            d || (s += "if (" + B + " !== undefined)"),
            (s += " " + B + "[" + $ + "] = " + K + "; } "));
        } else {
          var h = h || [];
          (h.push(s),
            (s = ""),
            e.createErrors !== !1
              ? ((s +=
                  " { keyword: '" +
                  (C || "type") +
                  "' , dataPath: (dataPath || '') + " +
                  e.errorPath +
                  " , schemaPath: " +
                  e.util.toQuotedString(f) +
                  " , params: { type: '"),
                A ? (s += "" + P.join(",")) : (s += "" + P),
                (s += "' } "),
                e.opts.messages !== !1 &&
                  ((s += " , message: 'should be "),
                  A ? (s += "" + P.join(",")) : (s += "" + P),
                  (s += "' ")),
                e.opts.verbose &&
                  (s +=
                    " , schema: validate.schema" +
                    p +
                    " , parentSchema: validate.schema" +
                    e.schemaPath +
                    " , data: " +
                    y +
                    " "),
                (s += " } "))
              : (s += " {} "));
          var g = s;
          ((s = h.pop()),
            !e.compositeRule && x
              ? e.async
                ? (s += " throw new ValidationError([" + g + "]); ")
                : (s += " validate.errors = [" + g + "]; return false; ")
              : (s +=
                  " var err = " +
                  g +
                  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "));
        }
        s += " } ";
      }
    }
    if (e.schema.$ref && !i)
      ((s += " " + e.RULES.all.$ref.code(e, "$ref") + " "),
        x &&
          ((s += " } if (errors === "),
          _ ? (s += "0") : (s += "errs_" + u),
          (s += ") { "),
          (S += "}")));
    else {
      var G = e.RULES;
      if (G) {
        for (var D, U = -1, T = G.length - 1; U < T; )
          if (((D = G[(U += 1)]), dt(D))) {
            if (
              (D.type &&
                (s +=
                  " if (" +
                  e.util.checkDataType(D.type, y, e.opts.strictNumbers) +
                  ") { "),
              e.opts.useDefaults)
            ) {
              if (D.type == "object" && e.schema.properties) {
                var m = e.schema.properties,
                  O = Object.keys(m),
                  H = O;
                if (H)
                  for (var ce, oe = -1, Fe = H.length - 1; oe < Fe; ) {
                    ce = H[(oe += 1)];
                    var Ee = m[ce];
                    if (Ee.default !== void 0) {
                      var Me = y + e.util.getProperty(ce);
                      if (e.compositeRule) {
                        if (e.opts.strictDefaults) {
                          var v = "default is ignored for: " + Me;
                          if (e.opts.strictDefaults === "log") e.logger.warn(v);
                          else throw new Error(v);
                        }
                      } else
                        ((s += " if (" + Me + " === undefined "),
                          e.opts.useDefaults == "empty" &&
                            (s +=
                              " || " + Me + " === null || " + Me + " === '' "),
                          (s += " ) " + Me + " = "),
                          e.opts.useDefaults == "shared"
                            ? (s += " " + e.useDefault(Ee.default) + " ")
                            : (s += " " + JSON.stringify(Ee.default) + " "),
                          (s += "; "));
                    }
                  }
              } else if (D.type == "array" && Array.isArray(e.schema.items)) {
                var q = e.schema.items;
                if (q) {
                  for (var Ee, Q = -1, z = q.length - 1; Q < z; )
                    if (((Ee = q[(Q += 1)]), Ee.default !== void 0)) {
                      var Me = y + "[" + Q + "]";
                      if (e.compositeRule) {
                        if (e.opts.strictDefaults) {
                          var v = "default is ignored for: " + Me;
                          if (e.opts.strictDefaults === "log") e.logger.warn(v);
                          else throw new Error(v);
                        }
                      } else
                        ((s += " if (" + Me + " === undefined "),
                          e.opts.useDefaults == "empty" &&
                            (s +=
                              " || " + Me + " === null || " + Me + " === '' "),
                          (s += " ) " + Me + " = "),
                          e.opts.useDefaults == "shared"
                            ? (s += " " + e.useDefault(Ee.default) + " ")
                            : (s += " " + JSON.stringify(Ee.default) + " "),
                          (s += "; "));
                    }
                }
              }
            }
            var Z = D.rules;
            if (Z) {
              for (var te, fe = -1, je = Z.length - 1; fe < je; )
                if (((te = Z[(fe += 1)]), vt(te))) {
                  var wt = te.code(e, te.keyword, D.type);
                  wt && ((s += " " + wt + " "), x && (w += "}"));
                }
            }
            if (
              (x && ((s += " " + w + " "), (w = "")),
              D.type && ((s += " } "), P && P === D.type && !R))
            ) {
              s += " else { ";
              var p = e.schemaPath + ".type",
                f = e.errSchemaPath + "/type",
                h = h || [];
              (h.push(s),
                (s = ""),
                e.createErrors !== !1
                  ? ((s +=
                      " { keyword: '" +
                      (C || "type") +
                      "' , dataPath: (dataPath || '') + " +
                      e.errorPath +
                      " , schemaPath: " +
                      e.util.toQuotedString(f) +
                      " , params: { type: '"),
                    A ? (s += "" + P.join(",")) : (s += "" + P),
                    (s += "' } "),
                    e.opts.messages !== !1 &&
                      ((s += " , message: 'should be "),
                      A ? (s += "" + P.join(",")) : (s += "" + P),
                      (s += "' ")),
                    e.opts.verbose &&
                      (s +=
                        " , schema: validate.schema" +
                        p +
                        " , parentSchema: validate.schema" +
                        e.schemaPath +
                        " , data: " +
                        y +
                        " "),
                    (s += " } "))
                  : (s += " {} "));
              var g = s;
              ((s = h.pop()),
                !e.compositeRule && x
                  ? e.async
                    ? (s += " throw new ValidationError([" + g + "]); ")
                    : (s += " validate.errors = [" + g + "]; return false; ")
                  : (s +=
                      " var err = " +
                      g +
                      ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
                (s += " } "));
            }
            x &&
              ((s += " if (errors === "),
              _ ? (s += "0") : (s += "errs_" + u),
              (s += ") { "),
              (S += "}"));
          }
      }
    }
    (x && (s += " " + S + " "),
      _
        ? (a
            ? ((s += " if (errors === 0) return data;           "),
              (s += " else throw new ValidationError(vErrors); "))
            : ((s += " validate.errors = vErrors; "),
              (s += " return errors === 0;       ")),
          (s += " }; return validate;"))
        : (s += " var " + b + " = errors === errs_" + u + ";"));
    function dt(et) {
      for (var er = et.rules, bt = 0; bt < er.length; bt++)
        if (vt(er[bt])) return !0;
    }
    function vt(et) {
      return e.schema[et.keyword] !== void 0 || (et.implements && pt(et));
    }
    function pt(et) {
      for (var er = et.implements, bt = 0; bt < er.length; bt++)
        if (e.schema[er[bt]] !== void 0) return !0;
    }
    return s;
  };
});
var fI = j((Cfe, pI) => {
  "use strict";
  var tp = Qd(),
    np = Da(),
    uI = ep(),
    nX = Gv(),
    lI = Wv(),
    sX = np.ucs2length,
    aX = Zd(),
    iX = uI.Validation;
  pI.exports = Kv;
  function Kv(t, e, r, n) {
    var s = this,
      a = this._opts,
      i = [void 0],
      o = {},
      c = [],
      l = {},
      u = [],
      d = {},
      m = [];
    e = e || { schema: t, refVal: i, refs: o };
    var p = oX.call(this, t, e, n),
      f = this._compilations[p.index];
    if (p.compiling) return (f.callValidate = v);
    var y = this._formats,
      h = this.RULES;
    try {
      var g = b(t, e, r, n);
      f.validate = g;
      var _ = f.callValidate;
      return (
        _ &&
          ((_.schema = g.schema),
          (_.errors = null),
          (_.refs = g.refs),
          (_.refVal = g.refVal),
          (_.root = g.root),
          (_.$async = g.$async),
          a.sourceCode && (_.source = g.source)),
        g
      );
    } finally {
      cX.call(this, t, e, n);
    }
    function v() {
      var F = f.validate,
        I = F.apply(this, arguments);
      return ((v.errors = F.errors), I);
    }
    function b(F, I, K, ee) {
      var Y = !I || (I && I.schema == F);
      if (I.schema != e.schema) return Kv.call(s, F, I, K, ee);
      var Q = F.$async === !0,
        ae = lI({
          isTop: !0,
          schema: F,
          isRoot: Y,
          baseId: ee,
          root: I,
          schemaPath: "",
          errSchemaPath: "#",
          errorPath: '""',
          MissingRefError: uI.MissingRef,
          RULES: h,
          validate: lI,
          util: np,
          resolve: tp,
          resolveRef: x,
          usePattern: A,
          useDefault: R,
          useCustomRule: D,
          opts: a,
          formats: y,
          logger: s.logger,
          self: s,
        });
      ((ae = rp(i, dX) + rp(c, lX) + rp(u, uX) + rp(m, pX) + ae),
        a.processCode && (ae = a.processCode(ae, F)));
      var B;
      try {
        var $ = new Function(
          "self",
          "RULES",
          "formats",
          "root",
          "refVal",
          "defaults",
          "customRules",
          "equal",
          "ucs2length",
          "ValidationError",
          ae,
        );
        ((B = $(s, h, y, e, i, u, m, aX, sX, iX)), (i[0] = B));
      } catch (G) {
        throw (s.logger.error("Error compiling schema, function code:", ae), G);
      }
      return (
        (B.schema = F),
        (B.errors = null),
        (B.refs = o),
        (B.refVal = i),
        (B.root = Y ? B : I),
        Q && (B.$async = !0),
        a.sourceCode === !0 &&
          (B.source = { code: ae, patterns: c, defaults: u }),
        B
      );
    }
    function x(F, I, K) {
      I = tp.url(F, I);
      var ee = o[I],
        Y,
        Q;
      if (ee !== void 0)
        return ((Y = i[ee]), (Q = "refVal[" + ee + "]"), P(Y, Q));
      if (!K && e.refs) {
        var ae = e.refs[I];
        if (ae !== void 0) return ((Y = e.refVal[ae]), (Q = w(I, Y)), P(Y, Q));
      }
      Q = w(I);
      var B = tp.call(s, b, e, I);
      if (B === void 0) {
        var $ = r && r[I];
        $ && (B = tp.inlineRef($, a.inlineRefs) ? $ : Kv.call(s, $, e, r, F));
      }
      if (B === void 0) S(I);
      else return (C(I, B), P(B, Q));
    }
    function w(F, I) {
      var K = i.length;
      return ((i[K] = I), (o[F] = K), "refVal" + K);
    }
    function S(F) {
      delete o[F];
    }
    function C(F, I) {
      var K = o[F];
      i[K] = I;
    }
    function P(F, I) {
      return typeof F == "object" || typeof F == "boolean"
        ? { code: I, schema: F, inline: !0 }
        : { code: I, $async: F && !!F.$async };
    }
    function A(F) {
      var I = l[F];
      return (
        I === void 0 && ((I = l[F] = c.length), (c[I] = F)),
        "pattern" + I
      );
    }
    function R(F) {
      switch (typeof F) {
        case "boolean":
        case "number":
          return "" + F;
        case "string":
          return np.toQuotedString(F);
        case "object":
          if (F === null) return "null";
          var I = nX(F),
            K = d[I];
          return (
            K === void 0 && ((K = d[I] = u.length), (u[K] = F)),
            "default" + K
          );
      }
    }
    function D(F, I, K, ee) {
      if (s._opts.validateSchema !== !1) {
        var Y = F.definition.dependencies;
        if (
          Y &&
          !Y.every(function (H) {
            return Object.prototype.hasOwnProperty.call(K, H);
          })
        )
          throw new Error(
            "parent schema must have all required keywords: " + Y.join(","),
          );
        var Q = F.definition.validateSchema;
        if (Q) {
          var ae = Q(I);
          if (!ae) {
            var B = "keyword schema is invalid: " + s.errorsText(Q.errors);
            if (s._opts.validateSchema == "log") s.logger.error(B);
            else throw new Error(B);
          }
        }
      }
      var $ = F.definition.compile,
        G = F.definition.inline,
        U = F.definition.macro,
        T;
      if ($) T = $.call(s, I, K, ee);
      else if (U)
        ((T = U.call(s, I, K, ee)),
          a.validateSchema !== !1 && s.validateSchema(T, !0));
      else if (G) T = G.call(s, ee, F.keyword, I, K);
      else if (((T = F.definition.validate), !T)) return;
      if (T === void 0)
        throw new Error('custom keyword "' + F.keyword + '"failed to compile');
      var O = m.length;
      return ((m[O] = T), { code: "customRule" + O, validate: T });
    }
  }
  function oX(t, e, r) {
    var n = dI.call(this, t, e, r);
    return n >= 0
      ? { index: n, compiling: !0 }
      : ((n = this._compilations.length),
        (this._compilations[n] = { schema: t, root: e, baseId: r }),
        { index: n, compiling: !1 });
  }
  function cX(t, e, r) {
    var n = dI.call(this, t, e, r);
    n >= 0 && this._compilations.splice(n, 1);
  }
  function dI(t, e, r) {
    for (var n = 0; n < this._compilations.length; n++) {
      var s = this._compilations[n];
      if (s.schema == t && s.root == e && s.baseId == r) return n;
    }
    return -1;
  }
  function lX(t, e) {
    return (
      "var pattern" + t + " = new RegExp(" + np.toQuotedString(e[t]) + ");"
    );
  }
  function uX(t) {
    return "var default" + t + " = defaults[" + t + "];";
  }
  function dX(t, e) {
    return e[t] === void 0 ? "" : "var refVal" + t + " = refVal[" + t + "];";
  }
  function pX(t) {
    return "var customRule" + t + " = customRules[" + t + "];";
  }
  function rp(t, e) {
    if (!t.length) return "";
    for (var r = "", n = 0; n < t.length; n++) r += e(n, t);
    return r;
  }
});
var hI = j((Pfe, mI) => {
  "use strict";
  var sp = (mI.exports = function () {
    this._cache = {};
  });
  sp.prototype.put = function (e, r) {
    this._cache[e] = r;
  };
  sp.prototype.get = function (e) {
    return this._cache[e];
  };
  sp.prototype.del = function (e) {
    delete this._cache[e];
  };
  sp.prototype.clear = function () {
    this._cache = {};
  };
});
var PI = j((kfe, CI) => {
  "use strict";
  var fX = Da(),
    mX = /^(\d\d\d\d)-(\d\d)-(\d\d)$/,
    hX = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    gX = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i,
    gI =
      /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    vX =
      /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    yX =
      /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    vI =
      /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    yI =
      /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i,
    bI = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    _I = /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    xI = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    wI = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
  CI.exports = ap;
  function ap(t) {
    return ((t = t == "full" ? "full" : "fast"), fX.copy(ap[t]));
  }
  ap.fast = {
    date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
    time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
    "date-time":
      /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference":
      /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    "uri-template": vI,
    url: yI,
    email:
      /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    hostname: gI,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex: TI,
    uuid: bI,
    "json-pointer": _I,
    "json-pointer-uri-fragment": xI,
    "relative-json-pointer": wI,
  };
  ap.full = {
    date: SI,
    time: EI,
    "date-time": xX,
    uri: SX,
    "uri-reference": yX,
    "uri-template": vI,
    url: yI,
    email:
      /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: gI,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex: TI,
    uuid: bI,
    "json-pointer": _I,
    "json-pointer-uri-fragment": xI,
    "relative-json-pointer": wI,
  };
  function bX(t) {
    return t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0);
  }
  function SI(t) {
    var e = t.match(mX);
    if (!e) return !1;
    var r = +e[1],
      n = +e[2],
      s = +e[3];
    return n >= 1 && n <= 12 && s >= 1 && s <= (n == 2 && bX(r) ? 29 : hX[n]);
  }
  function EI(t, e) {
    var r = t.match(gX);
    if (!r) return !1;
    var n = r[1],
      s = r[2],
      a = r[3],
      i = r[5];
    return (
      ((n <= 23 && s <= 59 && a <= 59) || (n == 23 && s == 59 && a == 60)) &&
      (!e || i)
    );
  }
  var _X = /t|\s/i;
  function xX(t) {
    var e = t.split(_X);
    return e.length == 2 && SI(e[0]) && EI(e[1], !0);
  }
  var wX = /\/|:/;
  function SX(t) {
    return wX.test(t) && vX.test(t);
  }
  var EX = /[^\\]\\Z/;
  function TI(t) {
    if (EX.test(t)) return !1;
    try {
      return (new RegExp(t), !0);
    } catch {
      return !1;
    }
  }
});
var RI = j((Rfe, kI) => {
  "use strict";
  kI.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.errSchemaPath + "/" + r,
      l = !e.opts.allErrors,
      u = "data" + (i || ""),
      d = "valid" + a,
      m,
      p;
    if (o == "#" || o == "#/")
      e.isRoot
        ? ((m = e.async), (p = "validate"))
        : ((m = e.root.schema.$async === !0), (p = "root.refVal[0]"));
    else {
      var f = e.resolveRef(e.baseId, o, e.isRoot);
      if (f === void 0) {
        var y = e.MissingRefError.message(e.baseId, o);
        if (e.opts.missingRefs == "fail") {
          e.logger.error(y);
          var h = h || [];
          (h.push(s),
            (s = ""),
            e.createErrors !== !1
              ? ((s +=
                  " { keyword: '$ref' , dataPath: (dataPath || '') + " +
                  e.errorPath +
                  " , schemaPath: " +
                  e.util.toQuotedString(c) +
                  " , params: { ref: '" +
                  e.util.escapeQuotes(o) +
                  "' } "),
                e.opts.messages !== !1 &&
                  (s +=
                    " , message: 'can\\'t resolve reference " +
                    e.util.escapeQuotes(o) +
                    "' "),
                e.opts.verbose &&
                  (s +=
                    " , schema: " +
                    e.util.toQuotedString(o) +
                    " , parentSchema: validate.schema" +
                    e.schemaPath +
                    " , data: " +
                    u +
                    " "),
                (s += " } "))
              : (s += " {} "));
          var g = s;
          ((s = h.pop()),
            !e.compositeRule && l
              ? e.async
                ? (s += " throw new ValidationError([" + g + "]); ")
                : (s += " validate.errors = [" + g + "]; return false; ")
              : (s +=
                  " var err = " +
                  g +
                  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
            l && (s += " if (false) { "));
        } else if (e.opts.missingRefs == "ignore")
          (e.logger.warn(y), l && (s += " if (true) { "));
        else throw new e.MissingRefError(e.baseId, o, y);
      } else if (f.inline) {
        var _ = e.util.copy(e);
        _.level++;
        var v = "valid" + _.level;
        ((_.schema = f.schema), (_.schemaPath = ""), (_.errSchemaPath = o));
        var b = e.validate(_).replace(/validate\.schema/g, f.code);
        ((s += " " + b + " "), l && (s += " if (" + v + ") { "));
      } else
        ((m = f.$async === !0 || (e.async && f.$async !== !1)), (p = f.code));
    }
    if (p) {
      var h = h || [];
      (h.push(s),
        (s = ""),
        e.opts.passContext
          ? (s += " " + p + ".call(this, ")
          : (s += " " + p + "( "),
        (s += " " + u + ", (dataPath || '')"),
        e.errorPath != '""' && (s += " + " + e.errorPath));
      var x = i ? "data" + (i - 1 || "") : "parentData",
        w = i ? e.dataPathArr[i] : "parentDataProperty";
      s += " , " + x + " , " + w + ", rootData)  ";
      var S = s;
      if (((s = h.pop()), m)) {
        if (!e.async) throw new Error("async schema referenced by sync schema");
        (l && (s += " var " + d + "; "),
          (s += " try { await " + S + "; "),
          l && (s += " " + d + " = true; "),
          (s +=
            " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; "),
          l && (s += " " + d + " = false; "),
          (s += " } "),
          l && (s += " if (" + d + ") { "));
      } else
        ((s +=
          " if (!" +
          S +
          ") { if (vErrors === null) vErrors = " +
          p +
          ".errors; else vErrors = vErrors.concat(" +
          p +
          ".errors); errors = vErrors.length; } "),
          l && (s += " else { "));
    }
    return s;
  };
});
var II = j((Ofe, OI) => {
  "use strict";
  OI.exports = function (e, r, n) {
    var s = " ",
      a = e.schema[r],
      i = e.schemaPath + e.util.getProperty(r),
      o = e.errSchemaPath + "/" + r,
      c = !e.opts.allErrors,
      l = e.util.copy(e),
      u = "";
    l.level++;
    var d = "valid" + l.level,
      m = l.baseId,
      p = !0,
      f = a;
    if (f)
      for (var y, h = -1, g = f.length - 1; h < g; )
        ((y = f[(h += 1)]),
          (e.opts.strictKeywords
            ? (typeof y == "object" && Object.keys(y).length > 0) || y === !1
            : e.util.schemaHasRules(y, e.RULES.all)) &&
            ((p = !1),
            (l.schema = y),
            (l.schemaPath = i + "[" + h + "]"),
            (l.errSchemaPath = o + "/" + h),
            (s += "  " + e.validate(l) + " "),
            (l.baseId = m),
            c && ((s += " if (" + d + ") { "), (u += "}"))));
    return (
      c && (p ? (s += " if (true) { ") : (s += " " + u.slice(0, -1) + " ")),
      s
    );
  };
});
var AI = j((Ife, $I) => {
  "use strict";
  $I.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.schemaPath + e.util.getProperty(r),
      l = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      d = "data" + (i || ""),
      m = "valid" + a,
      p = "errs__" + a,
      f = e.util.copy(e),
      y = "";
    f.level++;
    var h = "valid" + f.level,
      g = o.every(function (C) {
        return e.opts.strictKeywords
          ? (typeof C == "object" && Object.keys(C).length > 0) || C === !1
          : e.util.schemaHasRules(C, e.RULES.all);
      });
    if (g) {
      var _ = f.baseId;
      s += " var " + p + " = errors; var " + m + " = false;  ";
      var v = e.compositeRule;
      e.compositeRule = f.compositeRule = !0;
      var b = o;
      if (b)
        for (var x, w = -1, S = b.length - 1; w < S; )
          ((x = b[(w += 1)]),
            (f.schema = x),
            (f.schemaPath = c + "[" + w + "]"),
            (f.errSchemaPath = l + "/" + w),
            (s += "  " + e.validate(f) + " "),
            (f.baseId = _),
            (s += " " + m + " = " + m + " || " + h + "; if (!" + m + ") { "),
            (y += "}"));
      ((e.compositeRule = f.compositeRule = v),
        (s += " " + y + " if (!" + m + ") {   var err =   "),
        e.createErrors !== !1
          ? ((s +=
              " { keyword: 'anyOf' , dataPath: (dataPath || '') + " +
              e.errorPath +
              " , schemaPath: " +
              e.util.toQuotedString(l) +
              " , params: {} "),
            e.opts.messages !== !1 &&
              (s += " , message: 'should match some schema in anyOf' "),
            e.opts.verbose &&
              (s +=
                " , schema: validate.schema" +
                c +
                " , parentSchema: validate.schema" +
                e.schemaPath +
                " , data: " +
                d +
                " "),
            (s += " } "))
          : (s += " {} "),
        (s +=
          ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
        !e.compositeRule &&
          u &&
          (e.async
            ? (s += " throw new ValidationError(vErrors); ")
            : (s += " validate.errors = vErrors; return false; ")),
        (s +=
          " } else {  errors = " +
          p +
          "; if (vErrors !== null) { if (" +
          p +
          ") vErrors.length = " +
          p +
          "; else vErrors = null; } "),
        e.opts.allErrors && (s += " } "));
    } else u && (s += " if (true) { ");
    return s;
  };
});
var DI = j(($fe, NI) => {
  "use strict";
  NI.exports = function (e, r, n) {
    var s = " ",
      a = e.schema[r],
      i = e.errSchemaPath + "/" + r,
      o = !e.opts.allErrors,
      c = e.util.toQuotedString(a);
    return (
      e.opts.$comment === !0
        ? (s += " console.log(" + c + ");")
        : typeof e.opts.$comment == "function" &&
          (s +=
            " self._opts.$comment(" +
            c +
            ", " +
            e.util.toQuotedString(i) +
            ", validate.root.schema);"),
      s
    );
  };
});
var MI = j((Afe, LI) => {
  "use strict";
  LI.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.schemaPath + e.util.getProperty(r),
      l = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      d = "data" + (i || ""),
      m = "valid" + a,
      p = e.opts.$data && o && o.$data,
      f;
    (p
      ? ((s +=
          " var schema" +
          a +
          " = " +
          e.util.getData(o.$data, i, e.dataPathArr) +
          "; "),
        (f = "schema" + a))
      : (f = o),
      p || (s += " var schema" + a + " = validate.schema" + c + ";"),
      (s +=
        "var " +
        m +
        " = equal(" +
        d +
        ", schema" +
        a +
        "); if (!" +
        m +
        ") {   "));
    var y = y || [];
    (y.push(s),
      (s = ""),
      e.createErrors !== !1
        ? ((s +=
            " { keyword: 'const' , dataPath: (dataPath || '') + " +
            e.errorPath +
            " , schemaPath: " +
            e.util.toQuotedString(l) +
            " , params: { allowedValue: schema" +
            a +
            " } "),
          e.opts.messages !== !1 &&
            (s += " , message: 'should be equal to constant' "),
          e.opts.verbose &&
            (s +=
              " , schema: validate.schema" +
              c +
              " , parentSchema: validate.schema" +
              e.schemaPath +
              " , data: " +
              d +
              " "),
          (s += " } "))
        : (s += " {} "));
    var h = s;
    return (
      (s = y.pop()),
      !e.compositeRule && u
        ? e.async
          ? (s += " throw new ValidationError([" + h + "]); ")
          : (s += " validate.errors = [" + h + "]; return false; ")
        : (s +=
            " var err = " +
            h +
            ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
      (s += " }"),
      u && (s += " else { "),
      s
    );
  };
});
var FI = j((Nfe, jI) => {
  "use strict";
  jI.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.schemaPath + e.util.getProperty(r),
      l = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      d = "data" + (i || ""),
      m = "valid" + a,
      p = "errs__" + a,
      f = e.util.copy(e),
      y = "";
    f.level++;
    var h = "valid" + f.level,
      g = "i" + a,
      _ = (f.dataLevel = e.dataLevel + 1),
      v = "data" + _,
      b = e.baseId,
      x = e.opts.strictKeywords
        ? (typeof o == "object" && Object.keys(o).length > 0) || o === !1
        : e.util.schemaHasRules(o, e.RULES.all);
    if (((s += "var " + p + " = errors;var " + m + ";"), x)) {
      var w = e.compositeRule;
      ((e.compositeRule = f.compositeRule = !0),
        (f.schema = o),
        (f.schemaPath = c),
        (f.errSchemaPath = l),
        (s +=
          " var " +
          h +
          " = false; for (var " +
          g +
          " = 0; " +
          g +
          " < " +
          d +
          ".length; " +
          g +
          "++) { "),
        (f.errorPath = e.util.getPathExpr(
          e.errorPath,
          g,
          e.opts.jsonPointers,
          !0,
        )));
      var S = d + "[" + g + "]";
      f.dataPathArr[_] = g;
      var C = e.validate(f);
      ((f.baseId = b),
        e.util.varOccurences(C, v) < 2
          ? (s += " " + e.util.varReplace(C, v, S) + " ")
          : (s += " var " + v + " = " + S + "; " + C + " "),
        (s += " if (" + h + ") break; }  "),
        (e.compositeRule = f.compositeRule = w),
        (s += " " + y + " if (!" + h + ") {"));
    } else s += " if (" + d + ".length == 0) {";
    var P = P || [];
    (P.push(s),
      (s = ""),
      e.createErrors !== !1
        ? ((s +=
            " { keyword: 'contains' , dataPath: (dataPath || '') + " +
            e.errorPath +
            " , schemaPath: " +
            e.util.toQuotedString(l) +
            " , params: {} "),
          e.opts.messages !== !1 &&
            (s += " , message: 'should contain a valid item' "),
          e.opts.verbose &&
            (s +=
              " , schema: validate.schema" +
              c +
              " , parentSchema: validate.schema" +
              e.schemaPath +
              " , data: " +
              d +
              " "),
          (s += " } "))
        : (s += " {} "));
    var A = s;
    return (
      (s = P.pop()),
      !e.compositeRule && u
        ? e.async
          ? (s += " throw new ValidationError([" + A + "]); ")
          : (s += " validate.errors = [" + A + "]; return false; ")
        : (s +=
            " var err = " +
            A +
            ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
      (s += " } else { "),
      x &&
        (s +=
          "  errors = " +
          p +
          "; if (vErrors !== null) { if (" +
          p +
          ") vErrors.length = " +
          p +
          "; else vErrors = null; } "),
      e.opts.allErrors && (s += " } "),
      s
    );
  };
});
var qI = j((Dfe, UI) => {
  "use strict";
  UI.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.schemaPath + e.util.getProperty(r),
      l = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      d = "data" + (i || ""),
      m = "errs__" + a,
      p = e.util.copy(e),
      f = "";
    p.level++;
    var y = "valid" + p.level,
      h = {},
      g = {},
      _ = e.opts.ownProperties;
    for (w in o)
      if (w != "__proto__") {
        var v = o[w],
          b = Array.isArray(v) ? g : h;
        b[w] = v;
      }
    s += "var " + m + " = errors;";
    var x = e.errorPath;
    s += "var missing" + a + ";";
    for (var w in g)
      if (((b = g[w]), b.length)) {
        if (
          ((s += " if ( " + d + e.util.getProperty(w) + " !== undefined "),
          _ &&
            (s +=
              " && Object.prototype.hasOwnProperty.call(" +
              d +
              ", '" +
              e.util.escapeQuotes(w) +
              "') "),
          u)
        ) {
          s += " && ( ";
          var S = b;
          if (S)
            for (var C, P = -1, A = S.length - 1; P < A; ) {
              ((C = S[(P += 1)]), P && (s += " || "));
              var R = e.util.getProperty(C),
                D = d + R;
              ((s += " ( ( " + D + " === undefined "),
                _ &&
                  (s +=
                    " || ! Object.prototype.hasOwnProperty.call(" +
                    d +
                    ", '" +
                    e.util.escapeQuotes(C) +
                    "') "),
                (s +=
                  ") && (missing" +
                  a +
                  " = " +
                  e.util.toQuotedString(e.opts.jsonPointers ? C : R) +
                  ") ) "));
            }
          s += ")) {  ";
          var F = "missing" + a,
            I = "' + " + F + " + '";
          e.opts._errorDataPathProperty &&
            (e.errorPath = e.opts.jsonPointers
              ? e.util.getPathExpr(x, F, !0)
              : x + " + " + F);
          var K = K || [];
          (K.push(s),
            (s = ""),
            e.createErrors !== !1
              ? ((s +=
                  " { keyword: 'dependencies' , dataPath: (dataPath || '') + " +
                  e.errorPath +
                  " , schemaPath: " +
                  e.util.toQuotedString(l) +
                  " , params: { property: '" +
                  e.util.escapeQuotes(w) +
                  "', missingProperty: '" +
                  I +
                  "', depsCount: " +
                  b.length +
                  ", deps: '" +
                  e.util.escapeQuotes(b.length == 1 ? b[0] : b.join(", ")) +
                  "' } "),
                e.opts.messages !== !1 &&
                  ((s += " , message: 'should have "),
                  b.length == 1
                    ? (s += "property " + e.util.escapeQuotes(b[0]))
                    : (s += "properties " + e.util.escapeQuotes(b.join(", "))),
                  (s +=
                    " when property " +
                    e.util.escapeQuotes(w) +
                    " is present' ")),
                e.opts.verbose &&
                  (s +=
                    " , schema: validate.schema" +
                    c +
                    " , parentSchema: validate.schema" +
                    e.schemaPath +
                    " , data: " +
                    d +
                    " "),
                (s += " } "))
              : (s += " {} "));
          var ee = s;
          ((s = K.pop()),
            !e.compositeRule && u
              ? e.async
                ? (s += " throw new ValidationError([" + ee + "]); ")
                : (s += " validate.errors = [" + ee + "]; return false; ")
              : (s +=
                  " var err = " +
                  ee +
                  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "));
        } else {
          s += " ) { ";
          var Y = b;
          if (Y)
            for (var C, Q = -1, ae = Y.length - 1; Q < ae; ) {
              C = Y[(Q += 1)];
              var R = e.util.getProperty(C),
                I = e.util.escapeQuotes(C),
                D = d + R;
              (e.opts._errorDataPathProperty &&
                (e.errorPath = e.util.getPath(x, C, e.opts.jsonPointers)),
                (s += " if ( " + D + " === undefined "),
                _ &&
                  (s +=
                    " || ! Object.prototype.hasOwnProperty.call(" +
                    d +
                    ", '" +
                    e.util.escapeQuotes(C) +
                    "') "),
                (s += ") {  var err =   "),
                e.createErrors !== !1
                  ? ((s +=
                      " { keyword: 'dependencies' , dataPath: (dataPath || '') + " +
                      e.errorPath +
                      " , schemaPath: " +
                      e.util.toQuotedString(l) +
                      " , params: { property: '" +
                      e.util.escapeQuotes(w) +
                      "', missingProperty: '" +
                      I +
                      "', depsCount: " +
                      b.length +
                      ", deps: '" +
                      e.util.escapeQuotes(b.length == 1 ? b[0] : b.join(", ")) +
                      "' } "),
                    e.opts.messages !== !1 &&
                      ((s += " , message: 'should have "),
                      b.length == 1
                        ? (s += "property " + e.util.escapeQuotes(b[0]))
                        : (s +=
                            "properties " + e.util.escapeQuotes(b.join(", "))),
                      (s +=
                        " when property " +
                        e.util.escapeQuotes(w) +
                        " is present' ")),
                    e.opts.verbose &&
                      (s +=
                        " , schema: validate.schema" +
                        c +
                        " , parentSchema: validate.schema" +
                        e.schemaPath +
                        " , data: " +
                        d +
                        " "),
                    (s += " } "))
                  : (s += " {} "),
                (s +=
                  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } "));
            }
        }
        ((s += " }   "), u && ((f += "}"), (s += " else { ")));
      }
    e.errorPath = x;
    var B = p.baseId;
    for (var w in h) {
      var v = h[w];
      (e.opts.strictKeywords
        ? (typeof v == "object" && Object.keys(v).length > 0) || v === !1
        : e.util.schemaHasRules(v, e.RULES.all)) &&
        ((s +=
          " " +
          y +
          " = true; if ( " +
          d +
          e.util.getProperty(w) +
          " !== undefined "),
        _ &&
          (s +=
            " && Object.prototype.hasOwnProperty.call(" +
            d +
            ", '" +
            e.util.escapeQuotes(w) +
            "') "),
        (s += ") { "),
        (p.schema = v),
        (p.schemaPath = c + e.util.getProperty(w)),
        (p.errSchemaPath = l + "/" + e.util.escapeFragment(w)),
        (s += "  " + e.validate(p) + " "),
        (p.baseId = B),
        (s += " }  "),
        u && ((s += " if (" + y + ") { "), (f += "}")));
    }
    return (u && (s += "   " + f + " if (" + m + " == errors) {"), s);
  };
});
var BI = j((Lfe, zI) => {
  "use strict";
  zI.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.schemaPath + e.util.getProperty(r),
      l = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      d = "data" + (i || ""),
      m = "valid" + a,
      p = e.opts.$data && o && o.$data,
      f;
    p
      ? ((s +=
          " var schema" +
          a +
          " = " +
          e.util.getData(o.$data, i, e.dataPathArr) +
          "; "),
        (f = "schema" + a))
      : (f = o);
    var y = "i" + a,
      h = "schema" + a;
    (p || (s += " var " + h + " = validate.schema" + c + ";"),
      (s += "var " + m + ";"),
      p &&
        (s +=
          " if (schema" +
          a +
          " === undefined) " +
          m +
          " = true; else if (!Array.isArray(schema" +
          a +
          ")) " +
          m +
          " = false; else {"),
      (s +=
        "" +
        m +
        " = false;for (var " +
        y +
        "=0; " +
        y +
        "<" +
        h +
        ".length; " +
        y +
        "++) if (equal(" +
        d +
        ", " +
        h +
        "[" +
        y +
        "])) { " +
        m +
        " = true; break; }"),
      p && (s += "  }  "),
      (s += " if (!" + m + ") {   "));
    var g = g || [];
    (g.push(s),
      (s = ""),
      e.createErrors !== !1
        ? ((s +=
            " { keyword: 'enum' , dataPath: (dataPath || '') + " +
            e.errorPath +
            " , schemaPath: " +
            e.util.toQuotedString(l) +
            " , params: { allowedValues: schema" +
            a +
            " } "),
          e.opts.messages !== !1 &&
            (s +=
              " , message: 'should be equal to one of the allowed values' "),
          e.opts.verbose &&
            (s +=
              " , schema: validate.schema" +
              c +
              " , parentSchema: validate.schema" +
              e.schemaPath +
              " , data: " +
              d +
              " "),
          (s += " } "))
        : (s += " {} "));
    var _ = s;
    return (
      (s = g.pop()),
      !e.compositeRule && u
        ? e.async
          ? (s += " throw new ValidationError([" + _ + "]); ")
          : (s += " validate.errors = [" + _ + "]; return false; ")
        : (s +=
            " var err = " +
            _ +
            ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
      (s += " }"),
      u && (s += " else { "),
      s
    );
  };
});
var VI = j((Mfe, HI) => {
  "use strict";
  HI.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.schemaPath + e.util.getProperty(r),
      l = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      d = "data" + (i || "");
    if (e.opts.format === !1) return (u && (s += " if (true) { "), s);
    var m = e.opts.$data && o && o.$data,
      p;
    m
      ? ((s +=
          " var schema" +
          a +
          " = " +
          e.util.getData(o.$data, i, e.dataPathArr) +
          "; "),
        (p = "schema" + a))
      : (p = o);
    var f = e.opts.unknownFormats,
      y = Array.isArray(f);
    if (m) {
      var h = "format" + a,
        g = "isObject" + a,
        _ = "formatType" + a;
      ((s +=
        " var " +
        h +
        " = formats[" +
        p +
        "]; var " +
        g +
        " = typeof " +
        h +
        " == 'object' && !(" +
        h +
        " instanceof RegExp) && " +
        h +
        ".validate; var " +
        _ +
        " = " +
        g +
        " && " +
        h +
        ".type || 'string'; if (" +
        g +
        ") { "),
        e.async && (s += " var async" + a + " = " + h + ".async; "),
        (s += " " + h + " = " + h + ".validate; } if (  "),
        m &&
          (s +=
            " (" + p + " !== undefined && typeof " + p + " != 'string') || "),
        (s += " ("),
        f != "ignore" &&
          ((s += " (" + p + " && !" + h + " "),
          y && (s += " && self._opts.unknownFormats.indexOf(" + p + ") == -1 "),
          (s += ") || ")),
        (s +=
          " (" +
          h +
          " && " +
          _ +
          " == '" +
          n +
          "' && !(typeof " +
          h +
          " == 'function' ? "),
        e.async
          ? (s +=
              " (async" +
              a +
              " ? await " +
              h +
              "(" +
              d +
              ") : " +
              h +
              "(" +
              d +
              ")) ")
          : (s += " " + h + "(" + d + ") "),
        (s += " : " + h + ".test(" + d + "))))) {"));
    } else {
      var h = e.formats[o];
      if (!h) {
        if (f == "ignore")
          return (
            e.logger.warn(
              'unknown format "' +
                o +
                '" ignored in schema at path "' +
                e.errSchemaPath +
                '"',
            ),
            u && (s += " if (true) { "),
            s
          );
        if (y && f.indexOf(o) >= 0) return (u && (s += " if (true) { "), s);
        throw new Error(
          'unknown format "' +
            o +
            '" is used in schema at path "' +
            e.errSchemaPath +
            '"',
        );
      }
      var g = typeof h == "object" && !(h instanceof RegExp) && h.validate,
        _ = (g && h.type) || "string";
      if (g) {
        var v = h.async === !0;
        h = h.validate;
      }
      if (_ != n) return (u && (s += " if (true) { "), s);
      if (v) {
        if (!e.async) throw new Error("async format in sync schema");
        var b = "formats" + e.util.getProperty(o) + ".validate";
        s += " if (!(await " + b + "(" + d + "))) { ";
      } else {
        s += " if (! ";
        var b = "formats" + e.util.getProperty(o);
        (g && (b += ".validate"),
          typeof h == "function"
            ? (s += " " + b + "(" + d + ") ")
            : (s += " " + b + ".test(" + d + ") "),
          (s += ") { "));
      }
    }
    var x = x || [];
    (x.push(s),
      (s = ""),
      e.createErrors !== !1
        ? ((s +=
            " { keyword: 'format' , dataPath: (dataPath || '') + " +
            e.errorPath +
            " , schemaPath: " +
            e.util.toQuotedString(l) +
            " , params: { format:  "),
          m ? (s += "" + p) : (s += "" + e.util.toQuotedString(o)),
          (s += "  } "),
          e.opts.messages !== !1 &&
            ((s += ` , message: 'should match format "`),
            m ? (s += "' + " + p + " + '") : (s += "" + e.util.escapeQuotes(o)),
            (s += `"' `)),
          e.opts.verbose &&
            ((s += " , schema:  "),
            m
              ? (s += "validate.schema" + c)
              : (s += "" + e.util.toQuotedString(o)),
            (s +=
              "         , parentSchema: validate.schema" +
              e.schemaPath +
              " , data: " +
              d +
              " ")),
          (s += " } "))
        : (s += " {} "));
    var w = s;
    return (
      (s = x.pop()),
      !e.compositeRule && u
        ? e.async
          ? (s += " throw new ValidationError([" + w + "]); ")
          : (s += " validate.errors = [" + w + "]; return false; ")
        : (s +=
            " var err = " +
            w +
            ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
      (s += " } "),
      u && (s += " else { "),
      s
    );
  };
});
var GI = j((jfe, ZI) => {
  "use strict";
  ZI.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.schemaPath + e.util.getProperty(r),
      l = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      d = "data" + (i || ""),
      m = "valid" + a,
      p = "errs__" + a,
      f = e.util.copy(e);
    f.level++;
    var y = "valid" + f.level,
      h = e.schema.then,
      g = e.schema.else,
      _ =
        h !== void 0 &&
        (e.opts.strictKeywords
          ? (typeof h == "object" && Object.keys(h).length > 0) || h === !1
          : e.util.schemaHasRules(h, e.RULES.all)),
      v =
        g !== void 0 &&
        (e.opts.strictKeywords
          ? (typeof g == "object" && Object.keys(g).length > 0) || g === !1
          : e.util.schemaHasRules(g, e.RULES.all)),
      b = f.baseId;
    if (_ || v) {
      var x;
      ((f.createErrors = !1),
        (f.schema = o),
        (f.schemaPath = c),
        (f.errSchemaPath = l),
        (s += " var " + p + " = errors; var " + m + " = true;  "));
      var w = e.compositeRule;
      ((e.compositeRule = f.compositeRule = !0),
        (s += "  " + e.validate(f) + " "),
        (f.baseId = b),
        (f.createErrors = !0),
        (s +=
          "  errors = " +
          p +
          "; if (vErrors !== null) { if (" +
          p +
          ") vErrors.length = " +
          p +
          "; else vErrors = null; }  "),
        (e.compositeRule = f.compositeRule = w),
        _
          ? ((s += " if (" + y + ") {  "),
            (f.schema = e.schema.then),
            (f.schemaPath = e.schemaPath + ".then"),
            (f.errSchemaPath = e.errSchemaPath + "/then"),
            (s += "  " + e.validate(f) + " "),
            (f.baseId = b),
            (s += " " + m + " = " + y + "; "),
            _ && v
              ? ((x = "ifClause" + a), (s += " var " + x + " = 'then'; "))
              : (x = "'then'"),
            (s += " } "),
            v && (s += " else { "))
          : (s += " if (!" + y + ") { "),
        v &&
          ((f.schema = e.schema.else),
          (f.schemaPath = e.schemaPath + ".else"),
          (f.errSchemaPath = e.errSchemaPath + "/else"),
          (s += "  " + e.validate(f) + " "),
          (f.baseId = b),
          (s += " " + m + " = " + y + "; "),
          _ && v
            ? ((x = "ifClause" + a), (s += " var " + x + " = 'else'; "))
            : (x = "'else'"),
          (s += " } ")),
        (s += " if (!" + m + ") {   var err =   "),
        e.createErrors !== !1
          ? ((s +=
              " { keyword: 'if' , dataPath: (dataPath || '') + " +
              e.errorPath +
              " , schemaPath: " +
              e.util.toQuotedString(l) +
              " , params: { failingKeyword: " +
              x +
              " } "),
            e.opts.messages !== !1 &&
              (s += ` , message: 'should match "' + ` + x + ` + '" schema' `),
            e.opts.verbose &&
              (s +=
                " , schema: validate.schema" +
                c +
                " , parentSchema: validate.schema" +
                e.schemaPath +
                " , data: " +
                d +
                " "),
            (s += " } "))
          : (s += " {} "),
        (s +=
          ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
        !e.compositeRule &&
          u &&
          (e.async
            ? (s += " throw new ValidationError(vErrors); ")
            : (s += " validate.errors = vErrors; return false; ")),
        (s += " }   "),
        u && (s += " else { "));
    } else u && (s += " if (true) { ");
    return s;
  };
});
var KI = j((Ffe, WI) => {
  "use strict";
  WI.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.schemaPath + e.util.getProperty(r),
      l = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      d = "data" + (i || ""),
      m = "valid" + a,
      p = "errs__" + a,
      f = e.util.copy(e),
      y = "";
    f.level++;
    var h = "valid" + f.level,
      g = "i" + a,
      _ = (f.dataLevel = e.dataLevel + 1),
      v = "data" + _,
      b = e.baseId;
    if (((s += "var " + p + " = errors;var " + m + ";"), Array.isArray(o))) {
      var x = e.schema.additionalItems;
      if (x === !1) {
        s += " " + m + " = " + d + ".length <= " + o.length + "; ";
        var w = l;
        ((l = e.errSchemaPath + "/additionalItems"),
          (s += "  if (!" + m + ") {   "));
        var S = S || [];
        (S.push(s),
          (s = ""),
          e.createErrors !== !1
            ? ((s +=
                " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " +
                e.errorPath +
                " , schemaPath: " +
                e.util.toQuotedString(l) +
                " , params: { limit: " +
                o.length +
                " } "),
              e.opts.messages !== !1 &&
                (s +=
                  " , message: 'should NOT have more than " +
                  o.length +
                  " items' "),
              e.opts.verbose &&
                (s +=
                  " , schema: false , parentSchema: validate.schema" +
                  e.schemaPath +
                  " , data: " +
                  d +
                  " "),
              (s += " } "))
            : (s += " {} "));
        var C = s;
        ((s = S.pop()),
          !e.compositeRule && u
            ? e.async
              ? (s += " throw new ValidationError([" + C + "]); ")
              : (s += " validate.errors = [" + C + "]; return false; ")
            : (s +=
                " var err = " +
                C +
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
          (s += " } "),
          (l = w),
          u && ((y += "}"), (s += " else { ")));
      }
      var P = o;
      if (P) {
        for (var A, R = -1, D = P.length - 1; R < D; )
          if (
            ((A = P[(R += 1)]),
            e.opts.strictKeywords
              ? (typeof A == "object" && Object.keys(A).length > 0) || A === !1
              : e.util.schemaHasRules(A, e.RULES.all))
          ) {
            s += " " + h + " = true; if (" + d + ".length > " + R + ") { ";
            var F = d + "[" + R + "]";
            ((f.schema = A),
              (f.schemaPath = c + "[" + R + "]"),
              (f.errSchemaPath = l + "/" + R),
              (f.errorPath = e.util.getPathExpr(
                e.errorPath,
                R,
                e.opts.jsonPointers,
                !0,
              )),
              (f.dataPathArr[_] = R));
            var I = e.validate(f);
            ((f.baseId = b),
              e.util.varOccurences(I, v) < 2
                ? (s += " " + e.util.varReplace(I, v, F) + " ")
                : (s += " var " + v + " = " + F + "; " + I + " "),
              (s += " }  "),
              u && ((s += " if (" + h + ") { "), (y += "}")));
          }
      }
      if (
        typeof x == "object" &&
        (e.opts.strictKeywords
          ? (typeof x == "object" && Object.keys(x).length > 0) || x === !1
          : e.util.schemaHasRules(x, e.RULES.all))
      ) {
        ((f.schema = x),
          (f.schemaPath = e.schemaPath + ".additionalItems"),
          (f.errSchemaPath = e.errSchemaPath + "/additionalItems"),
          (s +=
            " " +
            h +
            " = true; if (" +
            d +
            ".length > " +
            o.length +
            ") {  for (var " +
            g +
            " = " +
            o.length +
            "; " +
            g +
            " < " +
            d +
            ".length; " +
            g +
            "++) { "),
          (f.errorPath = e.util.getPathExpr(
            e.errorPath,
            g,
            e.opts.jsonPointers,
            !0,
          )));
        var F = d + "[" + g + "]";
        f.dataPathArr[_] = g;
        var I = e.validate(f);
        ((f.baseId = b),
          e.util.varOccurences(I, v) < 2
            ? (s += " " + e.util.varReplace(I, v, F) + " ")
            : (s += " var " + v + " = " + F + "; " + I + " "),
          u && (s += " if (!" + h + ") break; "),
          (s += " } }  "),
          u && ((s += " if (" + h + ") { "), (y += "}")));
      }
    } else if (
      e.opts.strictKeywords
        ? (typeof o == "object" && Object.keys(o).length > 0) || o === !1
        : e.util.schemaHasRules(o, e.RULES.all)
    ) {
      ((f.schema = o),
        (f.schemaPath = c),
        (f.errSchemaPath = l),
        (s +=
          "  for (var " +
          g +
          " = 0; " +
          g +
          " < " +
          d +
          ".length; " +
          g +
          "++) { "),
        (f.errorPath = e.util.getPathExpr(
          e.errorPath,
          g,
          e.opts.jsonPointers,
          !0,
        )));
      var F = d + "[" + g + "]";
      f.dataPathArr[_] = g;
      var I = e.validate(f);
      ((f.baseId = b),
        e.util.varOccurences(I, v) < 2
          ? (s += " " + e.util.varReplace(I, v, F) + " ")
          : (s += " var " + v + " = " + F + "; " + I + " "),
        u && (s += " if (!" + h + ") break; "),
        (s += " }"));
    }
    return (u && (s += " " + y + " if (" + p + " == errors) {"), s);
  };
});
var Jv = j((Ufe, JI) => {
  "use strict";
  JI.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.schemaPath + e.util.getProperty(r),
      l = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      b,
      d = "data" + (i || ""),
      m = e.opts.$data && o && o.$data,
      p;
    m
      ? ((s +=
          " var schema" +
          a +
          " = " +
          e.util.getData(o.$data, i, e.dataPathArr) +
          "; "),
        (p = "schema" + a))
      : (p = o);
    var f = r == "maximum",
      y = f ? "exclusiveMaximum" : "exclusiveMinimum",
      h = e.schema[y],
      g = e.opts.$data && h && h.$data,
      _ = f ? "<" : ">",
      v = f ? ">" : "<",
      b = void 0;
    if (!(m || typeof o == "number" || o === void 0))
      throw new Error(r + " must be number");
    if (!(g || h === void 0 || typeof h == "number" || typeof h == "boolean"))
      throw new Error(y + " must be number or boolean");
    if (g) {
      var x = e.util.getData(h.$data, i, e.dataPathArr),
        w = "exclusive" + a,
        S = "exclType" + a,
        C = "exclIsNumber" + a,
        P = "op" + a,
        A = "' + " + P + " + '";
      ((s += " var schemaExcl" + a + " = " + x + "; "),
        (x = "schemaExcl" + a),
        (s +=
          " var " +
          w +
          "; var " +
          S +
          " = typeof " +
          x +
          "; if (" +
          S +
          " != 'boolean' && " +
          S +
          " != 'undefined' && " +
          S +
          " != 'number') { "));
      var b = y,
        R = R || [];
      (R.push(s),
        (s = ""),
        e.createErrors !== !1
          ? ((s +=
              " { keyword: '" +
              (b || "_exclusiveLimit") +
              "' , dataPath: (dataPath || '') + " +
              e.errorPath +
              " , schemaPath: " +
              e.util.toQuotedString(l) +
              " , params: {} "),
            e.opts.messages !== !1 &&
              (s += " , message: '" + y + " should be boolean' "),
            e.opts.verbose &&
              (s +=
                " , schema: validate.schema" +
                c +
                " , parentSchema: validate.schema" +
                e.schemaPath +
                " , data: " +
                d +
                " "),
            (s += " } "))
          : (s += " {} "));
      var D = s;
      ((s = R.pop()),
        !e.compositeRule && u
          ? e.async
            ? (s += " throw new ValidationError([" + D + "]); ")
            : (s += " validate.errors = [" + D + "]; return false; ")
          : (s +=
              " var err = " +
              D +
              ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
        (s += " } else if ( "),
        m &&
          (s +=
            " (" + p + " !== undefined && typeof " + p + " != 'number') || "),
        (s +=
          " " +
          S +
          " == 'number' ? ( (" +
          w +
          " = " +
          p +
          " === undefined || " +
          x +
          " " +
          _ +
          "= " +
          p +
          ") ? " +
          d +
          " " +
          v +
          "= " +
          x +
          " : " +
          d +
          " " +
          v +
          " " +
          p +
          " ) : ( (" +
          w +
          " = " +
          x +
          " === true) ? " +
          d +
          " " +
          v +
          "= " +
          p +
          " : " +
          d +
          " " +
          v +
          " " +
          p +
          " ) || " +
          d +
          " !== " +
          d +
          ") { var op" +
          a +
          " = " +
          w +
          " ? '" +
          _ +
          "' : '" +
          _ +
          "='; "),
        o === void 0 &&
          ((b = y), (l = e.errSchemaPath + "/" + y), (p = x), (m = g)));
    } else {
      var C = typeof h == "number",
        A = _;
      if (C && m) {
        var P = "'" + A + "'";
        ((s += " if ( "),
          m &&
            (s +=
              " (" + p + " !== undefined && typeof " + p + " != 'number') || "),
          (s +=
            " ( " +
            p +
            " === undefined || " +
            h +
            " " +
            _ +
            "= " +
            p +
            " ? " +
            d +
            " " +
            v +
            "= " +
            h +
            " : " +
            d +
            " " +
            v +
            " " +
            p +
            " ) || " +
            d +
            " !== " +
            d +
            ") { "));
      } else {
        C && o === void 0
          ? ((w = !0),
            (b = y),
            (l = e.errSchemaPath + "/" + y),
            (p = h),
            (v += "="))
          : (C && (p = Math[f ? "min" : "max"](h, o)),
            h === (C ? p : !0)
              ? ((w = !0), (b = y), (l = e.errSchemaPath + "/" + y), (v += "="))
              : ((w = !1), (A += "=")));
        var P = "'" + A + "'";
        ((s += " if ( "),
          m &&
            (s +=
              " (" + p + " !== undefined && typeof " + p + " != 'number') || "),
          (s +=
            " " + d + " " + v + " " + p + " || " + d + " !== " + d + ") { "));
      }
    }
    b = b || r;
    var R = R || [];
    (R.push(s),
      (s = ""),
      e.createErrors !== !1
        ? ((s +=
            " { keyword: '" +
            (b || "_limit") +
            "' , dataPath: (dataPath || '') + " +
            e.errorPath +
            " , schemaPath: " +
            e.util.toQuotedString(l) +
            " , params: { comparison: " +
            P +
            ", limit: " +
            p +
            ", exclusive: " +
            w +
            " } "),
          e.opts.messages !== !1 &&
            ((s += " , message: 'should be " + A + " "),
            m ? (s += "' + " + p) : (s += "" + p + "'")),
          e.opts.verbose &&
            ((s += " , schema:  "),
            m ? (s += "validate.schema" + c) : (s += "" + o),
            (s +=
              "         , parentSchema: validate.schema" +
              e.schemaPath +
              " , data: " +
              d +
              " ")),
          (s += " } "))
        : (s += " {} "));
    var D = s;
    return (
      (s = R.pop()),
      !e.compositeRule && u
        ? e.async
          ? (s += " throw new ValidationError([" + D + "]); ")
          : (s += " validate.errors = [" + D + "]; return false; ")
        : (s +=
            " var err = " +
            D +
            ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
      (s += " } "),
      u && (s += " else { "),
      s
    );
  };
});
var Xv = j((qfe, XI) => {
  "use strict";
  XI.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.schemaPath + e.util.getProperty(r),
      l = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      y,
      d = "data" + (i || ""),
      m = e.opts.$data && o && o.$data,
      p;
    if (
      (m
        ? ((s +=
            " var schema" +
            a +
            " = " +
            e.util.getData(o.$data, i, e.dataPathArr) +
            "; "),
          (p = "schema" + a))
        : (p = o),
      !(m || typeof o == "number"))
    )
      throw new Error(r + " must be number");
    var f = r == "maxItems" ? ">" : "<";
    ((s += "if ( "),
      m &&
        (s += " (" + p + " !== undefined && typeof " + p + " != 'number') || "),
      (s += " " + d + ".length " + f + " " + p + ") { "));
    var y = r,
      h = h || [];
    (h.push(s),
      (s = ""),
      e.createErrors !== !1
        ? ((s +=
            " { keyword: '" +
            (y || "_limitItems") +
            "' , dataPath: (dataPath || '') + " +
            e.errorPath +
            " , schemaPath: " +
            e.util.toQuotedString(l) +
            " , params: { limit: " +
            p +
            " } "),
          e.opts.messages !== !1 &&
            ((s += " , message: 'should NOT have "),
            r == "maxItems" ? (s += "more") : (s += "fewer"),
            (s += " than "),
            m ? (s += "' + " + p + " + '") : (s += "" + o),
            (s += " items' ")),
          e.opts.verbose &&
            ((s += " , schema:  "),
            m ? (s += "validate.schema" + c) : (s += "" + o),
            (s +=
              "         , parentSchema: validate.schema" +
              e.schemaPath +
              " , data: " +
              d +
              " ")),
          (s += " } "))
        : (s += " {} "));
    var g = s;
    return (
      (s = h.pop()),
      !e.compositeRule && u
        ? e.async
          ? (s += " throw new ValidationError([" + g + "]); ")
          : (s += " validate.errors = [" + g + "]; return false; ")
        : (s +=
            " var err = " +
            g +
            ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
      (s += "} "),
      u && (s += " else { "),
      s
    );
  };
});
var Yv = j((zfe, YI) => {
  "use strict";
  YI.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.schemaPath + e.util.getProperty(r),
      l = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      y,
      d = "data" + (i || ""),
      m = e.opts.$data && o && o.$data,
      p;
    if (
      (m
        ? ((s +=
            " var schema" +
            a +
            " = " +
            e.util.getData(o.$data, i, e.dataPathArr) +
            "; "),
          (p = "schema" + a))
        : (p = o),
      !(m || typeof o == "number"))
    )
      throw new Error(r + " must be number");
    var f = r == "maxLength" ? ">" : "<";
    ((s += "if ( "),
      m &&
        (s += " (" + p + " !== undefined && typeof " + p + " != 'number') || "),
      e.opts.unicode === !1
        ? (s += " " + d + ".length ")
        : (s += " ucs2length(" + d + ") "),
      (s += " " + f + " " + p + ") { "));
    var y = r,
      h = h || [];
    (h.push(s),
      (s = ""),
      e.createErrors !== !1
        ? ((s +=
            " { keyword: '" +
            (y || "_limitLength") +
            "' , dataPath: (dataPath || '') + " +
            e.errorPath +
            " , schemaPath: " +
            e.util.toQuotedString(l) +
            " , params: { limit: " +
            p +
            " } "),
          e.opts.messages !== !1 &&
            ((s += " , message: 'should NOT be "),
            r == "maxLength" ? (s += "longer") : (s += "shorter"),
            (s += " than "),
            m ? (s += "' + " + p + " + '") : (s += "" + o),
            (s += " characters' ")),
          e.opts.verbose &&
            ((s += " , schema:  "),
            m ? (s += "validate.schema" + c) : (s += "" + o),
            (s +=
              "         , parentSchema: validate.schema" +
              e.schemaPath +
              " , data: " +
              d +
              " ")),
          (s += " } "))
        : (s += " {} "));
    var g = s;
    return (
      (s = h.pop()),
      !e.compositeRule && u
        ? e.async
          ? (s += " throw new ValidationError([" + g + "]); ")
          : (s += " validate.errors = [" + g + "]; return false; ")
        : (s +=
            " var err = " +
            g +
            ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
      (s += "} "),
      u && (s += " else { "),
      s
    );
  };
});
var Qv = j((Bfe, QI) => {
  "use strict";
  QI.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.schemaPath + e.util.getProperty(r),
      l = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      y,
      d = "data" + (i || ""),
      m = e.opts.$data && o && o.$data,
      p;
    if (
      (m
        ? ((s +=
            " var schema" +
            a +
            " = " +
            e.util.getData(o.$data, i, e.dataPathArr) +
            "; "),
          (p = "schema" + a))
        : (p = o),
      !(m || typeof o == "number"))
    )
      throw new Error(r + " must be number");
    var f = r == "maxProperties" ? ">" : "<";
    ((s += "if ( "),
      m &&
        (s += " (" + p + " !== undefined && typeof " + p + " != 'number') || "),
      (s += " Object.keys(" + d + ").length " + f + " " + p + ") { "));
    var y = r,
      h = h || [];
    (h.push(s),
      (s = ""),
      e.createErrors !== !1
        ? ((s +=
            " { keyword: '" +
            (y || "_limitProperties") +
            "' , dataPath: (dataPath || '') + " +
            e.errorPath +
            " , schemaPath: " +
            e.util.toQuotedString(l) +
            " , params: { limit: " +
            p +
            " } "),
          e.opts.messages !== !1 &&
            ((s += " , message: 'should NOT have "),
            r == "maxProperties" ? (s += "more") : (s += "fewer"),
            (s += " than "),
            m ? (s += "' + " + p + " + '") : (s += "" + o),
            (s += " properties' ")),
          e.opts.verbose &&
            ((s += " , schema:  "),
            m ? (s += "validate.schema" + c) : (s += "" + o),
            (s +=
              "         , parentSchema: validate.schema" +
              e.schemaPath +
              " , data: " +
              d +
              " ")),
          (s += " } "))
        : (s += " {} "));
    var g = s;
    return (
      (s = h.pop()),
      !e.compositeRule && u
        ? e.async
          ? (s += " throw new ValidationError([" + g + "]); ")
          : (s += " validate.errors = [" + g + "]; return false; ")
        : (s +=
            " var err = " +
            g +
            ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
      (s += "} "),
      u && (s += " else { "),
      s
    );
  };
});
var t$ = j((Hfe, e$) => {
  "use strict";
  e$.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.schemaPath + e.util.getProperty(r),
      l = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      d = "data" + (i || ""),
      m = e.opts.$data && o && o.$data,
      p;
    if (
      (m
        ? ((s +=
            " var schema" +
            a +
            " = " +
            e.util.getData(o.$data, i, e.dataPathArr) +
            "; "),
          (p = "schema" + a))
        : (p = o),
      !(m || typeof o == "number"))
    )
      throw new Error(r + " must be number");
    ((s += "var division" + a + ";if ("),
      m &&
        (s += " " + p + " !== undefined && ( typeof " + p + " != 'number' || "),
      (s += " (division" + a + " = " + d + " / " + p + ", "),
      e.opts.multipleOfPrecision
        ? (s +=
            " Math.abs(Math.round(division" +
            a +
            ") - division" +
            a +
            ") > 1e-" +
            e.opts.multipleOfPrecision +
            " ")
        : (s += " division" + a + " !== parseInt(division" + a + ") "),
      (s += " ) "),
      m && (s += "  )  "),
      (s += " ) {   "));
    var f = f || [];
    (f.push(s),
      (s = ""),
      e.createErrors !== !1
        ? ((s +=
            " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " +
            e.errorPath +
            " , schemaPath: " +
            e.util.toQuotedString(l) +
            " , params: { multipleOf: " +
            p +
            " } "),
          e.opts.messages !== !1 &&
            ((s += " , message: 'should be multiple of "),
            m ? (s += "' + " + p) : (s += "" + p + "'")),
          e.opts.verbose &&
            ((s += " , schema:  "),
            m ? (s += "validate.schema" + c) : (s += "" + o),
            (s +=
              "         , parentSchema: validate.schema" +
              e.schemaPath +
              " , data: " +
              d +
              " ")),
          (s += " } "))
        : (s += " {} "));
    var y = s;
    return (
      (s = f.pop()),
      !e.compositeRule && u
        ? e.async
          ? (s += " throw new ValidationError([" + y + "]); ")
          : (s += " validate.errors = [" + y + "]; return false; ")
        : (s +=
            " var err = " +
            y +
            ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
      (s += "} "),
      u && (s += " else { "),
      s
    );
  };
});
var n$ = j((Vfe, r$) => {
  "use strict";
  r$.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.schemaPath + e.util.getProperty(r),
      l = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      d = "data" + (i || ""),
      m = "errs__" + a,
      p = e.util.copy(e);
    p.level++;
    var f = "valid" + p.level;
    if (
      e.opts.strictKeywords
        ? (typeof o == "object" && Object.keys(o).length > 0) || o === !1
        : e.util.schemaHasRules(o, e.RULES.all)
    ) {
      ((p.schema = o),
        (p.schemaPath = c),
        (p.errSchemaPath = l),
        (s += " var " + m + " = errors;  "));
      var y = e.compositeRule;
      ((e.compositeRule = p.compositeRule = !0), (p.createErrors = !1));
      var h;
      (p.opts.allErrors && ((h = p.opts.allErrors), (p.opts.allErrors = !1)),
        (s += " " + e.validate(p) + " "),
        (p.createErrors = !0),
        h && (p.opts.allErrors = h),
        (e.compositeRule = p.compositeRule = y),
        (s += " if (" + f + ") {   "));
      var g = g || [];
      (g.push(s),
        (s = ""),
        e.createErrors !== !1
          ? ((s +=
              " { keyword: 'not' , dataPath: (dataPath || '') + " +
              e.errorPath +
              " , schemaPath: " +
              e.util.toQuotedString(l) +
              " , params: {} "),
            e.opts.messages !== !1 &&
              (s += " , message: 'should NOT be valid' "),
            e.opts.verbose &&
              (s +=
                " , schema: validate.schema" +
                c +
                " , parentSchema: validate.schema" +
                e.schemaPath +
                " , data: " +
                d +
                " "),
            (s += " } "))
          : (s += " {} "));
      var _ = s;
      ((s = g.pop()),
        !e.compositeRule && u
          ? e.async
            ? (s += " throw new ValidationError([" + _ + "]); ")
            : (s += " validate.errors = [" + _ + "]; return false; ")
          : (s +=
              " var err = " +
              _ +
              ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
        (s +=
          " } else {  errors = " +
          m +
          "; if (vErrors !== null) { if (" +
          m +
          ") vErrors.length = " +
          m +
          "; else vErrors = null; } "),
        e.opts.allErrors && (s += " } "));
    } else
      ((s += "  var err =   "),
        e.createErrors !== !1
          ? ((s +=
              " { keyword: 'not' , dataPath: (dataPath || '') + " +
              e.errorPath +
              " , schemaPath: " +
              e.util.toQuotedString(l) +
              " , params: {} "),
            e.opts.messages !== !1 &&
              (s += " , message: 'should NOT be valid' "),
            e.opts.verbose &&
              (s +=
                " , schema: validate.schema" +
                c +
                " , parentSchema: validate.schema" +
                e.schemaPath +
                " , data: " +
                d +
                " "),
            (s += " } "))
          : (s += " {} "),
        (s +=
          ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
        u && (s += " if (false) { "));
    return s;
  };
});
var a$ = j((Zfe, s$) => {
  "use strict";
  s$.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.schemaPath + e.util.getProperty(r),
      l = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      d = "data" + (i || ""),
      m = "valid" + a,
      p = "errs__" + a,
      f = e.util.copy(e),
      y = "";
    f.level++;
    var h = "valid" + f.level,
      g = f.baseId,
      _ = "prevValid" + a,
      v = "passingSchemas" + a;
    s +=
      "var " +
      p +
      " = errors , " +
      _ +
      " = false , " +
      m +
      " = false , " +
      v +
      " = null; ";
    var b = e.compositeRule;
    e.compositeRule = f.compositeRule = !0;
    var x = o;
    if (x)
      for (var w, S = -1, C = x.length - 1; S < C; )
        ((w = x[(S += 1)]),
          (
            e.opts.strictKeywords
              ? (typeof w == "object" && Object.keys(w).length > 0) || w === !1
              : e.util.schemaHasRules(w, e.RULES.all)
          )
            ? ((f.schema = w),
              (f.schemaPath = c + "[" + S + "]"),
              (f.errSchemaPath = l + "/" + S),
              (s += "  " + e.validate(f) + " "),
              (f.baseId = g))
            : (s += " var " + h + " = true; "),
          S &&
            ((s +=
              " if (" +
              h +
              " && " +
              _ +
              ") { " +
              m +
              " = false; " +
              v +
              " = [" +
              v +
              ", " +
              S +
              "]; } else { "),
            (y += "}")),
          (s +=
            " if (" +
            h +
            ") { " +
            m +
            " = " +
            _ +
            " = true; " +
            v +
            " = " +
            S +
            "; }"));
    return (
      (e.compositeRule = f.compositeRule = b),
      (s += "" + y + "if (!" + m + ") {   var err =   "),
      e.createErrors !== !1
        ? ((s +=
            " { keyword: 'oneOf' , dataPath: (dataPath || '') + " +
            e.errorPath +
            " , schemaPath: " +
            e.util.toQuotedString(l) +
            " , params: { passingSchemas: " +
            v +
            " } "),
          e.opts.messages !== !1 &&
            (s += " , message: 'should match exactly one schema in oneOf' "),
          e.opts.verbose &&
            (s +=
              " , schema: validate.schema" +
              c +
              " , parentSchema: validate.schema" +
              e.schemaPath +
              " , data: " +
              d +
              " "),
          (s += " } "))
        : (s += " {} "),
      (s +=
        ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
      !e.compositeRule &&
        u &&
        (e.async
          ? (s += " throw new ValidationError(vErrors); ")
          : (s += " validate.errors = vErrors; return false; ")),
      (s +=
        "} else {  errors = " +
        p +
        "; if (vErrors !== null) { if (" +
        p +
        ") vErrors.length = " +
        p +
        "; else vErrors = null; }"),
      e.opts.allErrors && (s += " } "),
      s
    );
  };
});
var o$ = j((Gfe, i$) => {
  "use strict";
  i$.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.schemaPath + e.util.getProperty(r),
      l = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      d = "data" + (i || ""),
      m = e.opts.$data && o && o.$data,
      p;
    m
      ? ((s +=
          " var schema" +
          a +
          " = " +
          e.util.getData(o.$data, i, e.dataPathArr) +
          "; "),
        (p = "schema" + a))
      : (p = o);
    var f = m ? "(new RegExp(" + p + "))" : e.usePattern(o);
    ((s += "if ( "),
      m &&
        (s += " (" + p + " !== undefined && typeof " + p + " != 'string') || "),
      (s += " !" + f + ".test(" + d + ") ) {   "));
    var y = y || [];
    (y.push(s),
      (s = ""),
      e.createErrors !== !1
        ? ((s +=
            " { keyword: 'pattern' , dataPath: (dataPath || '') + " +
            e.errorPath +
            " , schemaPath: " +
            e.util.toQuotedString(l) +
            " , params: { pattern:  "),
          m ? (s += "" + p) : (s += "" + e.util.toQuotedString(o)),
          (s += "  } "),
          e.opts.messages !== !1 &&
            ((s += ` , message: 'should match pattern "`),
            m ? (s += "' + " + p + " + '") : (s += "" + e.util.escapeQuotes(o)),
            (s += `"' `)),
          e.opts.verbose &&
            ((s += " , schema:  "),
            m
              ? (s += "validate.schema" + c)
              : (s += "" + e.util.toQuotedString(o)),
            (s +=
              "         , parentSchema: validate.schema" +
              e.schemaPath +
              " , data: " +
              d +
              " ")),
          (s += " } "))
        : (s += " {} "));
    var h = s;
    return (
      (s = y.pop()),
      !e.compositeRule && u
        ? e.async
          ? (s += " throw new ValidationError([" + h + "]); ")
          : (s += " validate.errors = [" + h + "]; return false; ")
        : (s +=
            " var err = " +
            h +
            ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
      (s += "} "),
      u && (s += " else { "),
      s
    );
  };
});
var l$ = j((Wfe, c$) => {
  "use strict";
  c$.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.schemaPath + e.util.getProperty(r),
      l = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      d = "data" + (i || ""),
      m = "errs__" + a,
      p = e.util.copy(e),
      f = "";
    p.level++;
    var y = "valid" + p.level,
      h = "key" + a,
      g = "idx" + a,
      _ = (p.dataLevel = e.dataLevel + 1),
      v = "data" + _,
      b = "dataProperties" + a,
      x = Object.keys(o || {}).filter(Q),
      w = e.schema.patternProperties || {},
      S = Object.keys(w).filter(Q),
      C = e.schema.additionalProperties,
      P = x.length || S.length,
      A = C === !1,
      R = typeof C == "object" && Object.keys(C).length,
      D = e.opts.removeAdditional,
      F = A || R || D,
      I = e.opts.ownProperties,
      K = e.baseId,
      ee = e.schema.required;
    if (ee && !(e.opts.$data && ee.$data) && ee.length < e.opts.loopRequired)
      var Y = e.util.toHash(ee);
    function Q(lr) {
      return lr !== "__proto__";
    }
    if (
      ((s += "var " + m + " = errors;var " + y + " = true;"),
      I && (s += " var " + b + " = undefined;"),
      F)
    ) {
      if (
        (I
          ? (s +=
              " " +
              b +
              " = " +
              b +
              " || Object.keys(" +
              d +
              "); for (var " +
              g +
              "=0; " +
              g +
              "<" +
              b +
              ".length; " +
              g +
              "++) { var " +
              h +
              " = " +
              b +
              "[" +
              g +
              "]; ")
          : (s += " for (var " + h + " in " + d + ") { "),
        P)
      ) {
        if (((s += " var isAdditional" + a + " = !(false "), x.length))
          if (x.length > 8)
            s += " || validate.schema" + c + ".hasOwnProperty(" + h + ") ";
          else {
            var ae = x;
            if (ae)
              for (var B, $ = -1, G = ae.length - 1; $ < G; )
                ((B = ae[($ += 1)]),
                  (s += " || " + h + " == " + e.util.toQuotedString(B) + " "));
          }
        if (S.length) {
          var U = S;
          if (U)
            for (var T, O = -1, H = U.length - 1; O < H; )
              ((T = U[(O += 1)]),
                (s += " || " + e.usePattern(T) + ".test(" + h + ") "));
        }
        s += " ); if (isAdditional" + a + ") { ";
      }
      if (D == "all") s += " delete " + d + "[" + h + "]; ";
      else {
        var ce = e.errorPath,
          oe = "' + " + h + " + '";
        if (
          (e.opts._errorDataPathProperty &&
            (e.errorPath = e.util.getPathExpr(
              e.errorPath,
              h,
              e.opts.jsonPointers,
            )),
          A)
        )
          if (D) s += " delete " + d + "[" + h + "]; ";
          else {
            s += " " + y + " = false; ";
            var Fe = l;
            l = e.errSchemaPath + "/additionalProperties";
            var Ee = Ee || [];
            (Ee.push(s),
              (s = ""),
              e.createErrors !== !1
                ? ((s +=
                    " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " +
                    e.errorPath +
                    " , schemaPath: " +
                    e.util.toQuotedString(l) +
                    " , params: { additionalProperty: '" +
                    oe +
                    "' } "),
                  e.opts.messages !== !1 &&
                    ((s += " , message: '"),
                    e.opts._errorDataPathProperty
                      ? (s += "is an invalid additional property")
                      : (s += "should NOT have additional properties"),
                    (s += "' ")),
                  e.opts.verbose &&
                    (s +=
                      " , schema: false , parentSchema: validate.schema" +
                      e.schemaPath +
                      " , data: " +
                      d +
                      " "),
                  (s += " } "))
                : (s += " {} "));
            var Me = s;
            ((s = Ee.pop()),
              !e.compositeRule && u
                ? e.async
                  ? (s += " throw new ValidationError([" + Me + "]); ")
                  : (s += " validate.errors = [" + Me + "]; return false; ")
                : (s +=
                    " var err = " +
                    Me +
                    ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
              (l = Fe),
              u && (s += " break; "));
          }
        else if (R)
          if (D == "failing") {
            s += " var " + m + " = errors;  ";
            var q = e.compositeRule;
            ((e.compositeRule = p.compositeRule = !0),
              (p.schema = C),
              (p.schemaPath = e.schemaPath + ".additionalProperties"),
              (p.errSchemaPath = e.errSchemaPath + "/additionalProperties"),
              (p.errorPath = e.opts._errorDataPathProperty
                ? e.errorPath
                : e.util.getPathExpr(e.errorPath, h, e.opts.jsonPointers)));
            var z = d + "[" + h + "]";
            p.dataPathArr[_] = h;
            var Z = e.validate(p);
            ((p.baseId = K),
              e.util.varOccurences(Z, v) < 2
                ? (s += " " + e.util.varReplace(Z, v, z) + " ")
                : (s += " var " + v + " = " + z + "; " + Z + " "),
              (s +=
                " if (!" +
                y +
                ") { errors = " +
                m +
                "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " +
                d +
                "[" +
                h +
                "]; }  "),
              (e.compositeRule = p.compositeRule = q));
          } else {
            ((p.schema = C),
              (p.schemaPath = e.schemaPath + ".additionalProperties"),
              (p.errSchemaPath = e.errSchemaPath + "/additionalProperties"),
              (p.errorPath = e.opts._errorDataPathProperty
                ? e.errorPath
                : e.util.getPathExpr(e.errorPath, h, e.opts.jsonPointers)));
            var z = d + "[" + h + "]";
            p.dataPathArr[_] = h;
            var Z = e.validate(p);
            ((p.baseId = K),
              e.util.varOccurences(Z, v) < 2
                ? (s += " " + e.util.varReplace(Z, v, z) + " ")
                : (s += " var " + v + " = " + z + "; " + Z + " "),
              u && (s += " if (!" + y + ") break; "));
          }
        e.errorPath = ce;
      }
      (P && (s += " } "),
        (s += " }  "),
        u && ((s += " if (" + y + ") { "), (f += "}")));
    }
    var te = e.opts.useDefaults && !e.compositeRule;
    if (x.length) {
      var fe = x;
      if (fe)
        for (var B, je = -1, wt = fe.length - 1; je < wt; ) {
          B = fe[(je += 1)];
          var dt = o[B];
          if (
            e.opts.strictKeywords
              ? (typeof dt == "object" && Object.keys(dt).length > 0) ||
                dt === !1
              : e.util.schemaHasRules(dt, e.RULES.all)
          ) {
            var vt = e.util.getProperty(B),
              z = d + vt,
              pt = te && dt.default !== void 0;
            ((p.schema = dt),
              (p.schemaPath = c + vt),
              (p.errSchemaPath = l + "/" + e.util.escapeFragment(B)),
              (p.errorPath = e.util.getPath(
                e.errorPath,
                B,
                e.opts.jsonPointers,
              )),
              (p.dataPathArr[_] = e.util.toQuotedString(B)));
            var Z = e.validate(p);
            if (((p.baseId = K), e.util.varOccurences(Z, v) < 2)) {
              Z = e.util.varReplace(Z, v, z);
              var et = z;
            } else {
              var et = v;
              s += " var " + v + " = " + z + "; ";
            }
            if (pt) s += " " + Z + " ";
            else {
              if (Y && Y[B]) {
                ((s += " if ( " + et + " === undefined "),
                  I &&
                    (s +=
                      " || ! Object.prototype.hasOwnProperty.call(" +
                      d +
                      ", '" +
                      e.util.escapeQuotes(B) +
                      "') "),
                  (s += ") { " + y + " = false; "));
                var ce = e.errorPath,
                  Fe = l,
                  er = e.util.escapeQuotes(B);
                (e.opts._errorDataPathProperty &&
                  (e.errorPath = e.util.getPath(ce, B, e.opts.jsonPointers)),
                  (l = e.errSchemaPath + "/required"));
                var Ee = Ee || [];
                (Ee.push(s),
                  (s = ""),
                  e.createErrors !== !1
                    ? ((s +=
                        " { keyword: 'required' , dataPath: (dataPath || '') + " +
                        e.errorPath +
                        " , schemaPath: " +
                        e.util.toQuotedString(l) +
                        " , params: { missingProperty: '" +
                        er +
                        "' } "),
                      e.opts.messages !== !1 &&
                        ((s += " , message: '"),
                        e.opts._errorDataPathProperty
                          ? (s += "is a required property")
                          : (s +=
                              "should have required property \\'" + er + "\\'"),
                        (s += "' ")),
                      e.opts.verbose &&
                        (s +=
                          " , schema: validate.schema" +
                          c +
                          " , parentSchema: validate.schema" +
                          e.schemaPath +
                          " , data: " +
                          d +
                          " "),
                      (s += " } "))
                    : (s += " {} "));
                var Me = s;
                ((s = Ee.pop()),
                  !e.compositeRule && u
                    ? e.async
                      ? (s += " throw new ValidationError([" + Me + "]); ")
                      : (s += " validate.errors = [" + Me + "]; return false; ")
                    : (s +=
                        " var err = " +
                        Me +
                        ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
                  (l = Fe),
                  (e.errorPath = ce),
                  (s += " } else { "));
              } else
                u
                  ? ((s += " if ( " + et + " === undefined "),
                    I &&
                      (s +=
                        " || ! Object.prototype.hasOwnProperty.call(" +
                        d +
                        ", '" +
                        e.util.escapeQuotes(B) +
                        "') "),
                    (s += ") { " + y + " = true; } else { "))
                  : ((s += " if (" + et + " !== undefined "),
                    I &&
                      (s +=
                        " &&   Object.prototype.hasOwnProperty.call(" +
                        d +
                        ", '" +
                        e.util.escapeQuotes(B) +
                        "') "),
                    (s += " ) { "));
              s += " " + Z + " } ";
            }
          }
          u && ((s += " if (" + y + ") { "), (f += "}"));
        }
    }
    if (S.length) {
      var bt = S;
      if (bt)
        for (var T, hs = -1, Fn = bt.length - 1; hs < Fn; ) {
          T = bt[(hs += 1)];
          var dt = w[T];
          if (
            e.opts.strictKeywords
              ? (typeof dt == "object" && Object.keys(dt).length > 0) ||
                dt === !1
              : e.util.schemaHasRules(dt, e.RULES.all)
          ) {
            ((p.schema = dt),
              (p.schemaPath =
                e.schemaPath + ".patternProperties" + e.util.getProperty(T)),
              (p.errSchemaPath =
                e.errSchemaPath +
                "/patternProperties/" +
                e.util.escapeFragment(T)),
              I
                ? (s +=
                    " " +
                    b +
                    " = " +
                    b +
                    " || Object.keys(" +
                    d +
                    "); for (var " +
                    g +
                    "=0; " +
                    g +
                    "<" +
                    b +
                    ".length; " +
                    g +
                    "++) { var " +
                    h +
                    " = " +
                    b +
                    "[" +
                    g +
                    "]; ")
                : (s += " for (var " + h + " in " + d + ") { "),
              (s += " if (" + e.usePattern(T) + ".test(" + h + ")) { "),
              (p.errorPath = e.util.getPathExpr(
                e.errorPath,
                h,
                e.opts.jsonPointers,
              )));
            var z = d + "[" + h + "]";
            p.dataPathArr[_] = h;
            var Z = e.validate(p);
            ((p.baseId = K),
              e.util.varOccurences(Z, v) < 2
                ? (s += " " + e.util.varReplace(Z, v, z) + " ")
                : (s += " var " + v + " = " + z + "; " + Z + " "),
              u && (s += " if (!" + y + ") break; "),
              (s += " } "),
              u && (s += " else " + y + " = true; "),
              (s += " }  "),
              u && ((s += " if (" + y + ") { "), (f += "}")));
          }
        }
    }
    return (u && (s += " " + f + " if (" + m + " == errors) {"), s);
  };
});
var d$ = j((Kfe, u$) => {
  "use strict";
  u$.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.schemaPath + e.util.getProperty(r),
      l = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      d = "data" + (i || ""),
      m = "errs__" + a,
      p = e.util.copy(e),
      f = "";
    p.level++;
    var y = "valid" + p.level;
    if (
      ((s += "var " + m + " = errors;"),
      e.opts.strictKeywords
        ? (typeof o == "object" && Object.keys(o).length > 0) || o === !1
        : e.util.schemaHasRules(o, e.RULES.all))
    ) {
      ((p.schema = o), (p.schemaPath = c), (p.errSchemaPath = l));
      var h = "key" + a,
        g = "idx" + a,
        _ = "i" + a,
        v = "' + " + h + " + '",
        b = (p.dataLevel = e.dataLevel + 1),
        x = "data" + b,
        w = "dataProperties" + a,
        S = e.opts.ownProperties,
        C = e.baseId;
      (S && (s += " var " + w + " = undefined; "),
        S
          ? (s +=
              " " +
              w +
              " = " +
              w +
              " || Object.keys(" +
              d +
              "); for (var " +
              g +
              "=0; " +
              g +
              "<" +
              w +
              ".length; " +
              g +
              "++) { var " +
              h +
              " = " +
              w +
              "[" +
              g +
              "]; ")
          : (s += " for (var " + h + " in " + d + ") { "),
        (s += " var startErrs" + a + " = errors; "));
      var P = h,
        A = e.compositeRule;
      e.compositeRule = p.compositeRule = !0;
      var R = e.validate(p);
      ((p.baseId = C),
        e.util.varOccurences(R, x) < 2
          ? (s += " " + e.util.varReplace(R, x, P) + " ")
          : (s += " var " + x + " = " + P + "; " + R + " "),
        (e.compositeRule = p.compositeRule = A),
        (s +=
          " if (!" +
          y +
          ") { for (var " +
          _ +
          "=startErrs" +
          a +
          "; " +
          _ +
          "<errors; " +
          _ +
          "++) { vErrors[" +
          _ +
          "].propertyName = " +
          h +
          "; }   var err =   "),
        e.createErrors !== !1
          ? ((s +=
              " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " +
              e.errorPath +
              " , schemaPath: " +
              e.util.toQuotedString(l) +
              " , params: { propertyName: '" +
              v +
              "' } "),
            e.opts.messages !== !1 &&
              (s += " , message: 'property name \\'" + v + "\\' is invalid' "),
            e.opts.verbose &&
              (s +=
                " , schema: validate.schema" +
                c +
                " , parentSchema: validate.schema" +
                e.schemaPath +
                " , data: " +
                d +
                " "),
            (s += " } "))
          : (s += " {} "),
        (s +=
          ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
        !e.compositeRule &&
          u &&
          (e.async
            ? (s += " throw new ValidationError(vErrors); ")
            : (s += " validate.errors = vErrors; return false; ")),
        u && (s += " break; "),
        (s += " } }"));
    }
    return (u && (s += " " + f + " if (" + m + " == errors) {"), s);
  };
});
var f$ = j((Jfe, p$) => {
  "use strict";
  p$.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.schemaPath + e.util.getProperty(r),
      l = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      d = "data" + (i || ""),
      m = "valid" + a,
      p = e.opts.$data && o && o.$data,
      f;
    p
      ? ((s +=
          " var schema" +
          a +
          " = " +
          e.util.getData(o.$data, i, e.dataPathArr) +
          "; "),
        (f = "schema" + a))
      : (f = o);
    var y = "schema" + a;
    if (!p)
      if (
        o.length < e.opts.loopRequired &&
        e.schema.properties &&
        Object.keys(e.schema.properties).length
      ) {
        var h = [],
          g = o;
        if (g)
          for (var _, v = -1, b = g.length - 1; v < b; ) {
            _ = g[(v += 1)];
            var x = e.schema.properties[_];
            (x &&
              (e.opts.strictKeywords
                ? (typeof x == "object" && Object.keys(x).length > 0) ||
                  x === !1
                : e.util.schemaHasRules(x, e.RULES.all))) ||
              (h[h.length] = _);
          }
      } else var h = o;
    if (p || h.length) {
      var w = e.errorPath,
        S = p || h.length >= e.opts.loopRequired,
        C = e.opts.ownProperties;
      if (u)
        if (((s += " var missing" + a + "; "), S)) {
          p || (s += " var " + y + " = validate.schema" + c + "; ");
          var P = "i" + a,
            A = "schema" + a + "[" + P + "]",
            R = "' + " + A + " + '";
          (e.opts._errorDataPathProperty &&
            (e.errorPath = e.util.getPathExpr(w, A, e.opts.jsonPointers)),
            (s += " var " + m + " = true; "),
            p &&
              (s +=
                " if (schema" +
                a +
                " === undefined) " +
                m +
                " = true; else if (!Array.isArray(schema" +
                a +
                ")) " +
                m +
                " = false; else {"),
            (s +=
              " for (var " +
              P +
              " = 0; " +
              P +
              " < " +
              y +
              ".length; " +
              P +
              "++) { " +
              m +
              " = " +
              d +
              "[" +
              y +
              "[" +
              P +
              "]] !== undefined "),
            C &&
              (s +=
                " &&   Object.prototype.hasOwnProperty.call(" +
                d +
                ", " +
                y +
                "[" +
                P +
                "]) "),
            (s += "; if (!" + m + ") break; } "),
            p && (s += "  }  "),
            (s += "  if (!" + m + ") {   "));
          var D = D || [];
          (D.push(s),
            (s = ""),
            e.createErrors !== !1
              ? ((s +=
                  " { keyword: 'required' , dataPath: (dataPath || '') + " +
                  e.errorPath +
                  " , schemaPath: " +
                  e.util.toQuotedString(l) +
                  " , params: { missingProperty: '" +
                  R +
                  "' } "),
                e.opts.messages !== !1 &&
                  ((s += " , message: '"),
                  e.opts._errorDataPathProperty
                    ? (s += "is a required property")
                    : (s += "should have required property \\'" + R + "\\'"),
                  (s += "' ")),
                e.opts.verbose &&
                  (s +=
                    " , schema: validate.schema" +
                    c +
                    " , parentSchema: validate.schema" +
                    e.schemaPath +
                    " , data: " +
                    d +
                    " "),
                (s += " } "))
              : (s += " {} "));
          var F = s;
          ((s = D.pop()),
            !e.compositeRule && u
              ? e.async
                ? (s += " throw new ValidationError([" + F + "]); ")
                : (s += " validate.errors = [" + F + "]; return false; ")
              : (s +=
                  " var err = " +
                  F +
                  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
            (s += " } else { "));
        } else {
          s += " if ( ";
          var I = h;
          if (I)
            for (var K, P = -1, ee = I.length - 1; P < ee; ) {
              ((K = I[(P += 1)]), P && (s += " || "));
              var Y = e.util.getProperty(K),
                Q = d + Y;
              ((s += " ( ( " + Q + " === undefined "),
                C &&
                  (s +=
                    " || ! Object.prototype.hasOwnProperty.call(" +
                    d +
                    ", '" +
                    e.util.escapeQuotes(K) +
                    "') "),
                (s +=
                  ") && (missing" +
                  a +
                  " = " +
                  e.util.toQuotedString(e.opts.jsonPointers ? K : Y) +
                  ") ) "));
            }
          s += ") {  ";
          var A = "missing" + a,
            R = "' + " + A + " + '";
          e.opts._errorDataPathProperty &&
            (e.errorPath = e.opts.jsonPointers
              ? e.util.getPathExpr(w, A, !0)
              : w + " + " + A);
          var D = D || [];
          (D.push(s),
            (s = ""),
            e.createErrors !== !1
              ? ((s +=
                  " { keyword: 'required' , dataPath: (dataPath || '') + " +
                  e.errorPath +
                  " , schemaPath: " +
                  e.util.toQuotedString(l) +
                  " , params: { missingProperty: '" +
                  R +
                  "' } "),
                e.opts.messages !== !1 &&
                  ((s += " , message: '"),
                  e.opts._errorDataPathProperty
                    ? (s += "is a required property")
                    : (s += "should have required property \\'" + R + "\\'"),
                  (s += "' ")),
                e.opts.verbose &&
                  (s +=
                    " , schema: validate.schema" +
                    c +
                    " , parentSchema: validate.schema" +
                    e.schemaPath +
                    " , data: " +
                    d +
                    " "),
                (s += " } "))
              : (s += " {} "));
          var F = s;
          ((s = D.pop()),
            !e.compositeRule && u
              ? e.async
                ? (s += " throw new ValidationError([" + F + "]); ")
                : (s += " validate.errors = [" + F + "]; return false; ")
              : (s +=
                  " var err = " +
                  F +
                  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
            (s += " } else { "));
        }
      else if (S) {
        p || (s += " var " + y + " = validate.schema" + c + "; ");
        var P = "i" + a,
          A = "schema" + a + "[" + P + "]",
          R = "' + " + A + " + '";
        (e.opts._errorDataPathProperty &&
          (e.errorPath = e.util.getPathExpr(w, A, e.opts.jsonPointers)),
          p &&
            ((s +=
              " if (" + y + " && !Array.isArray(" + y + ")) {  var err =   "),
            e.createErrors !== !1
              ? ((s +=
                  " { keyword: 'required' , dataPath: (dataPath || '') + " +
                  e.errorPath +
                  " , schemaPath: " +
                  e.util.toQuotedString(l) +
                  " , params: { missingProperty: '" +
                  R +
                  "' } "),
                e.opts.messages !== !1 &&
                  ((s += " , message: '"),
                  e.opts._errorDataPathProperty
                    ? (s += "is a required property")
                    : (s += "should have required property \\'" + R + "\\'"),
                  (s += "' ")),
                e.opts.verbose &&
                  (s +=
                    " , schema: validate.schema" +
                    c +
                    " , parentSchema: validate.schema" +
                    e.schemaPath +
                    " , data: " +
                    d +
                    " "),
                (s += " } "))
              : (s += " {} "),
            (s +=
              ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" +
              y +
              " !== undefined) { ")),
          (s +=
            " for (var " +
            P +
            " = 0; " +
            P +
            " < " +
            y +
            ".length; " +
            P +
            "++) { if (" +
            d +
            "[" +
            y +
            "[" +
            P +
            "]] === undefined "),
          C &&
            (s +=
              " || ! Object.prototype.hasOwnProperty.call(" +
              d +
              ", " +
              y +
              "[" +
              P +
              "]) "),
          (s += ") {  var err =   "),
          e.createErrors !== !1
            ? ((s +=
                " { keyword: 'required' , dataPath: (dataPath || '') + " +
                e.errorPath +
                " , schemaPath: " +
                e.util.toQuotedString(l) +
                " , params: { missingProperty: '" +
                R +
                "' } "),
              e.opts.messages !== !1 &&
                ((s += " , message: '"),
                e.opts._errorDataPathProperty
                  ? (s += "is a required property")
                  : (s += "should have required property \\'" + R + "\\'"),
                (s += "' ")),
              e.opts.verbose &&
                (s +=
                  " , schema: validate.schema" +
                  c +
                  " , parentSchema: validate.schema" +
                  e.schemaPath +
                  " , data: " +
                  d +
                  " "),
              (s += " } "))
            : (s += " {} "),
          (s +=
            ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } "),
          p && (s += "  }  "));
      } else {
        var ae = h;
        if (ae)
          for (var K, B = -1, $ = ae.length - 1; B < $; ) {
            K = ae[(B += 1)];
            var Y = e.util.getProperty(K),
              R = e.util.escapeQuotes(K),
              Q = d + Y;
            (e.opts._errorDataPathProperty &&
              (e.errorPath = e.util.getPath(w, K, e.opts.jsonPointers)),
              (s += " if ( " + Q + " === undefined "),
              C &&
                (s +=
                  " || ! Object.prototype.hasOwnProperty.call(" +
                  d +
                  ", '" +
                  e.util.escapeQuotes(K) +
                  "') "),
              (s += ") {  var err =   "),
              e.createErrors !== !1
                ? ((s +=
                    " { keyword: 'required' , dataPath: (dataPath || '') + " +
                    e.errorPath +
                    " , schemaPath: " +
                    e.util.toQuotedString(l) +
                    " , params: { missingProperty: '" +
                    R +
                    "' } "),
                  e.opts.messages !== !1 &&
                    ((s += " , message: '"),
                    e.opts._errorDataPathProperty
                      ? (s += "is a required property")
                      : (s += "should have required property \\'" + R + "\\'"),
                    (s += "' ")),
                  e.opts.verbose &&
                    (s +=
                      " , schema: validate.schema" +
                      c +
                      " , parentSchema: validate.schema" +
                      e.schemaPath +
                      " , data: " +
                      d +
                      " "),
                  (s += " } "))
                : (s += " {} "),
              (s +=
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } "));
          }
      }
      e.errorPath = w;
    } else u && (s += " if (true) {");
    return s;
  };
});
var h$ = j((Xfe, m$) => {
  "use strict";
  m$.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.schemaPath + e.util.getProperty(r),
      l = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      d = "data" + (i || ""),
      m = "valid" + a,
      p = e.opts.$data && o && o.$data,
      f;
    if (
      (p
        ? ((s +=
            " var schema" +
            a +
            " = " +
            e.util.getData(o.$data, i, e.dataPathArr) +
            "; "),
          (f = "schema" + a))
        : (f = o),
      (o || p) && e.opts.uniqueItems !== !1)
    ) {
      (p &&
        (s +=
          " var " +
          m +
          "; if (" +
          f +
          " === false || " +
          f +
          " === undefined) " +
          m +
          " = true; else if (typeof " +
          f +
          " != 'boolean') " +
          m +
          " = false; else { "),
        (s +=
          " var i = " + d + ".length , " + m + " = true , j; if (i > 1) { "));
      var y = e.schema.items && e.schema.items.type,
        h = Array.isArray(y);
      if (
        !y ||
        y == "object" ||
        y == "array" ||
        (h && (y.indexOf("object") >= 0 || y.indexOf("array") >= 0))
      )
        s +=
          " outer: for (;i--;) { for (j = i; j--;) { if (equal(" +
          d +
          "[i], " +
          d +
          "[j])) { " +
          m +
          " = false; break outer; } } } ";
      else {
        s +=
          " var itemIndices = {}, item; for (;i--;) { var item = " +
          d +
          "[i]; ";
        var g = "checkDataType" + (h ? "s" : "");
        ((s +=
          " if (" +
          e.util[g](y, "item", e.opts.strictNumbers, !0) +
          ") continue; "),
          h && (s += ` if (typeof item == 'string') item = '"' + item; `),
          (s +=
            " if (typeof itemIndices[item] == 'number') { " +
            m +
            " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } "));
      }
      ((s += " } "), p && (s += "  }  "), (s += " if (!" + m + ") {   "));
      var _ = _ || [];
      (_.push(s),
        (s = ""),
        e.createErrors !== !1
          ? ((s +=
              " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " +
              e.errorPath +
              " , schemaPath: " +
              e.util.toQuotedString(l) +
              " , params: { i: i, j: j } "),
            e.opts.messages !== !1 &&
              (s +=
                " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' "),
            e.opts.verbose &&
              ((s += " , schema:  "),
              p ? (s += "validate.schema" + c) : (s += "" + o),
              (s +=
                "         , parentSchema: validate.schema" +
                e.schemaPath +
                " , data: " +
                d +
                " ")),
            (s += " } "))
          : (s += " {} "));
      var v = s;
      ((s = _.pop()),
        !e.compositeRule && u
          ? e.async
            ? (s += " throw new ValidationError([" + v + "]); ")
            : (s += " validate.errors = [" + v + "]; return false; ")
          : (s +=
              " var err = " +
              v +
              ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
        (s += " } "),
        u && (s += " else { "));
    } else u && (s += " if (true) { ");
    return s;
  };
});
var v$ = j((Yfe, g$) => {
  "use strict";
  g$.exports = {
    $ref: RI(),
    allOf: II(),
    anyOf: AI(),
    $comment: DI(),
    const: MI(),
    contains: FI(),
    dependencies: qI(),
    enum: BI(),
    format: VI(),
    if: GI(),
    items: KI(),
    maximum: Jv(),
    minimum: Jv(),
    maxItems: Xv(),
    minItems: Xv(),
    maxLength: Yv(),
    minLength: Yv(),
    maxProperties: Qv(),
    minProperties: Qv(),
    multipleOf: t$(),
    not: n$(),
    oneOf: a$(),
    pattern: o$(),
    properties: l$(),
    propertyNames: d$(),
    required: f$(),
    uniqueItems: h$(),
    validate: Wv(),
  };
});
var _$ = j((Qfe, b$) => {
  "use strict";
  var y$ = v$(),
    ey = Da().toHash;
  b$.exports = function () {
    var e = [
        {
          type: "number",
          rules: [
            { maximum: ["exclusiveMaximum"] },
            { minimum: ["exclusiveMinimum"] },
            "multipleOf",
            "format",
          ],
        },
        {
          type: "string",
          rules: ["maxLength", "minLength", "pattern", "format"],
        },
        {
          type: "array",
          rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"],
        },
        {
          type: "object",
          rules: [
            "maxProperties",
            "minProperties",
            "required",
            "dependencies",
            "propertyNames",
            { properties: ["additionalProperties", "patternProperties"] },
          ],
        },
        {
          rules: [
            "$ref",
            "const",
            "enum",
            "not",
            "anyOf",
            "oneOf",
            "allOf",
            "if",
          ],
        },
      ],
      r = ["type", "$comment"],
      n = [
        "$schema",
        "$id",
        "id",
        "$data",
        "$async",
        "title",
        "description",
        "default",
        "definitions",
        "examples",
        "readOnly",
        "writeOnly",
        "contentMediaType",
        "contentEncoding",
        "additionalItems",
        "then",
        "else",
      ],
      s = ["number", "integer", "string", "array", "object", "boolean", "null"];
    return (
      (e.all = ey(r)),
      (e.types = ey(s)),
      e.forEach(function (a) {
        ((a.rules = a.rules.map(function (i) {
          var o;
          if (typeof i == "object") {
            var c = Object.keys(i)[0];
            ((o = i[c]),
              (i = c),
              o.forEach(function (u) {
                (r.push(u), (e.all[u] = !0));
              }));
          }
          r.push(i);
          var l = (e.all[i] = { keyword: i, code: y$[i], implements: o });
          return l;
        })),
          (e.all.$comment = { keyword: "$comment", code: y$.$comment }),
          a.type && (e.types[a.type] = a));
      }),
      (e.keywords = ey(r.concat(n))),
      (e.custom = {}),
      e
    );
  };
});
var S$ = j((eme, w$) => {
  "use strict";
  var x$ = [
    "multipleOf",
    "maximum",
    "exclusiveMaximum",
    "minimum",
    "exclusiveMinimum",
    "maxLength",
    "minLength",
    "pattern",
    "additionalItems",
    "maxItems",
    "minItems",
    "uniqueItems",
    "maxProperties",
    "minProperties",
    "required",
    "additionalProperties",
    "enum",
    "format",
    "const",
  ];
  w$.exports = function (t, e) {
    for (var r = 0; r < e.length; r++) {
      t = JSON.parse(JSON.stringify(t));
      var n = e[r].split("/"),
        s = t,
        a;
      for (a = 1; a < n.length; a++) s = s[n[a]];
      for (a = 0; a < x$.length; a++) {
        var i = x$[a],
          o = s[i];
        o &&
          (s[i] = {
            anyOf: [
              o,
              {
                $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
              },
            ],
          });
      }
    }
    return t;
  };
});
var C$ = j((tme, T$) => {
  "use strict";
  var TX = ep().MissingRef;
  T$.exports = E$;
  function E$(t, e, r) {
    var n = this;
    if (typeof this._opts.loadSchema != "function")
      throw new Error("options.loadSchema should be a function");
    typeof e == "function" && ((r = e), (e = void 0));
    var s = a(t).then(function () {
      var o = n._addSchema(t, void 0, e);
      return o.validate || i(o);
    });
    return (
      r &&
        s.then(function (o) {
          r(null, o);
        }, r),
      s
    );
    function a(o) {
      var c = o.$schema;
      return c && !n.getSchema(c)
        ? E$.call(n, { $ref: c }, !0)
        : Promise.resolve();
    }
    function i(o) {
      try {
        return n._compile(o);
      } catch (l) {
        if (l instanceof TX) return c(l);
        throw l;
      }
      function c(l) {
        var u = l.missingSchema;
        if (p(u))
          throw new Error(
            "Schema " +
              u +
              " is loaded but " +
              l.missingRef +
              " cannot be resolved",
          );
        var d = n._loadingSchemas[u];
        return (
          d ||
            ((d = n._loadingSchemas[u] = n._opts.loadSchema(u)), d.then(m, m)),
          d
            .then(function (f) {
              if (!p(u))
                return a(f).then(function () {
                  p(u) || n.addSchema(f, u, void 0, e);
                });
            })
            .then(function () {
              return i(o);
            })
        );
        function m() {
          delete n._loadingSchemas[u];
        }
        function p(f) {
          return n._refs[f] || n._schemas[f];
        }
      }
    }
  }
});
var k$ = j((rme, P$) => {
  "use strict";
  P$.exports = function (e, r, n) {
    var s = " ",
      a = e.level,
      i = e.dataLevel,
      o = e.schema[r],
      c = e.schemaPath + e.util.getProperty(r),
      l = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      d,
      m = "data" + (i || ""),
      p = "valid" + a,
      f = "errs__" + a,
      y = e.opts.$data && o && o.$data,
      h;
    y
      ? ((s +=
          " var schema" +
          a +
          " = " +
          e.util.getData(o.$data, i, e.dataPathArr) +
          "; "),
        (h = "schema" + a))
      : (h = o);
    var g = this,
      _ = "definition" + a,
      v = g.definition,
      b = "",
      x,
      w,
      S,
      C,
      P;
    if (y && v.$data) {
      P = "keywordValidate" + a;
      var A = v.validateSchema;
      s +=
        " var " +
        _ +
        " = RULES.custom['" +
        r +
        "'].definition; var " +
        P +
        " = " +
        _ +
        ".validate;";
    } else {
      if (((C = e.useCustomRule(g, o, e.schema, e)), !C)) return;
      ((h = "validate.schema" + c),
        (P = C.code),
        (x = v.compile),
        (w = v.inline),
        (S = v.macro));
    }
    var R = P + ".errors",
      D = "i" + a,
      F = "ruleErr" + a,
      I = v.async;
    if (I && !e.async) throw new Error("async keyword in sync schema");
    if (
      (w || S || (s += "" + R + " = null;"),
      (s += "var " + f + " = errors;var " + p + ";"),
      y &&
        v.$data &&
        ((b += "}"),
        (s += " if (" + h + " === undefined) { " + p + " = true; } else { "),
        A &&
          ((b += "}"),
          (s +=
            " " +
            p +
            " = " +
            _ +
            ".validateSchema(" +
            h +
            "); if (" +
            p +
            ") { "))),
      w)
    )
      v.statements
        ? (s += " " + C.validate + " ")
        : (s += " " + p + " = " + C.validate + "; ");
    else if (S) {
      var K = e.util.copy(e),
        b = "";
      K.level++;
      var ee = "valid" + K.level;
      ((K.schema = C.validate), (K.schemaPath = ""));
      var Y = e.compositeRule;
      e.compositeRule = K.compositeRule = !0;
      var Q = e.validate(K).replace(/validate\.schema/g, P);
      ((e.compositeRule = K.compositeRule = Y), (s += " " + Q));
    } else {
      var ae = ae || [];
      (ae.push(s),
        (s = ""),
        (s += "  " + P + ".call( "),
        e.opts.passContext ? (s += "this") : (s += "self"),
        x || v.schema === !1
          ? (s += " , " + m + " ")
          : (s +=
              " , " +
              h +
              " , " +
              m +
              " , validate.schema" +
              e.schemaPath +
              " "),
        (s += " , (dataPath || '')"),
        e.errorPath != '""' && (s += " + " + e.errorPath));
      var B = i ? "data" + (i - 1 || "") : "parentData",
        $ = i ? e.dataPathArr[i] : "parentDataProperty";
      s += " , " + B + " , " + $ + " , rootData )  ";
      var G = s;
      ((s = ae.pop()),
        v.errors === !1
          ? ((s += " " + p + " = "), I && (s += "await "), (s += "" + G + "; "))
          : I
            ? ((R = "customErrors" + a),
              (s +=
                " var " +
                R +
                " = null; try { " +
                p +
                " = await " +
                G +
                "; } catch (e) { " +
                p +
                " = false; if (e instanceof ValidationError) " +
                R +
                " = e.errors; else throw e; } "))
            : (s += " " + R + " = null; " + p + " = " + G + "; "));
    }
    if (
      (v.modifying &&
        (s += " if (" + B + ") " + m + " = " + B + "[" + $ + "];"),
      (s += "" + b),
      v.valid)
    )
      u && (s += " if (true) { ");
    else {
      ((s += " if ( "),
        v.valid === void 0
          ? ((s += " !"), S ? (s += "" + ee) : (s += "" + p))
          : (s += " " + !v.valid + " "),
        (s += ") { "),
        (d = g.keyword));
      var ae = ae || [];
      (ae.push(s), (s = ""));
      var ae = ae || [];
      (ae.push(s),
        (s = ""),
        e.createErrors !== !1
          ? ((s +=
              " { keyword: '" +
              (d || "custom") +
              "' , dataPath: (dataPath || '') + " +
              e.errorPath +
              " , schemaPath: " +
              e.util.toQuotedString(l) +
              " , params: { keyword: '" +
              g.keyword +
              "' } "),
            e.opts.messages !== !1 &&
              (s +=
                ` , message: 'should pass "` +
                g.keyword +
                `" keyword validation' `),
            e.opts.verbose &&
              (s +=
                " , schema: validate.schema" +
                c +
                " , parentSchema: validate.schema" +
                e.schemaPath +
                " , data: " +
                m +
                " "),
            (s += " } "))
          : (s += " {} "));
      var U = s;
      ((s = ae.pop()),
        !e.compositeRule && u
          ? e.async
            ? (s += " throw new ValidationError([" + U + "]); ")
            : (s += " validate.errors = [" + U + "]; return false; ")
          : (s +=
              " var err = " +
              U +
              ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "));
      var T = s;
      ((s = ae.pop()),
        w
          ? v.errors
            ? v.errors != "full" &&
              ((s +=
                "  for (var " +
                D +
                "=" +
                f +
                "; " +
                D +
                "<errors; " +
                D +
                "++) { var " +
                F +
                " = vErrors[" +
                D +
                "]; if (" +
                F +
                ".dataPath === undefined) " +
                F +
                ".dataPath = (dataPath || '') + " +
                e.errorPath +
                "; if (" +
                F +
                ".schemaPath === undefined) { " +
                F +
                '.schemaPath = "' +
                l +
                '"; } '),
              e.opts.verbose &&
                (s +=
                  " " +
                  F +
                  ".schema = " +
                  h +
                  "; " +
                  F +
                  ".data = " +
                  m +
                  "; "),
              (s += " } "))
            : v.errors === !1
              ? (s += " " + T + " ")
              : ((s +=
                  " if (" +
                  f +
                  " == errors) { " +
                  T +
                  " } else {  for (var " +
                  D +
                  "=" +
                  f +
                  "; " +
                  D +
                  "<errors; " +
                  D +
                  "++) { var " +
                  F +
                  " = vErrors[" +
                  D +
                  "]; if (" +
                  F +
                  ".dataPath === undefined) " +
                  F +
                  ".dataPath = (dataPath || '') + " +
                  e.errorPath +
                  "; if (" +
                  F +
                  ".schemaPath === undefined) { " +
                  F +
                  '.schemaPath = "' +
                  l +
                  '"; } '),
                e.opts.verbose &&
                  (s +=
                    " " +
                    F +
                    ".schema = " +
                    h +
                    "; " +
                    F +
                    ".data = " +
                    m +
                    "; "),
                (s += " } } "))
          : S
            ? ((s += "   var err =   "),
              e.createErrors !== !1
                ? ((s +=
                    " { keyword: '" +
                    (d || "custom") +
                    "' , dataPath: (dataPath || '') + " +
                    e.errorPath +
                    " , schemaPath: " +
                    e.util.toQuotedString(l) +
                    " , params: { keyword: '" +
                    g.keyword +
                    "' } "),
                  e.opts.messages !== !1 &&
                    (s +=
                      ` , message: 'should pass "` +
                      g.keyword +
                      `" keyword validation' `),
                  e.opts.verbose &&
                    (s +=
                      " , schema: validate.schema" +
                      c +
                      " , parentSchema: validate.schema" +
                      e.schemaPath +
                      " , data: " +
                      m +
                      " "),
                  (s += " } "))
                : (s += " {} "),
              (s +=
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
              !e.compositeRule &&
                u &&
                (e.async
                  ? (s += " throw new ValidationError(vErrors); ")
                  : (s += " validate.errors = vErrors; return false; ")))
            : v.errors === !1
              ? (s += " " + T + " ")
              : ((s +=
                  " if (Array.isArray(" +
                  R +
                  ")) { if (vErrors === null) vErrors = " +
                  R +
                  "; else vErrors = vErrors.concat(" +
                  R +
                  "); errors = vErrors.length;  for (var " +
                  D +
                  "=" +
                  f +
                  "; " +
                  D +
                  "<errors; " +
                  D +
                  "++) { var " +
                  F +
                  " = vErrors[" +
                  D +
                  "]; if (" +
                  F +
                  ".dataPath === undefined) " +
                  F +
                  ".dataPath = (dataPath || '') + " +
                  e.errorPath +
                  ";  " +
                  F +
                  '.schemaPath = "' +
                  l +
                  '";  '),
                e.opts.verbose &&
                  (s +=
                    " " +
                    F +
                    ".schema = " +
                    h +
                    "; " +
                    F +
                    ".data = " +
                    m +
                    "; "),
                (s += " } } else { " + T + " } ")),
        (s += " } "),
        u && (s += " else { "));
    }
    return s;
  };
});
var ty = j((nme, CX) => {
  CX.exports = {
    $schema: "http://json-schema.org/draft-07/schema#",
    $id: "http://json-schema.org/draft-07/schema#",
    title: "Core schema meta-schema",
    definitions: {
      schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } },
      nonNegativeInteger: { type: "integer", minimum: 0 },
      nonNegativeIntegerDefault0: {
        allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }],
      },
      simpleTypes: {
        enum: [
          "array",
          "boolean",
          "integer",
          "null",
          "number",
          "object",
          "string",
        ],
      },
      stringArray: {
        type: "array",
        items: { type: "string" },
        uniqueItems: !0,
        default: [],
      },
    },
    type: ["object", "boolean"],
    properties: {
      $id: { type: "string", format: "uri-reference" },
      $schema: { type: "string", format: "uri" },
      $ref: { type: "string", format: "uri-reference" },
      $comment: { type: "string" },
      title: { type: "string" },
      description: { type: "string" },
      default: !0,
      readOnly: { type: "boolean", default: !1 },
      examples: { type: "array", items: !0 },
      multipleOf: { type: "number", exclusiveMinimum: 0 },
      maximum: { type: "number" },
      exclusiveMaximum: { type: "number" },
      minimum: { type: "number" },
      exclusiveMinimum: { type: "number" },
      maxLength: { $ref: "#/definitions/nonNegativeInteger" },
      minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      pattern: { type: "string", format: "regex" },
      additionalItems: { $ref: "#" },
      items: {
        anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
        default: !0,
      },
      maxItems: { $ref: "#/definitions/nonNegativeInteger" },
      minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      uniqueItems: { type: "boolean", default: !1 },
      contains: { $ref: "#" },
      maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
      minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      required: { $ref: "#/definitions/stringArray" },
      additionalProperties: { $ref: "#" },
      definitions: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {},
      },
      properties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {},
      },
      patternProperties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        propertyNames: { format: "regex" },
        default: {},
      },
      dependencies: {
        type: "object",
        additionalProperties: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }],
        },
      },
      propertyNames: { $ref: "#" },
      const: !0,
      enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 },
      type: {
        anyOf: [
          { $ref: "#/definitions/simpleTypes" },
          {
            type: "array",
            items: { $ref: "#/definitions/simpleTypes" },
            minItems: 1,
            uniqueItems: !0,
          },
        ],
      },
      format: { type: "string" },
      contentMediaType: { type: "string" },
      contentEncoding: { type: "string" },
      if: { $ref: "#" },
      then: { $ref: "#" },
      else: { $ref: "#" },
      allOf: { $ref: "#/definitions/schemaArray" },
      anyOf: { $ref: "#/definitions/schemaArray" },
      oneOf: { $ref: "#/definitions/schemaArray" },
      not: { $ref: "#" },
    },
    default: !0,
  };
});
var I$ = j((sme, O$) => {
  "use strict";
  var R$ = ty();
  O$.exports = {
    $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
    definitions: { simpleTypes: R$.definitions.simpleTypes },
    type: "object",
    dependencies: {
      schema: ["validate"],
      $data: ["validate"],
      statements: ["inline"],
      valid: { not: { required: ["macro"] } },
    },
    properties: {
      type: R$.properties.type,
      schema: { type: "boolean" },
      statements: { type: "boolean" },
      dependencies: { type: "array", items: { type: "string" } },
      metaSchema: { type: "object" },
      modifying: { type: "boolean" },
      valid: { type: "boolean" },
      $data: { type: "boolean" },
      async: { type: "boolean" },
      errors: { anyOf: [{ type: "boolean" }, { const: "full" }] },
    },
  };
});
var A$ = j((ame, $$) => {
  "use strict";
  var PX = /^[a-z_$][a-z0-9_$-]*$/i,
    kX = k$(),
    RX = I$();
  $$.exports = { add: OX, get: IX, remove: $X, validate: ry };
  function OX(t, e) {
    var r = this.RULES;
    if (r.keywords[t]) throw new Error("Keyword " + t + " is already defined");
    if (!PX.test(t))
      throw new Error("Keyword " + t + " is not a valid identifier");
    if (e) {
      this.validateKeyword(e, !0);
      var n = e.type;
      if (Array.isArray(n)) for (var s = 0; s < n.length; s++) i(t, n[s], e);
      else i(t, n, e);
      var a = e.metaSchema;
      a &&
        (e.$data &&
          this._opts.$data &&
          (a = {
            anyOf: [
              a,
              {
                $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
              },
            ],
          }),
        (e.validateSchema = this.compile(a, !0)));
    }
    r.keywords[t] = r.all[t] = !0;
    function i(o, c, l) {
      for (var u, d = 0; d < r.length; d++) {
        var m = r[d];
        if (m.type == c) {
          u = m;
          break;
        }
      }
      u || ((u = { type: c, rules: [] }), r.push(u));
      var p = {
        keyword: o,
        definition: l,
        custom: !0,
        code: kX,
        implements: l.implements,
      };
      (u.rules.push(p), (r.custom[o] = p));
    }
    return this;
  }
  function IX(t) {
    var e = this.RULES.custom[t];
    return e ? e.definition : this.RULES.keywords[t] || !1;
  }
  function $X(t) {
    var e = this.RULES;
    (delete e.keywords[t], delete e.all[t], delete e.custom[t]);
    for (var r = 0; r < e.length; r++)
      for (var n = e[r].rules, s = 0; s < n.length; s++)
        if (n[s].keyword == t) {
          n.splice(s, 1);
          break;
        }
    return this;
  }
  function ry(t, e) {
    ry.errors = null;
    var r = (this._validateKeyword =
      this._validateKeyword || this.compile(RX, !0));
    if (r(t)) return !0;
    if (((ry.errors = r.errors), e))
      throw new Error(
        "custom keyword definition is invalid: " + this.errorsText(r.errors),
      );
    return !1;
  }
});
var N$ = j((ime, AX) => {
  AX.exports = {
    $schema: "http://json-schema.org/draft-07/schema#",
    $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    description:
      "Meta-schema for $data reference (JSON Schema extension proposal)",
    type: "object",
    required: ["$data"],
    properties: {
      $data: {
        type: "string",
        anyOf: [
          { format: "relative-json-pointer" },
          { format: "json-pointer" },
        ],
      },
    },
    additionalProperties: !1,
  };
});
var sy = j((ome, B$) => {
  "use strict";
  var L$ = fI(),
    La = Qd(),
    NX = hI(),
    M$ = qv(),
    DX = Gv(),
    LX = PI(),
    MX = _$(),
    j$ = S$(),
    F$ = Da();
  B$.exports = Mt;
  Mt.prototype.validate = FX;
  Mt.prototype.compile = UX;
  Mt.prototype.addSchema = qX;
  Mt.prototype.addMetaSchema = zX;
  Mt.prototype.validateSchema = BX;
  Mt.prototype.getSchema = VX;
  Mt.prototype.removeSchema = GX;
  Mt.prototype.addFormat = tY;
  Mt.prototype.errorsText = eY;
  Mt.prototype._addSchema = WX;
  Mt.prototype._compile = KX;
  Mt.prototype.compileAsync = C$();
  var cp = A$();
  Mt.prototype.addKeyword = cp.add;
  Mt.prototype.getKeyword = cp.get;
  Mt.prototype.removeKeyword = cp.remove;
  Mt.prototype.validateKeyword = cp.validate;
  var U$ = ep();
  Mt.ValidationError = U$.Validation;
  Mt.MissingRefError = U$.MissingRef;
  Mt.$dataMetaSchema = j$;
  var op = "http://json-schema.org/draft-07/schema",
    D$ = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"],
    jX = ["/properties"];
  function Mt(t) {
    if (!(this instanceof Mt)) return new Mt(t);
    ((t = this._opts = F$.copy(t) || {}),
      oY(this),
      (this._schemas = {}),
      (this._refs = {}),
      (this._fragments = {}),
      (this._formats = LX(t.format)),
      (this._cache = t.cache || new NX()),
      (this._loadingSchemas = {}),
      (this._compilations = []),
      (this.RULES = MX()),
      (this._getId = JX(t)),
      (t.loopRequired = t.loopRequired || 1 / 0),
      t.errorDataPath == "property" && (t._errorDataPathProperty = !0),
      t.serialize === void 0 && (t.serialize = DX),
      (this._metaOpts = iY(this)),
      t.formats && sY(this),
      t.keywords && aY(this),
      rY(this),
      typeof t.meta == "object" && this.addMetaSchema(t.meta),
      t.nullable &&
        this.addKeyword("nullable", { metaSchema: { type: "boolean" } }),
      nY(this));
  }
  function FX(t, e) {
    var r;
    if (typeof t == "string") {
      if (((r = this.getSchema(t)), !r))
        throw new Error('no schema with key or ref "' + t + '"');
    } else {
      var n = this._addSchema(t);
      r = n.validate || this._compile(n);
    }
    var s = r(e);
    return (r.$async !== !0 && (this.errors = r.errors), s);
  }
  function UX(t, e) {
    var r = this._addSchema(t, void 0, e);
    return r.validate || this._compile(r);
  }
  function qX(t, e, r, n) {
    if (Array.isArray(t)) {
      for (var s = 0; s < t.length; s++) this.addSchema(t[s], void 0, r, n);
      return this;
    }
    var a = this._getId(t);
    if (a !== void 0 && typeof a != "string")
      throw new Error("schema id must be string");
    return (
      (e = La.normalizeId(e || a)),
      z$(this, e),
      (this._schemas[e] = this._addSchema(t, r, n, !0)),
      this
    );
  }
  function zX(t, e, r) {
    return (this.addSchema(t, e, r, !0), this);
  }
  function BX(t, e) {
    var r = t.$schema;
    if (r !== void 0 && typeof r != "string")
      throw new Error("$schema must be a string");
    if (((r = r || this._opts.defaultMeta || HX(this)), !r))
      return (
        this.logger.warn("meta-schema not available"),
        (this.errors = null),
        !0
      );
    var n = this.validate(r, t);
    if (!n && e) {
      var s = "schema is invalid: " + this.errorsText();
      if (this._opts.validateSchema == "log") this.logger.error(s);
      else throw new Error(s);
    }
    return n;
  }
  function HX(t) {
    var e = t._opts.meta;
    return (
      (t._opts.defaultMeta =
        typeof e == "object"
          ? t._getId(e) || e
          : t.getSchema(op)
            ? op
            : void 0),
      t._opts.defaultMeta
    );
  }
  function VX(t) {
    var e = q$(this, t);
    switch (typeof e) {
      case "object":
        return e.validate || this._compile(e);
      case "string":
        return this.getSchema(e);
      case "undefined":
        return ZX(this, t);
    }
  }
  function ZX(t, e) {
    var r = La.schema.call(t, { schema: {} }, e);
    if (r) {
      var n = r.schema,
        s = r.root,
        a = r.baseId,
        i = L$.call(t, n, s, void 0, a);
      return (
        (t._fragments[e] = new M$({
          ref: e,
          fragment: !0,
          schema: n,
          root: s,
          baseId: a,
          validate: i,
        })),
        i
      );
    }
  }
  function q$(t, e) {
    return (
      (e = La.normalizeId(e)),
      t._schemas[e] || t._refs[e] || t._fragments[e]
    );
  }
  function GX(t) {
    if (t instanceof RegExp)
      return (ip(this, this._schemas, t), ip(this, this._refs, t), this);
    switch (typeof t) {
      case "undefined":
        return (
          ip(this, this._schemas),
          ip(this, this._refs),
          this._cache.clear(),
          this
        );
      case "string":
        var e = q$(this, t);
        return (
          e && this._cache.del(e.cacheKey),
          delete this._schemas[t],
          delete this._refs[t],
          this
        );
      case "object":
        var r = this._opts.serialize,
          n = r ? r(t) : t;
        this._cache.del(n);
        var s = this._getId(t);
        s &&
          ((s = La.normalizeId(s)),
          delete this._schemas[s],
          delete this._refs[s]);
    }
    return this;
  }
  function ip(t, e, r) {
    for (var n in e) {
      var s = e[n];
      !s.meta && (!r || r.test(n)) && (t._cache.del(s.cacheKey), delete e[n]);
    }
  }
  function WX(t, e, r, n) {
    if (typeof t != "object" && typeof t != "boolean")
      throw new Error("schema should be object or boolean");
    var s = this._opts.serialize,
      a = s ? s(t) : t,
      i = this._cache.get(a);
    if (i) return i;
    n = n || this._opts.addUsedSchema !== !1;
    var o = La.normalizeId(this._getId(t));
    o && n && z$(this, o);
    var c = this._opts.validateSchema !== !1 && !e,
      l;
    c &&
      !(l = o && o == La.normalizeId(t.$schema)) &&
      this.validateSchema(t, !0);
    var u = La.ids.call(this, t),
      d = new M$({ id: o, schema: t, localRefs: u, cacheKey: a, meta: r });
    return (
      o[0] != "#" && n && (this._refs[o] = d),
      this._cache.put(a, d),
      c && l && this.validateSchema(t, !0),
      d
    );
  }
  function KX(t, e) {
    if (t.compiling)
      return (
        (t.validate = s),
        (s.schema = t.schema),
        (s.errors = null),
        (s.root = e || s),
        t.schema.$async === !0 && (s.$async = !0),
        s
      );
    t.compiling = !0;
    var r;
    t.meta && ((r = this._opts), (this._opts = this._metaOpts));
    var n;
    try {
      n = L$.call(this, t.schema, e, t.localRefs);
    } catch (a) {
      throw (delete t.validate, a);
    } finally {
      ((t.compiling = !1), t.meta && (this._opts = r));
    }
    return (
      (t.validate = n),
      (t.refs = n.refs),
      (t.refVal = n.refVal),
      (t.root = n.root),
      n
    );
    function s() {
      var a = t.validate,
        i = a.apply(this, arguments);
      return ((s.errors = a.errors), i);
    }
  }
  function JX(t) {
    switch (t.schemaId) {
      case "auto":
        return QX;
      case "id":
        return XX;
      default:
        return YX;
    }
  }
  function XX(t) {
    return (t.$id && this.logger.warn("schema $id ignored", t.$id), t.id);
  }
  function YX(t) {
    return (t.id && this.logger.warn("schema id ignored", t.id), t.$id);
  }
  function QX(t) {
    if (t.$id && t.id && t.$id != t.id)
      throw new Error("schema $id is different from id");
    return t.$id || t.id;
  }
  function eY(t, e) {
    if (((t = t || this.errors), !t)) return "No errors";
    e = e || {};
    for (
      var r = e.separator === void 0 ? ", " : e.separator,
        n = e.dataVar === void 0 ? "data" : e.dataVar,
        s = "",
        a = 0;
      a < t.length;
      a++
    ) {
      var i = t[a];
      i && (s += n + i.dataPath + " " + i.message + r);
    }
    return s.slice(0, -r.length);
  }
  function tY(t, e) {
    return (
      typeof e == "string" && (e = new RegExp(e)),
      (this._formats[t] = e),
      this
    );
  }
  function rY(t) {
    var e;
    if (
      (t._opts.$data && ((e = N$()), t.addMetaSchema(e, e.$id, !0)),
      t._opts.meta !== !1)
    ) {
      var r = ty();
      (t._opts.$data && (r = j$(r, jX)),
        t.addMetaSchema(r, op, !0),
        (t._refs["http://json-schema.org/schema"] = op));
    }
  }
  function nY(t) {
    var e = t._opts.schemas;
    if (e)
      if (Array.isArray(e)) t.addSchema(e);
      else for (var r in e) t.addSchema(e[r], r);
  }
  function sY(t) {
    for (var e in t._opts.formats) {
      var r = t._opts.formats[e];
      t.addFormat(e, r);
    }
  }
  function aY(t) {
    for (var e in t._opts.keywords) {
      var r = t._opts.keywords[e];
      t.addKeyword(e, r);
    }
  }
  function z$(t, e) {
    if (t._schemas[e] || t._refs[e])
      throw new Error('schema with key or id "' + e + '" already exists');
  }
  function iY(t) {
    for (var e = F$.copy(t._opts), r = 0; r < D$.length; r++) delete e[D$[r]];
    return e;
  }
  function oY(t) {
    var e = t._opts.logger;
    if (e === !1) t.logger = { log: ny, warn: ny, error: ny };
    else {
      if (
        (e === void 0 && (e = console),
        !(typeof e == "object" && e.log && e.warn && e.error))
      )
        throw new Error("logger must implement log, warn and error methods");
      t.logger = e;
    }
  }
  function ny() {}
});
var ls = j((Jve, r1) => {
  "use strict";
  var e1 = ["nodebuffer", "arraybuffer", "fragments"],
    t1 = typeof Blob < "u";
  t1 && e1.push("blob");
  r1.exports = {
    BINARY_TYPES: e1,
    EMPTY_BUFFER: Buffer.alloc(0),
    GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    hasBlob: t1,
    kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
    kListener: Symbol("kListener"),
    kStatusCode: Symbol("status-code"),
    kWebSocket: Symbol("websocket"),
    NOOP: () => {},
  };
});
var Xc = j((Xve, Cp) => {
  "use strict";
  var { EMPTY_BUFFER: jY } = ls(),
    by = Buffer[Symbol.species];
  function FY(t, e) {
    if (t.length === 0) return jY;
    if (t.length === 1) return t[0];
    let r = Buffer.allocUnsafe(e),
      n = 0;
    for (let s = 0; s < t.length; s++) {
      let a = t[s];
      (r.set(a, n), (n += a.length));
    }
    return n < e ? new by(r.buffer, r.byteOffset, n) : r;
  }
  function n1(t, e, r, n, s) {
    for (let a = 0; a < s; a++) r[n + a] = t[a] ^ e[a & 3];
  }
  function s1(t, e) {
    for (let r = 0; r < t.length; r++) t[r] ^= e[r & 3];
  }
  function UY(t) {
    return t.length === t.buffer.byteLength
      ? t.buffer
      : t.buffer.slice(t.byteOffset, t.byteOffset + t.length);
  }
  function _y(t) {
    if (((_y.readOnly = !0), Buffer.isBuffer(t))) return t;
    let e;
    return (
      t instanceof ArrayBuffer
        ? (e = new by(t))
        : ArrayBuffer.isView(t)
          ? (e = new by(t.buffer, t.byteOffset, t.byteLength))
          : ((e = Buffer.from(t)), (_y.readOnly = !1)),
      e
    );
  }
  Cp.exports = {
    concat: FY,
    mask: n1,
    toArrayBuffer: UY,
    toBuffer: _y,
    unmask: s1,
  };
  if (!process.env.WS_NO_BUFFER_UTIL)
    try {
      let t = require("bufferutil");
      ((Cp.exports.mask = function (e, r, n, s, a) {
        a < 48 ? n1(e, r, n, s, a) : t.mask(e, r, n, s, a);
      }),
        (Cp.exports.unmask = function (e, r) {
          e.length < 32 ? s1(e, r) : t.unmask(e, r);
        }));
    } catch {}
});
var o1 = j((Yve, i1) => {
  "use strict";
  var a1 = Symbol("kDone"),
    xy = Symbol("kRun"),
    wy = class {
      constructor(e) {
        ((this[a1] = () => {
          (this.pending--, this[xy]());
        }),
          (this.concurrency = e || 1 / 0),
          (this.jobs = []),
          (this.pending = 0));
      }
      add(e) {
        (this.jobs.push(e), this[xy]());
      }
      [xy]() {
        if (this.pending !== this.concurrency && this.jobs.length) {
          let e = this.jobs.shift();
          (this.pending++, e(this[a1]));
        }
      }
    };
  i1.exports = wy;
});
var Qc = j((Qve, d1) => {
  "use strict";
  var Yc = require("zlib"),
    c1 = Xc(),
    qY = o1(),
    { kStatusCode: l1 } = ls(),
    zY = Buffer[Symbol.species],
    BY = Buffer.from([0, 0, 255, 255]),
    kp = Symbol("permessage-deflate"),
    us = Symbol("total-length"),
    lo = Symbol("callback"),
    Bs = Symbol("buffers"),
    uo = Symbol("error"),
    Pp,
    Sy = class {
      constructor(e, r, n) {
        if (
          ((this._maxPayload = n | 0),
          (this._options = e || {}),
          (this._threshold =
            this._options.threshold !== void 0
              ? this._options.threshold
              : 1024),
          (this._isServer = !!r),
          (this._deflate = null),
          (this._inflate = null),
          (this.params = null),
          !Pp)
        ) {
          let s =
            this._options.concurrencyLimit !== void 0
              ? this._options.concurrencyLimit
              : 10;
          Pp = new qY(s);
        }
      }
      static get extensionName() {
        return "permessage-deflate";
      }
      offer() {
        let e = {};
        return (
          this._options.serverNoContextTakeover &&
            (e.server_no_context_takeover = !0),
          this._options.clientNoContextTakeover &&
            (e.client_no_context_takeover = !0),
          this._options.serverMaxWindowBits &&
            (e.server_max_window_bits = this._options.serverMaxWindowBits),
          this._options.clientMaxWindowBits
            ? (e.client_max_window_bits = this._options.clientMaxWindowBits)
            : this._options.clientMaxWindowBits == null &&
              (e.client_max_window_bits = !0),
          e
        );
      }
      accept(e) {
        return (
          (e = this.normalizeParams(e)),
          (this.params = this._isServer
            ? this.acceptAsServer(e)
            : this.acceptAsClient(e)),
          this.params
        );
      }
      cleanup() {
        if (
          (this._inflate && (this._inflate.close(), (this._inflate = null)),
          this._deflate)
        ) {
          let e = this._deflate[lo];
          (this._deflate.close(),
            (this._deflate = null),
            e &&
              e(
                new Error(
                  "The deflate stream was closed while data was being processed",
                ),
              ));
        }
      }
      acceptAsServer(e) {
        let r = this._options,
          n = e.find(
            (s) =>
              !(
                (r.serverNoContextTakeover === !1 &&
                  s.server_no_context_takeover) ||
                (s.server_max_window_bits &&
                  (r.serverMaxWindowBits === !1 ||
                    (typeof r.serverMaxWindowBits == "number" &&
                      r.serverMaxWindowBits > s.server_max_window_bits))) ||
                (typeof r.clientMaxWindowBits == "number" &&
                  !s.client_max_window_bits)
              ),
          );
        if (!n) throw new Error("None of the extension offers can be accepted");
        return (
          r.serverNoContextTakeover && (n.server_no_context_takeover = !0),
          r.clientNoContextTakeover && (n.client_no_context_takeover = !0),
          typeof r.serverMaxWindowBits == "number" &&
            (n.server_max_window_bits = r.serverMaxWindowBits),
          typeof r.clientMaxWindowBits == "number"
            ? (n.client_max_window_bits = r.clientMaxWindowBits)
            : (n.client_max_window_bits === !0 ||
                r.clientMaxWindowBits === !1) &&
              delete n.client_max_window_bits,
          n
        );
      }
      acceptAsClient(e) {
        let r = e[0];
        if (
          this._options.clientNoContextTakeover === !1 &&
          r.client_no_context_takeover
        )
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        if (!r.client_max_window_bits)
          typeof this._options.clientMaxWindowBits == "number" &&
            (r.client_max_window_bits = this._options.clientMaxWindowBits);
        else if (
          this._options.clientMaxWindowBits === !1 ||
          (typeof this._options.clientMaxWindowBits == "number" &&
            r.client_max_window_bits > this._options.clientMaxWindowBits)
        )
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"',
          );
        return r;
      }
      normalizeParams(e) {
        return (
          e.forEach((r) => {
            Object.keys(r).forEach((n) => {
              let s = r[n];
              if (s.length > 1)
                throw new Error(
                  `Parameter "${n}" must have only a single value`,
                );
              if (((s = s[0]), n === "client_max_window_bits")) {
                if (s !== !0) {
                  let a = +s;
                  if (!Number.isInteger(a) || a < 8 || a > 15)
                    throw new TypeError(
                      `Invalid value for parameter "${n}": ${s}`,
                    );
                  s = a;
                } else if (!this._isServer)
                  throw new TypeError(
                    `Invalid value for parameter "${n}": ${s}`,
                  );
              } else if (n === "server_max_window_bits") {
                let a = +s;
                if (!Number.isInteger(a) || a < 8 || a > 15)
                  throw new TypeError(
                    `Invalid value for parameter "${n}": ${s}`,
                  );
                s = a;
              } else if (
                n === "client_no_context_takeover" ||
                n === "server_no_context_takeover"
              ) {
                if (s !== !0)
                  throw new TypeError(
                    `Invalid value for parameter "${n}": ${s}`,
                  );
              } else throw new Error(`Unknown parameter "${n}"`);
              r[n] = s;
            });
          }),
          e
        );
      }
      decompress(e, r, n) {
        Pp.add((s) => {
          this._decompress(e, r, (a, i) => {
            (s(), n(a, i));
          });
        });
      }
      compress(e, r, n) {
        Pp.add((s) => {
          this._compress(e, r, (a, i) => {
            (s(), n(a, i));
          });
        });
      }
      _decompress(e, r, n) {
        let s = this._isServer ? "client" : "server";
        if (!this._inflate) {
          let a = `${s}_max_window_bits`,
            i =
              typeof this.params[a] != "number"
                ? Yc.Z_DEFAULT_WINDOWBITS
                : this.params[a];
          ((this._inflate = Yc.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits: i,
          })),
            (this._inflate[kp] = this),
            (this._inflate[us] = 0),
            (this._inflate[Bs] = []),
            this._inflate.on("error", VY),
            this._inflate.on("data", u1));
        }
        ((this._inflate[lo] = n),
          this._inflate.write(e),
          r && this._inflate.write(BY),
          this._inflate.flush(() => {
            let a = this._inflate[uo];
            if (a) {
              (this._inflate.close(), (this._inflate = null), n(a));
              return;
            }
            let i = c1.concat(this._inflate[Bs], this._inflate[us]);
            (this._inflate._readableState.endEmitted
              ? (this._inflate.close(), (this._inflate = null))
              : ((this._inflate[us] = 0),
                (this._inflate[Bs] = []),
                r &&
                  this.params[`${s}_no_context_takeover`] &&
                  this._inflate.reset()),
              n(null, i));
          }));
      }
      _compress(e, r, n) {
        let s = this._isServer ? "server" : "client";
        if (!this._deflate) {
          let a = `${s}_max_window_bits`,
            i =
              typeof this.params[a] != "number"
                ? Yc.Z_DEFAULT_WINDOWBITS
                : this.params[a];
          ((this._deflate = Yc.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits: i,
          })),
            (this._deflate[us] = 0),
            (this._deflate[Bs] = []),
            this._deflate.on("data", HY));
        }
        ((this._deflate[lo] = n),
          this._deflate.write(e),
          this._deflate.flush(Yc.Z_SYNC_FLUSH, () => {
            if (!this._deflate) return;
            let a = c1.concat(this._deflate[Bs], this._deflate[us]);
            (r && (a = new zY(a.buffer, a.byteOffset, a.length - 4)),
              (this._deflate[lo] = null),
              (this._deflate[us] = 0),
              (this._deflate[Bs] = []),
              r &&
                this.params[`${s}_no_context_takeover`] &&
                this._deflate.reset(),
              n(null, a));
          }));
      }
    };
  d1.exports = Sy;
  function HY(t) {
    (this[Bs].push(t), (this[us] += t.length));
  }
  function u1(t) {
    if (
      ((this[us] += t.length),
      this[kp]._maxPayload < 1 || this[us] <= this[kp]._maxPayload)
    ) {
      this[Bs].push(t);
      return;
    }
    ((this[uo] = new RangeError("Max payload size exceeded")),
      (this[uo].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"),
      (this[uo][l1] = 1009),
      this.removeListener("data", u1),
      this.reset());
  }
  function VY(t) {
    if (((this[kp]._inflate = null), this[uo])) {
      this[lo](this[uo]);
      return;
    }
    ((t[l1] = 1007), this[lo](t));
  }
});
var po = j((eye, Rp) => {
  "use strict";
  var { isUtf8: p1 } = require("buffer"),
    { hasBlob: ZY } = ls(),
    GY = [
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1,
      0, 1, 0,
    ];
  function WY(t) {
    return (
      (t >= 1e3 && t <= 1014 && t !== 1004 && t !== 1005 && t !== 1006) ||
      (t >= 3e3 && t <= 4999)
    );
  }
  function Ey(t) {
    let e = t.length,
      r = 0;
    for (; r < e; )
      if ((t[r] & 128) === 0) r++;
      else if ((t[r] & 224) === 192) {
        if (r + 1 === e || (t[r + 1] & 192) !== 128 || (t[r] & 254) === 192)
          return !1;
        r += 2;
      } else if ((t[r] & 240) === 224) {
        if (
          r + 2 >= e ||
          (t[r + 1] & 192) !== 128 ||
          (t[r + 2] & 192) !== 128 ||
          (t[r] === 224 && (t[r + 1] & 224) === 128) ||
          (t[r] === 237 && (t[r + 1] & 224) === 160)
        )
          return !1;
        r += 3;
      } else if ((t[r] & 248) === 240) {
        if (
          r + 3 >= e ||
          (t[r + 1] & 192) !== 128 ||
          (t[r + 2] & 192) !== 128 ||
          (t[r + 3] & 192) !== 128 ||
          (t[r] === 240 && (t[r + 1] & 240) === 128) ||
          (t[r] === 244 && t[r + 1] > 143) ||
          t[r] > 244
        )
          return !1;
        r += 4;
      } else return !1;
    return !0;
  }
  function KY(t) {
    return (
      ZY &&
      typeof t == "object" &&
      typeof t.arrayBuffer == "function" &&
      typeof t.type == "string" &&
      typeof t.stream == "function" &&
      (t[Symbol.toStringTag] === "Blob" || t[Symbol.toStringTag] === "File")
    );
  }
  Rp.exports = {
    isBlob: KY,
    isValidStatusCode: WY,
    isValidUTF8: Ey,
    tokenChars: GY,
  };
  if (p1)
    Rp.exports.isValidUTF8 = function (t) {
      return t.length < 24 ? Ey(t) : p1(t);
    };
  else if (!process.env.WS_NO_UTF_8_VALIDATE)
    try {
      let t = require("utf-8-validate");
      Rp.exports.isValidUTF8 = function (e) {
        return e.length < 32 ? Ey(e) : t(e);
      };
    } catch {}
});
var Ry = j((tye, b1) => {
  "use strict";
  var { Writable: JY } = require("stream"),
    f1 = Qc(),
    {
      BINARY_TYPES: XY,
      EMPTY_BUFFER: m1,
      kStatusCode: YY,
      kWebSocket: QY,
    } = ls(),
    { concat: Ty, toArrayBuffer: eQ, unmask: tQ } = Xc(),
    { isValidStatusCode: rQ, isValidUTF8: h1 } = po(),
    Op = Buffer[Symbol.species],
    rn = 0,
    g1 = 1,
    v1 = 2,
    y1 = 3,
    Cy = 4,
    Py = 5,
    Ip = 6,
    ky = class extends JY {
      constructor(e = {}) {
        (super(),
          (this._allowSynchronousEvents =
            e.allowSynchronousEvents !== void 0
              ? e.allowSynchronousEvents
              : !0),
          (this._binaryType = e.binaryType || XY[0]),
          (this._extensions = e.extensions || {}),
          (this._isServer = !!e.isServer),
          (this._maxPayload = e.maxPayload | 0),
          (this._skipUTF8Validation = !!e.skipUTF8Validation),
          (this[QY] = void 0),
          (this._bufferedBytes = 0),
          (this._buffers = []),
          (this._compressed = !1),
          (this._payloadLength = 0),
          (this._mask = void 0),
          (this._fragmented = 0),
          (this._masked = !1),
          (this._fin = !1),
          (this._opcode = 0),
          (this._totalPayloadLength = 0),
          (this._messageLength = 0),
          (this._fragments = []),
          (this._errored = !1),
          (this._loop = !1),
          (this._state = rn));
      }
      _write(e, r, n) {
        if (this._opcode === 8 && this._state == rn) return n();
        ((this._bufferedBytes += e.length),
          this._buffers.push(e),
          this.startLoop(n));
      }
      consume(e) {
        if (((this._bufferedBytes -= e), e === this._buffers[0].length))
          return this._buffers.shift();
        if (e < this._buffers[0].length) {
          let n = this._buffers[0];
          return (
            (this._buffers[0] = new Op(
              n.buffer,
              n.byteOffset + e,
              n.length - e,
            )),
            new Op(n.buffer, n.byteOffset, e)
          );
        }
        let r = Buffer.allocUnsafe(e);
        do {
          let n = this._buffers[0],
            s = r.length - e;
          (e >= n.length
            ? r.set(this._buffers.shift(), s)
            : (r.set(new Uint8Array(n.buffer, n.byteOffset, e), s),
              (this._buffers[0] = new Op(
                n.buffer,
                n.byteOffset + e,
                n.length - e,
              ))),
            (e -= n.length));
        } while (e > 0);
        return r;
      }
      startLoop(e) {
        this._loop = !0;
        do
          switch (this._state) {
            case rn:
              this.getInfo(e);
              break;
            case g1:
              this.getPayloadLength16(e);
              break;
            case v1:
              this.getPayloadLength64(e);
              break;
            case y1:
              this.getMask();
              break;
            case Cy:
              this.getData(e);
              break;
            case Py:
            case Ip:
              this._loop = !1;
              return;
          }
        while (this._loop);
        this._errored || e();
      }
      getInfo(e) {
        if (this._bufferedBytes < 2) {
          this._loop = !1;
          return;
        }
        let r = this.consume(2);
        if ((r[0] & 48) !== 0) {
          let s = this.createError(
            RangeError,
            "RSV2 and RSV3 must be clear",
            !0,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3",
          );
          e(s);
          return;
        }
        let n = (r[0] & 64) === 64;
        if (n && !this._extensions[f1.extensionName]) {
          let s = this.createError(
            RangeError,
            "RSV1 must be clear",
            !0,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1",
          );
          e(s);
          return;
        }
        if (
          ((this._fin = (r[0] & 128) === 128),
          (this._opcode = r[0] & 15),
          (this._payloadLength = r[1] & 127),
          this._opcode === 0)
        ) {
          if (n) {
            let s = this.createError(
              RangeError,
              "RSV1 must be clear",
              !0,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1",
            );
            e(s);
            return;
          }
          if (!this._fragmented) {
            let s = this.createError(
              RangeError,
              "invalid opcode 0",
              !0,
              1002,
              "WS_ERR_INVALID_OPCODE",
            );
            e(s);
            return;
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            let s = this.createError(
              RangeError,
              `invalid opcode ${this._opcode}`,
              !0,
              1002,
              "WS_ERR_INVALID_OPCODE",
            );
            e(s);
            return;
          }
          this._compressed = n;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            let s = this.createError(
              RangeError,
              "FIN must be set",
              !0,
              1002,
              "WS_ERR_EXPECTED_FIN",
            );
            e(s);
            return;
          }
          if (n) {
            let s = this.createError(
              RangeError,
              "RSV1 must be clear",
              !0,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1",
            );
            e(s);
            return;
          }
          if (
            this._payloadLength > 125 ||
            (this._opcode === 8 && this._payloadLength === 1)
          ) {
            let s = this.createError(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              !0,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH",
            );
            e(s);
            return;
          }
        } else {
          let s = this.createError(
            RangeError,
            `invalid opcode ${this._opcode}`,
            !0,
            1002,
            "WS_ERR_INVALID_OPCODE",
          );
          e(s);
          return;
        }
        if (
          (!this._fin && !this._fragmented && (this._fragmented = this._opcode),
          (this._masked = (r[1] & 128) === 128),
          this._isServer)
        ) {
          if (!this._masked) {
            let s = this.createError(
              RangeError,
              "MASK must be set",
              !0,
              1002,
              "WS_ERR_EXPECTED_MASK",
            );
            e(s);
            return;
          }
        } else if (this._masked) {
          let s = this.createError(
            RangeError,
            "MASK must be clear",
            !0,
            1002,
            "WS_ERR_UNEXPECTED_MASK",
          );
          e(s);
          return;
        }
        this._payloadLength === 126
          ? (this._state = g1)
          : this._payloadLength === 127
            ? (this._state = v1)
            : this.haveLength(e);
      }
      getPayloadLength16(e) {
        if (this._bufferedBytes < 2) {
          this._loop = !1;
          return;
        }
        ((this._payloadLength = this.consume(2).readUInt16BE(0)),
          this.haveLength(e));
      }
      getPayloadLength64(e) {
        if (this._bufferedBytes < 8) {
          this._loop = !1;
          return;
        }
        let r = this.consume(8),
          n = r.readUInt32BE(0);
        if (n > Math.pow(2, 21) - 1) {
          let s = this.createError(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            !1,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH",
          );
          e(s);
          return;
        }
        ((this._payloadLength = n * Math.pow(2, 32) + r.readUInt32BE(4)),
          this.haveLength(e));
      }
      haveLength(e) {
        if (
          this._payloadLength &&
          this._opcode < 8 &&
          ((this._totalPayloadLength += this._payloadLength),
          this._totalPayloadLength > this._maxPayload && this._maxPayload > 0)
        ) {
          let r = this.createError(
            RangeError,
            "Max payload size exceeded",
            !1,
            1009,
            "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH",
          );
          e(r);
          return;
        }
        this._masked ? (this._state = y1) : (this._state = Cy);
      }
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = !1;
          return;
        }
        ((this._mask = this.consume(4)), (this._state = Cy));
      }
      getData(e) {
        let r = m1;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = !1;
            return;
          }
          ((r = this.consume(this._payloadLength)),
            this._masked &&
              (this._mask[0] |
                this._mask[1] |
                this._mask[2] |
                this._mask[3]) !==
                0 &&
              tQ(r, this._mask));
        }
        if (this._opcode > 7) {
          this.controlMessage(r, e);
          return;
        }
        if (this._compressed) {
          ((this._state = Py), this.decompress(r, e));
          return;
        }
        (r.length &&
          ((this._messageLength = this._totalPayloadLength),
          this._fragments.push(r)),
          this.dataMessage(e));
      }
      decompress(e, r) {
        this._extensions[f1.extensionName].decompress(e, this._fin, (s, a) => {
          if (s) return r(s);
          if (a.length) {
            if (
              ((this._messageLength += a.length),
              this._messageLength > this._maxPayload && this._maxPayload > 0)
            ) {
              let i = this.createError(
                RangeError,
                "Max payload size exceeded",
                !1,
                1009,
                "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH",
              );
              r(i);
              return;
            }
            this._fragments.push(a);
          }
          (this.dataMessage(r), this._state === rn && this.startLoop(r));
        });
      }
      dataMessage(e) {
        if (!this._fin) {
          this._state = rn;
          return;
        }
        let r = this._messageLength,
          n = this._fragments;
        if (
          ((this._totalPayloadLength = 0),
          (this._messageLength = 0),
          (this._fragmented = 0),
          (this._fragments = []),
          this._opcode === 2)
        ) {
          let s;
          (this._binaryType === "nodebuffer"
            ? (s = Ty(n, r))
            : this._binaryType === "arraybuffer"
              ? (s = eQ(Ty(n, r)))
              : this._binaryType === "blob"
                ? (s = new Blob(n))
                : (s = n),
            this._allowSynchronousEvents
              ? (this.emit("message", s, !0), (this._state = rn))
              : ((this._state = Ip),
                setImmediate(() => {
                  (this.emit("message", s, !0),
                    (this._state = rn),
                    this.startLoop(e));
                })));
        } else {
          let s = Ty(n, r);
          if (!this._skipUTF8Validation && !h1(s)) {
            let a = this.createError(
              Error,
              "invalid UTF-8 sequence",
              !0,
              1007,
              "WS_ERR_INVALID_UTF8",
            );
            e(a);
            return;
          }
          this._state === Py || this._allowSynchronousEvents
            ? (this.emit("message", s, !1), (this._state = rn))
            : ((this._state = Ip),
              setImmediate(() => {
                (this.emit("message", s, !1),
                  (this._state = rn),
                  this.startLoop(e));
              }));
        }
      }
      controlMessage(e, r) {
        if (this._opcode === 8) {
          if (e.length === 0)
            ((this._loop = !1), this.emit("conclude", 1005, m1), this.end());
          else {
            let n = e.readUInt16BE(0);
            if (!rQ(n)) {
              let a = this.createError(
                RangeError,
                `invalid status code ${n}`,
                !0,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE",
              );
              r(a);
              return;
            }
            let s = new Op(e.buffer, e.byteOffset + 2, e.length - 2);
            if (!this._skipUTF8Validation && !h1(s)) {
              let a = this.createError(
                Error,
                "invalid UTF-8 sequence",
                !0,
                1007,
                "WS_ERR_INVALID_UTF8",
              );
              r(a);
              return;
            }
            ((this._loop = !1), this.emit("conclude", n, s), this.end());
          }
          this._state = rn;
          return;
        }
        this._allowSynchronousEvents
          ? (this.emit(this._opcode === 9 ? "ping" : "pong", e),
            (this._state = rn))
          : ((this._state = Ip),
            setImmediate(() => {
              (this.emit(this._opcode === 9 ? "ping" : "pong", e),
                (this._state = rn),
                this.startLoop(r));
            }));
      }
      createError(e, r, n, s, a) {
        ((this._loop = !1), (this._errored = !0));
        let i = new e(n ? `Invalid WebSocket frame: ${r}` : r);
        return (
          Error.captureStackTrace(i, this.createError),
          (i.code = a),
          (i[YY] = s),
          i
        );
      }
    };
  b1.exports = ky;
});
var $y = j((nye, w1) => {
  "use strict";
  var { Duplex: rye } = require("stream"),
    { randomFillSync: nQ } = require("crypto"),
    _1 = Qc(),
    { EMPTY_BUFFER: sQ, kWebSocket: aQ, NOOP: iQ } = ls(),
    { isBlob: fo, isValidStatusCode: oQ } = po(),
    { mask: x1, toBuffer: Ma } = Xc(),
    nn = Symbol("kByteLength"),
    cQ = Buffer.alloc(4),
    $p = 8 * 1024,
    ja,
    mo = $p,
    Sn = 0,
    lQ = 1,
    uQ = 2,
    Oy = class t {
      constructor(e, r, n) {
        ((this._extensions = r || {}),
          n && ((this._generateMask = n), (this._maskBuffer = Buffer.alloc(4))),
          (this._socket = e),
          (this._firstFragment = !0),
          (this._compress = !1),
          (this._bufferedBytes = 0),
          (this._queue = []),
          (this._state = Sn),
          (this.onerror = iQ),
          (this[aQ] = void 0));
      }
      static frame(e, r) {
        let n,
          s = !1,
          a = 2,
          i = !1;
        r.mask &&
          ((n = r.maskBuffer || cQ),
          r.generateMask
            ? r.generateMask(n)
            : (mo === $p &&
                (ja === void 0 && (ja = Buffer.alloc($p)),
                nQ(ja, 0, $p),
                (mo = 0)),
              (n[0] = ja[mo++]),
              (n[1] = ja[mo++]),
              (n[2] = ja[mo++]),
              (n[3] = ja[mo++])),
          (i = (n[0] | n[1] | n[2] | n[3]) === 0),
          (a = 6));
        let o;
        typeof e == "string"
          ? (!r.mask || i) && r[nn] !== void 0
            ? (o = r[nn])
            : ((e = Buffer.from(e)), (o = e.length))
          : ((o = e.length), (s = r.mask && r.readOnly && !i));
        let c = o;
        o >= 65536 ? ((a += 8), (c = 127)) : o > 125 && ((a += 2), (c = 126));
        let l = Buffer.allocUnsafe(s ? o + a : a);
        return (
          (l[0] = r.fin ? r.opcode | 128 : r.opcode),
          r.rsv1 && (l[0] |= 64),
          (l[1] = c),
          c === 126
            ? l.writeUInt16BE(o, 2)
            : c === 127 && ((l[2] = l[3] = 0), l.writeUIntBE(o, 4, 6)),
          r.mask
            ? ((l[1] |= 128),
              (l[a - 4] = n[0]),
              (l[a - 3] = n[1]),
              (l[a - 2] = n[2]),
              (l[a - 1] = n[3]),
              i
                ? [l, e]
                : s
                  ? (x1(e, n, l, a, o), [l])
                  : (x1(e, n, e, 0, o), [l, e]))
            : [l, e]
        );
      }
      close(e, r, n, s) {
        let a;
        if (e === void 0) a = sQ;
        else {
          if (typeof e != "number" || !oQ(e))
            throw new TypeError(
              "First argument must be a valid error code number",
            );
          if (r === void 0 || !r.length)
            ((a = Buffer.allocUnsafe(2)), a.writeUInt16BE(e, 0));
          else {
            let o = Buffer.byteLength(r);
            if (o > 123)
              throw new RangeError(
                "The message must not be greater than 123 bytes",
              );
            ((a = Buffer.allocUnsafe(2 + o)),
              a.writeUInt16BE(e, 0),
              typeof r == "string" ? a.write(r, 2) : a.set(r, 2));
          }
        }
        let i = {
          [nn]: a.length,
          fin: !0,
          generateMask: this._generateMask,
          mask: n,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: !1,
          rsv1: !1,
        };
        this._state !== Sn
          ? this.enqueue([this.dispatch, a, !1, i, s])
          : this.sendFrame(t.frame(a, i), s);
      }
      ping(e, r, n) {
        let s, a;
        if (
          (typeof e == "string"
            ? ((s = Buffer.byteLength(e)), (a = !1))
            : fo(e)
              ? ((s = e.size), (a = !1))
              : ((e = Ma(e)), (s = e.length), (a = Ma.readOnly)),
          s > 125)
        )
          throw new RangeError(
            "The data size must not be greater than 125 bytes",
          );
        let i = {
          [nn]: s,
          fin: !0,
          generateMask: this._generateMask,
          mask: r,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly: a,
          rsv1: !1,
        };
        fo(e)
          ? this._state !== Sn
            ? this.enqueue([this.getBlobData, e, !1, i, n])
            : this.getBlobData(e, !1, i, n)
          : this._state !== Sn
            ? this.enqueue([this.dispatch, e, !1, i, n])
            : this.sendFrame(t.frame(e, i), n);
      }
      pong(e, r, n) {
        let s, a;
        if (
          (typeof e == "string"
            ? ((s = Buffer.byteLength(e)), (a = !1))
            : fo(e)
              ? ((s = e.size), (a = !1))
              : ((e = Ma(e)), (s = e.length), (a = Ma.readOnly)),
          s > 125)
        )
          throw new RangeError(
            "The data size must not be greater than 125 bytes",
          );
        let i = {
          [nn]: s,
          fin: !0,
          generateMask: this._generateMask,
          mask: r,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly: a,
          rsv1: !1,
        };
        fo(e)
          ? this._state !== Sn
            ? this.enqueue([this.getBlobData, e, !1, i, n])
            : this.getBlobData(e, !1, i, n)
          : this._state !== Sn
            ? this.enqueue([this.dispatch, e, !1, i, n])
            : this.sendFrame(t.frame(e, i), n);
      }
      send(e, r, n) {
        let s = this._extensions[_1.extensionName],
          a = r.binary ? 2 : 1,
          i = r.compress,
          o,
          c;
        (typeof e == "string"
          ? ((o = Buffer.byteLength(e)), (c = !1))
          : fo(e)
            ? ((o = e.size), (c = !1))
            : ((e = Ma(e)), (o = e.length), (c = Ma.readOnly)),
          this._firstFragment
            ? ((this._firstFragment = !1),
              i &&
                s &&
                s.params[
                  s._isServer
                    ? "server_no_context_takeover"
                    : "client_no_context_takeover"
                ] &&
                (i = o >= s._threshold),
              (this._compress = i))
            : ((i = !1), (a = 0)),
          r.fin && (this._firstFragment = !0));
        let l = {
          [nn]: o,
          fin: r.fin,
          generateMask: this._generateMask,
          mask: r.mask,
          maskBuffer: this._maskBuffer,
          opcode: a,
          readOnly: c,
          rsv1: i,
        };
        fo(e)
          ? this._state !== Sn
            ? this.enqueue([this.getBlobData, e, this._compress, l, n])
            : this.getBlobData(e, this._compress, l, n)
          : this._state !== Sn
            ? this.enqueue([this.dispatch, e, this._compress, l, n])
            : this.dispatch(e, this._compress, l, n);
      }
      getBlobData(e, r, n, s) {
        ((this._bufferedBytes += n[nn]),
          (this._state = uQ),
          e
            .arrayBuffer()
            .then((a) => {
              if (this._socket.destroyed) {
                let o = new Error(
                  "The socket was closed while the blob was being read",
                );
                process.nextTick(Iy, this, o, s);
                return;
              }
              this._bufferedBytes -= n[nn];
              let i = Ma(a);
              r
                ? this.dispatch(i, r, n, s)
                : ((this._state = Sn),
                  this.sendFrame(t.frame(i, n), s),
                  this.dequeue());
            })
            .catch((a) => {
              process.nextTick(dQ, this, a, s);
            }));
      }
      dispatch(e, r, n, s) {
        if (!r) {
          this.sendFrame(t.frame(e, n), s);
          return;
        }
        let a = this._extensions[_1.extensionName];
        ((this._bufferedBytes += n[nn]),
          (this._state = lQ),
          a.compress(e, n.fin, (i, o) => {
            if (this._socket.destroyed) {
              let c = new Error(
                "The socket was closed while data was being compressed",
              );
              Iy(this, c, s);
              return;
            }
            ((this._bufferedBytes -= n[nn]),
              (this._state = Sn),
              (n.readOnly = !1),
              this.sendFrame(t.frame(o, n), s),
              this.dequeue());
          }));
      }
      dequeue() {
        for (; this._state === Sn && this._queue.length; ) {
          let e = this._queue.shift();
          ((this._bufferedBytes -= e[3][nn]),
            Reflect.apply(e[0], this, e.slice(1)));
        }
      }
      enqueue(e) {
        ((this._bufferedBytes += e[3][nn]), this._queue.push(e));
      }
      sendFrame(e, r) {
        e.length === 2
          ? (this._socket.cork(),
            this._socket.write(e[0]),
            this._socket.write(e[1], r),
            this._socket.uncork())
          : this._socket.write(e[0], r);
      }
    };
  w1.exports = Oy;
  function Iy(t, e, r) {
    typeof r == "function" && r(e);
    for (let n = 0; n < t._queue.length; n++) {
      let s = t._queue[n],
        a = s[s.length - 1];
      typeof a == "function" && a(e);
    }
  }
  function dQ(t, e, r) {
    (Iy(t, e, r), t.onerror(e));
  }
});
var I1 = j((sye, O1) => {
  "use strict";
  var { kForOnEventAttribute: el, kListener: Ay } = ls(),
    S1 = Symbol("kCode"),
    E1 = Symbol("kData"),
    T1 = Symbol("kError"),
    C1 = Symbol("kMessage"),
    P1 = Symbol("kReason"),
    ho = Symbol("kTarget"),
    k1 = Symbol("kType"),
    R1 = Symbol("kWasClean"),
    ds = class {
      constructor(e) {
        ((this[ho] = null), (this[k1] = e));
      }
      get target() {
        return this[ho];
      }
      get type() {
        return this[k1];
      }
    };
  Object.defineProperty(ds.prototype, "target", { enumerable: !0 });
  Object.defineProperty(ds.prototype, "type", { enumerable: !0 });
  var Fa = class extends ds {
    constructor(e, r = {}) {
      (super(e),
        (this[S1] = r.code === void 0 ? 0 : r.code),
        (this[P1] = r.reason === void 0 ? "" : r.reason),
        (this[R1] = r.wasClean === void 0 ? !1 : r.wasClean));
    }
    get code() {
      return this[S1];
    }
    get reason() {
      return this[P1];
    }
    get wasClean() {
      return this[R1];
    }
  };
  Object.defineProperty(Fa.prototype, "code", { enumerable: !0 });
  Object.defineProperty(Fa.prototype, "reason", { enumerable: !0 });
  Object.defineProperty(Fa.prototype, "wasClean", { enumerable: !0 });
  var go = class extends ds {
    constructor(e, r = {}) {
      (super(e),
        (this[T1] = r.error === void 0 ? null : r.error),
        (this[C1] = r.message === void 0 ? "" : r.message));
    }
    get error() {
      return this[T1];
    }
    get message() {
      return this[C1];
    }
  };
  Object.defineProperty(go.prototype, "error", { enumerable: !0 });
  Object.defineProperty(go.prototype, "message", { enumerable: !0 });
  var tl = class extends ds {
    constructor(e, r = {}) {
      (super(e), (this[E1] = r.data === void 0 ? null : r.data));
    }
    get data() {
      return this[E1];
    }
  };
  Object.defineProperty(tl.prototype, "data", { enumerable: !0 });
  var pQ = {
    addEventListener(t, e, r = {}) {
      for (let s of this.listeners(t))
        if (!r[el] && s[Ay] === e && !s[el]) return;
      let n;
      if (t === "message")
        n = function (a, i) {
          let o = new tl("message", { data: i ? a : a.toString() });
          ((o[ho] = this), Ap(e, this, o));
        };
      else if (t === "close")
        n = function (a, i) {
          let o = new Fa("close", {
            code: a,
            reason: i.toString(),
            wasClean: this._closeFrameReceived && this._closeFrameSent,
          });
          ((o[ho] = this), Ap(e, this, o));
        };
      else if (t === "error")
        n = function (a) {
          let i = new go("error", { error: a, message: a.message });
          ((i[ho] = this), Ap(e, this, i));
        };
      else if (t === "open")
        n = function () {
          let a = new ds("open");
          ((a[ho] = this), Ap(e, this, a));
        };
      else return;
      ((n[el] = !!r[el]),
        (n[Ay] = e),
        r.once ? this.once(t, n) : this.on(t, n));
    },
    removeEventListener(t, e) {
      for (let r of this.listeners(t))
        if (r[Ay] === e && !r[el]) {
          this.removeListener(t, r);
          break;
        }
    },
  };
  O1.exports = {
    CloseEvent: Fa,
    ErrorEvent: go,
    Event: ds,
    EventTarget: pQ,
    MessageEvent: tl,
  };
  function Ap(t, e, r) {
    typeof t == "object" && t.handleEvent
      ? t.handleEvent.call(t, r)
      : t.call(e, r);
  }
});
var Ny = j((aye, $1) => {
  "use strict";
  var { tokenChars: rl } = po();
  function jn(t, e, r) {
    t[e] === void 0 ? (t[e] = [r]) : t[e].push(r);
  }
  function fQ(t) {
    let e = Object.create(null),
      r = Object.create(null),
      n = !1,
      s = !1,
      a = !1,
      i,
      o,
      c = -1,
      l = -1,
      u = -1,
      d = 0;
    for (; d < t.length; d++)
      if (((l = t.charCodeAt(d)), i === void 0))
        if (u === -1 && rl[l] === 1) c === -1 && (c = d);
        else if (d !== 0 && (l === 32 || l === 9))
          u === -1 && c !== -1 && (u = d);
        else if (l === 59 || l === 44) {
          if (c === -1)
            throw new SyntaxError(`Unexpected character at index ${d}`);
          u === -1 && (u = d);
          let p = t.slice(c, u);
          (l === 44 ? (jn(e, p, r), (r = Object.create(null))) : (i = p),
            (c = u = -1));
        } else throw new SyntaxError(`Unexpected character at index ${d}`);
      else if (o === void 0)
        if (u === -1 && rl[l] === 1) c === -1 && (c = d);
        else if (l === 32 || l === 9) u === -1 && c !== -1 && (u = d);
        else if (l === 59 || l === 44) {
          if (c === -1)
            throw new SyntaxError(`Unexpected character at index ${d}`);
          (u === -1 && (u = d),
            jn(r, t.slice(c, u), !0),
            l === 44 && (jn(e, i, r), (r = Object.create(null)), (i = void 0)),
            (c = u = -1));
        } else if (l === 61 && c !== -1 && u === -1)
          ((o = t.slice(c, d)), (c = u = -1));
        else throw new SyntaxError(`Unexpected character at index ${d}`);
      else if (s) {
        if (rl[l] !== 1)
          throw new SyntaxError(`Unexpected character at index ${d}`);
        (c === -1 ? (c = d) : n || (n = !0), (s = !1));
      } else if (a)
        if (rl[l] === 1) c === -1 && (c = d);
        else if (l === 34 && c !== -1) ((a = !1), (u = d));
        else if (l === 92) s = !0;
        else throw new SyntaxError(`Unexpected character at index ${d}`);
      else if (l === 34 && t.charCodeAt(d - 1) === 61) a = !0;
      else if (u === -1 && rl[l] === 1) c === -1 && (c = d);
      else if (c !== -1 && (l === 32 || l === 9)) u === -1 && (u = d);
      else if (l === 59 || l === 44) {
        if (c === -1)
          throw new SyntaxError(`Unexpected character at index ${d}`);
        u === -1 && (u = d);
        let p = t.slice(c, u);
        (n && ((p = p.replace(/\\/g, "")), (n = !1)),
          jn(r, o, p),
          l === 44 && (jn(e, i, r), (r = Object.create(null)), (i = void 0)),
          (o = void 0),
          (c = u = -1));
      } else throw new SyntaxError(`Unexpected character at index ${d}`);
    if (c === -1 || a || l === 32 || l === 9)
      throw new SyntaxError("Unexpected end of input");
    u === -1 && (u = d);
    let m = t.slice(c, u);
    return (
      i === void 0
        ? jn(e, m, r)
        : (o === void 0
            ? jn(r, m, !0)
            : n
              ? jn(r, o, m.replace(/\\/g, ""))
              : jn(r, o, m),
          jn(e, i, r)),
      e
    );
  }
  function mQ(t) {
    return Object.keys(t)
      .map((e) => {
        let r = t[e];
        return (
          Array.isArray(r) || (r = [r]),
          r
            .map((n) =>
              [e]
                .concat(
                  Object.keys(n).map((s) => {
                    let a = n[s];
                    return (
                      Array.isArray(a) || (a = [a]),
                      a.map((i) => (i === !0 ? s : `${s}=${i}`)).join("; ")
                    );
                  }),
                )
                .join("; "),
            )
            .join(", ")
        );
      })
      .join(", ");
  }
  $1.exports = { format: mQ, parse: fQ };
});
var Mp = j((cye, H1) => {
  "use strict";
  var hQ = require("events"),
    gQ = require("https"),
    vQ = require("http"),
    D1 = require("net"),
    yQ = require("tls"),
    { randomBytes: bQ, createHash: _Q } = require("crypto"),
    { Duplex: iye, Readable: oye } = require("stream"),
    { URL: Dy } = require("url"),
    Hs = Qc(),
    xQ = Ry(),
    wQ = $y(),
    { isBlob: SQ } = po(),
    {
      BINARY_TYPES: A1,
      EMPTY_BUFFER: Np,
      GUID: EQ,
      kForOnEventAttribute: Ly,
      kListener: TQ,
      kStatusCode: CQ,
      kWebSocket: Qt,
      NOOP: L1,
    } = ls(),
    {
      EventTarget: { addEventListener: PQ, removeEventListener: kQ },
    } = I1(),
    { format: RQ, parse: OQ } = Ny(),
    { toBuffer: IQ } = Xc(),
    $Q = 30 * 1e3,
    M1 = Symbol("kAborted"),
    My = [8, 13],
    ps = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"],
    AQ = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/,
    kt = class t extends hQ {
      constructor(e, r, n) {
        (super(),
          (this._binaryType = A1[0]),
          (this._closeCode = 1006),
          (this._closeFrameReceived = !1),
          (this._closeFrameSent = !1),
          (this._closeMessage = Np),
          (this._closeTimer = null),
          (this._errorEmitted = !1),
          (this._extensions = {}),
          (this._paused = !1),
          (this._protocol = ""),
          (this._readyState = t.CONNECTING),
          (this._receiver = null),
          (this._sender = null),
          (this._socket = null),
          e !== null
            ? ((this._bufferedAmount = 0),
              (this._isServer = !1),
              (this._redirects = 0),
              r === void 0
                ? (r = [])
                : Array.isArray(r) ||
                  (typeof r == "object" && r !== null
                    ? ((n = r), (r = []))
                    : (r = [r])),
              j1(this, e, r, n))
            : ((this._autoPong = n.autoPong), (this._isServer = !0)));
      }
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(e) {
        A1.includes(e) &&
          ((this._binaryType = e),
          this._receiver && (this._receiver._binaryType = e));
      }
      get bufferedAmount() {
        return this._socket
          ? this._socket._writableState.length + this._sender._bufferedBytes
          : this._bufferedAmount;
      }
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      get isPaused() {
        return this._paused;
      }
      get onclose() {
        return null;
      }
      get onerror() {
        return null;
      }
      get onopen() {
        return null;
      }
      get onmessage() {
        return null;
      }
      get protocol() {
        return this._protocol;
      }
      get readyState() {
        return this._readyState;
      }
      get url() {
        return this._url;
      }
      setSocket(e, r, n) {
        let s = new xQ({
            allowSynchronousEvents: n.allowSynchronousEvents,
            binaryType: this.binaryType,
            extensions: this._extensions,
            isServer: this._isServer,
            maxPayload: n.maxPayload,
            skipUTF8Validation: n.skipUTF8Validation,
          }),
          a = new wQ(e, this._extensions, n.generateMask);
        ((this._receiver = s),
          (this._sender = a),
          (this._socket = e),
          (s[Qt] = this),
          (a[Qt] = this),
          (e[Qt] = this),
          s.on("conclude", LQ),
          s.on("drain", MQ),
          s.on("error", jQ),
          s.on("message", FQ),
          s.on("ping", UQ),
          s.on("pong", qQ),
          (a.onerror = zQ),
          e.setTimeout && e.setTimeout(0),
          e.setNoDelay && e.setNoDelay(),
          r.length > 0 && e.unshift(r),
          e.on("close", q1),
          e.on("data", Lp),
          e.on("end", z1),
          e.on("error", B1),
          (this._readyState = t.OPEN),
          this.emit("open"));
      }
      emitClose() {
        if (!this._socket) {
          ((this._readyState = t.CLOSED),
            this.emit("close", this._closeCode, this._closeMessage));
          return;
        }
        (this._extensions[Hs.extensionName] &&
          this._extensions[Hs.extensionName].cleanup(),
          this._receiver.removeAllListeners(),
          (this._readyState = t.CLOSED),
          this.emit("close", this._closeCode, this._closeMessage));
      }
      close(e, r) {
        if (this.readyState !== t.CLOSED) {
          if (this.readyState === t.CONNECTING) {
            zr(
              this,
              this._req,
              "WebSocket was closed before the connection was established",
            );
            return;
          }
          if (this.readyState === t.CLOSING) {
            this._closeFrameSent &&
              (this._closeFrameReceived ||
                this._receiver._writableState.errorEmitted) &&
              this._socket.end();
            return;
          }
          ((this._readyState = t.CLOSING),
            this._sender.close(e, r, !this._isServer, (n) => {
              n ||
                ((this._closeFrameSent = !0),
                (this._closeFrameReceived ||
                  this._receiver._writableState.errorEmitted) &&
                  this._socket.end());
            }),
            U1(this));
        }
      }
      pause() {
        this.readyState === t.CONNECTING ||
          this.readyState === t.CLOSED ||
          ((this._paused = !0), this._socket.pause());
      }
      ping(e, r, n) {
        if (this.readyState === t.CONNECTING)
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        if (
          (typeof e == "function"
            ? ((n = e), (e = r = void 0))
            : typeof r == "function" && ((n = r), (r = void 0)),
          typeof e == "number" && (e = e.toString()),
          this.readyState !== t.OPEN)
        ) {
          jy(this, e, n);
          return;
        }
        (r === void 0 && (r = !this._isServer),
          this._sender.ping(e || Np, r, n));
      }
      pong(e, r, n) {
        if (this.readyState === t.CONNECTING)
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        if (
          (typeof e == "function"
            ? ((n = e), (e = r = void 0))
            : typeof r == "function" && ((n = r), (r = void 0)),
          typeof e == "number" && (e = e.toString()),
          this.readyState !== t.OPEN)
        ) {
          jy(this, e, n);
          return;
        }
        (r === void 0 && (r = !this._isServer),
          this._sender.pong(e || Np, r, n));
      }
      resume() {
        this.readyState === t.CONNECTING ||
          this.readyState === t.CLOSED ||
          ((this._paused = !1),
          this._receiver._writableState.needDrain || this._socket.resume());
      }
      send(e, r, n) {
        if (this.readyState === t.CONNECTING)
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        if (
          (typeof r == "function" && ((n = r), (r = {})),
          typeof e == "number" && (e = e.toString()),
          this.readyState !== t.OPEN)
        ) {
          jy(this, e, n);
          return;
        }
        let s = {
          binary: typeof e != "string",
          mask: !this._isServer,
          compress: !0,
          fin: !0,
          ...r,
        };
        (this._extensions[Hs.extensionName] || (s.compress = !1),
          this._sender.send(e || Np, s, n));
      }
      terminate() {
        if (this.readyState !== t.CLOSED) {
          if (this.readyState === t.CONNECTING) {
            zr(
              this,
              this._req,
              "WebSocket was closed before the connection was established",
            );
            return;
          }
          this._socket &&
            ((this._readyState = t.CLOSING), this._socket.destroy());
        }
      }
    };
  Object.defineProperty(kt, "CONNECTING", {
    enumerable: !0,
    value: ps.indexOf("CONNECTING"),
  });
  Object.defineProperty(kt.prototype, "CONNECTING", {
    enumerable: !0,
    value: ps.indexOf("CONNECTING"),
  });
  Object.defineProperty(kt, "OPEN", {
    enumerable: !0,
    value: ps.indexOf("OPEN"),
  });
  Object.defineProperty(kt.prototype, "OPEN", {
    enumerable: !0,
    value: ps.indexOf("OPEN"),
  });
  Object.defineProperty(kt, "CLOSING", {
    enumerable: !0,
    value: ps.indexOf("CLOSING"),
  });
  Object.defineProperty(kt.prototype, "CLOSING", {
    enumerable: !0,
    value: ps.indexOf("CLOSING"),
  });
  Object.defineProperty(kt, "CLOSED", {
    enumerable: !0,
    value: ps.indexOf("CLOSED"),
  });
  Object.defineProperty(kt.prototype, "CLOSED", {
    enumerable: !0,
    value: ps.indexOf("CLOSED"),
  });
  [
    "binaryType",
    "bufferedAmount",
    "extensions",
    "isPaused",
    "protocol",
    "readyState",
    "url",
  ].forEach((t) => {
    Object.defineProperty(kt.prototype, t, { enumerable: !0 });
  });
  ["open", "error", "close", "message"].forEach((t) => {
    Object.defineProperty(kt.prototype, `on${t}`, {
      enumerable: !0,
      get() {
        for (let e of this.listeners(t)) if (e[Ly]) return e[TQ];
        return null;
      },
      set(e) {
        for (let r of this.listeners(t))
          if (r[Ly]) {
            this.removeListener(t, r);
            break;
          }
        typeof e == "function" && this.addEventListener(t, e, { [Ly]: !0 });
      },
    });
  });
  kt.prototype.addEventListener = PQ;
  kt.prototype.removeEventListener = kQ;
  H1.exports = kt;
  function j1(t, e, r, n) {
    let s = {
      allowSynchronousEvents: !0,
      autoPong: !0,
      protocolVersion: My[1],
      maxPayload: 104857600,
      skipUTF8Validation: !1,
      perMessageDeflate: !0,
      followRedirects: !1,
      maxRedirects: 10,
      ...n,
      socketPath: void 0,
      hostname: void 0,
      protocol: void 0,
      timeout: void 0,
      method: "GET",
      host: void 0,
      path: void 0,
      port: void 0,
    };
    if (((t._autoPong = s.autoPong), !My.includes(s.protocolVersion)))
      throw new RangeError(
        `Unsupported protocol version: ${s.protocolVersion} (supported versions: ${My.join(", ")})`,
      );
    let a;
    if (e instanceof Dy) a = e;
    else
      try {
        a = new Dy(e);
      } catch {
        throw new SyntaxError(`Invalid URL: ${e}`);
      }
    (a.protocol === "http:"
      ? (a.protocol = "ws:")
      : a.protocol === "https:" && (a.protocol = "wss:"),
      (t._url = a.href));
    let i = a.protocol === "wss:",
      o = a.protocol === "ws+unix:",
      c;
    if (
      (a.protocol !== "ws:" && !i && !o
        ? (c = `The URL's protocol must be one of "ws:", "wss:", "http:", "https:", or "ws+unix:"`)
        : o && !a.pathname
          ? (c = "The URL's pathname is empty")
          : a.hash && (c = "The URL contains a fragment identifier"),
      c)
    ) {
      let y = new SyntaxError(c);
      if (t._redirects === 0) throw y;
      Dp(t, y);
      return;
    }
    let l = i ? 443 : 80,
      u = bQ(16).toString("base64"),
      d = i ? gQ.request : vQ.request,
      m = new Set(),
      p;
    if (
      ((s.createConnection = s.createConnection || (i ? DQ : NQ)),
      (s.defaultPort = s.defaultPort || l),
      (s.port = a.port || l),
      (s.host = a.hostname.startsWith("[")
        ? a.hostname.slice(1, -1)
        : a.hostname),
      (s.headers = {
        ...s.headers,
        "Sec-WebSocket-Version": s.protocolVersion,
        "Sec-WebSocket-Key": u,
        Connection: "Upgrade",
        Upgrade: "websocket",
      }),
      (s.path = a.pathname + a.search),
      (s.timeout = s.handshakeTimeout),
      s.perMessageDeflate &&
        ((p = new Hs(
          s.perMessageDeflate !== !0 ? s.perMessageDeflate : {},
          !1,
          s.maxPayload,
        )),
        (s.headers["Sec-WebSocket-Extensions"] = RQ({
          [Hs.extensionName]: p.offer(),
        }))),
      r.length)
    ) {
      for (let y of r) {
        if (typeof y != "string" || !AQ.test(y) || m.has(y))
          throw new SyntaxError(
            "An invalid or duplicated subprotocol was specified",
          );
        m.add(y);
      }
      s.headers["Sec-WebSocket-Protocol"] = r.join(",");
    }
    if (
      (s.origin &&
        (s.protocolVersion < 13
          ? (s.headers["Sec-WebSocket-Origin"] = s.origin)
          : (s.headers.Origin = s.origin)),
      (a.username || a.password) && (s.auth = `${a.username}:${a.password}`),
      o)
    ) {
      let y = s.path.split(":");
      ((s.socketPath = y[0]), (s.path = y[1]));
    }
    let f;
    if (s.followRedirects) {
      if (t._redirects === 0) {
        ((t._originalIpc = o),
          (t._originalSecure = i),
          (t._originalHostOrSocketPath = o ? s.socketPath : a.host));
        let y = n && n.headers;
        if (((n = { ...n, headers: {} }), y))
          for (let [h, g] of Object.entries(y)) n.headers[h.toLowerCase()] = g;
      } else if (t.listenerCount("redirect") === 0) {
        let y = o
          ? t._originalIpc
            ? s.socketPath === t._originalHostOrSocketPath
            : !1
          : t._originalIpc
            ? !1
            : a.host === t._originalHostOrSocketPath;
        (!y || (t._originalSecure && !i)) &&
          (delete s.headers.authorization,
          delete s.headers.cookie,
          y || delete s.headers.host,
          (s.auth = void 0));
      }
      (s.auth &&
        !n.headers.authorization &&
        (n.headers.authorization =
          "Basic " + Buffer.from(s.auth).toString("base64")),
        (f = t._req = d(s)),
        t._redirects && t.emit("redirect", t.url, f));
    } else f = t._req = d(s);
    (s.timeout &&
      f.on("timeout", () => {
        zr(t, f, "Opening handshake has timed out");
      }),
      f.on("error", (y) => {
        f === null || f[M1] || ((f = t._req = null), Dp(t, y));
      }),
      f.on("response", (y) => {
        let h = y.headers.location,
          g = y.statusCode;
        if (h && s.followRedirects && g >= 300 && g < 400) {
          if (++t._redirects > s.maxRedirects) {
            zr(t, f, "Maximum redirects exceeded");
            return;
          }
          f.abort();
          let _;
          try {
            _ = new Dy(h, e);
          } catch {
            let b = new SyntaxError(`Invalid URL: ${h}`);
            Dp(t, b);
            return;
          }
          j1(t, _, r, n);
        } else
          t.emit("unexpected-response", f, y) ||
            zr(t, f, `Unexpected server response: ${y.statusCode}`);
      }),
      f.on("upgrade", (y, h, g) => {
        if ((t.emit("upgrade", y), t.readyState !== kt.CONNECTING)) return;
        f = t._req = null;
        let _ = y.headers.upgrade;
        if (_ === void 0 || _.toLowerCase() !== "websocket") {
          zr(t, h, "Invalid Upgrade header");
          return;
        }
        let v = _Q("sha1")
          .update(u + EQ)
          .digest("base64");
        if (y.headers["sec-websocket-accept"] !== v) {
          zr(t, h, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        let b = y.headers["sec-websocket-protocol"],
          x;
        if (
          (b !== void 0
            ? m.size
              ? m.has(b) || (x = "Server sent an invalid subprotocol")
              : (x = "Server sent a subprotocol but none was requested")
            : m.size && (x = "Server sent no subprotocol"),
          x)
        ) {
          zr(t, h, x);
          return;
        }
        b && (t._protocol = b);
        let w = y.headers["sec-websocket-extensions"];
        if (w !== void 0) {
          if (!p) {
            zr(
              t,
              h,
              "Server sent a Sec-WebSocket-Extensions header but no extension was requested",
            );
            return;
          }
          let S;
          try {
            S = OQ(w);
          } catch {
            zr(t, h, "Invalid Sec-WebSocket-Extensions header");
            return;
          }
          let C = Object.keys(S);
          if (C.length !== 1 || C[0] !== Hs.extensionName) {
            zr(t, h, "Server indicated an extension that was not requested");
            return;
          }
          try {
            p.accept(S[Hs.extensionName]);
          } catch {
            zr(t, h, "Invalid Sec-WebSocket-Extensions header");
            return;
          }
          t._extensions[Hs.extensionName] = p;
        }
        t.setSocket(h, g, {
          allowSynchronousEvents: s.allowSynchronousEvents,
          generateMask: s.generateMask,
          maxPayload: s.maxPayload,
          skipUTF8Validation: s.skipUTF8Validation,
        });
      }),
      s.finishRequest ? s.finishRequest(f, t) : f.end());
  }
  function Dp(t, e) {
    ((t._readyState = kt.CLOSING),
      (t._errorEmitted = !0),
      t.emit("error", e),
      t.emitClose());
  }
  function NQ(t) {
    return ((t.path = t.socketPath), D1.connect(t));
  }
  function DQ(t) {
    return (
      (t.path = void 0),
      !t.servername &&
        t.servername !== "" &&
        (t.servername = D1.isIP(t.host) ? "" : t.host),
      yQ.connect(t)
    );
  }
  function zr(t, e, r) {
    t._readyState = kt.CLOSING;
    let n = new Error(r);
    (Error.captureStackTrace(n, zr),
      e.setHeader
        ? ((e[M1] = !0),
          e.abort(),
          e.socket && !e.socket.destroyed && e.socket.destroy(),
          process.nextTick(Dp, t, n))
        : (e.destroy(n),
          e.once("error", t.emit.bind(t, "error")),
          e.once("close", t.emitClose.bind(t))));
  }
  function jy(t, e, r) {
    if (e) {
      let n = SQ(e) ? e.size : IQ(e).length;
      t._socket ? (t._sender._bufferedBytes += n) : (t._bufferedAmount += n);
    }
    if (r) {
      let n = new Error(
        `WebSocket is not open: readyState ${t.readyState} (${ps[t.readyState]})`,
      );
      process.nextTick(r, n);
    }
  }
  function LQ(t, e) {
    let r = this[Qt];
    ((r._closeFrameReceived = !0),
      (r._closeMessage = e),
      (r._closeCode = t),
      r._socket[Qt] !== void 0 &&
        (r._socket.removeListener("data", Lp),
        process.nextTick(F1, r._socket),
        t === 1005 ? r.close() : r.close(t, e)));
  }
  function MQ() {
    let t = this[Qt];
    t.isPaused || t._socket.resume();
  }
  function jQ(t) {
    let e = this[Qt];
    (e._socket[Qt] !== void 0 &&
      (e._socket.removeListener("data", Lp),
      process.nextTick(F1, e._socket),
      e.close(t[CQ])),
      e._errorEmitted || ((e._errorEmitted = !0), e.emit("error", t)));
  }
  function N1() {
    this[Qt].emitClose();
  }
  function FQ(t, e) {
    this[Qt].emit("message", t, e);
  }
  function UQ(t) {
    let e = this[Qt];
    (e._autoPong && e.pong(t, !this._isServer, L1), e.emit("ping", t));
  }
  function qQ(t) {
    this[Qt].emit("pong", t);
  }
  function F1(t) {
    t.resume();
  }
  function zQ(t) {
    let e = this[Qt];
    e.readyState !== kt.CLOSED &&
      (e.readyState === kt.OPEN && ((e._readyState = kt.CLOSING), U1(e)),
      this._socket.end(),
      e._errorEmitted || ((e._errorEmitted = !0), e.emit("error", t)));
  }
  function U1(t) {
    t._closeTimer = setTimeout(t._socket.destroy.bind(t._socket), $Q);
  }
  function q1() {
    let t = this[Qt];
    (this.removeListener("close", q1),
      this.removeListener("data", Lp),
      this.removeListener("end", z1),
      (t._readyState = kt.CLOSING));
    let e;
    (!this._readableState.endEmitted &&
      !t._closeFrameReceived &&
      !t._receiver._writableState.errorEmitted &&
      (e = t._socket.read()) !== null &&
      t._receiver.write(e),
      t._receiver.end(),
      (this[Qt] = void 0),
      clearTimeout(t._closeTimer),
      t._receiver._writableState.finished ||
      t._receiver._writableState.errorEmitted
        ? t.emitClose()
        : (t._receiver.on("error", N1), t._receiver.on("finish", N1)));
  }
  function Lp(t) {
    this[Qt]._receiver.write(t) || this.pause();
  }
  function z1() {
    let t = this[Qt];
    ((t._readyState = kt.CLOSING), t._receiver.end(), this.end());
  }
  function B1() {
    let t = this[Qt];
    (this.removeListener("error", B1),
      this.on("error", L1),
      t && ((t._readyState = kt.CLOSING), this.destroy()));
  }
});
var W1 = j((uye, G1) => {
  "use strict";
  var lye = Mp(),
    { Duplex: BQ } = require("stream");
  function V1(t) {
    t.emit("close");
  }
  function HQ() {
    !this.destroyed && this._writableState.finished && this.destroy();
  }
  function Z1(t) {
    (this.removeListener("error", Z1),
      this.destroy(),
      this.listenerCount("error") === 0 && this.emit("error", t));
  }
  function VQ(t, e) {
    let r = !0,
      n = new BQ({
        ...e,
        autoDestroy: !1,
        emitClose: !1,
        objectMode: !1,
        writableObjectMode: !1,
      });
    return (
      t.on("message", function (a, i) {
        let o = !i && n._readableState.objectMode ? a.toString() : a;
        n.push(o) || t.pause();
      }),
      t.once("error", function (a) {
        n.destroyed || ((r = !1), n.destroy(a));
      }),
      t.once("close", function () {
        n.destroyed || n.push(null);
      }),
      (n._destroy = function (s, a) {
        if (t.readyState === t.CLOSED) {
          (a(s), process.nextTick(V1, n));
          return;
        }
        let i = !1;
        (t.once("error", function (c) {
          ((i = !0), a(c));
        }),
          t.once("close", function () {
            (i || a(s), process.nextTick(V1, n));
          }),
          r && t.terminate());
      }),
      (n._final = function (s) {
        if (t.readyState === t.CONNECTING) {
          t.once("open", function () {
            n._final(s);
          });
          return;
        }
        t._socket !== null &&
          (t._socket._writableState.finished
            ? (s(), n._readableState.endEmitted && n.destroy())
            : (t._socket.once("finish", function () {
                s();
              }),
              t.close()));
      }),
      (n._read = function () {
        t.isPaused && t.resume();
      }),
      (n._write = function (s, a, i) {
        if (t.readyState === t.CONNECTING) {
          t.once("open", function () {
            n._write(s, a, i);
          });
          return;
        }
        t.send(s, i);
      }),
      n.on("end", HQ),
      n.on("error", Z1),
      n
    );
  }
  G1.exports = VQ;
});
var J1 = j((dye, K1) => {
  "use strict";
  var { tokenChars: ZQ } = po();
  function GQ(t) {
    let e = new Set(),
      r = -1,
      n = -1,
      s = 0;
    for (s; s < t.length; s++) {
      let i = t.charCodeAt(s);
      if (n === -1 && ZQ[i] === 1) r === -1 && (r = s);
      else if (s !== 0 && (i === 32 || i === 9))
        n === -1 && r !== -1 && (n = s);
      else if (i === 44) {
        if (r === -1)
          throw new SyntaxError(`Unexpected character at index ${s}`);
        n === -1 && (n = s);
        let o = t.slice(r, n);
        if (e.has(o))
          throw new SyntaxError(`The "${o}" subprotocol is duplicated`);
        (e.add(o), (r = n = -1));
      } else throw new SyntaxError(`Unexpected character at index ${s}`);
    }
    if (r === -1 || n !== -1) throw new SyntaxError("Unexpected end of input");
    let a = t.slice(r, s);
    if (e.has(a)) throw new SyntaxError(`The "${a}" subprotocol is duplicated`);
    return (e.add(a), e);
  }
  K1.exports = { parse: GQ };
});
var nN = j((fye, rN) => {
  "use strict";
  var WQ = require("events"),
    jp = require("http"),
    { Duplex: pye } = require("stream"),
    { createHash: KQ } = require("crypto"),
    X1 = Ny(),
    Ua = Qc(),
    JQ = J1(),
    XQ = Mp(),
    { GUID: YQ, kWebSocket: QQ } = ls(),
    eee = /^[+/0-9A-Za-z]{22}==$/,
    Y1 = 0,
    Q1 = 1,
    tN = 2,
    Fy = class extends WQ {
      constructor(e, r) {
        if (
          (super(),
          (e = {
            allowSynchronousEvents: !0,
            autoPong: !0,
            maxPayload: 100 * 1024 * 1024,
            skipUTF8Validation: !1,
            perMessageDeflate: !1,
            handleProtocols: null,
            clientTracking: !0,
            verifyClient: null,
            noServer: !1,
            backlog: null,
            server: null,
            host: null,
            path: null,
            port: null,
            WebSocket: XQ,
            ...e,
          }),
          (e.port == null && !e.server && !e.noServer) ||
            (e.port != null && (e.server || e.noServer)) ||
            (e.server && e.noServer))
        )
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified',
          );
        if (
          (e.port != null
            ? ((this._server = jp.createServer((n, s) => {
                let a = jp.STATUS_CODES[426];
                (s.writeHead(426, {
                  "Content-Length": a.length,
                  "Content-Type": "text/plain",
                }),
                  s.end(a));
              })),
              this._server.listen(e.port, e.host, e.backlog, r))
            : e.server && (this._server = e.server),
          this._server)
        ) {
          let n = this.emit.bind(this, "connection");
          this._removeListeners = tee(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (s, a, i) => {
              this.handleUpgrade(s, a, i, n);
            },
          });
        }
        (e.perMessageDeflate === !0 && (e.perMessageDeflate = {}),
          e.clientTracking &&
            ((this.clients = new Set()), (this._shouldEmitClose = !1)),
          (this.options = e),
          (this._state = Y1));
      }
      address() {
        if (this.options.noServer)
          throw new Error('The server is operating in "noServer" mode');
        return this._server ? this._server.address() : null;
      }
      close(e) {
        if (this._state === tN) {
          (e &&
            this.once("close", () => {
              e(new Error("The server is not running"));
            }),
            process.nextTick(nl, this));
          return;
        }
        if ((e && this.once("close", e), this._state !== Q1))
          if (
            ((this._state = Q1), this.options.noServer || this.options.server)
          )
            (this._server &&
              (this._removeListeners(),
              (this._removeListeners = this._server = null)),
              this.clients
                ? this.clients.size
                  ? (this._shouldEmitClose = !0)
                  : process.nextTick(nl, this)
                : process.nextTick(nl, this));
          else {
            let r = this._server;
            (this._removeListeners(),
              (this._removeListeners = this._server = null),
              r.close(() => {
                nl(this);
              }));
          }
      }
      shouldHandle(e) {
        if (this.options.path) {
          let r = e.url.indexOf("?");
          if ((r !== -1 ? e.url.slice(0, r) : e.url) !== this.options.path)
            return !1;
        }
        return !0;
      }
      handleUpgrade(e, r, n, s) {
        r.on("error", eN);
        let a = e.headers["sec-websocket-key"],
          i = e.headers.upgrade,
          o = +e.headers["sec-websocket-version"];
        if (e.method !== "GET") {
          qa(this, e, r, 405, "Invalid HTTP method");
          return;
        }
        if (i === void 0 || i.toLowerCase() !== "websocket") {
          qa(this, e, r, 400, "Invalid Upgrade header");
          return;
        }
        if (a === void 0 || !eee.test(a)) {
          qa(this, e, r, 400, "Missing or invalid Sec-WebSocket-Key header");
          return;
        }
        if (o !== 13 && o !== 8) {
          qa(
            this,
            e,
            r,
            400,
            "Missing or invalid Sec-WebSocket-Version header",
            { "Sec-WebSocket-Version": "13, 8" },
          );
          return;
        }
        if (!this.shouldHandle(e)) {
          sl(r, 400);
          return;
        }
        let c = e.headers["sec-websocket-protocol"],
          l = new Set();
        if (c !== void 0)
          try {
            l = JQ.parse(c);
          } catch {
            qa(this, e, r, 400, "Invalid Sec-WebSocket-Protocol header");
            return;
          }
        let u = e.headers["sec-websocket-extensions"],
          d = {};
        if (this.options.perMessageDeflate && u !== void 0) {
          let m = new Ua(
            this.options.perMessageDeflate,
            !0,
            this.options.maxPayload,
          );
          try {
            let p = X1.parse(u);
            p[Ua.extensionName] &&
              (m.accept(p[Ua.extensionName]), (d[Ua.extensionName] = m));
          } catch {
            qa(
              this,
              e,
              r,
              400,
              "Invalid or unacceptable Sec-WebSocket-Extensions header",
            );
            return;
          }
        }
        if (this.options.verifyClient) {
          let m = {
            origin: e.headers[`${o === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(e.socket.authorized || e.socket.encrypted),
            req: e,
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(m, (p, f, y, h) => {
              if (!p) return sl(r, f || 401, y, h);
              this.completeUpgrade(d, a, l, e, r, n, s);
            });
            return;
          }
          if (!this.options.verifyClient(m)) return sl(r, 401);
        }
        this.completeUpgrade(d, a, l, e, r, n, s);
      }
      completeUpgrade(e, r, n, s, a, i, o) {
        if (!a.readable || !a.writable) return a.destroy();
        if (a[QQ])
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration",
          );
        if (this._state > Y1) return sl(a, 503);
        let l = [
            "HTTP/1.1 101 Switching Protocols",
            "Upgrade: websocket",
            "Connection: Upgrade",
            `Sec-WebSocket-Accept: ${KQ("sha1")
              .update(r + YQ)
              .digest("base64")}`,
          ],
          u = new this.options.WebSocket(null, void 0, this.options);
        if (n.size) {
          let d = this.options.handleProtocols
            ? this.options.handleProtocols(n, s)
            : n.values().next().value;
          d && (l.push(`Sec-WebSocket-Protocol: ${d}`), (u._protocol = d));
        }
        if (e[Ua.extensionName]) {
          let d = e[Ua.extensionName].params,
            m = X1.format({ [Ua.extensionName]: [d] });
          (l.push(`Sec-WebSocket-Extensions: ${m}`), (u._extensions = e));
        }
        (this.emit("headers", l, s),
          a.write(
            l.concat(`\r
`).join(`\r
`),
          ),
          a.removeListener("error", eN),
          u.setSocket(a, i, {
            allowSynchronousEvents: this.options.allowSynchronousEvents,
            maxPayload: this.options.maxPayload,
            skipUTF8Validation: this.options.skipUTF8Validation,
          }),
          this.clients &&
            (this.clients.add(u),
            u.on("close", () => {
              (this.clients.delete(u),
                this._shouldEmitClose &&
                  !this.clients.size &&
                  process.nextTick(nl, this));
            })),
          o(u, s));
      }
    };
  rN.exports = Fy;
  function tee(t, e) {
    for (let r of Object.keys(e)) t.on(r, e[r]);
    return function () {
      for (let n of Object.keys(e)) t.removeListener(n, e[n]);
    };
  }
  function nl(t) {
    ((t._state = tN), t.emit("close"));
  }
  function eN() {
    this.destroy();
  }
  function sl(t, e, r, n) {
    ((r = r || jp.STATUS_CODES[e]),
      (n = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(r),
        ...n,
      }),
      t.once("finish", t.destroy),
      t.end(
        `HTTP/1.1 ${e} ${jp.STATUS_CODES[e]}\r
` +
          Object.keys(n).map((s) => `${s}: ${n[s]}`).join(`\r
`) +
          `\r
\r
` +
          r,
      ));
  }
  function qa(t, e, r, n, s, a) {
    if (t.listenerCount("wsClientError")) {
      let i = new Error(s);
      (Error.captureStackTrace(i, qa), t.emit("wsClientError", i, r, e));
    } else sl(r, n, s, a);
  }
});
var vee = {};
Hp(vee, { activate: () => dee, deactivate: () => hee, openTabs: () => gee });
module.exports = ZN(vee);
var ke = le(require("vscode"), 1);
var ut = le(require("vscode"), 1),
  X$ = le(require("path"), 1),
  iy = le(require("os"), 1);
var nb = require("crypto");
function vs() {
  return (0, nb.randomBytes)(16).toString("hex");
}
var Rr = le(require("fs"), 1);
var q_ = require("node:buffer"),
  z_ = le(require("node:path"), 1),
  Tl = le(require("node:child_process"), 1),
  ko = le(require("node:process"), 1),
  B_ = le(ef(), 1);
function tf(t) {
  let e =
      typeof t == "string"
        ? `
`
        : 10,
    r = typeof t == "string" ? "\r" : 13;
  return (
    t[t.length - 1] === e && (t = t.slice(0, -1)),
    t[t.length - 1] === r && (t = t.slice(0, -1)),
    t
  );
}
var To = le(require("node:process"), 1),
  Xa = le(require("node:path"), 1),
  rf = require("node:url");
function pl(t = {}) {
  let { env: e = process.env, platform: r = process.platform } = t;
  return r !== "win32"
    ? "PATH"
    : Object.keys(e)
        .reverse()
        .find((n) => n.toUpperCase() === "PATH") || "Path";
}
var bD = ({
    cwd: t = To.default.cwd(),
    path: e = To.default.env[pl()],
    preferLocal: r = !0,
    execPath: n = To.default.execPath,
    addExecPath: s = !0,
  } = {}) => {
    let a = t instanceof URL ? (0, rf.fileURLToPath)(t) : t,
      i = Xa.default.resolve(a),
      o = [];
    return (
      r && _D(o, i),
      s && xD(o, n, i),
      [...o, e].join(Xa.default.delimiter)
    );
  },
  _D = (t, e) => {
    let r;
    for (; r !== e; )
      (t.push(Xa.default.join(e, "node_modules/.bin")),
        (r = e),
        (e = Xa.default.resolve(e, "..")));
  },
  xD = (t, e, r) => {
    let n = e instanceof URL ? (0, rf.fileURLToPath)(e) : e;
    t.push(Xa.default.resolve(r, n, ".."));
  },
  Vb = ({ env: t = To.default.env, ...e } = {}) => {
    t = { ...t };
    let r = pl({ env: t });
    return ((e.path = t[r]), (t[r] = bD(e)), t);
  };
var wD = (t, e, r, n) => {
    if (
      r === "length" ||
      r === "prototype" ||
      r === "arguments" ||
      r === "caller"
    )
      return;
    let s = Object.getOwnPropertyDescriptor(t, r),
      a = Object.getOwnPropertyDescriptor(e, r);
    (!SD(s, a) && n) || Object.defineProperty(t, r, a);
  },
  SD = function (t, e) {
    return (
      t === void 0 ||
      t.configurable ||
      (t.writable === e.writable &&
        t.enumerable === e.enumerable &&
        t.configurable === e.configurable &&
        (t.writable || t.value === e.value))
    );
  },
  ED = (t, e) => {
    let r = Object.getPrototypeOf(e);
    r !== Object.getPrototypeOf(t) && Object.setPrototypeOf(t, r);
  },
  TD = (t, e) => `/* Wrapped ${t}*/
${e}`,
  CD = Object.getOwnPropertyDescriptor(Function.prototype, "toString"),
  PD = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name"),
  kD = (t, e, r) => {
    let n = r === "" ? "" : `with ${r.trim()}() `,
      s = TD.bind(null, n, e.toString());
    (Object.defineProperty(s, "name", PD),
      Object.defineProperty(t, "toString", { ...CD, value: s }));
  };
function nf(t, e, { ignoreNonConfigurable: r = !1 } = {}) {
  let { name: n } = t;
  for (let s of Reflect.ownKeys(e)) wD(t, e, s, r);
  return (ED(t, e), kD(t, e, n), t);
}
var fl = new WeakMap(),
  Zb = (t, e = {}) => {
    if (typeof t != "function") throw new TypeError("Expected a function");
    let r,
      n = 0,
      s = t.displayName || t.name || "<anonymous>",
      a = function (...i) {
        if ((fl.set(a, ++n), n === 1)) ((r = t.apply(this, i)), (t = null));
        else if (e.throw === !0)
          throw new Error(`Function \`${s}\` can only be called once`);
        return r;
      };
    return (nf(a, t), fl.set(a, n), a);
  };
Zb.callCount = (t) => {
  if (!fl.has(t))
    throw new Error(
      `The given function \`${t.name}\` is not wrapped by the \`onetime\` package`,
    );
  return fl.get(t);
};
var Gb = Zb;
var t_ = le(require("node:process"), 1);
var Qb = require("node:os");
var Wb = () => {
    let t = Jb - Kb + 1;
    return Array.from({ length: t }, RD);
  },
  RD = (t, e) => ({
    name: `SIGRT${e + 1}`,
    number: Kb + e,
    action: "terminate",
    description: "Application-specific signal (realtime)",
    standard: "posix",
  }),
  Kb = 34,
  Jb = 64;
var Yb = require("node:os");
var Xb = [
  {
    name: "SIGHUP",
    number: 1,
    action: "terminate",
    description: "Terminal closed",
    standard: "posix",
  },
  {
    name: "SIGINT",
    number: 2,
    action: "terminate",
    description: "User interruption with CTRL-C",
    standard: "ansi",
  },
  {
    name: "SIGQUIT",
    number: 3,
    action: "core",
    description: "User interruption with CTRL-\\",
    standard: "posix",
  },
  {
    name: "SIGILL",
    number: 4,
    action: "core",
    description: "Invalid machine instruction",
    standard: "ansi",
  },
  {
    name: "SIGTRAP",
    number: 5,
    action: "core",
    description: "Debugger breakpoint",
    standard: "posix",
  },
  {
    name: "SIGABRT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "ansi",
  },
  {
    name: "SIGIOT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "bsd",
  },
  {
    name: "SIGBUS",
    number: 7,
    action: "core",
    description:
      "Bus error due to misaligned, non-existing address or paging error",
    standard: "bsd",
  },
  {
    name: "SIGEMT",
    number: 7,
    action: "terminate",
    description: "Command should be emulated but is not implemented",
    standard: "other",
  },
  {
    name: "SIGFPE",
    number: 8,
    action: "core",
    description: "Floating point arithmetic error",
    standard: "ansi",
  },
  {
    name: "SIGKILL",
    number: 9,
    action: "terminate",
    description: "Forced termination",
    standard: "posix",
    forced: !0,
  },
  {
    name: "SIGUSR1",
    number: 10,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix",
  },
  {
    name: "SIGSEGV",
    number: 11,
    action: "core",
    description: "Segmentation fault",
    standard: "ansi",
  },
  {
    name: "SIGUSR2",
    number: 12,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix",
  },
  {
    name: "SIGPIPE",
    number: 13,
    action: "terminate",
    description: "Broken pipe or socket",
    standard: "posix",
  },
  {
    name: "SIGALRM",
    number: 14,
    action: "terminate",
    description: "Timeout or timer",
    standard: "posix",
  },
  {
    name: "SIGTERM",
    number: 15,
    action: "terminate",
    description: "Termination",
    standard: "ansi",
  },
  {
    name: "SIGSTKFLT",
    number: 16,
    action: "terminate",
    description: "Stack is empty or overflowed",
    standard: "other",
  },
  {
    name: "SIGCHLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "posix",
  },
  {
    name: "SIGCLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "other",
  },
  {
    name: "SIGCONT",
    number: 18,
    action: "unpause",
    description: "Unpaused",
    standard: "posix",
    forced: !0,
  },
  {
    name: "SIGSTOP",
    number: 19,
    action: "pause",
    description: "Paused",
    standard: "posix",
    forced: !0,
  },
  {
    name: "SIGTSTP",
    number: 20,
    action: "pause",
    description: 'Paused using CTRL-Z or "suspend"',
    standard: "posix",
  },
  {
    name: "SIGTTIN",
    number: 21,
    action: "pause",
    description: "Background process cannot read terminal input",
    standard: "posix",
  },
  {
    name: "SIGBREAK",
    number: 21,
    action: "terminate",
    description: "User interruption with CTRL-BREAK",
    standard: "other",
  },
  {
    name: "SIGTTOU",
    number: 22,
    action: "pause",
    description: "Background process cannot write to terminal output",
    standard: "posix",
  },
  {
    name: "SIGURG",
    number: 23,
    action: "ignore",
    description: "Socket received out-of-band data",
    standard: "bsd",
  },
  {
    name: "SIGXCPU",
    number: 24,
    action: "core",
    description: "Process timed out",
    standard: "bsd",
  },
  {
    name: "SIGXFSZ",
    number: 25,
    action: "core",
    description: "File too big",
    standard: "bsd",
  },
  {
    name: "SIGVTALRM",
    number: 26,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd",
  },
  {
    name: "SIGPROF",
    number: 27,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd",
  },
  {
    name: "SIGWINCH",
    number: 28,
    action: "ignore",
    description: "Terminal window size changed",
    standard: "bsd",
  },
  {
    name: "SIGIO",
    number: 29,
    action: "terminate",
    description: "I/O is available",
    standard: "other",
  },
  {
    name: "SIGPOLL",
    number: 29,
    action: "terminate",
    description: "Watched event",
    standard: "other",
  },
  {
    name: "SIGINFO",
    number: 29,
    action: "ignore",
    description: "Request for process information",
    standard: "other",
  },
  {
    name: "SIGPWR",
    number: 30,
    action: "terminate",
    description: "Device running out of power",
    standard: "systemv",
  },
  {
    name: "SIGSYS",
    number: 31,
    action: "core",
    description: "Invalid system call",
    standard: "other",
  },
  {
    name: "SIGUNUSED",
    number: 31,
    action: "terminate",
    description: "Invalid system call",
    standard: "other",
  },
];
var sf = () => {
    let t = Wb();
    return [...Xb, ...t].map(OD);
  },
  OD = ({
    name: t,
    number: e,
    description: r,
    action: n,
    forced: s = !1,
    standard: a,
  }) => {
    let {
        signals: { [t]: i },
      } = Yb.constants,
      o = i !== void 0;
    return {
      name: t,
      number: o ? i : e,
      description: r,
      supported: o,
      action: n,
      forced: s,
      standard: a,
    };
  };
var ID = () => {
    let t = sf();
    return Object.fromEntries(t.map($D));
  },
  $D = ({
    name: t,
    number: e,
    description: r,
    supported: n,
    action: s,
    forced: a,
    standard: i,
  }) => [
    t,
    {
      name: t,
      number: e,
      description: r,
      supported: n,
      action: s,
      forced: a,
      standard: i,
    },
  ],
  e_ = ID(),
  AD = () => {
    let t = sf(),
      e = 65,
      r = Array.from({ length: e }, (n, s) => ND(s, t));
    return Object.assign({}, ...r);
  },
  ND = (t, e) => {
    let r = DD(t, e);
    if (r === void 0) return {};
    let {
      name: n,
      description: s,
      supported: a,
      action: i,
      forced: o,
      standard: c,
    } = r;
    return {
      [t]: {
        name: n,
        number: t,
        description: s,
        supported: a,
        action: i,
        forced: o,
        standard: c,
      },
    };
  },
  DD = (t, e) => {
    let r = e.find(({ name: n }) => Qb.constants.signals[n] === t);
    return r !== void 0 ? r : e.find((n) => n.number === t);
  },
  tte = AD();
var LD = ({
    timedOut: t,
    timeout: e,
    errorCode: r,
    signal: n,
    signalDescription: s,
    exitCode: a,
    isCanceled: i,
  }) =>
    t
      ? `timed out after ${e} milliseconds`
      : i
        ? "was canceled"
        : r !== void 0
          ? `failed with ${r}`
          : n !== void 0
            ? `was killed with ${n} (${s})`
            : a !== void 0
              ? `failed with exit code ${a}`
              : "failed",
  Co = ({
    stdout: t,
    stderr: e,
    all: r,
    error: n,
    signal: s,
    exitCode: a,
    command: i,
    escapedCommand: o,
    timedOut: c,
    isCanceled: l,
    killed: u,
    parsed: {
      options: { timeout: d, cwd: m = t_.default.cwd() },
    },
  }) => {
    ((a = a === null ? void 0 : a), (s = s === null ? void 0 : s));
    let p = s === void 0 ? void 0 : e_[s].description,
      f = n && n.code,
      h = `Command ${LD({ timedOut: c, timeout: d, errorCode: f, signal: s, signalDescription: p, exitCode: a, isCanceled: l })}: ${i}`,
      g = Object.prototype.toString.call(n) === "[object Error]",
      _ = g
        ? `${h}
${n.message}`
        : h,
      v = [_, e, t].filter(Boolean).join(`
`);
    return (
      g
        ? ((n.originalMessage = n.message), (n.message = v))
        : (n = new Error(v)),
      (n.shortMessage = _),
      (n.command = i),
      (n.escapedCommand = o),
      (n.exitCode = a),
      (n.signal = s),
      (n.signalDescription = p),
      (n.stdout = t),
      (n.stderr = e),
      (n.cwd = m),
      r !== void 0 && (n.all = r),
      "bufferedData" in n && delete n.bufferedData,
      (n.failed = !0),
      (n.timedOut = !!c),
      (n.isCanceled = l),
      (n.killed = u && !c),
      n
    );
  };
var ml = ["stdin", "stdout", "stderr"],
  MD = (t) => ml.some((e) => t[e] !== void 0),
  r_ = (t) => {
    if (!t) return;
    let { stdio: e } = t;
    if (e === void 0) return ml.map((n) => t[n]);
    if (MD(t))
      throw new Error(
        `It's not possible to provide \`stdio\` in combination with one of ${ml.map((n) => `\`${n}\``).join(", ")}`,
      );
    if (typeof e == "string") return e;
    if (!Array.isArray(e))
      throw new TypeError(
        `Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof e}\``,
      );
    let r = Math.max(e.length, ml.length);
    return Array.from({ length: r }, (n, s) => e[s]);
  };
var s_ = le(require("node:os"), 1);
var Ws = [];
Ws.push("SIGHUP", "SIGINT", "SIGTERM");
process.platform !== "win32" &&
  Ws.push(
    "SIGALRM",
    "SIGABRT",
    "SIGVTALRM",
    "SIGXCPU",
    "SIGXFSZ",
    "SIGUSR2",
    "SIGTRAP",
    "SIGSYS",
    "SIGQUIT",
    "SIGIOT",
  );
process.platform === "linux" &&
  Ws.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");
var hl = (t) =>
    !!t &&
    typeof t == "object" &&
    typeof t.removeListener == "function" &&
    typeof t.emit == "function" &&
    typeof t.reallyExit == "function" &&
    typeof t.listeners == "function" &&
    typeof t.kill == "function" &&
    typeof t.pid == "number" &&
    typeof t.on == "function",
  af = Symbol.for("signal-exit emitter"),
  of = globalThis,
  jD = Object.defineProperty.bind(Object),
  cf = class {
    emitted = { afterExit: !1, exit: !1 };
    listeners = { afterExit: [], exit: [] };
    count = 0;
    id = Math.random();
    constructor() {
      if (of[af]) return of[af];
      jD(of, af, {
        value: this,
        writable: !1,
        enumerable: !1,
        configurable: !1,
      });
    }
    on(e, r) {
      this.listeners[e].push(r);
    }
    removeListener(e, r) {
      let n = this.listeners[e],
        s = n.indexOf(r);
      s !== -1 && (s === 0 && n.length === 1 ? (n.length = 0) : n.splice(s, 1));
    }
    emit(e, r, n) {
      if (this.emitted[e]) return !1;
      this.emitted[e] = !0;
      let s = !1;
      for (let a of this.listeners[e]) s = a(r, n) === !0 || s;
      return (e === "exit" && (s = this.emit("afterExit", r, n) || s), s);
    }
  },
  gl = class {},
  FD = (t) => ({
    onExit(e, r) {
      return t.onExit(e, r);
    },
    load() {
      return t.load();
    },
    unload() {
      return t.unload();
    },
  }),
  lf = class extends gl {
    onExit() {
      return () => {};
    }
    load() {}
    unload() {}
  },
  uf = class extends gl {
    #i = df.platform === "win32" ? "SIGINT" : "SIGHUP";
    #t = new cf();
    #e;
    #s;
    #a;
    #n = {};
    #r = !1;
    constructor(e) {
      (super(), (this.#e = e), (this.#n = {}));
      for (let r of Ws)
        this.#n[r] = () => {
          let n = this.#e.listeners(r),
            { count: s } = this.#t,
            a = e;
          if (
            (typeof a.__signal_exit_emitter__ == "object" &&
              typeof a.__signal_exit_emitter__.count == "number" &&
              (s += a.__signal_exit_emitter__.count),
            n.length === s)
          ) {
            this.unload();
            let i = this.#t.emit("exit", null, r),
              o = r === "SIGHUP" ? this.#i : r;
            i || e.kill(e.pid, o);
          }
        };
      ((this.#a = e.reallyExit), (this.#s = e.emit));
    }
    onExit(e, r) {
      if (!hl(this.#e)) return () => {};
      this.#r === !1 && this.load();
      let n = r?.alwaysLast ? "afterExit" : "exit";
      return (
        this.#t.on(n, e),
        () => {
          (this.#t.removeListener(n, e),
            this.#t.listeners.exit.length === 0 &&
              this.#t.listeners.afterExit.length === 0 &&
              this.unload());
        }
      );
    }
    load() {
      if (!this.#r) {
        ((this.#r = !0), (this.#t.count += 1));
        for (let e of Ws)
          try {
            let r = this.#n[e];
            r && this.#e.on(e, r);
          } catch {}
        ((this.#e.emit = (e, ...r) => this.#c(e, ...r)),
          (this.#e.reallyExit = (e) => this.#o(e)));
      }
    }
    unload() {
      this.#r &&
        ((this.#r = !1),
        Ws.forEach((e) => {
          let r = this.#n[e];
          if (!r) throw new Error("Listener not defined for signal: " + e);
          try {
            this.#e.removeListener(e, r);
          } catch {}
        }),
        (this.#e.emit = this.#s),
        (this.#e.reallyExit = this.#a),
        (this.#t.count -= 1));
    }
    #o(e) {
      return hl(this.#e)
        ? ((this.#e.exitCode = e || 0),
          this.#t.emit("exit", this.#e.exitCode, null),
          this.#a.call(this.#e, this.#e.exitCode))
        : 0;
    }
    #c(e, ...r) {
      let n = this.#s;
      if (e === "exit" && hl(this.#e)) {
        typeof r[0] == "number" && (this.#e.exitCode = r[0]);
        let s = n.call(this.#e, e, ...r);
        return (this.#t.emit("exit", this.#e.exitCode, null), s);
      } else return n.call(this.#e, e, ...r);
    }
  },
  df = globalThis.process,
  { onExit: n_, load: cte, unload: lte } = FD(hl(df) ? new uf(df) : new lf());
var UD = 1e3 * 5,
  a_ = (t, e = "SIGTERM", r = {}) => {
    let n = t(e);
    return (qD(t, e, r, n), n);
  },
  qD = (t, e, r, n) => {
    if (!zD(e, r, n)) return;
    let s = HD(r),
      a = setTimeout(() => {
        t("SIGKILL");
      }, s);
    a.unref && a.unref();
  },
  zD = (t, { forceKillAfterTimeout: e }, r) => BD(t) && e !== !1 && r,
  BD = (t) =>
    t === s_.default.constants.signals.SIGTERM ||
    (typeof t == "string" && t.toUpperCase() === "SIGTERM"),
  HD = ({ forceKillAfterTimeout: t = !0 }) => {
    if (t === !0) return UD;
    if (!Number.isFinite(t) || t < 0)
      throw new TypeError(
        `Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${t}\` (${typeof t})`,
      );
    return t;
  },
  i_ = (t, e) => {
    t.kill() && (e.isCanceled = !0);
  },
  VD = (t, e, r) => {
    (t.kill(e),
      r(Object.assign(new Error("Timed out"), { timedOut: !0, signal: e })));
  },
  o_ = (t, { timeout: e, killSignal: r = "SIGTERM" }, n) => {
    if (e === 0 || e === void 0) return n;
    let s,
      a = new Promise((o, c) => {
        s = setTimeout(() => {
          VD(t, r, c);
        }, e);
      }),
      i = n.finally(() => {
        clearTimeout(s);
      });
    return Promise.race([a, i]);
  },
  c_ = ({ timeout: t }) => {
    if (t !== void 0 && (!Number.isFinite(t) || t < 0))
      throw new TypeError(
        `Expected the \`timeout\` option to be a non-negative integer, got \`${t}\` (${typeof t})`,
      );
  },
  l_ = async (t, { cleanup: e, detached: r }, n) => {
    if (!e || r) return n;
    let s = n_(() => {
      t.kill();
    });
    return n.finally(() => {
      s();
    });
  };
var u_ = require("node:fs"),
  d_ = require("node:child_process");
function vl(t) {
  return t !== null && typeof t == "object" && typeof t.pipe == "function";
}
function pf(t) {
  return (
    vl(t) &&
    t.writable !== !1 &&
    typeof t._write == "function" &&
    typeof t._writableState == "object"
  );
}
var ZD = (t) => t instanceof d_.ChildProcess && typeof t.then == "function",
  ff = (t, e, r) => {
    if (typeof r == "string")
      return (t[e].pipe((0, u_.createWriteStream)(r)), t);
    if (pf(r)) return (t[e].pipe(r), t);
    if (!ZD(r))
      throw new TypeError(
        "The second argument must be a string, a stream or an Execa child process.",
      );
    if (!pf(r.stdin))
      throw new TypeError(
        "The target child process's stdin must be available.",
      );
    return (t[e].pipe(r.stdin), r);
  },
  p_ = (t) => {
    (t.stdout !== null && (t.pipeStdout = ff.bind(void 0, t, "stdout")),
      t.stderr !== null && (t.pipeStderr = ff.bind(void 0, t, "stderr")),
      t.all !== void 0 && (t.pipeAll = ff.bind(void 0, t, "all")));
  };
var Sl = require("node:fs"),
  E_ = require("node:timers/promises");
var Po = async (
    t,
    {
      init: e,
      convertChunk: r,
      getSize: n,
      truncateChunk: s,
      addChunk: a,
      getFinalChunk: i,
      finalize: o,
    },
    { maxBuffer: c = Number.POSITIVE_INFINITY } = {},
  ) => {
    if (!WD(t))
      throw new Error(
        "The first argument must be a Readable, a ReadableStream, or an async iterable.",
      );
    let l = e();
    l.length = 0;
    try {
      for await (let u of t) {
        let d = KD(u),
          m = r[d](u, l);
        h_({
          convertedChunk: m,
          state: l,
          getSize: n,
          truncateChunk: s,
          addChunk: a,
          maxBuffer: c,
        });
      }
      return (
        GD({
          state: l,
          convertChunk: r,
          getSize: n,
          truncateChunk: s,
          addChunk: a,
          getFinalChunk: i,
          maxBuffer: c,
        }),
        o(l)
      );
    } catch (u) {
      throw ((u.bufferedData = o(l)), u);
    }
  },
  GD = ({
    state: t,
    getSize: e,
    truncateChunk: r,
    addChunk: n,
    getFinalChunk: s,
    maxBuffer: a,
  }) => {
    let i = s(t);
    i !== void 0 &&
      h_({
        convertedChunk: i,
        state: t,
        getSize: e,
        truncateChunk: r,
        addChunk: n,
        maxBuffer: a,
      });
  },
  h_ = ({
    convertedChunk: t,
    state: e,
    getSize: r,
    truncateChunk: n,
    addChunk: s,
    maxBuffer: a,
  }) => {
    let i = r(t),
      o = e.length + i;
    if (o <= a) {
      f_(t, e, s, o);
      return;
    }
    let c = n(t, a - e.length);
    throw (c !== void 0 && f_(c, e, s, a), new yl());
  },
  f_ = (t, e, r, n) => {
    ((e.contents = r(t, e, n)), (e.length = n));
  },
  WD = (t) =>
    typeof t == "object" &&
    t !== null &&
    typeof t[Symbol.asyncIterator] == "function",
  KD = (t) => {
    let e = typeof t;
    if (e === "string") return "string";
    if (e !== "object" || t === null) return "others";
    if (globalThis.Buffer?.isBuffer(t)) return "buffer";
    let r = m_.call(t);
    return r === "[object ArrayBuffer]"
      ? "arrayBuffer"
      : r === "[object DataView]"
        ? "dataView"
        : Number.isInteger(t.byteLength) &&
            Number.isInteger(t.byteOffset) &&
            m_.call(t.buffer) === "[object ArrayBuffer]"
          ? "typedArray"
          : "others";
  },
  { toString: m_ } = Object.prototype,
  yl = class extends Error {
    name = "MaxBufferError";
    constructor() {
      super("maxBuffer exceeded");
    }
  };
var mf = (t) => t,
  hf = () => {},
  gf = ({ contents: t }) => t,
  bl = (t) => {
    throw new Error(`Streams in object mode are not supported: ${String(t)}`);
  },
  _l = (t) => t.length;
async function vf(t, e) {
  return Po(t, sL, e);
}
var JD = () => ({ contents: new ArrayBuffer(0) }),
  XD = (t) => YD.encode(t),
  YD = new TextEncoder(),
  g_ = (t) => new Uint8Array(t),
  v_ = (t) => new Uint8Array(t.buffer, t.byteOffset, t.byteLength),
  QD = (t, e) => t.slice(0, e),
  eL = (t, { contents: e, length: r }, n) => {
    let s = __() ? rL(e, n) : tL(e, n);
    return (new Uint8Array(s).set(t, r), s);
  },
  tL = (t, e) => {
    if (e <= t.byteLength) return t;
    let r = new ArrayBuffer(b_(e));
    return (new Uint8Array(r).set(new Uint8Array(t), 0), r);
  },
  rL = (t, e) => {
    if (e <= t.maxByteLength) return (t.resize(e), t);
    let r = new ArrayBuffer(e, { maxByteLength: b_(e) });
    return (new Uint8Array(r).set(new Uint8Array(t), 0), r);
  },
  b_ = (t) => y_ ** Math.ceil(Math.log(t) / Math.log(y_)),
  y_ = 2,
  nL = ({ contents: t, length: e }) => (__() ? t : t.slice(0, e)),
  __ = () => "resize" in ArrayBuffer.prototype,
  sL = {
    init: JD,
    convertChunk: {
      string: XD,
      buffer: g_,
      arrayBuffer: g_,
      dataView: v_,
      typedArray: v_,
      others: bl,
    },
    getSize: _l,
    truncateChunk: QD,
    addChunk: eL,
    getFinalChunk: hf,
    finalize: nL,
  };
async function xl(t, e) {
  if (!("Buffer" in globalThis))
    throw new Error("getStreamAsBuffer() is only supported in Node.js");
  try {
    return x_(await vf(t, e));
  } catch (r) {
    throw (
      r.bufferedData !== void 0 && (r.bufferedData = x_(r.bufferedData)),
      r
    );
  }
}
var x_ = (t) => globalThis.Buffer.from(t);
async function yf(t, e) {
  return Po(t, lL, e);
}
var aL = () => ({ contents: "", textDecoder: new TextDecoder() }),
  wl = (t, { textDecoder: e }) => e.decode(t, { stream: !0 }),
  iL = (t, { contents: e }) => e + t,
  oL = (t, e) => t.slice(0, e),
  cL = ({ textDecoder: t }) => {
    let e = t.decode();
    return e === "" ? void 0 : e;
  },
  lL = {
    init: aL,
    convertChunk: {
      string: mf,
      buffer: wl,
      arrayBuffer: wl,
      dataView: wl,
      typedArray: wl,
      others: bl,
    },
    getSize: _l,
    truncateChunk: oL,
    addChunk: iL,
    getFinalChunk: cL,
    finalize: gf,
  };
var T_ = le(S_(), 1),
  C_ = (t) => {
    if (t !== void 0)
      throw new TypeError(
        "The `input` and `inputFile` options cannot be both set.",
      );
  },
  dL = ({ input: t, inputFile: e }) =>
    typeof e != "string" ? t : (C_(t), (0, Sl.readFileSync)(e)),
  P_ = (t) => {
    let e = dL(t);
    if (vl(e))
      throw new TypeError("The `input` option cannot be a stream in sync mode");
    return e;
  },
  pL = ({ input: t, inputFile: e }) =>
    typeof e != "string" ? t : (C_(t), (0, Sl.createReadStream)(e)),
  k_ = (t, e) => {
    let r = pL(e);
    r !== void 0 && (vl(r) ? r.pipe(t.stdin) : t.stdin.end(r));
  },
  R_ = (t, { all: e }) => {
    if (!e || (!t.stdout && !t.stderr)) return;
    let r = (0, T_.default)();
    return (t.stdout && r.add(t.stdout), t.stderr && r.add(t.stderr), r);
  },
  bf = async (t, e) => {
    if (!(!t || e === void 0)) {
      (await (0, E_.setTimeout)(0), t.destroy());
      try {
        return await e;
      } catch (r) {
        return r.bufferedData;
      }
    }
  },
  _f = (t, { encoding: e, buffer: r, maxBuffer: n }) => {
    if (!(!t || !r))
      return e === "utf8" || e === "utf-8"
        ? yf(t, { maxBuffer: n })
        : e === null || e === "buffer"
          ? xl(t, { maxBuffer: n })
          : fL(t, n, e);
  },
  fL = async (t, e, r) => (await xl(t, { maxBuffer: e })).toString(r),
  O_ = async (
    { stdout: t, stderr: e, all: r },
    { encoding: n, buffer: s, maxBuffer: a },
    i,
  ) => {
    let o = _f(t, { encoding: n, buffer: s, maxBuffer: a }),
      c = _f(e, { encoding: n, buffer: s, maxBuffer: a }),
      l = _f(r, { encoding: n, buffer: s, maxBuffer: a * 2 });
    try {
      return await Promise.all([i, o, c, l]);
    } catch (u) {
      return Promise.all([
        { error: u, signal: u.signal, timedOut: u.timedOut },
        bf(t, o),
        bf(e, c),
        bf(r, l),
      ]);
    }
  };
var mL = (async () => {})().constructor.prototype,
  hL = ["then", "catch", "finally"].map((t) => [
    t,
    Reflect.getOwnPropertyDescriptor(mL, t),
  ]),
  xf = (t, e) => {
    for (let [r, n] of hL) {
      let s =
        typeof e == "function"
          ? (...a) => Reflect.apply(n.value, e(), a)
          : n.value.bind(e);
      Reflect.defineProperty(t, r, { ...n, value: s });
    }
  },
  I_ = (t) =>
    new Promise((e, r) => {
      (t.on("exit", (n, s) => {
        e({ exitCode: n, signal: s });
      }),
        t.on("error", (n) => {
          r(n);
        }),
        t.stdin &&
          t.stdin.on("error", (n) => {
            r(n);
          }));
    });
var N_ = require("node:buffer"),
  D_ = require("node:child_process"),
  L_ = (t, e = []) => (Array.isArray(e) ? [t, ...e] : [t]),
  gL = /^[\w.-]+$/,
  vL = (t) =>
    typeof t != "string" || gL.test(t) ? t : `"${t.replaceAll('"', '\\"')}"`,
  wf = (t, e) => L_(t, e).join(" "),
  Sf = (t, e) =>
    L_(t, e)
      .map((r) => vL(r))
      .join(" "),
  yL = / +/g;
var $_ = (t) => {
    let e = typeof t;
    if (e === "string") return t;
    if (e === "number") return String(t);
    if (
      e === "object" &&
      t !== null &&
      !(t instanceof D_.ChildProcess) &&
      "stdout" in t
    ) {
      let r = typeof t.stdout;
      if (r === "string") return t.stdout;
      if (N_.Buffer.isBuffer(t.stdout)) return t.stdout.toString();
      throw new TypeError(`Unexpected "${r}" stdout in template expression`);
    }
    throw new TypeError(`Unexpected "${e}" in template expression`);
  },
  A_ = (t, e, r) =>
    r || t.length === 0 || e.length === 0
      ? [...t, ...e]
      : [...t.slice(0, -1), `${t.at(-1)}${e[0]}`, ...e.slice(1)],
  bL = ({ templates: t, expressions: e, tokens: r, index: n, template: s }) => {
    let a = s ?? t.raw[n],
      i = a.split(yL).filter(Boolean),
      o = A_(r, i, a.startsWith(" "));
    if (n === e.length) return o;
    let c = e[n],
      l = Array.isArray(c) ? c.map((u) => $_(u)) : [$_(c)];
    return A_(o, l, a.endsWith(" "));
  },
  Ef = (t, e) => {
    let r = [];
    for (let [n, s] of t.entries())
      r = bL({
        templates: t,
        expressions: e,
        tokens: r,
        index: n,
        template: s,
      });
    return r;
  };
var M_ = require("node:util"),
  j_ = le(require("node:process"), 1),
  F_ = (0, M_.debuglog)("execa").enabled,
  El = (t, e) => String(t).padStart(e, "0"),
  _L = () => {
    let t = new Date();
    return `${El(t.getHours(), 2)}:${El(t.getMinutes(), 2)}:${El(t.getSeconds(), 2)}.${El(t.getMilliseconds(), 3)}`;
  },
  Tf = (t, { verbose: e }) => {
    e &&
      j_.default.stderr.write(`[${_L()}] ${t}
`);
  };
var xL = 1e3 * 1e3 * 100,
  wL = ({ env: t, extendEnv: e, preferLocal: r, localDir: n, execPath: s }) => {
    let a = e ? { ...ko.default.env, ...t } : t;
    return r ? Vb({ env: a, cwd: n, execPath: s }) : a;
  },
  H_ = (t, e, r = {}) => {
    let n = B_.default._parse(t, e, r);
    return (
      (t = n.command),
      (e = n.args),
      (r = n.options),
      (r = {
        maxBuffer: xL,
        buffer: !0,
        stripFinalNewline: !0,
        extendEnv: !0,
        preferLocal: !1,
        localDir: r.cwd || ko.default.cwd(),
        execPath: ko.default.execPath,
        encoding: "utf8",
        reject: !0,
        cleanup: !0,
        all: !1,
        windowsHide: !0,
        verbose: F_,
        ...r,
      }),
      (r.env = wL(r)),
      (r.stdio = r_(r)),
      ko.default.platform === "win32" &&
        z_.default.basename(t, ".exe") === "cmd" &&
        e.unshift("/q"),
      { file: t, args: e, options: r, parsed: n }
    );
  },
  Ro = (t, e, r) =>
    typeof e != "string" && !q_.Buffer.isBuffer(e)
      ? r === void 0
        ? void 0
        : ""
      : t.stripFinalNewline
        ? tf(e)
        : e;
function V_(t, e, r) {
  let n = H_(t, e, r),
    s = wf(t, e),
    a = Sf(t, e);
  (Tf(a, n.options), c_(n.options));
  let i;
  try {
    i = Tl.default.spawn(n.file, n.args, n.options);
  } catch (p) {
    let f = new Tl.default.ChildProcess(),
      y = Promise.reject(
        Co({
          error: p,
          stdout: "",
          stderr: "",
          all: "",
          command: s,
          escapedCommand: a,
          parsed: n,
          timedOut: !1,
          isCanceled: !1,
          killed: !1,
        }),
      );
    return (xf(f, y), f);
  }
  let o = I_(i),
    c = o_(i, n.options, o),
    l = l_(i, n.options, c),
    u = { isCanceled: !1 };
  ((i.kill = a_.bind(null, i.kill.bind(i))), (i.cancel = i_.bind(null, i, u)));
  let m = Gb(async () => {
    let [{ error: p, exitCode: f, signal: y, timedOut: h }, g, _, v] = await O_(
        i,
        n.options,
        l,
      ),
      b = Ro(n.options, g),
      x = Ro(n.options, _),
      w = Ro(n.options, v);
    if (p || f !== 0 || y !== null) {
      let S = Co({
        error: p,
        exitCode: f,
        signal: y,
        stdout: b,
        stderr: x,
        all: w,
        command: s,
        escapedCommand: a,
        parsed: n,
        timedOut: h,
        isCanceled:
          u.isCanceled || (n.options.signal ? n.options.signal.aborted : !1),
        killed: i.killed,
      });
      if (!n.options.reject) return S;
      throw S;
    }
    return {
      command: s,
      escapedCommand: a,
      exitCode: 0,
      stdout: b,
      stderr: x,
      all: w,
      failed: !1,
      timedOut: !1,
      isCanceled: !1,
      killed: !1,
    };
  });
  return (k_(i, n.options), (i.all = R_(i, n.options)), p_(i), xf(i, m), i);
}
function Ar(t, e, r) {
  let n = H_(t, e, r),
    s = wf(t, e),
    a = Sf(t, e);
  Tf(a, n.options);
  let i = P_(n.options),
    o;
  try {
    o = Tl.default.spawnSync(n.file, n.args, { ...n.options, input: i });
  } catch (u) {
    throw Co({
      error: u,
      stdout: "",
      stderr: "",
      all: "",
      command: s,
      escapedCommand: a,
      parsed: n,
      timedOut: !1,
      isCanceled: !1,
      killed: !1,
    });
  }
  let c = Ro(n.options, o.stdout, o.error),
    l = Ro(n.options, o.stderr, o.error);
  if (o.error || o.status !== 0 || o.signal !== null) {
    let u = Co({
      stdout: c,
      stderr: l,
      error: o.error,
      signal: o.signal,
      exitCode: o.status,
      command: s,
      escapedCommand: a,
      parsed: n,
      timedOut: o.error && o.error.code === "ETIMEDOUT",
      isCanceled: !1,
      killed: o.signal !== null,
    });
    if (!n.options.reject) return u;
    throw u;
  }
  return {
    command: s,
    escapedCommand: a,
    exitCode: 0,
    stdout: c,
    stderr: l,
    failed: !1,
    timedOut: !1,
    isCanceled: !1,
    killed: !1,
  };
}
var SL = ({ input: t, inputFile: e, stdio: r }) =>
    t === void 0 && e === void 0 && r === void 0 ? { stdin: "inherit" } : {},
  U_ = (t = {}) => ({ preferLocal: !0, ...SL(t), ...t });
function Z_(t) {
  function e(r, ...n) {
    if (!Array.isArray(r)) return Z_({ ...t, ...r });
    let [s, ...a] = Ef(r, n);
    return V_(s, a, U_(t));
  }
  return (
    (e.sync = (r, ...n) => {
      if (!Array.isArray(r))
        throw new TypeError(
          "Please use $(options).sync`command` instead of $.sync(options)`command`.",
        );
      let [s, ...a] = Ef(r, n);
      return Ar(s, a, U_(t));
    }),
    e
  );
}
var rre = Z_();
var K$ = le(Hf(), 1);
var ei = class t {
  constructor(e) {
    this.returned = e;
  }
  queue = [];
  readResolve;
  readReject;
  isDone = !1;
  hasError;
  started = !1;
  [Symbol.asyncIterator]() {
    if (this.started) throw new Error("Stream can only be iterated once");
    return ((this.started = !0), this);
  }
  next() {
    return this.queue.length > 0
      ? Promise.resolve({ done: !1, value: this.queue.shift() })
      : this.isDone
        ? Promise.resolve({ done: !0, value: void 0 })
        : this.hasError
          ? Promise.reject(this.hasError)
          : new Promise((e, r) => {
              ((this.readResolve = e), (this.readReject = r));
            });
  }
  enqueue(e) {
    if (this.readResolve) {
      let r = this.readResolve;
      ((this.readResolve = void 0),
        (this.readReject = void 0),
        r({ done: !1, value: e }));
    } else this.queue.push(e);
  }
  done() {
    if (((this.isDone = !0), this.readResolve)) {
      let e = this.readResolve;
      ((this.readResolve = void 0),
        (this.readReject = void 0),
        e({ done: !0, value: void 0 }));
    }
  }
  error(e) {
    if (((this.hasError = e), this.readReject)) {
      let r = this.readReject;
      ((this.readResolve = void 0), (this.readReject = void 0), r(e));
    }
  }
  return() {
    return (
      (this.isDone = !0),
      this.returned && this.returned(),
      Promise.resolve({ done: !0, value: void 0 })
    );
  }
  static from(e) {
    let r = new t();
    for (let n of e) r.enqueue(n);
    return (r.done(), r);
  }
};
function Dw() {
  return {
    clawd: { light: "/resources/clawd.svg", dark: "/resources/clawd.svg" },
    "welcome-art": {
      light: "/resources/welcome-art-light.svg",
      dark: "/resources/welcome-art-dark.svg",
    },
  };
}
function Lw() {
  return {
    clawd: { light: "./resources/clawd.svg", dark: "./resources/clawd.svg" },
    "welcome-art": {
      light: "./resources/welcome-art-light.svg",
      dark: "./resources/welcome-art-dark.svg",
    },
  };
}
var KE = require("child_process");
var an = require("path"),
  Nr = le(require("fs"), 1),
  Wf = require("crypto");
var Mw = require("path"),
  jw = require("os");
function sn() {
  return (
    process.env.CLAUDE_CONFIG_DIR ?? (0, Mw.join)((0, jw.homedir)(), ".claude")
  );
}
function Vf(t) {
  if (!t) return !1;
  if (typeof t == "boolean") return t;
  let e = t.toLowerCase().trim();
  return ["1", "true", "yes", "on"].includes(e);
}
var bF = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function _F() {
  return (0, an.join)(sn(), "projects");
}
function Zf(t) {
  return (0, an.join)(_F(), t.replace(/[^a-zA-Z0-9]/g, "-"));
}
function Fw(t, e) {
  return (0, an.join)(sn(), "file-history", e, t);
}
var Bn = class t {
  constructor(e, r, n, s, a, i) {
    this.sessionMessages = e;
    this.messages = r;
    this.summaries = n;
    this.projectRoot = s;
    this.fileModificationTimes = a;
    this.logger = i;
  }
  static cache = new Map();
  refreshing = Promise.resolve();
  async fetchSessions() {
    return this.getTranscripts().map((r) => {
      let n = r[r.length - 1],
        s = r[0],
        a = SF(r);
      return {
        lastModified: new Date(n.timestamp).getTime(),
        messageCount: r.length,
        isSidechain: s.isSidechain,
        id: n.sessionId,
        summary: this.summaries.get(n.uuid) || a,
      };
    });
  }
  getTranscripts() {
    let e = [...this.messages.values()],
      r = new Set(e.map((n) => n.parentUuid));
    return e
      .filter((n) => !r.has(n.uuid))
      .map((n) => this.getTranscript(n))
      .filter((n) => n.length);
  }
  async getSessionMessages(e) {
    if (e.endsWith(".jsonl")) {
      let c = [];
      for (let l of await Gf(e)) c.push(l);
      return c;
    }
    let r = e,
      s = this.sessionMessages.get(r);
    if (!s) return [];
    let i = Array.from(this.messages.values())
      .filter((c) => s.has(c.uuid))
      .filter((c) => !c.isSidechain)
      .sort(
        (c, l) =>
          new Date(l.timestamp).getTime() - new Date(c.timestamp).getTime(),
      )[0];
    return i
      ? this.getTranscript(i)
          .map(wF)
          .filter((c) => !!c)
      : [];
  }
  getTranscript(e, r = !1) {
    let n = [],
      s = e;
    for (; s; ) {
      n.unshift(s);
      let a = s.parentUuid ?? (r ? s.logicalParentUuid : null);
      s = a ? this.messages.get(a) : void 0;
    }
    return n;
  }
  static async load(e, r) {
    let n = Zf(e);
    if (!t.cache.has(n)) {
      let a = new t(new Map(), new Map(), new Map(), e, new Map(), r);
      t.cache.set(n, a);
    }
    let s = t.cache.get(n);
    return (await s.refresh(), s);
  }
  refresh() {
    return (
      (this.refreshing = this.refreshing.then(async () =>
        this.performRefresh(),
      )),
      this.refreshing
    );
  }
  async performRefresh() {
    let e = Zf(this.projectRoot),
      r = await Nr.promises.readdir(e),
      n = [];
    for (let s of r) {
      let a = (0, an.join)(e, s);
      if (!a.endsWith(".jsonl")) continue;
      let i = xF((0, an.basename)(a, ".jsonl"));
      if (i)
        try {
          let o = await Nr.promises.stat(a),
            c = this.fileModificationTimes.get(a) || 0;
          o.mtime.getTime() > c &&
            n.push({ path: a, sessionId: i, mtime: o.mtime.getTime() });
        } catch {
          if (this.fileModificationTimes.has(a)) {
            (this.fileModificationTimes.delete(a),
              this.sessionMessages.delete(i));
            for (let [o, c] of this.messages.entries())
              c.sessionId === i && this.messages.delete(o);
          }
        }
    }
    for (let { path: s, sessionId: a, mtime: i } of n) {
      let o = this.sessionMessages.get(a);
      if (o)
        for (let u of o) (this.messages.delete(u), this.summaries.delete(u));
      let c = new Map(),
        l = new Map();
      try {
        let u = !1,
          d = !1;
        for (let m of await Gf(s))
          if (
            m.type === "user" ||
            m.type === "assistant" ||
            m.type === "attachment" ||
            m.type === "system"
          ) {
            if (!u && ((u = !0), m.isSidechain === !0)) {
              d = !0;
              break;
            }
            c.set(m.uuid, m);
          } else
            m.type === "summary" && m.leafUuid && l.set(m.leafUuid, m.summary);
        if (d)
          (this.sessionMessages.delete(a),
            this.fileModificationTimes.delete(s));
        else {
          this.sessionMessages.set(a, new Set(c.keys()));
          for (let [m, p] of c.entries()) this.messages.set(m, p);
          for (let [m, p] of l.entries()) this.summaries.set(m, p);
          this.fileModificationTimes.set(s, i);
        }
      } catch {}
    }
  }
  async forkSession(e, r) {
    let n = this.sessionMessages.get(e);
    if (!n) throw new Error(`Session ${e} not found`);
    let a = Array.from(this.messages.values())
      .filter((v) => n.has(v.uuid))
      .sort(
        (v, b) =>
          new Date(b.timestamp).getTime() - new Date(v.timestamp).getTime(),
      )[0];
    if (!a) throw new Error(`No messages found for session ${e}`);
    let i = this.getTranscript(a, !!r);
    if (r) {
      let v = -1;
      for (let b = i.length - 1; b >= 0; b--)
        if (i[b].uuid === r) {
          v = b;
          break;
        }
      if (v === -1) throw new Error(`Message ${r} not found in session ${e}`);
      i = i.slice(0, v + 1);
    }
    let o = (0, Wf.randomUUID)(),
      c = Zf(this.projectRoot),
      l = (0, an.join)(c, `${o}.jsonl`),
      u = i.length > 0 ? this.summaries.get(i[i.length - 1].uuid) : void 0,
      d = (0, an.join)(c, `${e}.jsonl`),
      m = new Map();
    for (let v of await Gf(d))
      v.type === "file-history-snapshot" && m.set(v.messageId, v);
    let p = new Map();
    for (let v of i) p.set(v.uuid, (0, Wf.randomUUID)());
    let f = [],
      y = "",
      h = new Date().toISOString(),
      g = new Set();
    for (let v = 0; v < i.length; v++) {
      let b = i[v],
        x = p.get(b.uuid),
        w = (b.parentUuid && p.get(b.parentUuid)) || null,
        S = v === i.length - 1 ? h : b.timestamp,
        C = { ...b, uuid: x, parentUuid: w, sessionId: o, timestamp: S };
      (C.type === "assistant" &&
        C.message &&
        (C = { ...C, message: { ...C.message, id: x } }),
        f.push(C),
        (y +=
          JSON.stringify(C) +
          `
`));
      let P = m.get(b.uuid);
      if (P) {
        let A = p.get(b.uuid),
          R = { ...P, messageId: A, snapshot: { ...P.snapshot, messageId: A } };
        ((y +=
          JSON.stringify(R) +
          `
`),
          EF(P.snapshot, e, o, this.logger, g));
      }
    }
    await Nr.promises.appendFile(l, y);
    let _ = f[f.length - 1]?.uuid;
    if (u && _) {
      let v = { type: "summary", leafUuid: _, summary: u };
      await Nr.promises.appendFile(
        l,
        JSON.stringify(v) +
          `
`,
      );
    }
    this.sessionMessages.set(o, new Set(f.map((v) => v.uuid)));
    for (let v of f) this.messages.set(v.uuid, v);
    return (u && _ && this.summaries.set(_, u), o);
  }
};
function xF(t) {
  return typeof t != "string" ? null : bF.test(t) ? t : null;
}
async function Gf(t) {
  try {
    let e = await Nr.promises.readFile(t, "utf8");
    return e.trim()
      ? e
          .split(
            `
`,
          )
          .filter((r) => r.trim())
          .map((r) => {
            try {
              return JSON.parse(r);
            } catch {
              return null;
            }
          })
          .filter((r) => r !== null)
      : [];
  } catch {
    return [];
  }
}
function wF(t) {
  if (!t.isMeta) {
    if (t.type === "user")
      return {
        type: "user",
        message: t.message,
        uuid: t.uuid,
        session_id: t.sessionId,
        parent_tool_use_id: null,
      };
    if (t.type === "assistant")
      return {
        type: "assistant",
        message: t.message,
        uuid: t.uuid,
        session_id: t.sessionId,
        parent_tool_use_id: null,
      };
    if (t.type === "system") return;
    if (t.type === "attachment") return;
  }
}
function SF(t) {
  let e;
  for (let s of t)
    if (s.type === "user" && !s.isMeta) e = s;
    else if (e) break;
  if (!e || e.type !== "user") return "No prompt";
  let r = e.message?.content,
    n = "";
  return (
    typeof r == "string"
      ? (n = r)
      : Array.isArray(r)
        ? (n = r.findLast((a) => a.type === "text")?.text || "No prompt")
        : (n = "No prompt"),
    (n = n.replace(/\n/g, " ").trim()),
    n.length > 45 && (n = n.slice(0, 45) + "..."),
    n
  );
}
async function EF(t, e, r, n, s) {
  for (let a of Object.values(t.trackedFileBackups)) {
    if (!a.backupFileName || s.has(a.backupFileName)) continue;
    s.add(a.backupFileName);
    let i = Fw(a.backupFileName, e),
      o = Fw(a.backupFileName, r);
    if (!Nr.existsSync(i)) {
      n.error(`FileHistory: Backup file does not exist at ${i}`);
      continue;
    }
    if (Nr.existsSync(o)) continue;
    let c = (0, an.dirname)(o);
    Nr.existsSync(c) || (await Nr.promises.mkdir(c, { recursive: !0 }));
    try {
      (await Nr.promises.link(i, o),
        n.log(
          `FileHistory: Hard linked backup ${a.backupFileName} from ${e} to ${r}`,
        ));
    } catch {
      n.log(
        `FileHistory: Hard link failed, falling back to copy for ${a.backupFileName}`,
      );
      try {
        (await Nr.promises.copyFile(i, o),
          n.log(
            `FileHistory: Copied backup ${a.backupFileName} from ${e} to ${r}`,
          ));
      } catch (l) {
        n.error(`FileHistory: Failed to copy backup ${a.backupFileName}: ${l}`);
      }
    }
  }
}
var TF = 7,
  Uw = ["Edit", "Write"],
  Dr = {
    totalSessions: 0,
    recentSessions: 0,
    editsAccepted: 0,
    editsAutoAccepted: 0,
    editsDeclined: 0,
  };
function qw() {
  return Dr;
}
function zw(t) {
  let e = Date.now(),
    r = TF * 24 * 60 * 60 * 1e3,
    n = e - r,
    s = t.length,
    a = t.filter((i) => i.lastModified >= n).length;
  return ((Dr = { ...Dr, totalSessions: s, recentSessions: a }), Dr);
}
function Bw(t, e) {
  Uw.includes(t) &&
    (e.result.behavior === "allow"
      ? (Dr = { ...Dr, editsAccepted: Dr.editsAccepted + 1 })
      : (Dr = { ...Dr, editsDeclined: Dr.editsDeclined + 1 }));
}
var Kf = new Set();
function Hw(t) {
  if (t.type === "assistant" && Array.isArray(t.message.content))
    for (let e of t.message.content)
      e.type === "tool_use" && Uw.includes(e.name) && Kf.add(e.id);
  if (t.type === "user" && Array.isArray(t.message.content))
    for (let e of t.message.content)
      e.type === "tool_result" &&
        !e.is_error &&
        Kf.has(e.tool_use_id) &&
        ((Dr = { ...Dr, editsAutoAccepted: Dr.editsAutoAccepted + 1 }),
        Kf.delete(e.tool_use_id));
}
var ti = le(require("node:child_process"), 1);
async function jl(t) {
  return new Promise(async (e) => {
    try {
      let r =
          process.platform === "win32"
            ? ti.spawn("powershell.exe", [
                "-NoProfile",
                "-Command",
                `(Get-CimInstance Win32_Process -Filter "ParentProcessId=${t}").ProcessId`,
              ])
            : process.platform === "darwin"
              ? ti.spawn("bash", [
                  "-c",
                  `ps -eo pid,ppid | awk '$2 == ${t} {print $1}'`,
                ])
              : ti.spawn("bash", ["-c", `ps -o pid= --ppid ${t}`]),
        n = "";
      (r.stdout.on("data", (s) => {
        n += s.toString();
      }),
        r.on("close", () => {
          let s = n
            .trim()
            .split(/\r?\n/)
            .map((a) => a.trim())
            .filter((a) => a.length > 0);
          e(s);
        }),
        r.on("error", (s) => {
          (console.error(`Error finding children: ${s}`), e([]));
        }));
    } catch (r) {
      (console.error(`Error checking for child processes: ${r}`), e([]));
    }
  });
}
async function Jf(t) {
  return new Promise((e) => {
    try {
      let r =
          process.platform === "win32"
            ? ti.spawn("powershell.exe", [
                "-NoProfile",
                "-Command",
                `(Get-CimInstance Win32_Process -Filter "ProcessId=${t}").CommandLine`,
              ])
            : ti.spawn("bash", ["-c", `ps -p ${t} -o command=`]),
        n = "";
      (r.stdout.on("data", (s) => {
        n += s.toString();
      }),
        r.on("close", () => {
          e(n.trim());
        }),
        r.on("error", (s) => {
          (console.error(`Error getting process command: ${s}`), e(""));
        }));
    } catch (r) {
      (console.error(`Error checking process command: ${r}`), e(""));
    }
  });
}
var im = require("path"),
  zS = require("url"),
  BS = require("events"),
  VS = require("child_process"),
  ZS = require("readline"),
  Re = le(require("fs"), 1),
  GS = require("fs/promises"),
  YS = require("path"),
  QS = require("os"),
  Qs = require("path"),
  t0 = require("process"),
  r0 = require("fs"),
  n0 = require("crypto"),
  o0 = require("crypto"),
  wi = require("fs"),
  om = require("path"),
  c0 = require("crypto");
var j3 = {},
  CF = Object.create,
  PF = Object.getPrototypeOf,
  am = Object.defineProperty,
  kF = Object.getOwnPropertyNames,
  RF = Object.prototype.hasOwnProperty,
  AS = (t, e, r) => {
    r = t != null ? CF(PF(t)) : {};
    let n =
      e || !t || !t.__esModule
        ? am(r, "default", { value: t, enumerable: !0 })
        : r;
    for (let s of kF(t))
      RF.call(n, s) || am(n, s, { get: () => t[s], enumerable: !0 });
    return n;
  },
  ge = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports),
  NS = (t, e) => {
    for (var r in e)
      am(t, r, {
        get: e[r],
        enumerable: !0,
        configurable: !0,
        set: (n) => (e[r] = () => n),
      });
  };
var Hl = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.regexpCode =
        t.getEsmExportName =
        t.getProperty =
        t.safeStringify =
        t.stringify =
        t.strConcat =
        t.addCodeArg =
        t.str =
        t._ =
        t.nil =
        t._Code =
        t.Name =
        t.IDENTIFIER =
        t._CodeOrName =
          void 0));
    class e {}
    ((t._CodeOrName = e), (t.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i));
    class r extends e {
      constructor(_) {
        if ((super(), !t.IDENTIFIER.test(_)))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = _;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    t.Name = r;
    class n extends e {
      constructor(_) {
        (super(), (this._items = typeof _ == "string" ? [_] : _));
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1) return !1;
        let _ = this._items[0];
        return _ === "" || _ === '""';
      }
      get str() {
        var _;
        return (_ = this._str) !== null && _ !== void 0
          ? _
          : (this._str = this._items.reduce((v, b) => `${v}${b}`, ""));
      }
      get names() {
        var _;
        return (_ = this._names) !== null && _ !== void 0
          ? _
          : (this._names = this._items.reduce(
              (v, b) => (b instanceof r && (v[b.str] = (v[b.str] || 0) + 1), v),
              {},
            ));
      }
    }
    ((t._Code = n), (t.nil = new n("")));
    function s(g, ..._) {
      let v = [g[0]],
        b = 0;
      for (; b < _.length; ) (o(v, _[b]), v.push(g[++b]));
      return new n(v);
    }
    t._ = s;
    var a = new n("+");
    function i(g, ..._) {
      let v = [p(g[0])],
        b = 0;
      for (; b < _.length; ) (v.push(a), o(v, _[b]), v.push(a, p(g[++b])));
      return (c(v), new n(v));
    }
    t.str = i;
    function o(g, _) {
      _ instanceof n
        ? g.push(..._._items)
        : _ instanceof r
          ? g.push(_)
          : g.push(d(_));
    }
    t.addCodeArg = o;
    function c(g) {
      let _ = 1;
      for (; _ < g.length - 1; ) {
        if (g[_] === a) {
          let v = l(g[_ - 1], g[_ + 1]);
          if (v !== void 0) {
            g.splice(_ - 1, 3, v);
            continue;
          }
          g[_++] = "+";
        }
        _++;
      }
    }
    function l(g, _) {
      if (_ === '""') return g;
      if (g === '""') return _;
      if (typeof g == "string")
        return _ instanceof r || g[g.length - 1] !== '"'
          ? void 0
          : typeof _ != "string"
            ? `${g.slice(0, -1)}${_}"`
            : _[0] === '"'
              ? g.slice(0, -1) + _.slice(1)
              : void 0;
      if (typeof _ == "string" && _[0] === '"' && !(g instanceof r))
        return `"${g}${_.slice(1)}`;
    }
    function u(g, _) {
      return _.emptyStr() ? g : g.emptyStr() ? _ : i`${g}${_}`;
    }
    t.strConcat = u;
    function d(g) {
      return typeof g == "number" || typeof g == "boolean" || g === null
        ? g
        : p(Array.isArray(g) ? g.join(",") : g);
    }
    function m(g) {
      return new n(p(g));
    }
    t.stringify = m;
    function p(g) {
      return JSON.stringify(g)
        .replace(/\u2028/g, "\\u2028")
        .replace(/\u2029/g, "\\u2029");
    }
    t.safeStringify = p;
    function f(g) {
      return typeof g == "string" && t.IDENTIFIER.test(g)
        ? new n(`.${g}`)
        : s`[${g}]`;
    }
    t.getProperty = f;
    function y(g) {
      if (typeof g == "string" && t.IDENTIFIER.test(g)) return new n(`${g}`);
      throw new Error(
        `CodeGen: invalid export name: ${g}, use explicit $id name mapping`,
      );
    }
    t.getEsmExportName = y;
    function h(g) {
      return new n(g.toString());
    }
    t.regexpCode = h;
  }),
  Vw = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.ValueScope =
        t.ValueScopeName =
        t.Scope =
        t.varKinds =
        t.UsedValueState =
          void 0));
    var e = Hl();
    class r extends Error {
      constructor(l) {
        (super(`CodeGen: "code" for ${l} not defined`), (this.value = l.value));
      }
    }
    var n;
    ((function (c) {
      ((c[(c.Started = 0)] = "Started"), (c[(c.Completed = 1)] = "Completed"));
    })(n || (t.UsedValueState = n = {})),
      (t.varKinds = {
        const: new e.Name("const"),
        let: new e.Name("let"),
        var: new e.Name("var"),
      }));
    class s {
      constructor({ prefixes: l, parent: u } = {}) {
        ((this._names = {}), (this._prefixes = l), (this._parent = u));
      }
      toName(l) {
        return l instanceof e.Name ? l : this.name(l);
      }
      name(l) {
        return new e.Name(this._newName(l));
      }
      _newName(l) {
        let u = this._names[l] || this._nameGroup(l);
        return `${l}${u.index++}`;
      }
      _nameGroup(l) {
        var u, d;
        if (
          (!(
            (d =
              (u = this._parent) === null || u === void 0
                ? void 0
                : u._prefixes) === null || d === void 0
          ) &&
            d.has(l)) ||
          (this._prefixes && !this._prefixes.has(l))
        )
          throw new Error(
            `CodeGen: prefix "${l}" is not allowed in this scope`,
          );
        return (this._names[l] = { prefix: l, index: 0 });
      }
    }
    t.Scope = s;
    class a extends e.Name {
      constructor(l, u) {
        (super(u), (this.prefix = l));
      }
      setValue(l, { property: u, itemIndex: d }) {
        ((this.value = l),
          (this.scopePath = (0, e._)`.${new e.Name(u)}[${d}]`));
      }
    }
    t.ValueScopeName = a;
    var i = (0, e._)`\n`;
    class o extends s {
      constructor(l) {
        (super(l),
          (this._values = {}),
          (this._scope = l.scope),
          (this.opts = { ...l, _n: l.lines ? i : e.nil }));
      }
      get() {
        return this._scope;
      }
      name(l) {
        return new a(l, this._newName(l));
      }
      value(l, u) {
        var d;
        if (u.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        let m = this.toName(l),
          { prefix: p } = m,
          f = (d = u.key) !== null && d !== void 0 ? d : u.ref,
          y = this._values[p];
        if (y) {
          let _ = y.get(f);
          if (_) return _;
        } else y = this._values[p] = new Map();
        y.set(f, m);
        let h = this._scope[p] || (this._scope[p] = []),
          g = h.length;
        return (
          (h[g] = u.ref),
          m.setValue(u, { property: p, itemIndex: g }),
          m
        );
      }
      getValue(l, u) {
        let d = this._values[l];
        if (d) return d.get(u);
      }
      scopeRefs(l, u = this._values) {
        return this._reduceValues(u, (d) => {
          if (d.scopePath === void 0)
            throw new Error(`CodeGen: name "${d}" has no value`);
          return (0, e._)`${l}${d.scopePath}`;
        });
      }
      scopeCode(l = this._values, u, d) {
        return this._reduceValues(
          l,
          (m) => {
            if (m.value === void 0)
              throw new Error(`CodeGen: name "${m}" has no value`);
            return m.value.code;
          },
          u,
          d,
        );
      }
      _reduceValues(l, u, d = {}, m) {
        let p = e.nil;
        for (let f in l) {
          let y = l[f];
          if (!y) continue;
          let h = (d[f] = d[f] || new Map());
          y.forEach((g) => {
            if (h.has(g)) return;
            h.set(g, n.Started);
            let _ = u(g);
            if (_) {
              let v = this.opts.es5 ? t.varKinds.var : t.varKinds.const;
              p = (0, e._)`${p}${v} ${g} = ${_};${this.opts._n}`;
            } else if ((_ = m?.(g))) p = (0, e._)`${p}${_}${this.opts._n}`;
            else throw new r(g);
            h.set(g, n.Completed);
          });
        }
        return p;
      }
    }
    t.ValueScope = o;
  }),
  Ze = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.or =
        t.and =
        t.not =
        t.CodeGen =
        t.operators =
        t.varKinds =
        t.ValueScopeName =
        t.ValueScope =
        t.Scope =
        t.Name =
        t.regexpCode =
        t.stringify =
        t.getProperty =
        t.nil =
        t.strConcat =
        t.str =
        t._ =
          void 0));
    var e = Hl(),
      r = Vw(),
      n = Hl();
    (Object.defineProperty(t, "_", {
      enumerable: !0,
      get: function () {
        return n._;
      },
    }),
      Object.defineProperty(t, "str", {
        enumerable: !0,
        get: function () {
          return n.str;
        },
      }),
      Object.defineProperty(t, "strConcat", {
        enumerable: !0,
        get: function () {
          return n.strConcat;
        },
      }),
      Object.defineProperty(t, "nil", {
        enumerable: !0,
        get: function () {
          return n.nil;
        },
      }),
      Object.defineProperty(t, "getProperty", {
        enumerable: !0,
        get: function () {
          return n.getProperty;
        },
      }),
      Object.defineProperty(t, "stringify", {
        enumerable: !0,
        get: function () {
          return n.stringify;
        },
      }),
      Object.defineProperty(t, "regexpCode", {
        enumerable: !0,
        get: function () {
          return n.regexpCode;
        },
      }),
      Object.defineProperty(t, "Name", {
        enumerable: !0,
        get: function () {
          return n.Name;
        },
      }));
    var s = Vw();
    (Object.defineProperty(t, "Scope", {
      enumerable: !0,
      get: function () {
        return s.Scope;
      },
    }),
      Object.defineProperty(t, "ValueScope", {
        enumerable: !0,
        get: function () {
          return s.ValueScope;
        },
      }),
      Object.defineProperty(t, "ValueScopeName", {
        enumerable: !0,
        get: function () {
          return s.ValueScopeName;
        },
      }),
      Object.defineProperty(t, "varKinds", {
        enumerable: !0,
        get: function () {
          return s.varKinds;
        },
      }),
      (t.operators = {
        GT: new e._Code(">"),
        GTE: new e._Code(">="),
        LT: new e._Code("<"),
        LTE: new e._Code("<="),
        EQ: new e._Code("==="),
        NEQ: new e._Code("!=="),
        NOT: new e._Code("!"),
        OR: new e._Code("||"),
        AND: new e._Code("&&"),
        ADD: new e._Code("+"),
      }));
    class a {
      optimizeNodes() {
        return this;
      }
      optimizeNames(T, O) {
        return this;
      }
    }
    class i extends a {
      constructor(T, O, H) {
        (super(), (this.varKind = T), (this.name = O), (this.rhs = H));
      }
      render({ es5: T, _n: O }) {
        let H = T ? r.varKinds.var : this.varKind,
          ce = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${H} ${this.name}${ce};` + O;
      }
      optimizeNames(T, O) {
        if (T[this.name.str])
          return (this.rhs && (this.rhs = I(this.rhs, T, O)), this);
      }
      get names() {
        return this.rhs instanceof e._CodeOrName ? this.rhs.names : {};
      }
    }
    class o extends a {
      constructor(T, O, H) {
        (super(), (this.lhs = T), (this.rhs = O), (this.sideEffects = H));
      }
      render({ _n: T }) {
        return `${this.lhs} = ${this.rhs};` + T;
      }
      optimizeNames(T, O) {
        if (
          !(this.lhs instanceof e.Name && !T[this.lhs.str] && !this.sideEffects)
        )
          return ((this.rhs = I(this.rhs, T, O)), this);
      }
      get names() {
        let T = this.lhs instanceof e.Name ? {} : { ...this.lhs.names };
        return F(T, this.rhs);
      }
    }
    class c extends o {
      constructor(T, O, H, ce) {
        (super(T, H, ce), (this.op = O));
      }
      render({ _n: T }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + T;
      }
    }
    class l extends a {
      constructor(T) {
        (super(), (this.label = T), (this.names = {}));
      }
      render({ _n: T }) {
        return `${this.label}:` + T;
      }
    }
    class u extends a {
      constructor(T) {
        (super(), (this.label = T), (this.names = {}));
      }
      render({ _n: T }) {
        return `break${this.label ? ` ${this.label}` : ""};` + T;
      }
    }
    class d extends a {
      constructor(T) {
        (super(), (this.error = T));
      }
      render({ _n: T }) {
        return `throw ${this.error};` + T;
      }
      get names() {
        return this.error.names;
      }
    }
    class m extends a {
      constructor(T) {
        (super(), (this.code = T));
      }
      render({ _n: T }) {
        return `${this.code};` + T;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(T, O) {
        return ((this.code = I(this.code, T, O)), this);
      }
      get names() {
        return this.code instanceof e._CodeOrName ? this.code.names : {};
      }
    }
    class p extends a {
      constructor(T = []) {
        (super(), (this.nodes = T));
      }
      render(T) {
        return this.nodes.reduce((O, H) => O + H.render(T), "");
      }
      optimizeNodes() {
        let { nodes: T } = this,
          O = T.length;
        for (; O--; ) {
          let H = T[O].optimizeNodes();
          Array.isArray(H)
            ? T.splice(O, 1, ...H)
            : H
              ? (T[O] = H)
              : T.splice(O, 1);
        }
        return T.length > 0 ? this : void 0;
      }
      optimizeNames(T, O) {
        let { nodes: H } = this,
          ce = H.length;
        for (; ce--; ) {
          let oe = H[ce];
          oe.optimizeNames(T, O) || (K(T, oe.names), H.splice(ce, 1));
        }
        return H.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((T, O) => D(T, O.names), {});
      }
    }
    class f extends p {
      render(T) {
        return "{" + T._n + super.render(T) + "}" + T._n;
      }
    }
    class y extends p {}
    class h extends f {}
    h.kind = "else";
    class g extends f {
      constructor(T, O) {
        (super(O), (this.condition = T));
      }
      render(T) {
        let O = `if(${this.condition})` + super.render(T);
        return (this.else && (O += "else " + this.else.render(T)), O);
      }
      optimizeNodes() {
        super.optimizeNodes();
        let T = this.condition;
        if (T === !0) return this.nodes;
        let O = this.else;
        if (O) {
          let H = O.optimizeNodes();
          O = this.else = Array.isArray(H) ? new h(H) : H;
        }
        if (O)
          return T === !1
            ? O instanceof g
              ? O
              : O.nodes
            : this.nodes.length
              ? this
              : new g(ee(T), O instanceof g ? [O] : O.nodes);
        if (!(T === !1 || !this.nodes.length)) return this;
      }
      optimizeNames(T, O) {
        var H;
        if (
          ((this.else =
            (H = this.else) === null || H === void 0
              ? void 0
              : H.optimizeNames(T, O)),
          !!(super.optimizeNames(T, O) || this.else))
        )
          return ((this.condition = I(this.condition, T, O)), this);
      }
      get names() {
        let T = super.names;
        return (F(T, this.condition), this.else && D(T, this.else.names), T);
      }
    }
    g.kind = "if";
    class _ extends f {}
    _.kind = "for";
    class v extends _ {
      constructor(T) {
        (super(), (this.iteration = T));
      }
      render(T) {
        return `for(${this.iteration})` + super.render(T);
      }
      optimizeNames(T, O) {
        if (super.optimizeNames(T, O))
          return ((this.iteration = I(this.iteration, T, O)), this);
      }
      get names() {
        return D(super.names, this.iteration.names);
      }
    }
    class b extends _ {
      constructor(T, O, H, ce) {
        (super(),
          (this.varKind = T),
          (this.name = O),
          (this.from = H),
          (this.to = ce));
      }
      render(T) {
        let O = T.es5 ? r.varKinds.var : this.varKind,
          { name: H, from: ce, to: oe } = this;
        return `for(${O} ${H}=${ce}; ${H}<${oe}; ${H}++)` + super.render(T);
      }
      get names() {
        let T = F(super.names, this.from);
        return F(T, this.to);
      }
    }
    class x extends _ {
      constructor(T, O, H, ce) {
        (super(),
          (this.loop = T),
          (this.varKind = O),
          (this.name = H),
          (this.iterable = ce));
      }
      render(T) {
        return (
          `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` +
          super.render(T)
        );
      }
      optimizeNames(T, O) {
        if (super.optimizeNames(T, O))
          return ((this.iterable = I(this.iterable, T, O)), this);
      }
      get names() {
        return D(super.names, this.iterable.names);
      }
    }
    class w extends f {
      constructor(T, O, H) {
        (super(), (this.name = T), (this.args = O), (this.async = H));
      }
      render(T) {
        return (
          `${this.async ? "async " : ""}function ${this.name}(${this.args})` +
          super.render(T)
        );
      }
    }
    w.kind = "func";
    class S extends p {
      render(T) {
        return "return " + super.render(T);
      }
    }
    S.kind = "return";
    class C extends f {
      render(T) {
        let O = "try" + super.render(T);
        return (
          this.catch && (O += this.catch.render(T)),
          this.finally && (O += this.finally.render(T)),
          O
        );
      }
      optimizeNodes() {
        var T, O;
        return (
          super.optimizeNodes(),
          (T = this.catch) === null || T === void 0 || T.optimizeNodes(),
          (O = this.finally) === null || O === void 0 || O.optimizeNodes(),
          this
        );
      }
      optimizeNames(T, O) {
        var H, ce;
        return (
          super.optimizeNames(T, O),
          (H = this.catch) === null || H === void 0 || H.optimizeNames(T, O),
          (ce = this.finally) === null ||
            ce === void 0 ||
            ce.optimizeNames(T, O),
          this
        );
      }
      get names() {
        let T = super.names;
        return (
          this.catch && D(T, this.catch.names),
          this.finally && D(T, this.finally.names),
          T
        );
      }
    }
    class P extends f {
      constructor(T) {
        (super(), (this.error = T));
      }
      render(T) {
        return `catch(${this.error})` + super.render(T);
      }
    }
    P.kind = "catch";
    class A extends f {
      render(T) {
        return "finally" + super.render(T);
      }
    }
    A.kind = "finally";
    class R {
      constructor(T, O = {}) {
        ((this._values = {}),
          (this._blockStarts = []),
          (this._constants = {}),
          (this.opts = {
            ...O,
            _n: O.lines
              ? `
`
              : "",
          }),
          (this._extScope = T),
          (this._scope = new r.Scope({ parent: T })),
          (this._nodes = [new y()]));
      }
      toString() {
        return this._root.render(this.opts);
      }
      name(T) {
        return this._scope.name(T);
      }
      scopeName(T) {
        return this._extScope.name(T);
      }
      scopeValue(T, O) {
        let H = this._extScope.value(T, O);
        return (
          (this._values[H.prefix] || (this._values[H.prefix] = new Set())).add(
            H,
          ),
          H
        );
      }
      getScopeValue(T, O) {
        return this._extScope.getValue(T, O);
      }
      scopeRefs(T) {
        return this._extScope.scopeRefs(T, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(T, O, H, ce) {
        let oe = this._scope.toName(O);
        return (
          H !== void 0 && ce && (this._constants[oe.str] = H),
          this._leafNode(new i(T, oe, H)),
          oe
        );
      }
      const(T, O, H) {
        return this._def(r.varKinds.const, T, O, H);
      }
      let(T, O, H) {
        return this._def(r.varKinds.let, T, O, H);
      }
      var(T, O, H) {
        return this._def(r.varKinds.var, T, O, H);
      }
      assign(T, O, H) {
        return this._leafNode(new o(T, O, H));
      }
      add(T, O) {
        return this._leafNode(new c(T, t.operators.ADD, O));
      }
      code(T) {
        return (
          typeof T == "function"
            ? T()
            : T !== e.nil && this._leafNode(new m(T)),
          this
        );
      }
      object(...T) {
        let O = ["{"];
        for (let [H, ce] of T)
          (O.length > 1 && O.push(","),
            O.push(H),
            (H !== ce || this.opts.es5) &&
              (O.push(":"), (0, e.addCodeArg)(O, ce)));
        return (O.push("}"), new e._Code(O));
      }
      if(T, O, H) {
        if ((this._blockNode(new g(T)), O && H))
          this.code(O).else().code(H).endIf();
        else if (O) this.code(O).endIf();
        else if (H) throw new Error('CodeGen: "else" body without "then" body');
        return this;
      }
      elseIf(T) {
        return this._elseNode(new g(T));
      }
      else() {
        return this._elseNode(new h());
      }
      endIf() {
        return this._endBlockNode(g, h);
      }
      _for(T, O) {
        return (this._blockNode(T), O && this.code(O).endFor(), this);
      }
      for(T, O) {
        return this._for(new v(T), O);
      }
      forRange(
        T,
        O,
        H,
        ce,
        oe = this.opts.es5 ? r.varKinds.var : r.varKinds.let,
      ) {
        let Fe = this._scope.toName(T);
        return this._for(new b(oe, Fe, O, H), () => ce(Fe));
      }
      forOf(T, O, H, ce = r.varKinds.const) {
        let oe = this._scope.toName(T);
        if (this.opts.es5) {
          let Fe = O instanceof e.Name ? O : this.var("_arr", O);
          return this.forRange("_i", 0, (0, e._)`${Fe}.length`, (Ee) => {
            (this.var(oe, (0, e._)`${Fe}[${Ee}]`), H(oe));
          });
        }
        return this._for(new x("of", ce, oe, O), () => H(oe));
      }
      forIn(T, O, H, ce = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf(T, (0, e._)`Object.keys(${O})`, H);
        let oe = this._scope.toName(T);
        return this._for(new x("in", ce, oe, O), () => H(oe));
      }
      endFor() {
        return this._endBlockNode(_);
      }
      label(T) {
        return this._leafNode(new l(T));
      }
      break(T) {
        return this._leafNode(new u(T));
      }
      return(T) {
        let O = new S();
        if ((this._blockNode(O), this.code(T), O.nodes.length !== 1))
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(S);
      }
      try(T, O, H) {
        if (!O && !H)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        let ce = new C();
        if ((this._blockNode(ce), this.code(T), O)) {
          let oe = this.name("e");
          ((this._currNode = ce.catch = new P(oe)), O(oe));
        }
        return (
          H && ((this._currNode = ce.finally = new A()), this.code(H)),
          this._endBlockNode(P, A)
        );
      }
      throw(T) {
        return this._leafNode(new d(T));
      }
      block(T, O) {
        return (
          this._blockStarts.push(this._nodes.length),
          T && this.code(T).endBlock(O),
          this
        );
      }
      endBlock(T) {
        let O = this._blockStarts.pop();
        if (O === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        let H = this._nodes.length - O;
        if (H < 0 || (T !== void 0 && H !== T))
          throw new Error(
            `CodeGen: wrong number of nodes: ${H} vs ${T} expected`,
          );
        return ((this._nodes.length = O), this);
      }
      func(T, O = e.nil, H, ce) {
        return (
          this._blockNode(new w(T, O, H)),
          ce && this.code(ce).endFunc(),
          this
        );
      }
      endFunc() {
        return this._endBlockNode(w);
      }
      optimize(T = 1) {
        for (; T-- > 0; )
          (this._root.optimizeNodes(),
            this._root.optimizeNames(this._root.names, this._constants));
      }
      _leafNode(T) {
        return (this._currNode.nodes.push(T), this);
      }
      _blockNode(T) {
        (this._currNode.nodes.push(T), this._nodes.push(T));
      }
      _endBlockNode(T, O) {
        let H = this._currNode;
        if (H instanceof T || (O && H instanceof O))
          return (this._nodes.pop(), this);
        throw new Error(
          `CodeGen: not in block "${O ? `${T.kind}/${O.kind}` : T.kind}"`,
        );
      }
      _elseNode(T) {
        let O = this._currNode;
        if (!(O instanceof g)) throw new Error('CodeGen: "else" without "if"');
        return ((this._currNode = O.else = T), this);
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        let T = this._nodes;
        return T[T.length - 1];
      }
      set _currNode(T) {
        let O = this._nodes;
        O[O.length - 1] = T;
      }
    }
    t.CodeGen = R;
    function D(U, T) {
      for (let O in T) U[O] = (U[O] || 0) + (T[O] || 0);
      return U;
    }
    function F(U, T) {
      return T instanceof e._CodeOrName ? D(U, T.names) : U;
    }
    function I(U, T, O) {
      if (U instanceof e.Name) return H(U);
      if (!ce(U)) return U;
      return new e._Code(
        U._items.reduce(
          (oe, Fe) => (
            Fe instanceof e.Name && (Fe = H(Fe)),
            Fe instanceof e._Code ? oe.push(...Fe._items) : oe.push(Fe),
            oe
          ),
          [],
        ),
      );
      function H(oe) {
        let Fe = O[oe.str];
        return Fe === void 0 || T[oe.str] !== 1 ? oe : (delete T[oe.str], Fe);
      }
      function ce(oe) {
        return (
          oe instanceof e._Code &&
          oe._items.some(
            (Fe) =>
              Fe instanceof e.Name && T[Fe.str] === 1 && O[Fe.str] !== void 0,
          )
        );
      }
    }
    function K(U, T) {
      for (let O in T) U[O] = (U[O] || 0) - (T[O] || 0);
    }
    function ee(U) {
      return typeof U == "boolean" || typeof U == "number" || U === null
        ? !U
        : (0, e._)`!${G(U)}`;
    }
    t.not = ee;
    var Y = $(t.operators.AND);
    function Q(...U) {
      return U.reduce(Y);
    }
    t.and = Q;
    var ae = $(t.operators.OR);
    function B(...U) {
      return U.reduce(ae);
    }
    t.or = B;
    function $(U) {
      return (T, O) =>
        T === e.nil ? O : O === e.nil ? T : (0, e._)`${G(T)} ${U} ${G(O)}`;
    }
    function G(U) {
      return U instanceof e.Name ? U : (0, e._)`(${U})`;
    }
  }),
  st = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.checkStrictMode =
        t.getErrorPath =
        t.Type =
        t.useFunc =
        t.setEvaluated =
        t.evaluatedPropsToName =
        t.mergeEvaluated =
        t.eachItem =
        t.unescapeJsonPointer =
        t.escapeJsonPointer =
        t.escapeFragment =
        t.unescapeFragment =
        t.schemaRefOrVal =
        t.schemaHasRulesButRef =
        t.schemaHasRules =
        t.checkUnknownRules =
        t.alwaysValidSchema =
        t.toHash =
          void 0));
    var e = Ze(),
      r = Hl();
    function n(w) {
      let S = {};
      for (let C of w) S[C] = !0;
      return S;
    }
    t.toHash = n;
    function s(w, S) {
      return typeof S == "boolean"
        ? S
        : Object.keys(S).length === 0
          ? !0
          : (a(w, S), !i(S, w.self.RULES.all));
    }
    t.alwaysValidSchema = s;
    function a(w, S = w.schema) {
      let { opts: C, self: P } = w;
      if (!C.strictSchema || typeof S == "boolean") return;
      let A = P.RULES.keywords;
      for (let R in S) A[R] || x(w, `unknown keyword: "${R}"`);
    }
    t.checkUnknownRules = a;
    function i(w, S) {
      if (typeof w == "boolean") return !w;
      for (let C in w) if (S[C]) return !0;
      return !1;
    }
    t.schemaHasRules = i;
    function o(w, S) {
      if (typeof w == "boolean") return !w;
      for (let C in w) if (C !== "$ref" && S.all[C]) return !0;
      return !1;
    }
    t.schemaHasRulesButRef = o;
    function c({ topSchemaRef: w, schemaPath: S }, C, P, A) {
      if (!A) {
        if (typeof C == "number" || typeof C == "boolean") return C;
        if (typeof C == "string") return (0, e._)`${C}`;
      }
      return (0, e._)`${w}${S}${(0, e.getProperty)(P)}`;
    }
    t.schemaRefOrVal = c;
    function l(w) {
      return m(decodeURIComponent(w));
    }
    t.unescapeFragment = l;
    function u(w) {
      return encodeURIComponent(d(w));
    }
    t.escapeFragment = u;
    function d(w) {
      return typeof w == "number"
        ? `${w}`
        : w.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    t.escapeJsonPointer = d;
    function m(w) {
      return w.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    t.unescapeJsonPointer = m;
    function p(w, S) {
      if (Array.isArray(w)) for (let C of w) S(C);
      else S(w);
    }
    t.eachItem = p;
    function f({
      mergeNames: w,
      mergeToName: S,
      mergeValues: C,
      resultToName: P,
    }) {
      return (A, R, D, F) => {
        let I =
          D === void 0
            ? R
            : D instanceof e.Name
              ? (R instanceof e.Name ? w(A, R, D) : S(A, R, D), D)
              : R instanceof e.Name
                ? (S(A, D, R), R)
                : C(R, D);
        return F === e.Name && !(I instanceof e.Name) ? P(A, I) : I;
      };
    }
    t.mergeEvaluated = {
      props: f({
        mergeNames: (w, S, C) =>
          w.if((0, e._)`${C} !== true && ${S} !== undefined`, () => {
            w.if(
              (0, e._)`${S} === true`,
              () => w.assign(C, !0),
              () =>
                w
                  .assign(C, (0, e._)`${C} || {}`)
                  .code((0, e._)`Object.assign(${C}, ${S})`),
            );
          }),
        mergeToName: (w, S, C) =>
          w.if((0, e._)`${C} !== true`, () => {
            S === !0
              ? w.assign(C, !0)
              : (w.assign(C, (0, e._)`${C} || {}`), h(w, C, S));
          }),
        mergeValues: (w, S) => (w === !0 ? !0 : { ...w, ...S }),
        resultToName: y,
      }),
      items: f({
        mergeNames: (w, S, C) =>
          w.if((0, e._)`${C} !== true && ${S} !== undefined`, () =>
            w.assign(
              C,
              (0, e._)`${S} === true ? true : ${C} > ${S} ? ${C} : ${S}`,
            ),
          ),
        mergeToName: (w, S, C) =>
          w.if((0, e._)`${C} !== true`, () =>
            w.assign(C, S === !0 ? !0 : (0, e._)`${C} > ${S} ? ${C} : ${S}`),
          ),
        mergeValues: (w, S) => (w === !0 ? !0 : Math.max(w, S)),
        resultToName: (w, S) => w.var("items", S),
      }),
    };
    function y(w, S) {
      if (S === !0) return w.var("props", !0);
      let C = w.var("props", (0, e._)`{}`);
      return (S !== void 0 && h(w, C, S), C);
    }
    t.evaluatedPropsToName = y;
    function h(w, S, C) {
      Object.keys(C).forEach((P) =>
        w.assign((0, e._)`${S}${(0, e.getProperty)(P)}`, !0),
      );
    }
    t.setEvaluated = h;
    var g = {};
    function _(w, S) {
      return w.scopeValue("func", {
        ref: S,
        code: g[S.code] || (g[S.code] = new r._Code(S.code)),
      });
    }
    t.useFunc = _;
    var v;
    (function (w) {
      ((w[(w.Num = 0)] = "Num"), (w[(w.Str = 1)] = "Str"));
    })(v || (t.Type = v = {}));
    function b(w, S, C) {
      if (w instanceof e.Name) {
        let P = S === v.Num;
        return C
          ? P
            ? (0, e._)`"[" + ${w} + "]"`
            : (0, e._)`"['" + ${w} + "']"`
          : P
            ? (0, e._)`"/" + ${w}`
            : (0, e._)`"/" + ${w}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return C ? (0, e.getProperty)(w).toString() : "/" + d(w);
    }
    t.getErrorPath = b;
    function x(w, S, C = w.opts.strictSchema) {
      if (C) {
        if (((S = `strict mode: ${S}`), C === !0)) throw new Error(S);
        w.self.logger.warn(S);
      }
    }
    t.checkStrictMode = x;
  }),
  Es = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = Ze(),
      r = {
        data: new e.Name("data"),
        valCxt: new e.Name("valCxt"),
        instancePath: new e.Name("instancePath"),
        parentData: new e.Name("parentData"),
        parentDataProperty: new e.Name("parentDataProperty"),
        rootData: new e.Name("rootData"),
        dynamicAnchors: new e.Name("dynamicAnchors"),
        vErrors: new e.Name("vErrors"),
        errors: new e.Name("errors"),
        this: new e.Name("this"),
        self: new e.Name("self"),
        scope: new e.Name("scope"),
        json: new e.Name("json"),
        jsonPos: new e.Name("jsonPos"),
        jsonLen: new e.Name("jsonLen"),
        jsonPart: new e.Name("jsonPart"),
      };
    t.default = r;
  }),
  su = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.extendErrors =
        t.resetErrorsCount =
        t.reportExtraError =
        t.reportError =
        t.keyword$DataError =
        t.keywordError =
          void 0));
    var e = Ze(),
      r = st(),
      n = Es();
    ((t.keywordError = {
      message: ({ keyword: h }) =>
        (0, e.str)`must pass "${h}" keyword validation`,
    }),
      (t.keyword$DataError = {
        message: ({ keyword: h, schemaType: g }) =>
          g
            ? (0, e.str)`"${h}" keyword must be ${g} ($data)`
            : (0, e.str)`"${h}" keyword is invalid ($data)`,
      }));
    function s(h, g = t.keywordError, _, v) {
      let { it: b } = h,
        { gen: x, compositeRule: w, allErrors: S } = b,
        C = d(h, g, _);
      (v ?? (w || S)) ? c(x, C) : l(b, (0, e._)`[${C}]`);
    }
    t.reportError = s;
    function a(h, g = t.keywordError, _) {
      let { it: v } = h,
        { gen: b, compositeRule: x, allErrors: w } = v,
        S = d(h, g, _);
      (c(b, S), x || w || l(v, n.default.vErrors));
    }
    t.reportExtraError = a;
    function i(h, g) {
      (h.assign(n.default.errors, g),
        h.if((0, e._)`${n.default.vErrors} !== null`, () =>
          h.if(
            g,
            () => h.assign((0, e._)`${n.default.vErrors}.length`, g),
            () => h.assign(n.default.vErrors, null),
          ),
        ));
    }
    t.resetErrorsCount = i;
    function o({
      gen: h,
      keyword: g,
      schemaValue: _,
      data: v,
      errsCount: b,
      it: x,
    }) {
      if (b === void 0) throw new Error("ajv implementation error");
      let w = h.name("err");
      h.forRange("i", b, n.default.errors, (S) => {
        (h.const(w, (0, e._)`${n.default.vErrors}[${S}]`),
          h.if((0, e._)`${w}.instancePath === undefined`, () =>
            h.assign(
              (0, e._)`${w}.instancePath`,
              (0, e.strConcat)(n.default.instancePath, x.errorPath),
            ),
          ),
          h.assign(
            (0, e._)`${w}.schemaPath`,
            (0, e.str)`${x.errSchemaPath}/${g}`,
          ),
          x.opts.verbose &&
            (h.assign((0, e._)`${w}.schema`, _),
            h.assign((0, e._)`${w}.data`, v)));
      });
    }
    t.extendErrors = o;
    function c(h, g) {
      let _ = h.const("err", g);
      (h.if(
        (0, e._)`${n.default.vErrors} === null`,
        () => h.assign(n.default.vErrors, (0, e._)`[${_}]`),
        (0, e._)`${n.default.vErrors}.push(${_})`,
      ),
        h.code((0, e._)`${n.default.errors}++`));
    }
    function l(h, g) {
      let { gen: _, validateName: v, schemaEnv: b } = h;
      b.$async
        ? _.throw((0, e._)`new ${h.ValidationError}(${g})`)
        : (_.assign((0, e._)`${v}.errors`, g), _.return(!1));
    }
    var u = {
      keyword: new e.Name("keyword"),
      schemaPath: new e.Name("schemaPath"),
      params: new e.Name("params"),
      propertyName: new e.Name("propertyName"),
      message: new e.Name("message"),
      schema: new e.Name("schema"),
      parentSchema: new e.Name("parentSchema"),
    };
    function d(h, g, _) {
      let { createErrors: v } = h.it;
      return v === !1 ? (0, e._)`{}` : m(h, g, _);
    }
    function m(h, g, _ = {}) {
      let { gen: v, it: b } = h,
        x = [p(b, _), f(h, _)];
      return (y(h, g, x), v.object(...x));
    }
    function p({ errorPath: h }, { instancePath: g }) {
      let _ = g ? (0, e.str)`${h}${(0, r.getErrorPath)(g, r.Type.Str)}` : h;
      return [
        n.default.instancePath,
        (0, e.strConcat)(n.default.instancePath, _),
      ];
    }
    function f(
      { keyword: h, it: { errSchemaPath: g } },
      { schemaPath: _, parentSchema: v },
    ) {
      let b = v ? g : (0, e.str)`${g}/${h}`;
      return (
        _ && (b = (0, e.str)`${b}${(0, r.getErrorPath)(_, r.Type.Str)}`),
        [u.schemaPath, b]
      );
    }
    function y(h, { params: g, message: _ }, v) {
      let { keyword: b, data: x, schemaValue: w, it: S } = h,
        { opts: C, propertyName: P, topSchemaRef: A, schemaPath: R } = S;
      (v.push(
        [u.keyword, b],
        [u.params, typeof g == "function" ? g(h) : g || (0, e._)`{}`],
      ),
        C.messages && v.push([u.message, typeof _ == "function" ? _(h) : _]),
        C.verbose &&
          v.push(
            [u.schema, w],
            [u.parentSchema, (0, e._)`${A}${R}`],
            [n.default.data, x],
          ),
        P && v.push([u.propertyName, P]));
    }
  }),
  OF = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.boolOrEmptySchema = t.topBoolOrEmptySchema = void 0));
    var e = su(),
      r = Ze(),
      n = Es(),
      s = { message: "boolean schema is false" };
    function a(c) {
      let { gen: l, schema: u, validateName: d } = c;
      u === !1
        ? o(c, !1)
        : typeof u == "object" && u.$async === !0
          ? l.return(n.default.data)
          : (l.assign((0, r._)`${d}.errors`, null), l.return(!0));
    }
    t.topBoolOrEmptySchema = a;
    function i(c, l) {
      let { gen: u, schema: d } = c;
      d === !1 ? (u.var(l, !1), o(c)) : u.var(l, !0);
    }
    t.boolOrEmptySchema = i;
    function o(c, l) {
      let { gen: u, data: d } = c,
        m = {
          gen: u,
          keyword: "false schema",
          data: d,
          schema: !1,
          schemaCode: !1,
          schemaValue: !1,
          params: {},
          it: c,
        };
      (0, e.reportError)(m, s, void 0, l);
    }
  }),
  DS = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.getRules = t.isJSONType = void 0));
    var e = [
        "string",
        "number",
        "integer",
        "boolean",
        "null",
        "object",
        "array",
      ],
      r = new Set(e);
    function n(a) {
      return typeof a == "string" && r.has(a);
    }
    t.isJSONType = n;
    function s() {
      let a = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] },
      };
      return {
        types: { ...a, integer: !0, boolean: !0, null: !0 },
        rules: [{ rules: [] }, a.number, a.string, a.array, a.object],
        post: { rules: [] },
        all: {},
        keywords: {},
      };
    }
    t.getRules = s;
  }),
  LS = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.shouldUseRule = t.shouldUseGroup = t.schemaHasRulesForType = void 0));
    function e({ schema: s, self: a }, i) {
      let o = a.RULES.types[i];
      return o && o !== !0 && r(s, o);
    }
    t.schemaHasRulesForType = e;
    function r(s, a) {
      return a.rules.some((i) => n(s, i));
    }
    t.shouldUseGroup = r;
    function n(s, a) {
      var i;
      return (
        s[a.keyword] !== void 0 ||
        ((i = a.definition.implements) === null || i === void 0
          ? void 0
          : i.some((o) => s[o] !== void 0))
      );
    }
    t.shouldUseRule = n;
  }),
  Vl = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.reportTypeError =
        t.checkDataTypes =
        t.checkDataType =
        t.coerceAndCheckDataType =
        t.getJSONTypes =
        t.getSchemaTypes =
        t.DataType =
          void 0));
    var e = DS(),
      r = LS(),
      n = su(),
      s = Ze(),
      a = st(),
      i;
    (function (v) {
      ((v[(v.Correct = 0)] = "Correct"), (v[(v.Wrong = 1)] = "Wrong"));
    })(i || (t.DataType = i = {}));
    function o(v) {
      let b = c(v.type);
      if (b.includes("null")) {
        if (v.nullable === !1)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!b.length && v.nullable !== void 0)
          throw new Error('"nullable" cannot be used without "type"');
        v.nullable === !0 && b.push("null");
      }
      return b;
    }
    t.getSchemaTypes = o;
    function c(v) {
      let b = Array.isArray(v) ? v : v ? [v] : [];
      if (b.every(e.isJSONType)) return b;
      throw new Error("type must be JSONType or JSONType[]: " + b.join(","));
    }
    t.getJSONTypes = c;
    function l(v, b) {
      let { gen: x, data: w, opts: S } = v,
        C = d(b, S.coerceTypes),
        P =
          b.length > 0 &&
          !(
            C.length === 0 &&
            b.length === 1 &&
            (0, r.schemaHasRulesForType)(v, b[0])
          );
      if (P) {
        let A = y(b, w, S.strictNumbers, i.Wrong);
        x.if(A, () => {
          C.length ? m(v, b, C) : g(v);
        });
      }
      return P;
    }
    t.coerceAndCheckDataType = l;
    var u = new Set(["string", "number", "integer", "boolean", "null"]);
    function d(v, b) {
      return b
        ? v.filter((x) => u.has(x) || (b === "array" && x === "array"))
        : [];
    }
    function m(v, b, x) {
      let { gen: w, data: S, opts: C } = v,
        P = w.let("dataType", (0, s._)`typeof ${S}`),
        A = w.let("coerced", (0, s._)`undefined`);
      (C.coerceTypes === "array" &&
        w.if(
          (0, s._)`${P} == 'object' && Array.isArray(${S}) && ${S}.length == 1`,
          () =>
            w
              .assign(S, (0, s._)`${S}[0]`)
              .assign(P, (0, s._)`typeof ${S}`)
              .if(y(b, S, C.strictNumbers), () => w.assign(A, S)),
        ),
        w.if((0, s._)`${A} !== undefined`));
      for (let D of x)
        (u.has(D) || (D === "array" && C.coerceTypes === "array")) && R(D);
      (w.else(),
        g(v),
        w.endIf(),
        w.if((0, s._)`${A} !== undefined`, () => {
          (w.assign(S, A), p(v, A));
        }));
      function R(D) {
        switch (D) {
          case "string":
            w.elseIf((0, s._)`${P} == "number" || ${P} == "boolean"`)
              .assign(A, (0, s._)`"" + ${S}`)
              .elseIf((0, s._)`${S} === null`)
              .assign(A, (0, s._)`""`);
            return;
          case "number":
            w.elseIf(
              (0, s._)`${P} == "boolean" || ${S} === null
              || (${P} == "string" && ${S} && ${S} == +${S})`,
            ).assign(A, (0, s._)`+${S}`);
            return;
          case "integer":
            w.elseIf(
              (0, s._)`${P} === "boolean" || ${S} === null
              || (${P} === "string" && ${S} && ${S} == +${S} && !(${S} % 1))`,
            ).assign(A, (0, s._)`+${S}`);
            return;
          case "boolean":
            w.elseIf((0, s._)`${S} === "false" || ${S} === 0 || ${S} === null`)
              .assign(A, !1)
              .elseIf((0, s._)`${S} === "true" || ${S} === 1`)
              .assign(A, !0);
            return;
          case "null":
            (w.elseIf((0, s._)`${S} === "" || ${S} === 0 || ${S} === false`),
              w.assign(A, null));
            return;
          case "array":
            w.elseIf(
              (0, s._)`${P} === "string" || ${P} === "number"
              || ${P} === "boolean" || ${S} === null`,
            ).assign(A, (0, s._)`[${S}]`);
        }
      }
    }
    function p({ gen: v, parentData: b, parentDataProperty: x }, w) {
      v.if((0, s._)`${b} !== undefined`, () =>
        v.assign((0, s._)`${b}[${x}]`, w),
      );
    }
    function f(v, b, x, w = i.Correct) {
      let S = w === i.Correct ? s.operators.EQ : s.operators.NEQ,
        C;
      switch (v) {
        case "null":
          return (0, s._)`${b} ${S} null`;
        case "array":
          C = (0, s._)`Array.isArray(${b})`;
          break;
        case "object":
          C = (0, s._)`${b} && typeof ${b} == "object" && !Array.isArray(${b})`;
          break;
        case "integer":
          C = P((0, s._)`!(${b} % 1) && !isNaN(${b})`);
          break;
        case "number":
          C = P();
          break;
        default:
          return (0, s._)`typeof ${b} ${S} ${v}`;
      }
      return w === i.Correct ? C : (0, s.not)(C);
      function P(A = s.nil) {
        return (0, s.and)(
          (0, s._)`typeof ${b} == "number"`,
          A,
          x ? (0, s._)`isFinite(${b})` : s.nil,
        );
      }
    }
    t.checkDataType = f;
    function y(v, b, x, w) {
      if (v.length === 1) return f(v[0], b, x, w);
      let S,
        C = (0, a.toHash)(v);
      if (C.array && C.object) {
        let P = (0, s._)`typeof ${b} != "object"`;
        ((S = C.null ? P : (0, s._)`!${b} || ${P}`),
          delete C.null,
          delete C.array,
          delete C.object);
      } else S = s.nil;
      C.number && delete C.integer;
      for (let P in C) S = (0, s.and)(S, f(P, b, x, w));
      return S;
    }
    t.checkDataTypes = y;
    var h = {
      message: ({ schema: v }) => `must be ${v}`,
      params: ({ schema: v, schemaValue: b }) =>
        typeof v == "string" ? (0, s._)`{type: ${v}}` : (0, s._)`{type: ${b}}`,
    };
    function g(v) {
      let b = _(v);
      (0, n.reportError)(b, h);
    }
    t.reportTypeError = g;
    function _(v) {
      let { gen: b, data: x, schema: w } = v,
        S = (0, a.schemaRefOrVal)(v, w, "type");
      return {
        gen: b,
        keyword: "type",
        data: x,
        schema: w.type,
        schemaCode: S,
        schemaValue: S,
        parentSchema: w,
        params: {},
        it: v,
      };
    }
  }),
  IF = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.assignDefaults = void 0));
    var e = Ze(),
      r = st();
    function n(a, i) {
      let { properties: o, items: c } = a.schema;
      if (i === "object" && o) for (let l in o) s(a, l, o[l].default);
      else
        i === "array" &&
          Array.isArray(c) &&
          c.forEach((l, u) => s(a, u, l.default));
    }
    t.assignDefaults = n;
    function s(a, i, o) {
      let { gen: c, compositeRule: l, data: u, opts: d } = a;
      if (o === void 0) return;
      let m = (0, e._)`${u}${(0, e.getProperty)(i)}`;
      if (l) {
        (0, r.checkStrictMode)(a, `default is ignored for: ${m}`);
        return;
      }
      let p = (0, e._)`${m} === undefined`;
      (d.useDefaults === "empty" &&
        (p = (0, e._)`${p} || ${m} === null || ${m} === ""`),
        c.if(p, (0, e._)`${m} = ${(0, e.stringify)(o)}`));
    }
  }),
  fn = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.validateUnion =
        t.validateArray =
        t.usePattern =
        t.callValidateCode =
        t.schemaProperties =
        t.allSchemaProperties =
        t.noPropertyInData =
        t.propertyInData =
        t.isOwnProperty =
        t.hasPropFunc =
        t.reportMissingProp =
        t.checkMissingProp =
        t.checkReportMissingProp =
          void 0));
    var e = Ze(),
      r = st(),
      n = Es(),
      s = st();
    function a(v, b) {
      let { gen: x, data: w, it: S } = v;
      x.if(d(x, w, b, S.opts.ownProperties), () => {
        (v.setParams({ missingProperty: (0, e._)`${b}` }, !0), v.error());
      });
    }
    t.checkReportMissingProp = a;
    function i({ gen: v, data: b, it: { opts: x } }, w, S) {
      return (0, e.or)(
        ...w.map((C) =>
          (0, e.and)(d(v, b, C, x.ownProperties), (0, e._)`${S} = ${C}`),
        ),
      );
    }
    t.checkMissingProp = i;
    function o(v, b) {
      (v.setParams({ missingProperty: b }, !0), v.error());
    }
    t.reportMissingProp = o;
    function c(v) {
      return v.scopeValue("func", {
        ref: Object.prototype.hasOwnProperty,
        code: (0, e._)`Object.prototype.hasOwnProperty`,
      });
    }
    t.hasPropFunc = c;
    function l(v, b, x) {
      return (0, e._)`${c(v)}.call(${b}, ${x})`;
    }
    t.isOwnProperty = l;
    function u(v, b, x, w) {
      let S = (0, e._)`${b}${(0, e.getProperty)(x)} !== undefined`;
      return w ? (0, e._)`${S} && ${l(v, b, x)}` : S;
    }
    t.propertyInData = u;
    function d(v, b, x, w) {
      let S = (0, e._)`${b}${(0, e.getProperty)(x)} === undefined`;
      return w ? (0, e.or)(S, (0, e.not)(l(v, b, x))) : S;
    }
    t.noPropertyInData = d;
    function m(v) {
      return v ? Object.keys(v).filter((b) => b !== "__proto__") : [];
    }
    t.allSchemaProperties = m;
    function p(v, b) {
      return m(b).filter((x) => !(0, r.alwaysValidSchema)(v, b[x]));
    }
    t.schemaProperties = p;
    function f(
      {
        schemaCode: v,
        data: b,
        it: { gen: x, topSchemaRef: w, schemaPath: S, errorPath: C },
        it: P,
      },
      A,
      R,
      D,
    ) {
      let F = D ? (0, e._)`${v}, ${b}, ${w}${S}` : b,
        I = [
          [n.default.instancePath, (0, e.strConcat)(n.default.instancePath, C)],
          [n.default.parentData, P.parentData],
          [n.default.parentDataProperty, P.parentDataProperty],
          [n.default.rootData, n.default.rootData],
        ];
      P.opts.dynamicRef &&
        I.push([n.default.dynamicAnchors, n.default.dynamicAnchors]);
      let K = (0, e._)`${F}, ${x.object(...I)}`;
      return R !== e.nil
        ? (0, e._)`${A}.call(${R}, ${K})`
        : (0, e._)`${A}(${K})`;
    }
    t.callValidateCode = f;
    var y = (0, e._)`new RegExp`;
    function h({ gen: v, it: { opts: b } }, x) {
      let w = b.unicodeRegExp ? "u" : "",
        { regExp: S } = b.code,
        C = S(x, w);
      return v.scopeValue("pattern", {
        key: C.toString(),
        ref: C,
        code: (0,
        e._)`${S.code === "new RegExp" ? y : (0, s.useFunc)(v, S)}(${x}, ${w})`,
      });
    }
    t.usePattern = h;
    function g(v) {
      let { gen: b, data: x, keyword: w, it: S } = v,
        C = b.name("valid");
      if (S.allErrors) {
        let A = b.let("valid", !0);
        return (P(() => b.assign(A, !1)), A);
      }
      return (b.var(C, !0), P(() => b.break()), C);
      function P(A) {
        let R = b.const("len", (0, e._)`${x}.length`);
        b.forRange("i", 0, R, (D) => {
          (v.subschema(
            { keyword: w, dataProp: D, dataPropType: r.Type.Num },
            C,
          ),
            b.if((0, e.not)(C), A));
        });
      }
    }
    t.validateArray = g;
    function _(v) {
      let { gen: b, schema: x, keyword: w, it: S } = v;
      if (!Array.isArray(x)) throw new Error("ajv implementation error");
      if (x.some((R) => (0, r.alwaysValidSchema)(S, R)) && !S.opts.unevaluated)
        return;
      let P = b.let("valid", !1),
        A = b.name("_valid");
      (b.block(() =>
        x.forEach((R, D) => {
          let F = v.subschema(
            { keyword: w, schemaProp: D, compositeRule: !0 },
            A,
          );
          (b.assign(P, (0, e._)`${P} || ${A}`),
            v.mergeValidEvaluated(F, A) || b.if((0, e.not)(P)));
        }),
      ),
        v.result(
          P,
          () => v.reset(),
          () => v.error(!0),
        ));
    }
    t.validateUnion = _;
  }),
  $F = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.validateKeywordUsage =
        t.validSchemaType =
        t.funcKeywordCode =
        t.macroKeywordCode =
          void 0));
    var e = Ze(),
      r = Es(),
      n = fn(),
      s = su();
    function a(p, f) {
      let { gen: y, keyword: h, schema: g, parentSchema: _, it: v } = p,
        b = f.macro.call(v.self, g, _, v),
        x = u(y, h, b);
      v.opts.validateSchema !== !1 && v.self.validateSchema(b, !0);
      let w = y.name("valid");
      (p.subschema(
        {
          schema: b,
          schemaPath: e.nil,
          errSchemaPath: `${v.errSchemaPath}/${h}`,
          topSchemaRef: x,
          compositeRule: !0,
        },
        w,
      ),
        p.pass(w, () => p.error(!0)));
    }
    t.macroKeywordCode = a;
    function i(p, f) {
      var y;
      let {
        gen: h,
        keyword: g,
        schema: _,
        parentSchema: v,
        $data: b,
        it: x,
      } = p;
      l(x, f);
      let w = !b && f.compile ? f.compile.call(x.self, _, v, x) : f.validate,
        S = u(h, g, w),
        C = h.let("valid");
      (p.block$data(C, P),
        p.ok((y = f.valid) !== null && y !== void 0 ? y : C));
      function P() {
        if (f.errors === !1) (D(), f.modifying && o(p), F(() => p.error()));
        else {
          let I = f.async ? A() : R();
          (f.modifying && o(p), F(() => c(p, I)));
        }
      }
      function A() {
        let I = h.let("ruleErrs", null);
        return (
          h.try(
            () => D((0, e._)`await `),
            (K) =>
              h.assign(C, !1).if(
                (0, e._)`${K} instanceof ${x.ValidationError}`,
                () => h.assign(I, (0, e._)`${K}.errors`),
                () => h.throw(K),
              ),
          ),
          I
        );
      }
      function R() {
        let I = (0, e._)`${S}.errors`;
        return (h.assign(I, null), D(e.nil), I);
      }
      function D(I = f.async ? (0, e._)`await ` : e.nil) {
        let K = x.opts.passContext ? r.default.this : r.default.self,
          ee = !(("compile" in f && !b) || f.schema === !1);
        h.assign(
          C,
          (0, e._)`${I}${(0, n.callValidateCode)(p, S, K, ee)}`,
          f.modifying,
        );
      }
      function F(I) {
        var K;
        h.if((0, e.not)((K = f.valid) !== null && K !== void 0 ? K : C), I);
      }
    }
    t.funcKeywordCode = i;
    function o(p) {
      let { gen: f, data: y, it: h } = p;
      f.if(h.parentData, () =>
        f.assign(y, (0, e._)`${h.parentData}[${h.parentDataProperty}]`),
      );
    }
    function c(p, f) {
      let { gen: y } = p;
      y.if(
        (0, e._)`Array.isArray(${f})`,
        () => {
          (y
            .assign(
              r.default.vErrors,
              (0,
              e._)`${r.default.vErrors} === null ? ${f} : ${r.default.vErrors}.concat(${f})`,
            )
            .assign(r.default.errors, (0, e._)`${r.default.vErrors}.length`),
            (0, s.extendErrors)(p));
        },
        () => p.error(),
      );
    }
    function l({ schemaEnv: p }, f) {
      if (f.async && !p.$async) throw new Error("async keyword in sync schema");
    }
    function u(p, f, y) {
      if (y === void 0) throw new Error(`keyword "${f}" failed to compile`);
      return p.scopeValue(
        "keyword",
        typeof y == "function"
          ? { ref: y }
          : { ref: y, code: (0, e.stringify)(y) },
      );
    }
    function d(p, f, y = !1) {
      return (
        !f.length ||
        f.some((h) =>
          h === "array"
            ? Array.isArray(p)
            : h === "object"
              ? p && typeof p == "object" && !Array.isArray(p)
              : typeof p == h || (y && typeof p > "u"),
        )
      );
    }
    t.validSchemaType = d;
    function m({ schema: p, opts: f, self: y, errSchemaPath: h }, g, _) {
      if (Array.isArray(g.keyword) ? !g.keyword.includes(_) : g.keyword !== _)
        throw new Error("ajv implementation error");
      let v = g.dependencies;
      if (v?.some((b) => !Object.prototype.hasOwnProperty.call(p, b)))
        throw new Error(
          `parent schema must have dependencies of ${_}: ${v.join(",")}`,
        );
      if (g.validateSchema && !g.validateSchema(p[_])) {
        let x =
          `keyword "${_}" value is invalid at path "${h}": ` +
          y.errorsText(g.validateSchema.errors);
        if (f.validateSchema === "log") y.logger.error(x);
        else throw new Error(x);
      }
    }
    t.validateKeywordUsage = m;
  }),
  AF = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.extendSubschemaMode =
        t.extendSubschemaData =
        t.getSubschema =
          void 0));
    var e = Ze(),
      r = st();
    function n(
      i,
      {
        keyword: o,
        schemaProp: c,
        schema: l,
        schemaPath: u,
        errSchemaPath: d,
        topSchemaRef: m,
      },
    ) {
      if (o !== void 0 && l !== void 0)
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      if (o !== void 0) {
        let p = i.schema[o];
        return c === void 0
          ? {
              schema: p,
              schemaPath: (0, e._)`${i.schemaPath}${(0, e.getProperty)(o)}`,
              errSchemaPath: `${i.errSchemaPath}/${o}`,
            }
          : {
              schema: p[c],
              schemaPath: (0,
              e._)`${i.schemaPath}${(0, e.getProperty)(o)}${(0, e.getProperty)(c)}`,
              errSchemaPath: `${i.errSchemaPath}/${o}/${(0, r.escapeFragment)(c)}`,
            };
      }
      if (l !== void 0) {
        if (u === void 0 || d === void 0 || m === void 0)
          throw new Error(
            '"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"',
          );
        return { schema: l, schemaPath: u, topSchemaRef: m, errSchemaPath: d };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    t.getSubschema = n;
    function s(
      i,
      o,
      { dataProp: c, dataPropType: l, data: u, dataTypes: d, propertyName: m },
    ) {
      if (u !== void 0 && c !== void 0)
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      let { gen: p } = o;
      if (c !== void 0) {
        let { errorPath: y, dataPathArr: h, opts: g } = o,
          _ = p.let("data", (0, e._)`${o.data}${(0, e.getProperty)(c)}`, !0);
        (f(_),
          (i.errorPath = (0,
          e.str)`${y}${(0, r.getErrorPath)(c, l, g.jsPropertySyntax)}`),
          (i.parentDataProperty = (0, e._)`${c}`),
          (i.dataPathArr = [...h, i.parentDataProperty]));
      }
      if (u !== void 0) {
        let y = u instanceof e.Name ? u : p.let("data", u, !0);
        (f(y), m !== void 0 && (i.propertyName = m));
      }
      d && (i.dataTypes = d);
      function f(y) {
        ((i.data = y),
          (i.dataLevel = o.dataLevel + 1),
          (i.dataTypes = []),
          (o.definedProperties = new Set()),
          (i.parentData = o.data),
          (i.dataNames = [...o.dataNames, y]));
      }
    }
    t.extendSubschemaData = s;
    function a(
      i,
      {
        jtdDiscriminator: o,
        jtdMetadata: c,
        compositeRule: l,
        createErrors: u,
        allErrors: d,
      },
    ) {
      (l !== void 0 && (i.compositeRule = l),
        u !== void 0 && (i.createErrors = u),
        d !== void 0 && (i.allErrors = d),
        (i.jtdDiscriminator = o),
        (i.jtdMetadata = c));
    }
    t.extendSubschemaMode = a;
  }),
  MS = ge((t, e) => {
    e.exports = function r(n, s) {
      if (n === s) return !0;
      if (n && s && typeof n == "object" && typeof s == "object") {
        if (n.constructor !== s.constructor) return !1;
        var a, i, o;
        if (Array.isArray(n)) {
          if (((a = n.length), a != s.length)) return !1;
          for (i = a; i-- !== 0; ) if (!r(n[i], s[i])) return !1;
          return !0;
        }
        if (n.constructor === RegExp)
          return n.source === s.source && n.flags === s.flags;
        if (n.valueOf !== Object.prototype.valueOf)
          return n.valueOf() === s.valueOf();
        if (n.toString !== Object.prototype.toString)
          return n.toString() === s.toString();
        if (((o = Object.keys(n)), (a = o.length), a !== Object.keys(s).length))
          return !1;
        for (i = a; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(s, o[i])) return !1;
        for (i = a; i-- !== 0; ) {
          var c = o[i];
          if (!r(n[c], s[c])) return !1;
        }
        return !0;
      }
      return n !== n && s !== s;
    };
  }),
  NF = ge((t, e) => {
    var r = (e.exports = function (a, i, o) {
      (typeof i == "function" && ((o = i), (i = {})), (o = i.cb || o));
      var c = typeof o == "function" ? o : o.pre || function () {},
        l = o.post || function () {};
      n(i, c, l, a, "", a);
    });
    ((r.keywords = {
      additionalItems: !0,
      items: !0,
      contains: !0,
      additionalProperties: !0,
      propertyNames: !0,
      not: !0,
      if: !0,
      then: !0,
      else: !0,
    }),
      (r.arrayKeywords = { items: !0, allOf: !0, anyOf: !0, oneOf: !0 }),
      (r.propsKeywords = {
        $defs: !0,
        definitions: !0,
        properties: !0,
        patternProperties: !0,
        dependencies: !0,
      }),
      (r.skipKeywords = {
        default: !0,
        enum: !0,
        const: !0,
        required: !0,
        maximum: !0,
        minimum: !0,
        exclusiveMaximum: !0,
        exclusiveMinimum: !0,
        multipleOf: !0,
        maxLength: !0,
        minLength: !0,
        pattern: !0,
        format: !0,
        maxItems: !0,
        minItems: !0,
        uniqueItems: !0,
        maxProperties: !0,
        minProperties: !0,
      }));
    function n(a, i, o, c, l, u, d, m, p, f) {
      if (c && typeof c == "object" && !Array.isArray(c)) {
        i(c, l, u, d, m, p, f);
        for (var y in c) {
          var h = c[y];
          if (Array.isArray(h)) {
            if (y in r.arrayKeywords)
              for (var g = 0; g < h.length; g++)
                n(a, i, o, h[g], l + "/" + y + "/" + g, u, l, y, c, g);
          } else if (y in r.propsKeywords) {
            if (h && typeof h == "object")
              for (var _ in h)
                n(a, i, o, h[_], l + "/" + y + "/" + s(_), u, l, y, c, _);
          } else
            (y in r.keywords || (a.allKeys && !(y in r.skipKeywords))) &&
              n(a, i, o, h, l + "/" + y, u, l, y, c);
        }
        o(c, l, u, d, m, p, f);
      }
    }
    function s(a) {
      return a.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }),
  au = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.getSchemaRefs =
        t.resolveUrl =
        t.normalizeId =
        t._getFullPath =
        t.getFullPath =
        t.inlineRef =
          void 0));
    var e = st(),
      r = MS(),
      n = NF(),
      s = new Set([
        "type",
        "format",
        "pattern",
        "maxLength",
        "minLength",
        "maxProperties",
        "minProperties",
        "maxItems",
        "minItems",
        "maximum",
        "minimum",
        "uniqueItems",
        "multipleOf",
        "required",
        "enum",
        "const",
      ]);
    function a(h, g = !0) {
      return typeof h == "boolean" ? !0 : g === !0 ? !o(h) : g ? c(h) <= g : !1;
    }
    t.inlineRef = a;
    var i = new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor",
    ]);
    function o(h) {
      for (let g in h) {
        if (i.has(g)) return !0;
        let _ = h[g];
        if ((Array.isArray(_) && _.some(o)) || (typeof _ == "object" && o(_)))
          return !0;
      }
      return !1;
    }
    function c(h) {
      let g = 0;
      for (let _ in h) {
        if (_ === "$ref") return 1 / 0;
        if (
          (g++,
          !s.has(_) &&
            (typeof h[_] == "object" &&
              (0, e.eachItem)(h[_], (v) => (g += c(v))),
            g === 1 / 0))
        )
          return 1 / 0;
      }
      return g;
    }
    function l(h, g = "", _) {
      _ !== !1 && (g = m(g));
      let v = h.parse(g);
      return u(h, v);
    }
    t.getFullPath = l;
    function u(h, g) {
      return h.serialize(g).split("#")[0] + "#";
    }
    t._getFullPath = u;
    var d = /#\/?$/;
    function m(h) {
      return h ? h.replace(d, "") : "";
    }
    t.normalizeId = m;
    function p(h, g, _) {
      return ((_ = m(_)), h.resolve(g, _));
    }
    t.resolveUrl = p;
    var f = /^[a-z_][-a-z0-9._]*$/i;
    function y(h, g) {
      if (typeof h == "boolean") return {};
      let { schemaId: _, uriResolver: v } = this.opts,
        b = m(h[_] || g),
        x = { "": b },
        w = l(v, b, !1),
        S = {},
        C = new Set();
      return (
        n(h, { allKeys: !0 }, (R, D, F, I) => {
          if (I === void 0) return;
          let K = w + D,
            ee = x[I];
          (typeof R[_] == "string" && (ee = Y.call(this, R[_])),
            Q.call(this, R.$anchor),
            Q.call(this, R.$dynamicAnchor),
            (x[D] = ee));
          function Y(ae) {
            let B = this.opts.uriResolver.resolve;
            if (((ae = m(ee ? B(ee, ae) : ae)), C.has(ae))) throw A(ae);
            C.add(ae);
            let $ = this.refs[ae];
            return (
              typeof $ == "string" && ($ = this.refs[$]),
              typeof $ == "object"
                ? P(R, $.schema, ae)
                : ae !== m(K) &&
                  (ae[0] === "#"
                    ? (P(R, S[ae], ae), (S[ae] = R))
                    : (this.refs[ae] = K)),
              ae
            );
          }
          function Q(ae) {
            if (typeof ae == "string") {
              if (!f.test(ae)) throw new Error(`invalid anchor "${ae}"`);
              Y.call(this, `#${ae}`);
            }
          }
        }),
        S
      );
      function P(R, D, F) {
        if (D !== void 0 && !r(R, D)) throw A(F);
      }
      function A(R) {
        return new Error(`reference "${R}" resolves to more than one schema`);
      }
    }
    t.getSchemaRefs = y;
  }),
  iu = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.getData = t.KeywordCxt = t.validateFunctionCode = void 0));
    var e = OF(),
      r = Vl(),
      n = LS(),
      s = Vl(),
      a = IF(),
      i = $F(),
      o = AF(),
      c = Ze(),
      l = Es(),
      u = au(),
      d = st(),
      m = su();
    function p(q) {
      if (w(q) && (C(q), x(q))) {
        g(q);
        return;
      }
      f(q, () => (0, e.topBoolOrEmptySchema)(q));
    }
    t.validateFunctionCode = p;
    function f(
      { gen: q, validateName: z, schema: Z, schemaEnv: te, opts: fe },
      je,
    ) {
      fe.code.es5
        ? q.func(
            z,
            (0, c._)`${l.default.data}, ${l.default.valCxt}`,
            te.$async,
            () => {
              (q.code((0, c._)`"use strict"; ${v(Z, fe)}`),
                h(q, fe),
                q.code(je));
            },
          )
        : q.func(z, (0, c._)`${l.default.data}, ${y(fe)}`, te.$async, () =>
            q.code(v(Z, fe)).code(je),
          );
    }
    function y(q) {
      return (0,
      c._)`{${l.default.instancePath}="", ${l.default.parentData}, ${l.default.parentDataProperty}, ${l.default.rootData}=${l.default.data}${q.dynamicRef ? (0, c._)`, ${l.default.dynamicAnchors}={}` : c.nil}}={}`;
    }
    function h(q, z) {
      q.if(
        l.default.valCxt,
        () => {
          (q.var(
            l.default.instancePath,
            (0, c._)`${l.default.valCxt}.${l.default.instancePath}`,
          ),
            q.var(
              l.default.parentData,
              (0, c._)`${l.default.valCxt}.${l.default.parentData}`,
            ),
            q.var(
              l.default.parentDataProperty,
              (0, c._)`${l.default.valCxt}.${l.default.parentDataProperty}`,
            ),
            q.var(
              l.default.rootData,
              (0, c._)`${l.default.valCxt}.${l.default.rootData}`,
            ),
            z.dynamicRef &&
              q.var(
                l.default.dynamicAnchors,
                (0, c._)`${l.default.valCxt}.${l.default.dynamicAnchors}`,
              ));
        },
        () => {
          (q.var(l.default.instancePath, (0, c._)`""`),
            q.var(l.default.parentData, (0, c._)`undefined`),
            q.var(l.default.parentDataProperty, (0, c._)`undefined`),
            q.var(l.default.rootData, l.default.data),
            z.dynamicRef && q.var(l.default.dynamicAnchors, (0, c._)`{}`));
        },
      );
    }
    function g(q) {
      let { schema: z, opts: Z, gen: te } = q;
      f(q, () => {
        (Z.$comment && z.$comment && I(q),
          R(q),
          te.let(l.default.vErrors, null),
          te.let(l.default.errors, 0),
          Z.unevaluated && _(q),
          P(q),
          K(q));
      });
    }
    function _(q) {
      let { gen: z, validateName: Z } = q;
      ((q.evaluated = z.const("evaluated", (0, c._)`${Z}.evaluated`)),
        z.if((0, c._)`${q.evaluated}.dynamicProps`, () =>
          z.assign((0, c._)`${q.evaluated}.props`, (0, c._)`undefined`),
        ),
        z.if((0, c._)`${q.evaluated}.dynamicItems`, () =>
          z.assign((0, c._)`${q.evaluated}.items`, (0, c._)`undefined`),
        ));
    }
    function v(q, z) {
      let Z = typeof q == "object" && q[z.schemaId];
      return Z && (z.code.source || z.code.process)
        ? (0, c._)`/*# sourceURL=${Z} */`
        : c.nil;
    }
    function b(q, z) {
      if (w(q) && (C(q), x(q))) {
        S(q, z);
        return;
      }
      (0, e.boolOrEmptySchema)(q, z);
    }
    function x({ schema: q, self: z }) {
      if (typeof q == "boolean") return !q;
      for (let Z in q) if (z.RULES.all[Z]) return !0;
      return !1;
    }
    function w(q) {
      return typeof q.schema != "boolean";
    }
    function S(q, z) {
      let { schema: Z, gen: te, opts: fe } = q;
      (fe.$comment && Z.$comment && I(q), D(q), F(q));
      let je = te.const("_errs", l.default.errors);
      (P(q, je), te.var(z, (0, c._)`${je} === ${l.default.errors}`));
    }
    function C(q) {
      ((0, d.checkUnknownRules)(q), A(q));
    }
    function P(q, z) {
      if (q.opts.jtd) return Y(q, [], !1, z);
      let Z = (0, r.getSchemaTypes)(q.schema),
        te = (0, r.coerceAndCheckDataType)(q, Z);
      Y(q, Z, !te, z);
    }
    function A(q) {
      let { schema: z, errSchemaPath: Z, opts: te, self: fe } = q;
      z.$ref &&
        te.ignoreKeywordsWithRef &&
        (0, d.schemaHasRulesButRef)(z, fe.RULES) &&
        fe.logger.warn(`$ref: keywords ignored in schema at path "${Z}"`);
    }
    function R(q) {
      let { schema: z, opts: Z } = q;
      z.default !== void 0 &&
        Z.useDefaults &&
        Z.strictSchema &&
        (0, d.checkStrictMode)(q, "default is ignored in the schema root");
    }
    function D(q) {
      let z = q.schema[q.opts.schemaId];
      z && (q.baseId = (0, u.resolveUrl)(q.opts.uriResolver, q.baseId, z));
    }
    function F(q) {
      if (q.schema.$async && !q.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function I({
      gen: q,
      schemaEnv: z,
      schema: Z,
      errSchemaPath: te,
      opts: fe,
    }) {
      let je = Z.$comment;
      if (fe.$comment === !0)
        q.code((0, c._)`${l.default.self}.logger.log(${je})`);
      else if (typeof fe.$comment == "function") {
        let wt = (0, c.str)`${te}/$comment`,
          dt = q.scopeValue("root", { ref: z.root });
        q.code(
          (0, c._)`${l.default.self}.opts.$comment(${je}, ${wt}, ${dt}.schema)`,
        );
      }
    }
    function K(q) {
      let {
        gen: z,
        schemaEnv: Z,
        validateName: te,
        ValidationError: fe,
        opts: je,
      } = q;
      Z.$async
        ? z.if(
            (0, c._)`${l.default.errors} === 0`,
            () => z.return(l.default.data),
            () => z.throw((0, c._)`new ${fe}(${l.default.vErrors})`),
          )
        : (z.assign((0, c._)`${te}.errors`, l.default.vErrors),
          je.unevaluated && ee(q),
          z.return((0, c._)`${l.default.errors} === 0`));
    }
    function ee({ gen: q, evaluated: z, props: Z, items: te }) {
      (Z instanceof c.Name && q.assign((0, c._)`${z}.props`, Z),
        te instanceof c.Name && q.assign((0, c._)`${z}.items`, te));
    }
    function Y(q, z, Z, te) {
      let {
          gen: fe,
          schema: je,
          data: wt,
          allErrors: dt,
          opts: vt,
          self: pt,
        } = q,
        { RULES: et } = pt;
      if (
        je.$ref &&
        (vt.ignoreKeywordsWithRef || !(0, d.schemaHasRulesButRef)(je, et))
      ) {
        fe.block(() => oe(q, "$ref", et.all.$ref.definition));
        return;
      }
      (vt.jtd || ae(q, z),
        fe.block(() => {
          for (let bt of et.rules) er(bt);
          er(et.post);
        }));
      function er(bt) {
        (0, n.shouldUseGroup)(je, bt) &&
          (bt.type
            ? (fe.if((0, s.checkDataType)(bt.type, wt, vt.strictNumbers)),
              Q(q, bt),
              z.length === 1 &&
                z[0] === bt.type &&
                Z &&
                (fe.else(), (0, s.reportTypeError)(q)),
              fe.endIf())
            : Q(q, bt),
          dt || fe.if((0, c._)`${l.default.errors} === ${te || 0}`));
      }
    }
    function Q(q, z) {
      let {
        gen: Z,
        schema: te,
        opts: { useDefaults: fe },
      } = q;
      (fe && (0, a.assignDefaults)(q, z.type),
        Z.block(() => {
          for (let je of z.rules)
            (0, n.shouldUseRule)(te, je) &&
              oe(q, je.keyword, je.definition, z.type);
        }));
    }
    function ae(q, z) {
      q.schemaEnv.meta ||
        !q.opts.strictTypes ||
        (B(q, z), q.opts.allowUnionTypes || $(q, z), G(q, q.dataTypes));
    }
    function B(q, z) {
      if (z.length) {
        if (!q.dataTypes.length) {
          q.dataTypes = z;
          return;
        }
        (z.forEach((Z) => {
          T(q.dataTypes, Z) ||
            H(
              q,
              `type "${Z}" not allowed by context "${q.dataTypes.join(",")}"`,
            );
        }),
          O(q, z));
      }
    }
    function $(q, z) {
      z.length > 1 &&
        !(z.length === 2 && z.includes("null")) &&
        H(q, "use allowUnionTypes to allow union type keyword");
    }
    function G(q, z) {
      let Z = q.self.RULES.all;
      for (let te in Z) {
        let fe = Z[te];
        if (typeof fe == "object" && (0, n.shouldUseRule)(q.schema, fe)) {
          let { type: je } = fe.definition;
          je.length &&
            !je.some((wt) => U(z, wt)) &&
            H(q, `missing type "${je.join(",")}" for keyword "${te}"`);
        }
      }
    }
    function U(q, z) {
      return q.includes(z) || (z === "number" && q.includes("integer"));
    }
    function T(q, z) {
      return q.includes(z) || (z === "integer" && q.includes("number"));
    }
    function O(q, z) {
      let Z = [];
      for (let te of q.dataTypes)
        T(z, te)
          ? Z.push(te)
          : z.includes("integer") && te === "number" && Z.push("integer");
      q.dataTypes = Z;
    }
    function H(q, z) {
      let Z = q.schemaEnv.baseId + q.errSchemaPath;
      ((z += ` at "${Z}" (strictTypes)`),
        (0, d.checkStrictMode)(q, z, q.opts.strictTypes));
    }
    class ce {
      constructor(z, Z, te) {
        if (
          ((0, i.validateKeywordUsage)(z, Z, te),
          (this.gen = z.gen),
          (this.allErrors = z.allErrors),
          (this.keyword = te),
          (this.data = z.data),
          (this.schema = z.schema[te]),
          (this.$data =
            Z.$data && z.opts.$data && this.schema && this.schema.$data),
          (this.schemaValue = (0, d.schemaRefOrVal)(
            z,
            this.schema,
            te,
            this.$data,
          )),
          (this.schemaType = Z.schemaType),
          (this.parentSchema = z.schema),
          (this.params = {}),
          (this.it = z),
          (this.def = Z),
          this.$data)
        )
          this.schemaCode = z.gen.const("vSchema", Me(this.$data, z));
        else if (
          ((this.schemaCode = this.schemaValue),
          !(0, i.validSchemaType)(this.schema, Z.schemaType, Z.allowUndefined))
        )
          throw new Error(
            `${te} value must be ${JSON.stringify(Z.schemaType)}`,
          );
        ("code" in Z ? Z.trackErrors : Z.errors !== !1) &&
          (this.errsCount = z.gen.const("_errs", l.default.errors));
      }
      result(z, Z, te) {
        this.failResult((0, c.not)(z), Z, te);
      }
      failResult(z, Z, te) {
        (this.gen.if(z),
          te ? te() : this.error(),
          Z
            ? (this.gen.else(), Z(), this.allErrors && this.gen.endIf())
            : this.allErrors
              ? this.gen.endIf()
              : this.gen.else());
      }
      pass(z, Z) {
        this.failResult((0, c.not)(z), void 0, Z);
      }
      fail(z) {
        if (z === void 0) {
          (this.error(), this.allErrors || this.gen.if(!1));
          return;
        }
        (this.gen.if(z),
          this.error(),
          this.allErrors ? this.gen.endIf() : this.gen.else());
      }
      fail$data(z) {
        if (!this.$data) return this.fail(z);
        let { schemaCode: Z } = this;
        this.fail(
          (0,
          c._)`${Z} !== undefined && (${(0, c.or)(this.invalid$data(), z)})`,
        );
      }
      error(z, Z, te) {
        if (Z) {
          (this.setParams(Z), this._error(z, te), this.setParams({}));
          return;
        }
        this._error(z, te);
      }
      _error(z, Z) {
        (z ? m.reportExtraError : m.reportError)(this, this.def.error, Z);
      }
      $dataError() {
        (0, m.reportError)(this, this.def.$dataError || m.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, m.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(z) {
        this.allErrors || this.gen.if(z);
      }
      setParams(z, Z) {
        Z ? Object.assign(this.params, z) : (this.params = z);
      }
      block$data(z, Z, te = c.nil) {
        this.gen.block(() => {
          (this.check$data(z, te), Z());
        });
      }
      check$data(z = c.nil, Z = c.nil) {
        if (!this.$data) return;
        let { gen: te, schemaCode: fe, schemaType: je, def: wt } = this;
        (te.if((0, c.or)((0, c._)`${fe} === undefined`, Z)),
          z !== c.nil && te.assign(z, !0),
          (je.length || wt.validateSchema) &&
            (te.elseIf(this.invalid$data()),
            this.$dataError(),
            z !== c.nil && te.assign(z, !1)),
          te.else());
      }
      invalid$data() {
        let { gen: z, schemaCode: Z, schemaType: te, def: fe, it: je } = this;
        return (0, c.or)(wt(), dt());
        function wt() {
          if (te.length) {
            if (!(Z instanceof c.Name))
              throw new Error("ajv implementation error");
            let vt = Array.isArray(te) ? te : [te];
            return (0,
            c._)`${(0, s.checkDataTypes)(vt, Z, je.opts.strictNumbers, s.DataType.Wrong)}`;
          }
          return c.nil;
        }
        function dt() {
          if (fe.validateSchema) {
            let vt = z.scopeValue("validate$data", { ref: fe.validateSchema });
            return (0, c._)`!${vt}(${Z})`;
          }
          return c.nil;
        }
      }
      subschema(z, Z) {
        let te = (0, o.getSubschema)(this.it, z);
        ((0, o.extendSubschemaData)(te, this.it, z),
          (0, o.extendSubschemaMode)(te, z));
        let fe = { ...this.it, ...te, items: void 0, props: void 0 };
        return (b(fe, Z), fe);
      }
      mergeEvaluated(z, Z) {
        let { it: te, gen: fe } = this;
        te.opts.unevaluated &&
          (te.props !== !0 &&
            z.props !== void 0 &&
            (te.props = d.mergeEvaluated.props(fe, z.props, te.props, Z)),
          te.items !== !0 &&
            z.items !== void 0 &&
            (te.items = d.mergeEvaluated.items(fe, z.items, te.items, Z)));
      }
      mergeValidEvaluated(z, Z) {
        let { it: te, gen: fe } = this;
        if (te.opts.unevaluated && (te.props !== !0 || te.items !== !0))
          return (fe.if(Z, () => this.mergeEvaluated(z, c.Name)), !0);
      }
    }
    t.KeywordCxt = ce;
    function oe(q, z, Z, te) {
      let fe = new ce(q, Z, z);
      "code" in Z
        ? Z.code(fe, te)
        : fe.$data && Z.validate
          ? (0, i.funcKeywordCode)(fe, Z)
          : "macro" in Z
            ? (0, i.macroKeywordCode)(fe, Z)
            : (Z.compile || Z.validate) && (0, i.funcKeywordCode)(fe, Z);
    }
    var Fe = /^\/(?:[^~]|~0|~1)*$/,
      Ee = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function Me(q, { dataLevel: z, dataNames: Z, dataPathArr: te }) {
      let fe, je;
      if (q === "") return l.default.rootData;
      if (q[0] === "/") {
        if (!Fe.test(q)) throw new Error(`Invalid JSON-pointer: ${q}`);
        ((fe = q), (je = l.default.rootData));
      } else {
        let pt = Ee.exec(q);
        if (!pt) throw new Error(`Invalid JSON-pointer: ${q}`);
        let et = +pt[1];
        if (((fe = pt[2]), fe === "#")) {
          if (et >= z) throw new Error(vt("property/index", et));
          return te[z - et];
        }
        if (et > z) throw new Error(vt("data", et));
        if (((je = Z[z - et]), !fe)) return je;
      }
      let wt = je,
        dt = fe.split("/");
      for (let pt of dt)
        pt &&
          ((je = (0,
          c._)`${je}${(0, c.getProperty)((0, d.unescapeJsonPointer)(pt))}`),
          (wt = (0, c._)`${wt} && ${je}`));
      return wt;
      function vt(pt, et) {
        return `Cannot access ${pt} ${et} levels up, current level is ${z}`;
      }
    }
    t.getData = Me;
  }),
  qm = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    class e extends Error {
      constructor(n) {
        (super("validation failed"),
          (this.errors = n),
          (this.ajv = this.validation = !0));
      }
    }
    t.default = e;
  }),
  ou = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = au();
    class r extends Error {
      constructor(s, a, i, o) {
        (super(o || `can't resolve reference ${i} from id ${a}`),
          (this.missingRef = (0, e.resolveUrl)(s, a, i)),
          (this.missingSchema = (0, e.normalizeId)(
            (0, e.getFullPath)(s, this.missingRef),
          )));
      }
    }
    t.default = r;
  }),
  zm = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.resolveSchema =
        t.getCompilingSchema =
        t.resolveRef =
        t.compileSchema =
        t.SchemaEnv =
          void 0));
    var e = Ze(),
      r = qm(),
      n = Es(),
      s = au(),
      a = st(),
      i = iu();
    class o {
      constructor(_) {
        var v;
        ((this.refs = {}), (this.dynamicAnchors = {}));
        let b;
        (typeof _.schema == "object" && (b = _.schema),
          (this.schema = _.schema),
          (this.schemaId = _.schemaId),
          (this.root = _.root || this),
          (this.baseId =
            (v = _.baseId) !== null && v !== void 0
              ? v
              : (0, s.normalizeId)(b?.[_.schemaId || "$id"])),
          (this.schemaPath = _.schemaPath),
          (this.localRefs = _.localRefs),
          (this.meta = _.meta),
          (this.$async = b?.$async),
          (this.refs = {}));
      }
    }
    t.SchemaEnv = o;
    function c(g) {
      let _ = d.call(this, g);
      if (_) return _;
      let v = (0, s.getFullPath)(this.opts.uriResolver, g.root.baseId),
        { es5: b, lines: x } = this.opts.code,
        { ownProperties: w } = this.opts,
        S = new e.CodeGen(this.scope, { es5: b, lines: x, ownProperties: w }),
        C;
      g.$async &&
        (C = S.scopeValue("Error", {
          ref: r.default,
          code: (0, e._)`require("ajv/dist/runtime/validation_error").default`,
        }));
      let P = S.scopeName("validate");
      g.validateName = P;
      let A = {
          gen: S,
          allErrors: this.opts.allErrors,
          data: n.default.data,
          parentData: n.default.parentData,
          parentDataProperty: n.default.parentDataProperty,
          dataNames: [n.default.data],
          dataPathArr: [e.nil],
          dataLevel: 0,
          dataTypes: [],
          definedProperties: new Set(),
          topSchemaRef: S.scopeValue(
            "schema",
            this.opts.code.source === !0
              ? { ref: g.schema, code: (0, e.stringify)(g.schema) }
              : { ref: g.schema },
          ),
          validateName: P,
          ValidationError: C,
          schema: g.schema,
          schemaEnv: g,
          rootId: v,
          baseId: g.baseId || v,
          schemaPath: e.nil,
          errSchemaPath: g.schemaPath || (this.opts.jtd ? "" : "#"),
          errorPath: (0, e._)`""`,
          opts: this.opts,
          self: this,
        },
        R;
      try {
        (this._compilations.add(g),
          (0, i.validateFunctionCode)(A),
          S.optimize(this.opts.code.optimize));
        let D = S.toString();
        ((R = `${S.scopeRefs(n.default.scope)}return ${D}`),
          this.opts.code.process && (R = this.opts.code.process(R, g)));
        let I = new Function(`${n.default.self}`, `${n.default.scope}`, R)(
          this,
          this.scope.get(),
        );
        if (
          (this.scope.value(P, { ref: I }),
          (I.errors = null),
          (I.schema = g.schema),
          (I.schemaEnv = g),
          g.$async && (I.$async = !0),
          this.opts.code.source === !0 &&
            (I.source = {
              validateName: P,
              validateCode: D,
              scopeValues: S._values,
            }),
          this.opts.unevaluated)
        ) {
          let { props: K, items: ee } = A;
          ((I.evaluated = {
            props: K instanceof e.Name ? void 0 : K,
            items: ee instanceof e.Name ? void 0 : ee,
            dynamicProps: K instanceof e.Name,
            dynamicItems: ee instanceof e.Name,
          }),
            I.source && (I.source.evaluated = (0, e.stringify)(I.evaluated)));
        }
        return ((g.validate = I), g);
      } catch (D) {
        throw (
          delete g.validate,
          delete g.validateName,
          R && this.logger.error("Error compiling schema, function code:", R),
          D
        );
      } finally {
        this._compilations.delete(g);
      }
    }
    t.compileSchema = c;
    function l(g, _, v) {
      var b;
      v = (0, s.resolveUrl)(this.opts.uriResolver, _, v);
      let x = g.refs[v];
      if (x) return x;
      let w = p.call(this, g, v);
      if (w === void 0) {
        let S = (b = g.localRefs) === null || b === void 0 ? void 0 : b[v],
          { schemaId: C } = this.opts;
        S && (w = new o({ schema: S, schemaId: C, root: g, baseId: _ }));
      }
      if (w !== void 0) return (g.refs[v] = u.call(this, w));
    }
    t.resolveRef = l;
    function u(g) {
      return (0, s.inlineRef)(g.schema, this.opts.inlineRefs)
        ? g.schema
        : g.validate
          ? g
          : c.call(this, g);
    }
    function d(g) {
      for (let _ of this._compilations) if (m(_, g)) return _;
    }
    t.getCompilingSchema = d;
    function m(g, _) {
      return (
        g.schema === _.schema && g.root === _.root && g.baseId === _.baseId
      );
    }
    function p(g, _) {
      let v;
      for (; typeof (v = this.refs[_]) == "string"; ) _ = v;
      return v || this.schemas[_] || f.call(this, g, _);
    }
    function f(g, _) {
      let v = this.opts.uriResolver.parse(_),
        b = (0, s._getFullPath)(this.opts.uriResolver, v),
        x = (0, s.getFullPath)(this.opts.uriResolver, g.baseId, void 0);
      if (Object.keys(g.schema).length > 0 && b === x)
        return h.call(this, v, g);
      let w = (0, s.normalizeId)(b),
        S = this.refs[w] || this.schemas[w];
      if (typeof S == "string") {
        let C = f.call(this, g, S);
        return typeof C?.schema != "object" ? void 0 : h.call(this, v, C);
      }
      if (typeof S?.schema == "object") {
        if ((S.validate || c.call(this, S), w === (0, s.normalizeId)(_))) {
          let { schema: C } = S,
            { schemaId: P } = this.opts,
            A = C[P];
          return (
            A && (x = (0, s.resolveUrl)(this.opts.uriResolver, x, A)),
            new o({ schema: C, schemaId: P, root: g, baseId: x })
          );
        }
        return h.call(this, v, S);
      }
    }
    t.resolveSchema = f;
    var y = new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions",
    ]);
    function h(g, { baseId: _, schema: v, root: b }) {
      var x;
      if (((x = g.fragment) === null || x === void 0 ? void 0 : x[0]) !== "/")
        return;
      for (let C of g.fragment.slice(1).split("/")) {
        if (typeof v == "boolean") return;
        let P = v[(0, a.unescapeFragment)(C)];
        if (P === void 0) return;
        v = P;
        let A = typeof v == "object" && v[this.opts.schemaId];
        !y.has(C) && A && (_ = (0, s.resolveUrl)(this.opts.uriResolver, _, A));
      }
      let w;
      if (
        typeof v != "boolean" &&
        v.$ref &&
        !(0, a.schemaHasRulesButRef)(v, this.RULES)
      ) {
        let C = (0, s.resolveUrl)(this.opts.uriResolver, _, v.$ref);
        w = f.call(this, b, C);
      }
      let { schemaId: S } = this.opts;
      if (
        ((w = w || new o({ schema: v, schemaId: S, root: b, baseId: _ })),
        w.schema !== w.root.schema)
      )
        return w;
    }
  }),
  DF = ge((t, e) => {
    e.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description:
        "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [
            { format: "relative-json-pointer" },
            { format: "json-pointer" },
          ],
        },
      },
      additionalProperties: !1,
    };
  }),
  LF = ge((t, e) => {
    var r = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15,
    };
    e.exports = { HEX: r };
  }),
  MF = ge((t, e) => {
    var { HEX: r } = LF(),
      n =
        /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
    function s(g) {
      if (l(g, ".") < 3) return { host: g, isIPV4: !1 };
      let _ = g.match(n) || [],
        [v] = _;
      return v ? { host: c(v, "."), isIPV4: !0 } : { host: g, isIPV4: !1 };
    }
    function a(g, _ = !1) {
      let v = "",
        b = !0;
      for (let x of g) {
        if (r[x] === void 0) return;
        (x !== "0" && b === !0 && (b = !1), b || (v += x));
      }
      return (_ && v.length === 0 && (v = "0"), v);
    }
    function i(g) {
      let _ = 0,
        v = { error: !1, address: "", zone: "" },
        b = [],
        x = [],
        w = !1,
        S = !1,
        C = !1;
      function P() {
        if (x.length) {
          if (w === !1) {
            let A = a(x);
            if (A !== void 0) b.push(A);
            else return ((v.error = !0), !1);
          }
          x.length = 0;
        }
        return !0;
      }
      for (let A = 0; A < g.length; A++) {
        let R = g[A];
        if (!(R === "[" || R === "]"))
          if (R === ":") {
            if ((S === !0 && (C = !0), !P())) break;
            if ((_++, b.push(":"), _ > 7)) {
              v.error = !0;
              break;
            }
            A - 1 >= 0 && g[A - 1] === ":" && (S = !0);
            continue;
          } else if (R === "%") {
            if (!P()) break;
            w = !0;
          } else {
            x.push(R);
            continue;
          }
      }
      return (
        x.length &&
          (w ? (v.zone = x.join("")) : C ? b.push(x.join("")) : b.push(a(x))),
        (v.address = b.join("")),
        v
      );
    }
    function o(g) {
      if (l(g, ":") < 2) return { host: g, isIPV6: !1 };
      let _ = i(g);
      if (_.error) return { host: g, isIPV6: !1 };
      {
        let v = _.address,
          b = _.address;
        return (
          _.zone && ((v += "%" + _.zone), (b += "%25" + _.zone)),
          { host: v, escapedHost: b, isIPV6: !0 }
        );
      }
    }
    function c(g, _) {
      let v = "",
        b = !0,
        x = g.length;
      for (let w = 0; w < x; w++) {
        let S = g[w];
        S === "0" && b
          ? ((w + 1 <= x && g[w + 1] === _) || w + 1 === x) &&
            ((v += S), (b = !1))
          : (S === _ ? (b = !0) : (b = !1), (v += S));
      }
      return v;
    }
    function l(g, _) {
      let v = 0;
      for (let b = 0; b < g.length; b++) g[b] === _ && v++;
      return v;
    }
    var u = /^\.\.?\//u,
      d = /^\/\.(?:\/|$)/u,
      m = /^\/\.\.(?:\/|$)/u,
      p = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function f(g) {
      let _ = [];
      for (; g.length; )
        if (g.match(u)) g = g.replace(u, "");
        else if (g.match(d)) g = g.replace(d, "/");
        else if (g.match(m)) ((g = g.replace(m, "/")), _.pop());
        else if (g === "." || g === "..") g = "";
        else {
          let v = g.match(p);
          if (v) {
            let b = v[0];
            ((g = g.slice(b.length)), _.push(b));
          } else throw new Error("Unexpected dot segment condition");
        }
      return _.join("");
    }
    function y(g, _) {
      let v = _ !== !0 ? escape : unescape;
      return (
        g.scheme !== void 0 && (g.scheme = v(g.scheme)),
        g.userinfo !== void 0 && (g.userinfo = v(g.userinfo)),
        g.host !== void 0 && (g.host = v(g.host)),
        g.path !== void 0 && (g.path = v(g.path)),
        g.query !== void 0 && (g.query = v(g.query)),
        g.fragment !== void 0 && (g.fragment = v(g.fragment)),
        g
      );
    }
    function h(g) {
      let _ = [];
      if (
        (g.userinfo !== void 0 && (_.push(g.userinfo), _.push("@")),
        g.host !== void 0)
      ) {
        let v = unescape(g.host),
          b = s(v);
        if (b.isIPV4) v = b.host;
        else {
          let x = o(b.host);
          x.isIPV6 === !0 ? (v = `[${x.escapedHost}]`) : (v = g.host);
        }
        _.push(v);
      }
      return (
        (typeof g.port == "number" || typeof g.port == "string") &&
          (_.push(":"), _.push(String(g.port))),
        _.length ? _.join("") : void 0
      );
    }
    e.exports = {
      recomposeAuthority: h,
      normalizeComponentEncoding: y,
      removeDotSegments: f,
      normalizeIPv4: s,
      normalizeIPv6: o,
      stringArrayToHexStripped: a,
    };
  }),
  jF = ge((t, e) => {
    var r = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu,
      n = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function s(b) {
      return typeof b.secure == "boolean"
        ? b.secure
        : String(b.scheme).toLowerCase() === "wss";
    }
    function a(b) {
      return (
        b.host || (b.error = b.error || "HTTP URIs must have a host."),
        b
      );
    }
    function i(b) {
      let x = String(b.scheme).toLowerCase() === "https";
      return (
        (b.port === (x ? 443 : 80) || b.port === "") && (b.port = void 0),
        b.path || (b.path = "/"),
        b
      );
    }
    function o(b) {
      return (
        (b.secure = s(b)),
        (b.resourceName = (b.path || "/") + (b.query ? "?" + b.query : "")),
        (b.path = void 0),
        (b.query = void 0),
        b
      );
    }
    function c(b) {
      if (
        ((b.port === (s(b) ? 443 : 80) || b.port === "") && (b.port = void 0),
        typeof b.secure == "boolean" &&
          ((b.scheme = b.secure ? "wss" : "ws"), (b.secure = void 0)),
        b.resourceName)
      ) {
        let [x, w] = b.resourceName.split("?");
        ((b.path = x && x !== "/" ? x : void 0),
          (b.query = w),
          (b.resourceName = void 0));
      }
      return ((b.fragment = void 0), b);
    }
    function l(b, x) {
      if (!b.path) return ((b.error = "URN can not be parsed"), b);
      let w = b.path.match(n);
      if (w) {
        let S = x.scheme || b.scheme || "urn";
        ((b.nid = w[1].toLowerCase()), (b.nss = w[2]));
        let C = `${S}:${x.nid || b.nid}`,
          P = v[C];
        ((b.path = void 0), P && (b = P.parse(b, x)));
      } else b.error = b.error || "URN can not be parsed.";
      return b;
    }
    function u(b, x) {
      let w = x.scheme || b.scheme || "urn",
        S = b.nid.toLowerCase(),
        C = `${w}:${x.nid || S}`,
        P = v[C];
      P && (b = P.serialize(b, x));
      let A = b,
        R = b.nss;
      return ((A.path = `${S || x.nid}:${R}`), (x.skipEscape = !0), A);
    }
    function d(b, x) {
      let w = b;
      return (
        (w.uuid = w.nss),
        (w.nss = void 0),
        !x.tolerant &&
          (!w.uuid || !r.test(w.uuid)) &&
          (w.error = w.error || "UUID is not valid."),
        w
      );
    }
    function m(b) {
      let x = b;
      return ((x.nss = (b.uuid || "").toLowerCase()), x);
    }
    var p = { scheme: "http", domainHost: !0, parse: a, serialize: i },
      f = { scheme: "https", domainHost: p.domainHost, parse: a, serialize: i },
      y = { scheme: "ws", domainHost: !0, parse: o, serialize: c },
      h = {
        scheme: "wss",
        domainHost: y.domainHost,
        parse: y.parse,
        serialize: y.serialize,
      },
      g = { scheme: "urn", parse: l, serialize: u, skipNormalize: !0 },
      _ = { scheme: "urn:uuid", parse: d, serialize: m, skipNormalize: !0 },
      v = { http: p, https: f, ws: y, wss: h, urn: g, "urn:uuid": _ };
    e.exports = v;
  }),
  FF = ge((t, e) => {
    var {
        normalizeIPv6: r,
        normalizeIPv4: n,
        removeDotSegments: s,
        recomposeAuthority: a,
        normalizeComponentEncoding: i,
      } = MF(),
      o = jF();
    function c(_, v) {
      return (
        typeof _ == "string"
          ? (_ = m(h(_, v), v))
          : typeof _ == "object" && (_ = h(m(_, v), v)),
        _
      );
    }
    function l(_, v, b) {
      let x = Object.assign({ scheme: "null" }, b),
        w = u(h(_, x), h(v, x), x, !0);
      return m(w, { ...x, skipEscape: !0 });
    }
    function u(_, v, b, x) {
      let w = {};
      return (
        x || ((_ = h(m(_, b), b)), (v = h(m(v, b), b))),
        (b = b || {}),
        !b.tolerant && v.scheme
          ? ((w.scheme = v.scheme),
            (w.userinfo = v.userinfo),
            (w.host = v.host),
            (w.port = v.port),
            (w.path = s(v.path || "")),
            (w.query = v.query))
          : (v.userinfo !== void 0 || v.host !== void 0 || v.port !== void 0
              ? ((w.userinfo = v.userinfo),
                (w.host = v.host),
                (w.port = v.port),
                (w.path = s(v.path || "")),
                (w.query = v.query))
              : (v.path
                  ? (v.path.charAt(0) === "/"
                      ? (w.path = s(v.path))
                      : ((_.userinfo !== void 0 ||
                          _.host !== void 0 ||
                          _.port !== void 0) &&
                        !_.path
                          ? (w.path = "/" + v.path)
                          : _.path
                            ? (w.path =
                                _.path.slice(0, _.path.lastIndexOf("/") + 1) +
                                v.path)
                            : (w.path = v.path),
                        (w.path = s(w.path))),
                    (w.query = v.query))
                  : ((w.path = _.path),
                    v.query !== void 0
                      ? (w.query = v.query)
                      : (w.query = _.query)),
                (w.userinfo = _.userinfo),
                (w.host = _.host),
                (w.port = _.port)),
            (w.scheme = _.scheme)),
        (w.fragment = v.fragment),
        w
      );
    }
    function d(_, v, b) {
      return (
        typeof _ == "string"
          ? ((_ = unescape(_)),
            (_ = m(i(h(_, b), !0), { ...b, skipEscape: !0 })))
          : typeof _ == "object" && (_ = m(i(_, !0), { ...b, skipEscape: !0 })),
        typeof v == "string"
          ? ((v = unescape(v)),
            (v = m(i(h(v, b), !0), { ...b, skipEscape: !0 })))
          : typeof v == "object" && (v = m(i(v, !0), { ...b, skipEscape: !0 })),
        _.toLowerCase() === v.toLowerCase()
      );
    }
    function m(_, v) {
      let b = {
          host: _.host,
          scheme: _.scheme,
          userinfo: _.userinfo,
          port: _.port,
          path: _.path,
          query: _.query,
          nid: _.nid,
          nss: _.nss,
          uuid: _.uuid,
          fragment: _.fragment,
          reference: _.reference,
          resourceName: _.resourceName,
          secure: _.secure,
          error: "",
        },
        x = Object.assign({}, v),
        w = [],
        S = o[(x.scheme || b.scheme || "").toLowerCase()];
      (S && S.serialize && S.serialize(b, x),
        b.path !== void 0 &&
          (x.skipEscape
            ? (b.path = unescape(b.path))
            : ((b.path = escape(b.path)),
              b.scheme !== void 0 && (b.path = b.path.split("%3A").join(":")))),
        x.reference !== "suffix" && b.scheme && w.push(b.scheme, ":"));
      let C = a(b);
      if (
        (C !== void 0 &&
          (x.reference !== "suffix" && w.push("//"),
          w.push(C),
          b.path && b.path.charAt(0) !== "/" && w.push("/")),
        b.path !== void 0)
      ) {
        let P = b.path;
        (!x.absolutePath && (!S || !S.absolutePath) && (P = s(P)),
          C === void 0 && (P = P.replace(/^\/\//u, "/%2F")),
          w.push(P));
      }
      return (
        b.query !== void 0 && w.push("?", b.query),
        b.fragment !== void 0 && w.push("#", b.fragment),
        w.join("")
      );
    }
    var p = Array.from({ length: 127 }, (_, v) =>
      /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(v)),
    );
    function f(_) {
      let v = 0;
      for (let b = 0, x = _.length; b < x; ++b)
        if (((v = _.charCodeAt(b)), v > 126 || p[v])) return !0;
      return !1;
    }
    var y =
      /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function h(_, v) {
      let b = Object.assign({}, v),
        x = {
          scheme: void 0,
          userinfo: void 0,
          host: "",
          port: void 0,
          path: "",
          query: void 0,
          fragment: void 0,
        },
        w = _.indexOf("%") !== -1,
        S = !1;
      b.reference === "suffix" &&
        (_ = (b.scheme ? b.scheme + ":" : "") + "//" + _);
      let C = _.match(y);
      if (C) {
        if (
          ((x.scheme = C[1]),
          (x.userinfo = C[3]),
          (x.host = C[4]),
          (x.port = parseInt(C[5], 10)),
          (x.path = C[6] || ""),
          (x.query = C[7]),
          (x.fragment = C[8]),
          isNaN(x.port) && (x.port = C[5]),
          x.host)
        ) {
          let A = n(x.host);
          if (A.isIPV4 === !1) {
            let R = r(A.host);
            ((x.host = R.host.toLowerCase()), (S = R.isIPV6));
          } else ((x.host = A.host), (S = !0));
        }
        (x.scheme === void 0 &&
        x.userinfo === void 0 &&
        x.host === void 0 &&
        x.port === void 0 &&
        x.query === void 0 &&
        !x.path
          ? (x.reference = "same-document")
          : x.scheme === void 0
            ? (x.reference = "relative")
            : x.fragment === void 0
              ? (x.reference = "absolute")
              : (x.reference = "uri"),
          b.reference &&
            b.reference !== "suffix" &&
            b.reference !== x.reference &&
            (x.error =
              x.error || "URI is not a " + b.reference + " reference."));
        let P = o[(b.scheme || x.scheme || "").toLowerCase()];
        if (
          !b.unicodeSupport &&
          (!P || !P.unicodeSupport) &&
          x.host &&
          (b.domainHost || (P && P.domainHost)) &&
          S === !1 &&
          f(x.host)
        )
          try {
            x.host = URL.domainToASCII(x.host.toLowerCase());
          } catch (A) {
            x.error =
              x.error ||
              "Host's domain name can not be converted to ASCII: " + A;
          }
        ((!P || (P && !P.skipNormalize)) &&
          (w && x.scheme !== void 0 && (x.scheme = unescape(x.scheme)),
          w && x.host !== void 0 && (x.host = unescape(x.host)),
          x.path && (x.path = escape(unescape(x.path))),
          x.fragment &&
            (x.fragment = encodeURI(decodeURIComponent(x.fragment)))),
          P && P.parse && P.parse(x, b));
      } else x.error = x.error || "URI can not be parsed.";
      return x;
    }
    var g = {
      SCHEMES: o,
      normalize: c,
      resolve: l,
      resolveComponents: u,
      equal: d,
      serialize: m,
      parse: h,
    };
    ((e.exports = g), (e.exports.default = g), (e.exports.fastUri = g));
  }),
  UF = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = FF();
    ((e.code = 'require("ajv/dist/runtime/uri").default'), (t.default = e));
  }),
  qF = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.CodeGen =
        t.Name =
        t.nil =
        t.stringify =
        t.str =
        t._ =
        t.KeywordCxt =
          void 0));
    var e = iu();
    Object.defineProperty(t, "KeywordCxt", {
      enumerable: !0,
      get: function () {
        return e.KeywordCxt;
      },
    });
    var r = Ze();
    (Object.defineProperty(t, "_", {
      enumerable: !0,
      get: function () {
        return r._;
      },
    }),
      Object.defineProperty(t, "str", {
        enumerable: !0,
        get: function () {
          return r.str;
        },
      }),
      Object.defineProperty(t, "stringify", {
        enumerable: !0,
        get: function () {
          return r.stringify;
        },
      }),
      Object.defineProperty(t, "nil", {
        enumerable: !0,
        get: function () {
          return r.nil;
        },
      }),
      Object.defineProperty(t, "Name", {
        enumerable: !0,
        get: function () {
          return r.Name;
        },
      }),
      Object.defineProperty(t, "CodeGen", {
        enumerable: !0,
        get: function () {
          return r.CodeGen;
        },
      }));
    var n = qm(),
      s = ou(),
      a = DS(),
      i = zm(),
      o = Ze(),
      c = au(),
      l = Vl(),
      u = st(),
      d = DF(),
      m = UF(),
      p = (B, $) => new RegExp(B, $);
    p.code = "new RegExp";
    var f = ["removeAdditional", "useDefaults", "coerceTypes"],
      y = new Set([
        "validate",
        "serialize",
        "parse",
        "wrapper",
        "root",
        "schema",
        "keyword",
        "pattern",
        "formats",
        "validate$data",
        "func",
        "obj",
        "Error",
      ]),
      h = {
        errorDataPath: "",
        format: "`validateFormats: false` can be used instead.",
        nullable: '"nullable" keyword is supported by default.',
        jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
        extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
        missingRefs:
          "Pass empty schema with $id that should be ignored to ajv.addSchema.",
        processCode:
          "Use option `code: {process: (code, schemaEnv: object) => string}`",
        sourceCode: "Use option `code: {source: true}`",
        strictDefaults: "It is default now, see option `strict`.",
        strictKeywords: "It is default now, see option `strict`.",
        uniqueItems: '"uniqueItems" keyword is always validated.',
        unknownFormats:
          "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
        cache: "Map is used as cache, schema object as key.",
        serialize: "Map is used as cache, schema object as key.",
        ajvErrors: "It is default now.",
      },
      g = {
        ignoreKeywordsWithRef: "",
        jsPropertySyntax: "",
        unicode:
          '"minLength"/"maxLength" account for unicode characters by default.',
      },
      _ = 200;
    function v(B) {
      var $,
        G,
        U,
        T,
        O,
        H,
        ce,
        oe,
        Fe,
        Ee,
        Me,
        q,
        z,
        Z,
        te,
        fe,
        je,
        wt,
        dt,
        vt,
        pt,
        et,
        er,
        bt,
        hs;
      let Fn = B.strict,
        lr = ($ = B.code) === null || $ === void 0 ? void 0 : $.optimize,
        gs = lr === !0 || lr === void 0 ? 1 : lr || 0,
        yo =
          (U = (G = B.code) === null || G === void 0 ? void 0 : G.regExp) !==
            null && U !== void 0
            ? U
            : p,
        il = (T = B.uriResolver) !== null && T !== void 0 ? T : m.default;
      return {
        strictSchema:
          (H = (O = B.strictSchema) !== null && O !== void 0 ? O : Fn) !==
            null && H !== void 0
            ? H
            : !0,
        strictNumbers:
          (oe = (ce = B.strictNumbers) !== null && ce !== void 0 ? ce : Fn) !==
            null && oe !== void 0
            ? oe
            : !0,
        strictTypes:
          (Ee = (Fe = B.strictTypes) !== null && Fe !== void 0 ? Fe : Fn) !==
            null && Ee !== void 0
            ? Ee
            : "log",
        strictTuples:
          (q = (Me = B.strictTuples) !== null && Me !== void 0 ? Me : Fn) !==
            null && q !== void 0
            ? q
            : "log",
        strictRequired:
          (Z = (z = B.strictRequired) !== null && z !== void 0 ? z : Fn) !==
            null && Z !== void 0
            ? Z
            : !1,
        code: B.code
          ? { ...B.code, optimize: gs, regExp: yo }
          : { optimize: gs, regExp: yo },
        loopRequired: (te = B.loopRequired) !== null && te !== void 0 ? te : _,
        loopEnum: (fe = B.loopEnum) !== null && fe !== void 0 ? fe : _,
        meta: (je = B.meta) !== null && je !== void 0 ? je : !0,
        messages: (wt = B.messages) !== null && wt !== void 0 ? wt : !0,
        inlineRefs: (dt = B.inlineRefs) !== null && dt !== void 0 ? dt : !0,
        schemaId: (vt = B.schemaId) !== null && vt !== void 0 ? vt : "$id",
        addUsedSchema:
          (pt = B.addUsedSchema) !== null && pt !== void 0 ? pt : !0,
        validateSchema:
          (et = B.validateSchema) !== null && et !== void 0 ? et : !0,
        validateFormats:
          (er = B.validateFormats) !== null && er !== void 0 ? er : !0,
        unicodeRegExp:
          (bt = B.unicodeRegExp) !== null && bt !== void 0 ? bt : !0,
        int32range: (hs = B.int32range) !== null && hs !== void 0 ? hs : !0,
        uriResolver: il,
      };
    }
    class b {
      constructor($ = {}) {
        ((this.schemas = {}),
          (this.refs = {}),
          (this.formats = {}),
          (this._compilations = new Set()),
          (this._loading = {}),
          (this._cache = new Map()),
          ($ = this.opts = { ...$, ...v($) }));
        let { es5: G, lines: U } = this.opts.code;
        ((this.scope = new o.ValueScope({
          scope: {},
          prefixes: y,
          es5: G,
          lines: U,
        })),
          (this.logger = D($.logger)));
        let T = $.validateFormats;
        (($.validateFormats = !1),
          (this.RULES = (0, a.getRules)()),
          x.call(this, h, $, "NOT SUPPORTED"),
          x.call(this, g, $, "DEPRECATED", "warn"),
          (this._metaOpts = A.call(this)),
          $.formats && C.call(this),
          this._addVocabularies(),
          this._addDefaultMetaSchema(),
          $.keywords && P.call(this, $.keywords),
          typeof $.meta == "object" && this.addMetaSchema($.meta),
          S.call(this),
          ($.validateFormats = T));
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        let { $data: $, meta: G, schemaId: U } = this.opts,
          T = d;
        (U === "id" && ((T = { ...d }), (T.id = T.$id), delete T.$id),
          G && $ && this.addMetaSchema(T, T[U], !1));
      }
      defaultMeta() {
        let { meta: $, schemaId: G } = this.opts;
        return (this.opts.defaultMeta =
          typeof $ == "object" ? $[G] || $ : void 0);
      }
      validate($, G) {
        let U;
        if (typeof $ == "string") {
          if (((U = this.getSchema($)), !U))
            throw new Error(`no schema with key or ref "${$}"`);
        } else U = this.compile($);
        let T = U(G);
        return ("$async" in U || (this.errors = U.errors), T);
      }
      compile($, G) {
        let U = this._addSchema($, G);
        return U.validate || this._compileSchemaEnv(U);
      }
      compileAsync($, G) {
        if (typeof this.opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        let { loadSchema: U } = this.opts;
        return T.call(this, $, G);
        async function T(Ee, Me) {
          await O.call(this, Ee.$schema);
          let q = this._addSchema(Ee, Me);
          return q.validate || H.call(this, q);
        }
        async function O(Ee) {
          Ee && !this.getSchema(Ee) && (await T.call(this, { $ref: Ee }, !0));
        }
        async function H(Ee) {
          try {
            return this._compileSchemaEnv(Ee);
          } catch (Me) {
            if (!(Me instanceof s.default)) throw Me;
            return (
              ce.call(this, Me),
              await oe.call(this, Me.missingSchema),
              H.call(this, Ee)
            );
          }
        }
        function ce({ missingSchema: Ee, missingRef: Me }) {
          if (this.refs[Ee])
            throw new Error(
              `AnySchema ${Ee} is loaded but ${Me} cannot be resolved`,
            );
        }
        async function oe(Ee) {
          let Me = await Fe.call(this, Ee);
          (this.refs[Ee] || (await O.call(this, Me.$schema)),
            this.refs[Ee] || this.addSchema(Me, Ee, G));
        }
        async function Fe(Ee) {
          let Me = this._loading[Ee];
          if (Me) return Me;
          try {
            return await (this._loading[Ee] = U(Ee));
          } finally {
            delete this._loading[Ee];
          }
        }
      }
      addSchema($, G, U, T = this.opts.validateSchema) {
        if (Array.isArray($)) {
          for (let H of $) this.addSchema(H, void 0, U, T);
          return this;
        }
        let O;
        if (typeof $ == "object") {
          let { schemaId: H } = this.opts;
          if (((O = $[H]), O !== void 0 && typeof O != "string"))
            throw new Error(`schema ${H} must be string`);
        }
        return (
          (G = (0, c.normalizeId)(G || O)),
          this._checkUnique(G),
          (this.schemas[G] = this._addSchema($, U, G, T, !0)),
          this
        );
      }
      addMetaSchema($, G, U = this.opts.validateSchema) {
        return (this.addSchema($, G, !0, U), this);
      }
      validateSchema($, G) {
        if (typeof $ == "boolean") return !0;
        let U;
        if (((U = $.$schema), U !== void 0 && typeof U != "string"))
          throw new Error("$schema must be a string");
        if (((U = U || this.opts.defaultMeta || this.defaultMeta()), !U))
          return (
            this.logger.warn("meta-schema not available"),
            (this.errors = null),
            !0
          );
        let T = this.validate(U, $);
        if (!T && G) {
          let O = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log") this.logger.error(O);
          else throw new Error(O);
        }
        return T;
      }
      getSchema($) {
        let G;
        for (; typeof (G = w.call(this, $)) == "string"; ) $ = G;
        if (G === void 0) {
          let { schemaId: U } = this.opts,
            T = new i.SchemaEnv({ schema: {}, schemaId: U });
          if (((G = i.resolveSchema.call(this, T, $)), !G)) return;
          this.refs[$] = G;
        }
        return G.validate || this._compileSchemaEnv(G);
      }
      removeSchema($) {
        if ($ instanceof RegExp)
          return (
            this._removeAllSchemas(this.schemas, $),
            this._removeAllSchemas(this.refs, $),
            this
          );
        switch (typeof $) {
          case "undefined":
            return (
              this._removeAllSchemas(this.schemas),
              this._removeAllSchemas(this.refs),
              this._cache.clear(),
              this
            );
          case "string": {
            let G = w.call(this, $);
            return (
              typeof G == "object" && this._cache.delete(G.schema),
              delete this.schemas[$],
              delete this.refs[$],
              this
            );
          }
          case "object": {
            let G = $;
            this._cache.delete(G);
            let U = $[this.opts.schemaId];
            return (
              U &&
                ((U = (0, c.normalizeId)(U)),
                delete this.schemas[U],
                delete this.refs[U]),
              this
            );
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      addVocabulary($) {
        for (let G of $) this.addKeyword(G);
        return this;
      }
      addKeyword($, G) {
        let U;
        if (typeof $ == "string")
          ((U = $),
            typeof G == "object" &&
              (this.logger.warn(
                "these parameters are deprecated, see docs for addKeyword",
              ),
              (G.keyword = U)));
        else if (typeof $ == "object" && G === void 0) {
          if (((G = $), (U = G.keyword), Array.isArray(U) && !U.length))
            throw new Error(
              "addKeywords: keyword must be string or non-empty array",
            );
        } else throw new Error("invalid addKeywords parameters");
        if ((I.call(this, U, G), !G))
          return ((0, u.eachItem)(U, (O) => K.call(this, O)), this);
        Y.call(this, G);
        let T = {
          ...G,
          type: (0, l.getJSONTypes)(G.type),
          schemaType: (0, l.getJSONTypes)(G.schemaType),
        };
        return (
          (0, u.eachItem)(
            U,
            T.type.length === 0
              ? (O) => K.call(this, O, T)
              : (O) => T.type.forEach((H) => K.call(this, O, T, H)),
          ),
          this
        );
      }
      getKeyword($) {
        let G = this.RULES.all[$];
        return typeof G == "object" ? G.definition : !!G;
      }
      removeKeyword($) {
        let { RULES: G } = this;
        (delete G.keywords[$], delete G.all[$]);
        for (let U of G.rules) {
          let T = U.rules.findIndex((O) => O.keyword === $);
          T >= 0 && U.rules.splice(T, 1);
        }
        return this;
      }
      addFormat($, G) {
        return (
          typeof G == "string" && (G = new RegExp(G)),
          (this.formats[$] = G),
          this
        );
      }
      errorsText(
        $ = this.errors,
        { separator: G = ", ", dataVar: U = "data" } = {},
      ) {
        return !$ || $.length === 0
          ? "No errors"
          : $.map((T) => `${U}${T.instancePath} ${T.message}`).reduce(
              (T, O) => T + G + O,
            );
      }
      $dataMetaSchema($, G) {
        let U = this.RULES.all;
        $ = JSON.parse(JSON.stringify($));
        for (let T of G) {
          let O = T.split("/").slice(1),
            H = $;
          for (let ce of O) H = H[ce];
          for (let ce in U) {
            let oe = U[ce];
            if (typeof oe != "object") continue;
            let { $data: Fe } = oe.definition,
              Ee = H[ce];
            Fe && Ee && (H[ce] = ae(Ee));
          }
        }
        return $;
      }
      _removeAllSchemas($, G) {
        for (let U in $) {
          let T = $[U];
          (!G || G.test(U)) &&
            (typeof T == "string"
              ? delete $[U]
              : T && !T.meta && (this._cache.delete(T.schema), delete $[U]));
        }
      }
      _addSchema(
        $,
        G,
        U,
        T = this.opts.validateSchema,
        O = this.opts.addUsedSchema,
      ) {
        let H,
          { schemaId: ce } = this.opts;
        if (typeof $ == "object") H = $[ce];
        else {
          if (this.opts.jtd) throw new Error("schema must be object");
          if (typeof $ != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let oe = this._cache.get($);
        if (oe !== void 0) return oe;
        U = (0, c.normalizeId)(H || U);
        let Fe = c.getSchemaRefs.call(this, $, U);
        return (
          (oe = new i.SchemaEnv({
            schema: $,
            schemaId: ce,
            meta: G,
            baseId: U,
            localRefs: Fe,
          })),
          this._cache.set(oe.schema, oe),
          O &&
            !U.startsWith("#") &&
            (U && this._checkUnique(U), (this.refs[U] = oe)),
          T && this.validateSchema($, !0),
          oe
        );
      }
      _checkUnique($) {
        if (this.schemas[$] || this.refs[$])
          throw new Error(`schema with key or id "${$}" already exists`);
      }
      _compileSchemaEnv($) {
        if (
          ($.meta ? this._compileMetaSchema($) : i.compileSchema.call(this, $),
          !$.validate)
        )
          throw new Error("ajv implementation error");
        return $.validate;
      }
      _compileMetaSchema($) {
        let G = this.opts;
        this.opts = this._metaOpts;
        try {
          i.compileSchema.call(this, $);
        } finally {
          this.opts = G;
        }
      }
    }
    ((b.ValidationError = n.default),
      (b.MissingRefError = s.default),
      (t.default = b));
    function x(B, $, G, U = "error") {
      for (let T in B) {
        let O = T;
        O in $ && this.logger[U](`${G}: option ${T}. ${B[O]}`);
      }
    }
    function w(B) {
      return ((B = (0, c.normalizeId)(B)), this.schemas[B] || this.refs[B]);
    }
    function S() {
      let B = this.opts.schemas;
      if (B)
        if (Array.isArray(B)) this.addSchema(B);
        else for (let $ in B) this.addSchema(B[$], $);
    }
    function C() {
      for (let B in this.opts.formats) {
        let $ = this.opts.formats[B];
        $ && this.addFormat(B, $);
      }
    }
    function P(B) {
      if (Array.isArray(B)) {
        this.addVocabulary(B);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (let $ in B) {
        let G = B[$];
        (G.keyword || (G.keyword = $), this.addKeyword(G));
      }
    }
    function A() {
      let B = { ...this.opts };
      for (let $ of f) delete B[$];
      return B;
    }
    var R = { log() {}, warn() {}, error() {} };
    function D(B) {
      if (B === !1) return R;
      if (B === void 0) return console;
      if (B.log && B.warn && B.error) return B;
      throw new Error("logger must implement log, warn and error methods");
    }
    var F = /^[a-z_$][a-z0-9_$:-]*$/i;
    function I(B, $) {
      let { RULES: G } = this;
      if (
        ((0, u.eachItem)(B, (U) => {
          if (G.keywords[U]) throw new Error(`Keyword ${U} is already defined`);
          if (!F.test(U)) throw new Error(`Keyword ${U} has invalid name`);
        }),
        !!$ && $.$data && !("code" in $ || "validate" in $))
      )
        throw new Error(
          '$data keyword must have "code" or "validate" function',
        );
    }
    function K(B, $, G) {
      var U;
      let T = $?.post;
      if (G && T)
        throw new Error('keyword with "post" flag cannot have "type"');
      let { RULES: O } = this,
        H = T ? O.post : O.rules.find(({ type: oe }) => oe === G);
      if (
        (H || ((H = { type: G, rules: [] }), O.rules.push(H)),
        (O.keywords[B] = !0),
        !$)
      )
        return;
      let ce = {
        keyword: B,
        definition: {
          ...$,
          type: (0, l.getJSONTypes)($.type),
          schemaType: (0, l.getJSONTypes)($.schemaType),
        },
      };
      ($.before ? ee.call(this, H, ce, $.before) : H.rules.push(ce),
        (O.all[B] = ce),
        (U = $.implements) === null ||
          U === void 0 ||
          U.forEach((oe) => this.addKeyword(oe)));
    }
    function ee(B, $, G) {
      let U = B.rules.findIndex((T) => T.keyword === G);
      U >= 0
        ? B.rules.splice(U, 0, $)
        : (B.rules.push($), this.logger.warn(`rule ${G} is not defined`));
    }
    function Y(B) {
      let { metaSchema: $ } = B;
      $ !== void 0 &&
        (B.$data && this.opts.$data && ($ = ae($)),
        (B.validateSchema = this.compile($, !0)));
    }
    var Q = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    };
    function ae(B) {
      return { anyOf: [B, Q] };
    }
  }),
  zF = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      },
    };
    t.default = e;
  }),
  BF = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.callRef = t.getValidate = void 0));
    var e = ou(),
      r = fn(),
      n = Ze(),
      s = Es(),
      a = zm(),
      i = st(),
      o = {
        keyword: "$ref",
        schemaType: "string",
        code(u) {
          let { gen: d, schema: m, it: p } = u,
            { baseId: f, schemaEnv: y, validateName: h, opts: g, self: _ } = p,
            { root: v } = y;
          if ((m === "#" || m === "#/") && f === v.baseId) return x();
          let b = a.resolveRef.call(_, v, f, m);
          if (b === void 0) throw new e.default(p.opts.uriResolver, f, m);
          if (b instanceof a.SchemaEnv) return w(b);
          return S(b);
          function x() {
            if (y === v) return l(u, h, y, y.$async);
            let C = d.scopeValue("root", { ref: v });
            return l(u, (0, n._)`${C}.validate`, v, v.$async);
          }
          function w(C) {
            let P = c(u, C);
            l(u, P, C, C.$async);
          }
          function S(C) {
            let P = d.scopeValue(
                "schema",
                g.code.source === !0
                  ? { ref: C, code: (0, n.stringify)(C) }
                  : { ref: C },
              ),
              A = d.name("valid"),
              R = u.subschema(
                {
                  schema: C,
                  dataTypes: [],
                  schemaPath: n.nil,
                  topSchemaRef: P,
                  errSchemaPath: m,
                },
                A,
              );
            (u.mergeEvaluated(R), u.ok(A));
          }
        },
      };
    function c(u, d) {
      let { gen: m } = u;
      return d.validate
        ? m.scopeValue("validate", { ref: d.validate })
        : (0, n._)`${m.scopeValue("wrapper", { ref: d })}.validate`;
    }
    t.getValidate = c;
    function l(u, d, m, p) {
      let { gen: f, it: y } = u,
        { allErrors: h, schemaEnv: g, opts: _ } = y,
        v = _.passContext ? s.default.this : n.nil;
      p ? b() : x();
      function b() {
        if (!g.$async)
          throw new Error("async schema referenced by sync schema");
        let C = f.let("valid");
        (f.try(
          () => {
            (f.code((0, n._)`await ${(0, r.callValidateCode)(u, d, v)}`),
              S(d),
              h || f.assign(C, !0));
          },
          (P) => {
            (f.if((0, n._)`!(${P} instanceof ${y.ValidationError})`, () =>
              f.throw(P),
            ),
              w(P),
              h || f.assign(C, !1));
          },
        ),
          u.ok(C));
      }
      function x() {
        u.result(
          (0, r.callValidateCode)(u, d, v),
          () => S(d),
          () => w(d),
        );
      }
      function w(C) {
        let P = (0, n._)`${C}.errors`;
        (f.assign(
          s.default.vErrors,
          (0,
          n._)`${s.default.vErrors} === null ? ${P} : ${s.default.vErrors}.concat(${P})`,
        ),
          f.assign(s.default.errors, (0, n._)`${s.default.vErrors}.length`));
      }
      function S(C) {
        var P;
        if (!y.opts.unevaluated) return;
        let A =
          (P = m?.validate) === null || P === void 0 ? void 0 : P.evaluated;
        if (y.props !== !0)
          if (A && !A.dynamicProps)
            A.props !== void 0 &&
              (y.props = i.mergeEvaluated.props(f, A.props, y.props));
          else {
            let R = f.var("props", (0, n._)`${C}.evaluated.props`);
            y.props = i.mergeEvaluated.props(f, R, y.props, n.Name);
          }
        if (y.items !== !0)
          if (A && !A.dynamicItems)
            A.items !== void 0 &&
              (y.items = i.mergeEvaluated.items(f, A.items, y.items));
          else {
            let R = f.var("items", (0, n._)`${C}.evaluated.items`);
            y.items = i.mergeEvaluated.items(f, R, y.items, n.Name);
          }
      }
    }
    ((t.callRef = l), (t.default = o));
  }),
  HF = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = zF(),
      r = BF(),
      n = [
        "$schema",
        "$id",
        "$defs",
        "$vocabulary",
        { keyword: "$comment" },
        "definitions",
        e.default,
        r.default,
      ];
    t.default = n;
  }),
  VF = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = Ze(),
      r = e.operators,
      n = {
        maximum: { okStr: "<=", ok: r.LTE, fail: r.GT },
        minimum: { okStr: ">=", ok: r.GTE, fail: r.LT },
        exclusiveMaximum: { okStr: "<", ok: r.LT, fail: r.GTE },
        exclusiveMinimum: { okStr: ">", ok: r.GT, fail: r.LTE },
      },
      s = {
        message: ({ keyword: i, schemaCode: o }) =>
          (0, e.str)`must be ${n[i].okStr} ${o}`,
        params: ({ keyword: i, schemaCode: o }) =>
          (0, e._)`{comparison: ${n[i].okStr}, limit: ${o}}`,
      },
      a = {
        keyword: Object.keys(n),
        type: "number",
        schemaType: "number",
        $data: !0,
        error: s,
        code(i) {
          let { keyword: o, data: c, schemaCode: l } = i;
          i.fail$data((0, e._)`${c} ${n[o].fail} ${l} || isNaN(${c})`);
        },
      };
    t.default = a;
  }),
  ZF = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = Ze(),
      r = {
        message: ({ schemaCode: s }) => (0, e.str)`must be multiple of ${s}`,
        params: ({ schemaCode: s }) => (0, e._)`{multipleOf: ${s}}`,
      },
      n = {
        keyword: "multipleOf",
        type: "number",
        schemaType: "number",
        $data: !0,
        error: r,
        code(s) {
          let { gen: a, data: i, schemaCode: o, it: c } = s,
            l = c.opts.multipleOfPrecision,
            u = a.let("res"),
            d = l
              ? (0, e._)`Math.abs(Math.round(${u}) - ${u}) > 1e-${l}`
              : (0, e._)`${u} !== parseInt(${u})`;
          s.fail$data((0, e._)`(${o} === 0 || (${u} = ${i}/${o}, ${d}))`);
        },
      };
    t.default = n;
  }),
  GF = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    function e(r) {
      let n = r.length,
        s = 0,
        a = 0,
        i;
      for (; a < n; )
        (s++,
          (i = r.charCodeAt(a++)),
          i >= 55296 &&
            i <= 56319 &&
            a < n &&
            ((i = r.charCodeAt(a)), (i & 64512) === 56320 && a++));
      return s;
    }
    ((t.default = e),
      (e.code = 'require("ajv/dist/runtime/ucs2length").default'));
  }),
  WF = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = Ze(),
      r = st(),
      n = GF(),
      s = {
        message({ keyword: i, schemaCode: o }) {
          let c = i === "maxLength" ? "more" : "fewer";
          return (0, e.str)`must NOT have ${c} than ${o} characters`;
        },
        params: ({ schemaCode: i }) => (0, e._)`{limit: ${i}}`,
      },
      a = {
        keyword: ["maxLength", "minLength"],
        type: "string",
        schemaType: "number",
        $data: !0,
        error: s,
        code(i) {
          let { keyword: o, data: c, schemaCode: l, it: u } = i,
            d = o === "maxLength" ? e.operators.GT : e.operators.LT,
            m =
              u.opts.unicode === !1
                ? (0, e._)`${c}.length`
                : (0, e._)`${(0, r.useFunc)(i.gen, n.default)}(${c})`;
          i.fail$data((0, e._)`${m} ${d} ${l}`);
        },
      };
    t.default = a;
  }),
  KF = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = fn(),
      r = Ze(),
      n = {
        message: ({ schemaCode: a }) => (0, r.str)`must match pattern "${a}"`,
        params: ({ schemaCode: a }) => (0, r._)`{pattern: ${a}}`,
      },
      s = {
        keyword: "pattern",
        type: "string",
        schemaType: "string",
        $data: !0,
        error: n,
        code(a) {
          let { data: i, $data: o, schema: c, schemaCode: l, it: u } = a,
            d = u.opts.unicodeRegExp ? "u" : "",
            m = o
              ? (0, r._)`(new RegExp(${l}, ${d}))`
              : (0, e.usePattern)(a, c);
          a.fail$data((0, r._)`!${m}.test(${i})`);
        },
      };
    t.default = s;
  }),
  JF = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = Ze(),
      r = {
        message({ keyword: s, schemaCode: a }) {
          let i = s === "maxProperties" ? "more" : "fewer";
          return (0, e.str)`must NOT have ${i} than ${a} properties`;
        },
        params: ({ schemaCode: s }) => (0, e._)`{limit: ${s}}`,
      },
      n = {
        keyword: ["maxProperties", "minProperties"],
        type: "object",
        schemaType: "number",
        $data: !0,
        error: r,
        code(s) {
          let { keyword: a, data: i, schemaCode: o } = s,
            c = a === "maxProperties" ? e.operators.GT : e.operators.LT;
          s.fail$data((0, e._)`Object.keys(${i}).length ${c} ${o}`);
        },
      };
    t.default = n;
  }),
  XF = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = fn(),
      r = Ze(),
      n = st(),
      s = {
        message: ({ params: { missingProperty: i } }) =>
          (0, r.str)`must have required property '${i}'`,
        params: ({ params: { missingProperty: i } }) =>
          (0, r._)`{missingProperty: ${i}}`,
      },
      a = {
        keyword: "required",
        type: "object",
        schemaType: "array",
        $data: !0,
        error: s,
        code(i) {
          let {
              gen: o,
              schema: c,
              schemaCode: l,
              data: u,
              $data: d,
              it: m,
            } = i,
            { opts: p } = m;
          if (!d && c.length === 0) return;
          let f = c.length >= p.loopRequired;
          if ((m.allErrors ? y() : h(), p.strictRequired)) {
            let v = i.parentSchema.properties,
              { definedProperties: b } = i.it;
            for (let x of c)
              if (v?.[x] === void 0 && !b.has(x)) {
                let w = m.schemaEnv.baseId + m.errSchemaPath,
                  S = `required property "${x}" is not defined at "${w}" (strictRequired)`;
                (0, n.checkStrictMode)(m, S, m.opts.strictRequired);
              }
          }
          function y() {
            if (f || d) i.block$data(r.nil, g);
            else for (let v of c) (0, e.checkReportMissingProp)(i, v);
          }
          function h() {
            let v = o.let("missing");
            if (f || d) {
              let b = o.let("valid", !0);
              (i.block$data(b, () => _(v, b)), i.ok(b));
            } else
              (o.if((0, e.checkMissingProp)(i, c, v)),
                (0, e.reportMissingProp)(i, v),
                o.else());
          }
          function g() {
            o.forOf("prop", l, (v) => {
              (i.setParams({ missingProperty: v }),
                o.if((0, e.noPropertyInData)(o, u, v, p.ownProperties), () =>
                  i.error(),
                ));
            });
          }
          function _(v, b) {
            (i.setParams({ missingProperty: v }),
              o.forOf(
                v,
                l,
                () => {
                  (o.assign(b, (0, e.propertyInData)(o, u, v, p.ownProperties)),
                    o.if((0, r.not)(b), () => {
                      (i.error(), o.break());
                    }));
                },
                r.nil,
              ));
          }
        },
      };
    t.default = a;
  }),
  YF = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = Ze(),
      r = {
        message({ keyword: s, schemaCode: a }) {
          let i = s === "maxItems" ? "more" : "fewer";
          return (0, e.str)`must NOT have ${i} than ${a} items`;
        },
        params: ({ schemaCode: s }) => (0, e._)`{limit: ${s}}`,
      },
      n = {
        keyword: ["maxItems", "minItems"],
        type: "array",
        schemaType: "number",
        $data: !0,
        error: r,
        code(s) {
          let { keyword: a, data: i, schemaCode: o } = s,
            c = a === "maxItems" ? e.operators.GT : e.operators.LT;
          s.fail$data((0, e._)`${i}.length ${c} ${o}`);
        },
      };
    t.default = n;
  }),
  Bm = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = MS();
    ((e.code = 'require("ajv/dist/runtime/equal").default'), (t.default = e));
  }),
  QF = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = Vl(),
      r = Ze(),
      n = st(),
      s = Bm(),
      a = {
        message: ({ params: { i: o, j: c } }) =>
          (0,
          r.str)`must NOT have duplicate items (items ## ${c} and ${o} are identical)`,
        params: ({ params: { i: o, j: c } }) => (0, r._)`{i: ${o}, j: ${c}}`,
      },
      i = {
        keyword: "uniqueItems",
        type: "array",
        schemaType: "boolean",
        $data: !0,
        error: a,
        code(o) {
          let {
            gen: c,
            data: l,
            $data: u,
            schema: d,
            parentSchema: m,
            schemaCode: p,
            it: f,
          } = o;
          if (!u && !d) return;
          let y = c.let("valid"),
            h = m.items ? (0, e.getSchemaTypes)(m.items) : [];
          (o.block$data(y, g, (0, r._)`${p} === false`), o.ok(y));
          function g() {
            let x = c.let("i", (0, r._)`${l}.length`),
              w = c.let("j");
            (o.setParams({ i: x, j: w }),
              c.assign(y, !0),
              c.if((0, r._)`${x} > 1`, () => (_() ? v : b)(x, w)));
          }
          function _() {
            return (
              h.length > 0 && !h.some((x) => x === "object" || x === "array")
            );
          }
          function v(x, w) {
            let S = c.name("item"),
              C = (0, e.checkDataTypes)(
                h,
                S,
                f.opts.strictNumbers,
                e.DataType.Wrong,
              ),
              P = c.const("indices", (0, r._)`{}`);
            c.for((0, r._)`;${x}--;`, () => {
              (c.let(S, (0, r._)`${l}[${x}]`),
                c.if(C, (0, r._)`continue`),
                h.length > 1 &&
                  c.if(
                    (0, r._)`typeof ${S} == "string"`,
                    (0, r._)`${S} += "_"`,
                  ),
                c
                  .if((0, r._)`typeof ${P}[${S}] == "number"`, () => {
                    (c.assign(w, (0, r._)`${P}[${S}]`),
                      o.error(),
                      c.assign(y, !1).break());
                  })
                  .code((0, r._)`${P}[${S}] = ${x}`));
            });
          }
          function b(x, w) {
            let S = (0, n.useFunc)(c, s.default),
              C = c.name("outer");
            c.label(C).for((0, r._)`;${x}--;`, () =>
              c.for((0, r._)`${w} = ${x}; ${w}--;`, () =>
                c.if((0, r._)`${S}(${l}[${x}], ${l}[${w}])`, () => {
                  (o.error(), c.assign(y, !1).break(C));
                }),
              ),
            );
          }
        },
      };
    t.default = i;
  }),
  eU = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = Ze(),
      r = st(),
      n = Bm(),
      s = {
        message: "must be equal to constant",
        params: ({ schemaCode: i }) => (0, e._)`{allowedValue: ${i}}`,
      },
      a = {
        keyword: "const",
        $data: !0,
        error: s,
        code(i) {
          let { gen: o, data: c, $data: l, schemaCode: u, schema: d } = i;
          l || (d && typeof d == "object")
            ? i.fail$data(
                (0, e._)`!${(0, r.useFunc)(o, n.default)}(${c}, ${u})`,
              )
            : i.fail((0, e._)`${d} !== ${c}`);
        },
      };
    t.default = a;
  }),
  tU = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = Ze(),
      r = st(),
      n = Bm(),
      s = {
        message: "must be equal to one of the allowed values",
        params: ({ schemaCode: i }) => (0, e._)`{allowedValues: ${i}}`,
      },
      a = {
        keyword: "enum",
        schemaType: "array",
        $data: !0,
        error: s,
        code(i) {
          let {
            gen: o,
            data: c,
            $data: l,
            schema: u,
            schemaCode: d,
            it: m,
          } = i;
          if (!l && u.length === 0)
            throw new Error("enum must have non-empty array");
          let p = u.length >= m.opts.loopEnum,
            f,
            y = () => f ?? (f = (0, r.useFunc)(o, n.default)),
            h;
          if (p || l) ((h = o.let("valid")), i.block$data(h, g));
          else {
            if (!Array.isArray(u)) throw new Error("ajv implementation error");
            let v = o.const("vSchema", d);
            h = (0, e.or)(...u.map((b, x) => _(v, x)));
          }
          i.pass(h);
          function g() {
            (o.assign(h, !1),
              o.forOf("v", d, (v) =>
                o.if((0, e._)`${y()}(${c}, ${v})`, () =>
                  o.assign(h, !0).break(),
                ),
              ));
          }
          function _(v, b) {
            let x = u[b];
            return typeof x == "object" && x !== null
              ? (0, e._)`${y()}(${c}, ${v}[${b}])`
              : (0, e._)`${c} === ${x}`;
          }
        },
      };
    t.default = a;
  }),
  rU = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = VF(),
      r = ZF(),
      n = WF(),
      s = KF(),
      a = JF(),
      i = XF(),
      o = YF(),
      c = QF(),
      l = eU(),
      u = tU(),
      d = [
        e.default,
        r.default,
        n.default,
        s.default,
        a.default,
        i.default,
        o.default,
        c.default,
        { keyword: "type", schemaType: ["string", "array"] },
        { keyword: "nullable", schemaType: "boolean" },
        l.default,
        u.default,
      ];
    t.default = d;
  }),
  jS = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.validateAdditionalItems = void 0));
    var e = Ze(),
      r = st(),
      n = {
        message: ({ params: { len: i } }) =>
          (0, e.str)`must NOT have more than ${i} items`,
        params: ({ params: { len: i } }) => (0, e._)`{limit: ${i}}`,
      },
      s = {
        keyword: "additionalItems",
        type: "array",
        schemaType: ["boolean", "object"],
        before: "uniqueItems",
        error: n,
        code(i) {
          let { parentSchema: o, it: c } = i,
            { items: l } = o;
          if (!Array.isArray(l)) {
            (0, r.checkStrictMode)(
              c,
              '"additionalItems" is ignored when "items" is not an array of schemas',
            );
            return;
          }
          a(i, l);
        },
      };
    function a(i, o) {
      let { gen: c, schema: l, data: u, keyword: d, it: m } = i;
      m.items = !0;
      let p = c.const("len", (0, e._)`${u}.length`);
      if (l === !1)
        (i.setParams({ len: o.length }), i.pass((0, e._)`${p} <= ${o.length}`));
      else if (typeof l == "object" && !(0, r.alwaysValidSchema)(m, l)) {
        let y = c.var("valid", (0, e._)`${p} <= ${o.length}`);
        (c.if((0, e.not)(y), () => f(y)), i.ok(y));
      }
      function f(y) {
        c.forRange("i", o.length, p, (h) => {
          (i.subschema(
            { keyword: d, dataProp: h, dataPropType: r.Type.Num },
            y,
          ),
            m.allErrors || c.if((0, e.not)(y), () => c.break()));
        });
      }
    }
    ((t.validateAdditionalItems = a), (t.default = s));
  }),
  FS = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.validateTuple = void 0));
    var e = Ze(),
      r = st(),
      n = fn(),
      s = {
        keyword: "items",
        type: "array",
        schemaType: ["object", "array", "boolean"],
        before: "uniqueItems",
        code(i) {
          let { schema: o, it: c } = i;
          if (Array.isArray(o)) return a(i, "additionalItems", o);
          ((c.items = !0),
            !(0, r.alwaysValidSchema)(c, o) && i.ok((0, n.validateArray)(i)));
        },
      };
    function a(i, o, c = i.schema) {
      let { gen: l, parentSchema: u, data: d, keyword: m, it: p } = i;
      (h(u),
        p.opts.unevaluated &&
          c.length &&
          p.items !== !0 &&
          (p.items = r.mergeEvaluated.items(l, c.length, p.items)));
      let f = l.name("valid"),
        y = l.const("len", (0, e._)`${d}.length`);
      c.forEach((g, _) => {
        (0, r.alwaysValidSchema)(p, g) ||
          (l.if((0, e._)`${y} > ${_}`, () =>
            i.subschema({ keyword: m, schemaProp: _, dataProp: _ }, f),
          ),
          i.ok(f));
      });
      function h(g) {
        let { opts: _, errSchemaPath: v } = p,
          b = c.length,
          x = b === g.minItems && (b === g.maxItems || g[o] === !1);
        if (_.strictTuples && !x) {
          let w = `"${m}" is ${b}-tuple, but minItems or maxItems/${o} are not specified or different at path "${v}"`;
          (0, r.checkStrictMode)(p, w, _.strictTuples);
        }
      }
    }
    ((t.validateTuple = a), (t.default = s));
  }),
  nU = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = FS(),
      r = {
        keyword: "prefixItems",
        type: "array",
        schemaType: ["array"],
        before: "uniqueItems",
        code: (n) => (0, e.validateTuple)(n, "items"),
      };
    t.default = r;
  }),
  sU = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = Ze(),
      r = st(),
      n = fn(),
      s = jS(),
      a = {
        message: ({ params: { len: o } }) =>
          (0, e.str)`must NOT have more than ${o} items`,
        params: ({ params: { len: o } }) => (0, e._)`{limit: ${o}}`,
      },
      i = {
        keyword: "items",
        type: "array",
        schemaType: ["object", "boolean"],
        before: "uniqueItems",
        error: a,
        code(o) {
          let { schema: c, parentSchema: l, it: u } = o,
            { prefixItems: d } = l;
          ((u.items = !0),
            !(0, r.alwaysValidSchema)(u, c) &&
              (d
                ? (0, s.validateAdditionalItems)(o, d)
                : o.ok((0, n.validateArray)(o))));
        },
      };
    t.default = i;
  }),
  aU = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = Ze(),
      r = st(),
      n = {
        message: ({ params: { min: a, max: i } }) =>
          i === void 0
            ? (0, e.str)`must contain at least ${a} valid item(s)`
            : (0,
              e.str)`must contain at least ${a} and no more than ${i} valid item(s)`,
        params: ({ params: { min: a, max: i } }) =>
          i === void 0
            ? (0, e._)`{minContains: ${a}}`
            : (0, e._)`{minContains: ${a}, maxContains: ${i}}`,
      },
      s = {
        keyword: "contains",
        type: "array",
        schemaType: ["object", "boolean"],
        before: "uniqueItems",
        trackErrors: !0,
        error: n,
        code(a) {
          let { gen: i, schema: o, parentSchema: c, data: l, it: u } = a,
            d,
            m,
            { minContains: p, maxContains: f } = c;
          u.opts.next ? ((d = p === void 0 ? 1 : p), (m = f)) : (d = 1);
          let y = i.const("len", (0, e._)`${l}.length`);
          if ((a.setParams({ min: d, max: m }), m === void 0 && d === 0)) {
            (0, r.checkStrictMode)(
              u,
              '"minContains" == 0 without "maxContains": "contains" keyword ignored',
            );
            return;
          }
          if (m !== void 0 && d > m) {
            ((0, r.checkStrictMode)(
              u,
              '"minContains" > "maxContains" is always invalid',
            ),
              a.fail());
            return;
          }
          if ((0, r.alwaysValidSchema)(u, o)) {
            let b = (0, e._)`${y} >= ${d}`;
            (m !== void 0 && (b = (0, e._)`${b} && ${y} <= ${m}`), a.pass(b));
            return;
          }
          u.items = !0;
          let h = i.name("valid");
          (m === void 0 && d === 1
            ? _(h, () => i.if(h, () => i.break()))
            : d === 0
              ? (i.let(h, !0),
                m !== void 0 && i.if((0, e._)`${l}.length > 0`, g))
              : (i.let(h, !1), g()),
            a.result(h, () => a.reset()));
          function g() {
            let b = i.name("_valid"),
              x = i.let("count", 0);
            _(b, () => i.if(b, () => v(x)));
          }
          function _(b, x) {
            i.forRange("i", 0, y, (w) => {
              (a.subschema(
                {
                  keyword: "contains",
                  dataProp: w,
                  dataPropType: r.Type.Num,
                  compositeRule: !0,
                },
                b,
              ),
                x());
            });
          }
          function v(b) {
            (i.code((0, e._)`${b}++`),
              m === void 0
                ? i.if((0, e._)`${b} >= ${d}`, () => i.assign(h, !0).break())
                : (i.if((0, e._)`${b} > ${m}`, () => i.assign(h, !1).break()),
                  d === 1
                    ? i.assign(h, !0)
                    : i.if((0, e._)`${b} >= ${d}`, () => i.assign(h, !0))));
          }
        },
      };
    t.default = s;
  }),
  iU = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.validateSchemaDeps = t.validatePropertyDeps = t.error = void 0));
    var e = Ze(),
      r = st(),
      n = fn();
    t.error = {
      message: ({ params: { property: c, depsCount: l, deps: u } }) => {
        let d = l === 1 ? "property" : "properties";
        return (0, e.str)`must have ${d} ${u} when property ${c} is present`;
      },
      params: ({
        params: { property: c, depsCount: l, deps: u, missingProperty: d },
      }) => (0, e._)`{property: ${c},
    missingProperty: ${d},
    depsCount: ${l},
    deps: ${u}}`,
    };
    var s = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: t.error,
      code(c) {
        let [l, u] = a(c);
        (i(c, l), o(c, u));
      },
    };
    function a({ schema: c }) {
      let l = {},
        u = {};
      for (let d in c) {
        if (d === "__proto__") continue;
        let m = Array.isArray(c[d]) ? l : u;
        m[d] = c[d];
      }
      return [l, u];
    }
    function i(c, l = c.schema) {
      let { gen: u, data: d, it: m } = c;
      if (Object.keys(l).length === 0) return;
      let p = u.let("missing");
      for (let f in l) {
        let y = l[f];
        if (y.length === 0) continue;
        let h = (0, n.propertyInData)(u, d, f, m.opts.ownProperties);
        (c.setParams({ property: f, depsCount: y.length, deps: y.join(", ") }),
          m.allErrors
            ? u.if(h, () => {
                for (let g of y) (0, n.checkReportMissingProp)(c, g);
              })
            : (u.if((0, e._)`${h} && (${(0, n.checkMissingProp)(c, y, p)})`),
              (0, n.reportMissingProp)(c, p),
              u.else()));
      }
    }
    t.validatePropertyDeps = i;
    function o(c, l = c.schema) {
      let { gen: u, data: d, keyword: m, it: p } = c,
        f = u.name("valid");
      for (let y in l)
        (0, r.alwaysValidSchema)(p, l[y]) ||
          (u.if(
            (0, n.propertyInData)(u, d, y, p.opts.ownProperties),
            () => {
              let h = c.subschema({ keyword: m, schemaProp: y }, f);
              c.mergeValidEvaluated(h, f);
            },
            () => u.var(f, !0),
          ),
          c.ok(f));
    }
    ((t.validateSchemaDeps = o), (t.default = s));
  }),
  oU = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = Ze(),
      r = st(),
      n = {
        message: "property name must be valid",
        params: ({ params: a }) => (0, e._)`{propertyName: ${a.propertyName}}`,
      },
      s = {
        keyword: "propertyNames",
        type: "object",
        schemaType: ["object", "boolean"],
        error: n,
        code(a) {
          let { gen: i, schema: o, data: c, it: l } = a;
          if ((0, r.alwaysValidSchema)(l, o)) return;
          let u = i.name("valid");
          (i.forIn("key", c, (d) => {
            (a.setParams({ propertyName: d }),
              a.subschema(
                {
                  keyword: "propertyNames",
                  data: d,
                  dataTypes: ["string"],
                  propertyName: d,
                  compositeRule: !0,
                },
                u,
              ),
              i.if((0, e.not)(u), () => {
                (a.error(!0), l.allErrors || i.break());
              }));
          }),
            a.ok(u));
        },
      };
    t.default = s;
  }),
  US = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = fn(),
      r = Ze(),
      n = Es(),
      s = st(),
      a = {
        message: "must NOT have additional properties",
        params: ({ params: o }) =>
          (0, r._)`{additionalProperty: ${o.additionalProperty}}`,
      },
      i = {
        keyword: "additionalProperties",
        type: ["object"],
        schemaType: ["boolean", "object"],
        allowUndefined: !0,
        trackErrors: !0,
        error: a,
        code(o) {
          let {
            gen: c,
            schema: l,
            parentSchema: u,
            data: d,
            errsCount: m,
            it: p,
          } = o;
          if (!m) throw new Error("ajv implementation error");
          let { allErrors: f, opts: y } = p;
          if (
            ((p.props = !0),
            y.removeAdditional !== "all" && (0, s.alwaysValidSchema)(p, l))
          )
            return;
          let h = (0, e.allSchemaProperties)(u.properties),
            g = (0, e.allSchemaProperties)(u.patternProperties);
          (_(), o.ok((0, r._)`${m} === ${n.default.errors}`));
          function _() {
            c.forIn("key", d, (S) => {
              !h.length && !g.length ? x(S) : c.if(v(S), () => x(S));
            });
          }
          function v(S) {
            let C;
            if (h.length > 8) {
              let P = (0, s.schemaRefOrVal)(p, u.properties, "properties");
              C = (0, e.isOwnProperty)(c, P, S);
            } else
              h.length
                ? (C = (0, r.or)(...h.map((P) => (0, r._)`${S} === ${P}`)))
                : (C = r.nil);
            return (
              g.length &&
                (C = (0, r.or)(
                  C,
                  ...g.map(
                    (P) => (0, r._)`${(0, e.usePattern)(o, P)}.test(${S})`,
                  ),
                )),
              (0, r.not)(C)
            );
          }
          function b(S) {
            c.code((0, r._)`delete ${d}[${S}]`);
          }
          function x(S) {
            if (
              y.removeAdditional === "all" ||
              (y.removeAdditional && l === !1)
            ) {
              b(S);
              return;
            }
            if (l === !1) {
              (o.setParams({ additionalProperty: S }),
                o.error(),
                f || c.break());
              return;
            }
            if (typeof l == "object" && !(0, s.alwaysValidSchema)(p, l)) {
              let C = c.name("valid");
              y.removeAdditional === "failing"
                ? (w(S, C, !1),
                  c.if((0, r.not)(C), () => {
                    (o.reset(), b(S));
                  }))
                : (w(S, C), f || c.if((0, r.not)(C), () => c.break()));
            }
          }
          function w(S, C, P) {
            let A = {
              keyword: "additionalProperties",
              dataProp: S,
              dataPropType: s.Type.Str,
            };
            (P === !1 &&
              Object.assign(A, {
                compositeRule: !0,
                createErrors: !1,
                allErrors: !1,
              }),
              o.subschema(A, C));
          }
        },
      };
    t.default = i;
  }),
  cU = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = iu(),
      r = fn(),
      n = st(),
      s = US(),
      a = {
        keyword: "properties",
        type: "object",
        schemaType: "object",
        code(i) {
          let { gen: o, schema: c, parentSchema: l, data: u, it: d } = i;
          d.opts.removeAdditional === "all" &&
            l.additionalProperties === void 0 &&
            s.default.code(
              new e.KeywordCxt(d, s.default, "additionalProperties"),
            );
          let m = (0, r.allSchemaProperties)(c);
          for (let g of m) d.definedProperties.add(g);
          d.opts.unevaluated &&
            m.length &&
            d.props !== !0 &&
            (d.props = n.mergeEvaluated.props(o, (0, n.toHash)(m), d.props));
          let p = m.filter((g) => !(0, n.alwaysValidSchema)(d, c[g]));
          if (p.length === 0) return;
          let f = o.name("valid");
          for (let g of p)
            (y(g)
              ? h(g)
              : (o.if((0, r.propertyInData)(o, u, g, d.opts.ownProperties)),
                h(g),
                d.allErrors || o.else().var(f, !0),
                o.endIf()),
              i.it.definedProperties.add(g),
              i.ok(f));
          function y(g) {
            return (
              d.opts.useDefaults && !d.compositeRule && c[g].default !== void 0
            );
          }
          function h(g) {
            i.subschema(
              { keyword: "properties", schemaProp: g, dataProp: g },
              f,
            );
          }
        },
      };
    t.default = a;
  }),
  lU = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = fn(),
      r = Ze(),
      n = st(),
      s = st(),
      a = {
        keyword: "patternProperties",
        type: "object",
        schemaType: "object",
        code(i) {
          let { gen: o, schema: c, data: l, parentSchema: u, it: d } = i,
            { opts: m } = d,
            p = (0, e.allSchemaProperties)(c),
            f = p.filter((x) => (0, n.alwaysValidSchema)(d, c[x]));
          if (
            p.length === 0 ||
            (f.length === p.length && (!d.opts.unevaluated || d.props === !0))
          )
            return;
          let y = m.strictSchema && !m.allowMatchingProperties && u.properties,
            h = o.name("valid");
          d.props !== !0 &&
            !(d.props instanceof r.Name) &&
            (d.props = (0, s.evaluatedPropsToName)(o, d.props));
          let { props: g } = d;
          _();
          function _() {
            for (let x of p)
              (y && v(x), d.allErrors ? b(x) : (o.var(h, !0), b(x), o.if(h)));
          }
          function v(x) {
            for (let w in y)
              new RegExp(x).test(w) &&
                (0, n.checkStrictMode)(
                  d,
                  `property ${w} matches pattern ${x} (use allowMatchingProperties)`,
                );
          }
          function b(x) {
            o.forIn("key", l, (w) => {
              o.if((0, r._)`${(0, e.usePattern)(i, x)}.test(${w})`, () => {
                let S = f.includes(x);
                (S ||
                  i.subschema(
                    {
                      keyword: "patternProperties",
                      schemaProp: x,
                      dataProp: w,
                      dataPropType: s.Type.Str,
                    },
                    h,
                  ),
                  d.opts.unevaluated && g !== !0
                    ? o.assign((0, r._)`${g}[${w}]`, !0)
                    : !S &&
                      !d.allErrors &&
                      o.if((0, r.not)(h), () => o.break()));
              });
            });
          }
        },
      };
    t.default = a;
  }),
  uU = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = st(),
      r = {
        keyword: "not",
        schemaType: ["object", "boolean"],
        trackErrors: !0,
        code(n) {
          let { gen: s, schema: a, it: i } = n;
          if ((0, e.alwaysValidSchema)(i, a)) {
            n.fail();
            return;
          }
          let o = s.name("valid");
          (n.subschema(
            {
              keyword: "not",
              compositeRule: !0,
              createErrors: !1,
              allErrors: !1,
            },
            o,
          ),
            n.failResult(
              o,
              () => n.reset(),
              () => n.error(),
            ));
        },
        error: { message: "must NOT be valid" },
      };
    t.default = r;
  }),
  dU = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = fn(),
      r = {
        keyword: "anyOf",
        schemaType: "array",
        trackErrors: !0,
        code: e.validateUnion,
        error: { message: "must match a schema in anyOf" },
      };
    t.default = r;
  }),
  pU = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = Ze(),
      r = st(),
      n = {
        message: "must match exactly one schema in oneOf",
        params: ({ params: a }) => (0, e._)`{passingSchemas: ${a.passing}}`,
      },
      s = {
        keyword: "oneOf",
        schemaType: "array",
        trackErrors: !0,
        error: n,
        code(a) {
          let { gen: i, schema: o, parentSchema: c, it: l } = a;
          if (!Array.isArray(o)) throw new Error("ajv implementation error");
          if (l.opts.discriminator && c.discriminator) return;
          let u = o,
            d = i.let("valid", !1),
            m = i.let("passing", null),
            p = i.name("_valid");
          (a.setParams({ passing: m }),
            i.block(f),
            a.result(
              d,
              () => a.reset(),
              () => a.error(!0),
            ));
          function f() {
            u.forEach((y, h) => {
              let g;
              ((0, r.alwaysValidSchema)(l, y)
                ? i.var(p, !0)
                : (g = a.subschema(
                    { keyword: "oneOf", schemaProp: h, compositeRule: !0 },
                    p,
                  )),
                h > 0 &&
                  i
                    .if((0, e._)`${p} && ${d}`)
                    .assign(d, !1)
                    .assign(m, (0, e._)`[${m}, ${h}]`)
                    .else(),
                i.if(p, () => {
                  (i.assign(d, !0),
                    i.assign(m, h),
                    g && a.mergeEvaluated(g, e.Name));
                }));
            });
          }
        },
      };
    t.default = s;
  }),
  fU = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = st(),
      r = {
        keyword: "allOf",
        schemaType: "array",
        code(n) {
          let { gen: s, schema: a, it: i } = n;
          if (!Array.isArray(a)) throw new Error("ajv implementation error");
          let o = s.name("valid");
          a.forEach((c, l) => {
            if ((0, e.alwaysValidSchema)(i, c)) return;
            let u = n.subschema({ keyword: "allOf", schemaProp: l }, o);
            (n.ok(o), n.mergeEvaluated(u));
          });
        },
      };
    t.default = r;
  }),
  mU = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = Ze(),
      r = st(),
      n = {
        message: ({ params: i }) =>
          (0, e.str)`must match "${i.ifClause}" schema`,
        params: ({ params: i }) => (0, e._)`{failingKeyword: ${i.ifClause}}`,
      },
      s = {
        keyword: "if",
        schemaType: ["object", "boolean"],
        trackErrors: !0,
        error: n,
        code(i) {
          let { gen: o, parentSchema: c, it: l } = i;
          c.then === void 0 &&
            c.else === void 0 &&
            (0, r.checkStrictMode)(
              l,
              '"if" without "then" and "else" is ignored',
            );
          let u = a(l, "then"),
            d = a(l, "else");
          if (!u && !d) return;
          let m = o.let("valid", !0),
            p = o.name("_valid");
          if ((f(), i.reset(), u && d)) {
            let h = o.let("ifClause");
            (i.setParams({ ifClause: h }), o.if(p, y("then", h), y("else", h)));
          } else u ? o.if(p, y("then")) : o.if((0, e.not)(p), y("else"));
          i.pass(m, () => i.error(!0));
          function f() {
            let h = i.subschema(
              {
                keyword: "if",
                compositeRule: !0,
                createErrors: !1,
                allErrors: !1,
              },
              p,
            );
            i.mergeEvaluated(h);
          }
          function y(h, g) {
            return () => {
              let _ = i.subschema({ keyword: h }, p);
              (o.assign(m, p),
                i.mergeValidEvaluated(_, m),
                g ? o.assign(g, (0, e._)`${h}`) : i.setParams({ ifClause: h }));
            };
          }
        },
      };
    function a(i, o) {
      let c = i.schema[o];
      return c !== void 0 && !(0, r.alwaysValidSchema)(i, c);
    }
    t.default = s;
  }),
  hU = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = st(),
      r = {
        keyword: ["then", "else"],
        schemaType: ["object", "boolean"],
        code({ keyword: n, parentSchema: s, it: a }) {
          s.if === void 0 &&
            (0, e.checkStrictMode)(a, `"${n}" without "if" is ignored`);
        },
      };
    t.default = r;
  }),
  gU = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = jS(),
      r = nU(),
      n = FS(),
      s = sU(),
      a = aU(),
      i = iU(),
      o = oU(),
      c = US(),
      l = cU(),
      u = lU(),
      d = uU(),
      m = dU(),
      p = pU(),
      f = fU(),
      y = mU(),
      h = hU();
    function g(_ = !1) {
      let v = [
        d.default,
        m.default,
        p.default,
        f.default,
        y.default,
        h.default,
        o.default,
        c.default,
        i.default,
        l.default,
        u.default,
      ];
      return (
        _ ? v.push(r.default, s.default) : v.push(e.default, n.default),
        v.push(a.default),
        v
      );
    }
    t.default = g;
  }),
  vU = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = Ze(),
      r = {
        message: ({ schemaCode: s }) => (0, e.str)`must match format "${s}"`,
        params: ({ schemaCode: s }) => (0, e._)`{format: ${s}}`,
      },
      n = {
        keyword: "format",
        type: ["number", "string"],
        schemaType: "string",
        $data: !0,
        error: r,
        code(s, a) {
          let {
              gen: i,
              data: o,
              $data: c,
              schema: l,
              schemaCode: u,
              it: d,
            } = s,
            { opts: m, errSchemaPath: p, schemaEnv: f, self: y } = d;
          if (!m.validateFormats) return;
          c ? h() : g();
          function h() {
            let _ = i.scopeValue("formats", {
                ref: y.formats,
                code: m.code.formats,
              }),
              v = i.const("fDef", (0, e._)`${_}[${u}]`),
              b = i.let("fType"),
              x = i.let("format");
            (i.if(
              (0, e._)`typeof ${v} == "object" && !(${v} instanceof RegExp)`,
              () =>
                i
                  .assign(b, (0, e._)`${v}.type || "string"`)
                  .assign(x, (0, e._)`${v}.validate`),
              () => i.assign(b, (0, e._)`"string"`).assign(x, v),
            ),
              s.fail$data((0, e.or)(w(), S())));
            function w() {
              return m.strictSchema === !1 ? e.nil : (0, e._)`${u} && !${x}`;
            }
            function S() {
              let C = f.$async
                  ? (0, e._)`(${v}.async ? await ${x}(${o}) : ${x}(${o}))`
                  : (0, e._)`${x}(${o})`,
                P = (0,
                e._)`(typeof ${x} == "function" ? ${C} : ${x}.test(${o}))`;
              return (0, e._)`${x} && ${x} !== true && ${b} === ${a} && !${P}`;
            }
          }
          function g() {
            let _ = y.formats[l];
            if (!_) {
              w();
              return;
            }
            if (_ === !0) return;
            let [v, b, x] = S(_);
            v === a && s.pass(C());
            function w() {
              if (m.strictSchema === !1) {
                y.logger.warn(P());
                return;
              }
              throw new Error(P());
              function P() {
                return `unknown format "${l}" ignored in schema at path "${p}"`;
              }
            }
            function S(P) {
              let A =
                  P instanceof RegExp
                    ? (0, e.regexpCode)(P)
                    : m.code.formats
                      ? (0, e._)`${m.code.formats}${(0, e.getProperty)(l)}`
                      : void 0,
                R = i.scopeValue("formats", { key: l, ref: P, code: A });
              return typeof P == "object" && !(P instanceof RegExp)
                ? [P.type || "string", P.validate, (0, e._)`${R}.validate`]
                : ["string", P, R];
            }
            function C() {
              if (typeof _ == "object" && !(_ instanceof RegExp) && _.async) {
                if (!f.$async) throw new Error("async format in sync schema");
                return (0, e._)`await ${x}(${o})`;
              }
              return typeof b == "function"
                ? (0, e._)`${x}(${o})`
                : (0, e._)`${x}.test(${o})`;
            }
          }
        },
      };
    t.default = n;
  }),
  yU = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = vU(),
      r = [e.default];
    t.default = r;
  }),
  bU = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.contentVocabulary = t.metadataVocabulary = void 0),
      (t.metadataVocabulary = [
        "title",
        "description",
        "default",
        "deprecated",
        "readOnly",
        "writeOnly",
        "examples",
      ]),
      (t.contentVocabulary = [
        "contentMediaType",
        "contentEncoding",
        "contentSchema",
      ]));
  }),
  _U = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = HF(),
      r = rU(),
      n = gU(),
      s = yU(),
      a = bU(),
      i = [
        e.default,
        r.default,
        (0, n.default)(),
        s.default,
        a.metadataVocabulary,
        a.contentVocabulary,
      ];
    t.default = i;
  }),
  xU = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.DiscrError = void 0));
    var e;
    (function (r) {
      ((r.Tag = "tag"), (r.Mapping = "mapping"));
    })(e || (t.DiscrError = e = {}));
  }),
  wU = ge((t) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = Ze(),
      r = xU(),
      n = zm(),
      s = ou(),
      a = st(),
      i = {
        message: ({ params: { discrError: c, tagName: l } }) =>
          c === r.DiscrError.Tag
            ? `tag "${l}" must be string`
            : `value of tag "${l}" must be in oneOf`,
        params: ({ params: { discrError: c, tag: l, tagName: u } }) =>
          (0, e._)`{error: ${c}, tag: ${u}, tagValue: ${l}}`,
      },
      o = {
        keyword: "discriminator",
        type: "object",
        schemaType: "object",
        error: i,
        code(c) {
          let { gen: l, data: u, schema: d, parentSchema: m, it: p } = c,
            { oneOf: f } = m;
          if (!p.opts.discriminator)
            throw new Error("discriminator: requires discriminator option");
          let y = d.propertyName;
          if (typeof y != "string")
            throw new Error("discriminator: requires propertyName");
          if (d.mapping)
            throw new Error("discriminator: mapping is not supported");
          if (!f) throw new Error("discriminator: requires oneOf keyword");
          let h = l.let("valid", !1),
            g = l.const("tag", (0, e._)`${u}${(0, e.getProperty)(y)}`);
          (l.if(
            (0, e._)`typeof ${g} == "string"`,
            () => _(),
            () =>
              c.error(!1, { discrError: r.DiscrError.Tag, tag: g, tagName: y }),
          ),
            c.ok(h));
          function _() {
            let x = b();
            l.if(!1);
            for (let w in x)
              (l.elseIf((0, e._)`${g} === ${w}`), l.assign(h, v(x[w])));
            (l.else(),
              c.error(!1, {
                discrError: r.DiscrError.Mapping,
                tag: g,
                tagName: y,
              }),
              l.endIf());
          }
          function v(x) {
            let w = l.name("valid"),
              S = c.subschema({ keyword: "oneOf", schemaProp: x }, w);
            return (c.mergeEvaluated(S, e.Name), w);
          }
          function b() {
            var x;
            let w = {},
              S = P(m),
              C = !0;
            for (let D = 0; D < f.length; D++) {
              let F = f[D];
              if (F?.$ref && !(0, a.schemaHasRulesButRef)(F, p.self.RULES)) {
                let K = F.$ref;
                if (
                  ((F = n.resolveRef.call(
                    p.self,
                    p.schemaEnv.root,
                    p.baseId,
                    K,
                  )),
                  F instanceof n.SchemaEnv && (F = F.schema),
                  F === void 0)
                )
                  throw new s.default(p.opts.uriResolver, p.baseId, K);
              }
              let I =
                (x = F?.properties) === null || x === void 0 ? void 0 : x[y];
              if (typeof I != "object")
                throw new Error(
                  `discriminator: oneOf subschemas (or referenced schemas) must have "properties/${y}"`,
                );
              ((C = C && (S || P(F))), A(I, D));
            }
            if (!C) throw new Error(`discriminator: "${y}" must be required`);
            return w;
            function P({ required: D }) {
              return Array.isArray(D) && D.includes(y);
            }
            function A(D, F) {
              if (D.const) R(D.const, F);
              else if (D.enum) for (let I of D.enum) R(I, F);
              else
                throw new Error(
                  `discriminator: "properties/${y}" must have "const" or "enum"`,
                );
            }
            function R(D, F) {
              if (typeof D != "string" || D in w)
                throw new Error(
                  `discriminator: "${y}" values must be unique strings`,
                );
              w[D] = F;
            }
          }
        },
      };
    t.default = o;
  }),
  SU = ge((t, e) => {
    e.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } },
        nonNegativeInteger: { type: "integer", minimum: 0 },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }],
        },
        simpleTypes: {
          enum: [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string",
          ],
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: !0,
          default: [],
        },
      },
      type: ["object", "boolean"],
      properties: {
        $id: { type: "string", format: "uri-reference" },
        $schema: { type: "string", format: "uri" },
        $ref: { type: "string", format: "uri-reference" },
        $comment: { type: "string" },
        title: { type: "string" },
        description: { type: "string" },
        default: !0,
        readOnly: { type: "boolean", default: !1 },
        examples: { type: "array", items: !0 },
        multipleOf: { type: "number", exclusiveMinimum: 0 },
        maximum: { type: "number" },
        exclusiveMaximum: { type: "number" },
        minimum: { type: "number" },
        exclusiveMinimum: { type: "number" },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: { type: "string", format: "regex" },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: !0,
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: { type: "boolean", default: !1 },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {},
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {},
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {},
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }],
          },
        },
        propertyNames: { $ref: "#" },
        const: !0,
        enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: !0,
            },
          ],
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" },
      },
      default: !0,
    };
  }),
  qS = ge((t, e) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.MissingRefError =
        t.ValidationError =
        t.CodeGen =
        t.Name =
        t.nil =
        t.stringify =
        t.str =
        t._ =
        t.KeywordCxt =
        t.Ajv =
          void 0));
    var r = qF(),
      n = _U(),
      s = wU(),
      a = SU(),
      i = ["/properties"],
      o = "http://json-schema.org/draft-07/schema";
    class c extends r.default {
      _addVocabularies() {
        (super._addVocabularies(),
          n.default.forEach((f) => this.addVocabulary(f)),
          this.opts.discriminator && this.addKeyword(s.default));
      }
      _addDefaultMetaSchema() {
        if ((super._addDefaultMetaSchema(), !this.opts.meta)) return;
        let f = this.opts.$data ? this.$dataMetaSchema(a, i) : a;
        (this.addMetaSchema(f, o, !1),
          (this.refs["http://json-schema.org/schema"] = o));
      }
      defaultMeta() {
        return (this.opts.defaultMeta =
          super.defaultMeta() || (this.getSchema(o) ? o : void 0));
      }
    }
    ((t.Ajv = c),
      (e.exports = t = c),
      (e.exports.Ajv = c),
      Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.default = c));
    var l = iu();
    Object.defineProperty(t, "KeywordCxt", {
      enumerable: !0,
      get: function () {
        return l.KeywordCxt;
      },
    });
    var u = Ze();
    (Object.defineProperty(t, "_", {
      enumerable: !0,
      get: function () {
        return u._;
      },
    }),
      Object.defineProperty(t, "str", {
        enumerable: !0,
        get: function () {
          return u.str;
        },
      }),
      Object.defineProperty(t, "stringify", {
        enumerable: !0,
        get: function () {
          return u.stringify;
        },
      }),
      Object.defineProperty(t, "nil", {
        enumerable: !0,
        get: function () {
          return u.nil;
        },
      }),
      Object.defineProperty(t, "Name", {
        enumerable: !0,
        get: function () {
          return u.Name;
        },
      }),
      Object.defineProperty(t, "CodeGen", {
        enumerable: !0,
        get: function () {
          return u.CodeGen;
        },
      }));
    var d = qm();
    Object.defineProperty(t, "ValidationError", {
      enumerable: !0,
      get: function () {
        return d.default;
      },
    });
    var m = ou();
    Object.defineProperty(t, "MissingRefError", {
      enumerable: !0,
      get: function () {
        return m.default;
      },
    });
  }),
  EU = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.formatNames = t.fastFormats = t.fullFormats = void 0));
    function e(R, D) {
      return { validate: R, compare: D };
    }
    ((t.fullFormats = {
      date: e(a, i),
      time: e(c(!0), l),
      "date-time": e(m(!0), p),
      "iso-time": e(c(), u),
      "iso-date-time": e(m(), f),
      duration:
        /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri: g,
      "uri-reference":
        /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      "uri-template":
        /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email:
        /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname:
        /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex: A,
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment":
        /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      "relative-json-pointer":
        /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      byte: v,
      int32: { type: "number", validate: w },
      int64: { type: "number", validate: S },
      float: { type: "number", validate: C },
      double: { type: "number", validate: C },
      password: !0,
      binary: !0,
    }),
      (t.fastFormats = {
        ...t.fullFormats,
        date: e(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, i),
        time: e(
          /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
          l,
        ),
        "date-time": e(
          /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
          p,
        ),
        "iso-time": e(
          /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
          u,
        ),
        "iso-date-time": e(
          /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
          f,
        ),
        uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
        "uri-reference":
          /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        email:
          /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
      }),
      (t.formatNames = Object.keys(t.fullFormats)));
    function r(R) {
      return R % 4 === 0 && (R % 100 !== 0 || R % 400 === 0);
    }
    var n = /^(\d\d\d\d)-(\d\d)-(\d\d)$/,
      s = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function a(R) {
      let D = n.exec(R);
      if (!D) return !1;
      let F = +D[1],
        I = +D[2],
        K = +D[3];
      return I >= 1 && I <= 12 && K >= 1 && K <= (I === 2 && r(F) ? 29 : s[I]);
    }
    function i(R, D) {
      if (R && D) return R > D ? 1 : R < D ? -1 : 0;
    }
    var o = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function c(R) {
      return function (F) {
        let I = o.exec(F);
        if (!I) return !1;
        let K = +I[1],
          ee = +I[2],
          Y = +I[3],
          Q = I[4],
          ae = I[5] === "-" ? -1 : 1,
          B = +(I[6] || 0),
          $ = +(I[7] || 0);
        if (B > 23 || $ > 59 || (R && !Q)) return !1;
        if (K <= 23 && ee <= 59 && Y < 60) return !0;
        let G = ee - $ * ae,
          U = K - B * ae - (G < 0 ? 1 : 0);
        return (U === 23 || U === -1) && (G === 59 || G === -1) && Y < 61;
      };
    }
    function l(R, D) {
      if (!(R && D)) return;
      let F = new Date("2020-01-01T" + R).valueOf(),
        I = new Date("2020-01-01T" + D).valueOf();
      if (F && I) return F - I;
    }
    function u(R, D) {
      if (!(R && D)) return;
      let F = o.exec(R),
        I = o.exec(D);
      if (F && I)
        return (
          (R = F[1] + F[2] + F[3]),
          (D = I[1] + I[2] + I[3]),
          R > D ? 1 : R < D ? -1 : 0
        );
    }
    var d = /t|\s/i;
    function m(R) {
      let D = c(R);
      return function (I) {
        let K = I.split(d);
        return K.length === 2 && a(K[0]) && D(K[1]);
      };
    }
    function p(R, D) {
      if (!(R && D)) return;
      let F = new Date(R).valueOf(),
        I = new Date(D).valueOf();
      if (F && I) return F - I;
    }
    function f(R, D) {
      if (!(R && D)) return;
      let [F, I] = R.split(d),
        [K, ee] = D.split(d),
        Y = i(F, K);
      if (Y !== void 0) return Y || l(I, ee);
    }
    var y = /\/|:/,
      h =
        /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function g(R) {
      return y.test(R) && h.test(R);
    }
    var _ =
      /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function v(R) {
      return ((_.lastIndex = 0), _.test(R));
    }
    var b = -(2 ** 31),
      x = 2 ** 31 - 1;
    function w(R) {
      return Number.isInteger(R) && R <= x && R >= b;
    }
    function S(R) {
      return Number.isInteger(R);
    }
    function C() {
      return !0;
    }
    var P = /[^\\]\\Z/;
    function A(R) {
      if (P.test(R)) return !1;
      try {
        return (new RegExp(R), !0);
      } catch {
        return !1;
      }
    }
  }),
  TU = ge((t) => {
    (Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.formatLimitDefinition = void 0));
    var e = qS(),
      r = Ze(),
      n = r.operators,
      s = {
        formatMaximum: { okStr: "<=", ok: n.LTE, fail: n.GT },
        formatMinimum: { okStr: ">=", ok: n.GTE, fail: n.LT },
        formatExclusiveMaximum: { okStr: "<", ok: n.LT, fail: n.GTE },
        formatExclusiveMinimum: { okStr: ">", ok: n.GT, fail: n.LTE },
      },
      a = {
        message: ({ keyword: o, schemaCode: c }) =>
          (0, r.str)`should be ${s[o].okStr} ${c}`,
        params: ({ keyword: o, schemaCode: c }) =>
          (0, r._)`{comparison: ${s[o].okStr}, limit: ${c}}`,
      };
    t.formatLimitDefinition = {
      keyword: Object.keys(s),
      type: "string",
      schemaType: "string",
      $data: !0,
      error: a,
      code(o) {
        let { gen: c, data: l, schemaCode: u, keyword: d, it: m } = o,
          { opts: p, self: f } = m;
        if (!p.validateFormats) return;
        let y = new e.KeywordCxt(m, f.RULES.all.format.definition, "format");
        y.$data ? h() : g();
        function h() {
          let v = c.scopeValue("formats", {
              ref: f.formats,
              code: p.code.formats,
            }),
            b = c.const("fmt", (0, r._)`${v}[${y.schemaCode}]`);
          o.fail$data(
            (0, r.or)(
              (0, r._)`typeof ${b} != "object"`,
              (0, r._)`${b} instanceof RegExp`,
              (0, r._)`typeof ${b}.compare != "function"`,
              _(b),
            ),
          );
        }
        function g() {
          let v = y.schema,
            b = f.formats[v];
          if (!b || b === !0) return;
          if (
            typeof b != "object" ||
            b instanceof RegExp ||
            typeof b.compare != "function"
          )
            throw new Error(
              `"${d}": format "${v}" does not define "compare" function`,
            );
          let x = c.scopeValue("formats", {
            key: v,
            ref: b,
            code: p.code.formats
              ? (0, r._)`${p.code.formats}${(0, r.getProperty)(v)}`
              : void 0,
          });
          o.fail$data(_(x));
        }
        function _(v) {
          return (0, r._)`${v}.compare(${l}, ${u}) ${s[d].fail} 0`;
        }
      },
      dependencies: ["format"],
    };
    var i = (o) => (o.addKeyword(t.formatLimitDefinition), o);
    t.default = i;
  }),
  CU = ge((t, e) => {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var r = EU(),
      n = TU(),
      s = Ze(),
      a = new s.Name("fullFormats"),
      i = new s.Name("fastFormats"),
      o = (l, u = { keywords: !0 }) => {
        if (Array.isArray(u)) return (c(l, u, r.fullFormats, a), l);
        let [d, m] =
            u.mode === "fast" ? [r.fastFormats, i] : [r.fullFormats, a],
          p = u.formats || r.formatNames;
        return (c(l, p, d, m), u.keywords && (0, n.default)(l), l);
      };
    o.get = (l, u = "full") => {
      let m = (u === "fast" ? r.fastFormats : r.fullFormats)[l];
      if (!m) throw new Error(`Unknown format "${l}"`);
      return m;
    };
    function c(l, u, d, m) {
      var p, f;
      ((p = (f = l.opts.code).formats) !== null && p !== void 0) ||
        (f.formats = (0, s._)`require("ajv-formats/dist/formats").${m}`);
      for (let y of u) l.addFormat(y, d[y]);
    }
    ((e.exports = t = o),
      Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.default = o));
  }),
  PU = 50;
function HS(t = PU) {
  let e = new AbortController();
  return ((0, BS.setMaxListeners)(t, e.signal), e);
}
var kU =
    typeof global == "object" && global && global.Object === Object && global,
  RU = kU,
  OU = typeof self == "object" && self && self.Object === Object && self,
  IU = RU || OU || Function("return this")(),
  Hm = IU,
  $U = Hm.Symbol,
  Zl = $U,
  WS = Object.prototype,
  AU = WS.hasOwnProperty,
  NU = WS.toString,
  Mo = Zl ? Zl.toStringTag : void 0;
function DU(t) {
  var e = AU.call(t, Mo),
    r = t[Mo];
  try {
    t[Mo] = void 0;
    var n = !0;
  } catch {}
  var s = NU.call(t);
  return (n && (e ? (t[Mo] = r) : delete t[Mo]), s);
}
var LU = DU,
  MU = Object.prototype,
  jU = MU.toString;
function FU(t) {
  return jU.call(t);
}
var UU = FU,
  qU = "[object Null]",
  zU = "[object Undefined]",
  Zw = Zl ? Zl.toStringTag : void 0;
function BU(t) {
  return t == null
    ? t === void 0
      ? zU
      : qU
    : Zw && Zw in Object(t)
      ? LU(t)
      : UU(t);
}
var HU = BU;
function VU(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var KS = VU,
  ZU = "[object AsyncFunction]",
  GU = "[object Function]",
  WU = "[object GeneratorFunction]",
  KU = "[object Proxy]";
function JU(t) {
  if (!KS(t)) return !1;
  var e = HU(t);
  return e == GU || e == WU || e == ZU || e == KU;
}
var XU = JU,
  YU = Hm["__core-js_shared__"],
  Xf = YU,
  Gw = (function () {
    var t = /[^.]+$/.exec((Xf && Xf.keys && Xf.keys.IE_PROTO) || "");
    return t ? "Symbol(src)_1." + t : "";
  })();
function QU(t) {
  return !!Gw && Gw in t;
}
var eq = QU,
  tq = Function.prototype,
  rq = tq.toString;
function nq(t) {
  if (t != null) {
    try {
      return rq.call(t);
    } catch {}
    try {
      return t + "";
    } catch {}
  }
  return "";
}
var sq = nq,
  aq = /[\\^$.*+?()[\]{}|]/g,
  iq = /^\[object .+?Constructor\]$/,
  oq = Function.prototype,
  cq = Object.prototype,
  lq = oq.toString,
  uq = cq.hasOwnProperty,
  dq = RegExp(
    "^" +
      lq
        .call(uq)
        .replace(aq, "\\$&")
        .replace(
          /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
          "$1.*?",
        ) +
      "$",
  );
function pq(t) {
  if (!KS(t) || eq(t)) return !1;
  var e = XU(t) ? dq : iq;
  return e.test(sq(t));
}
var fq = pq;
function mq(t, e) {
  return t?.[e];
}
var hq = mq;
function gq(t, e) {
  var r = hq(t, e);
  return fq(r) ? r : void 0;
}
var JS = gq,
  vq = JS(Object, "create"),
  Vo = vq;
function yq() {
  ((this.__data__ = Vo ? Vo(null) : {}), (this.size = 0));
}
var bq = yq;
function _q(t) {
  var e = this.has(t) && delete this.__data__[t];
  return ((this.size -= e ? 1 : 0), e);
}
var xq = _q,
  wq = "__lodash_hash_undefined__",
  Sq = Object.prototype,
  Eq = Sq.hasOwnProperty;
function Tq(t) {
  var e = this.__data__;
  if (Vo) {
    var r = e[t];
    return r === wq ? void 0 : r;
  }
  return Eq.call(e, t) ? e[t] : void 0;
}
var Cq = Tq,
  Pq = Object.prototype,
  kq = Pq.hasOwnProperty;
function Rq(t) {
  var e = this.__data__;
  return Vo ? e[t] !== void 0 : kq.call(e, t);
}
var Oq = Rq,
  Iq = "__lodash_hash_undefined__";
function $q(t, e) {
  var r = this.__data__;
  return (
    (this.size += this.has(t) ? 0 : 1),
    (r[t] = Vo && e === void 0 ? Iq : e),
    this
  );
}
var Aq = $q;
function bi(t) {
  var e = -1,
    r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
bi.prototype.clear = bq;
bi.prototype.delete = xq;
bi.prototype.get = Cq;
bi.prototype.has = Oq;
bi.prototype.set = Aq;
var Ww = bi;
function Nq() {
  ((this.__data__ = []), (this.size = 0));
}
var Dq = Nq;
function Lq(t, e) {
  return t === e || (t !== t && e !== e);
}
var Mq = Lq;
function jq(t, e) {
  for (var r = t.length; r--; ) if (Mq(t[r][0], e)) return r;
  return -1;
}
var cu = jq,
  Fq = Array.prototype,
  Uq = Fq.splice;
function qq(t) {
  var e = this.__data__,
    r = cu(e, t);
  if (r < 0) return !1;
  var n = e.length - 1;
  return (r == n ? e.pop() : Uq.call(e, r, 1), --this.size, !0);
}
var zq = qq;
function Bq(t) {
  var e = this.__data__,
    r = cu(e, t);
  return r < 0 ? void 0 : e[r][1];
}
var Hq = Bq;
function Vq(t) {
  return cu(this.__data__, t) > -1;
}
var Zq = Vq;
function Gq(t, e) {
  var r = this.__data__,
    n = cu(r, t);
  return (n < 0 ? (++this.size, r.push([t, e])) : (r[n][1] = e), this);
}
var Wq = Gq;
function _i(t) {
  var e = -1,
    r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
_i.prototype.clear = Dq;
_i.prototype.delete = zq;
_i.prototype.get = Hq;
_i.prototype.has = Zq;
_i.prototype.set = Wq;
var Kq = _i,
  Jq = JS(Hm, "Map"),
  Xq = Jq;
function Yq() {
  ((this.size = 0),
    (this.__data__ = {
      hash: new Ww(),
      map: new (Xq || Kq)(),
      string: new Ww(),
    }));
}
var Qq = Yq;
function e2(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean"
    ? t !== "__proto__"
    : t === null;
}
var t2 = e2;
function r2(t, e) {
  var r = t.__data__;
  return t2(e) ? r[typeof e == "string" ? "string" : "hash"] : r.map;
}
var lu = r2;
function n2(t) {
  var e = lu(this, t).delete(t);
  return ((this.size -= e ? 1 : 0), e);
}
var s2 = n2;
function a2(t) {
  return lu(this, t).get(t);
}
var i2 = a2;
function o2(t) {
  return lu(this, t).has(t);
}
var c2 = o2;
function l2(t, e) {
  var r = lu(this, t),
    n = r.size;
  return (r.set(t, e), (this.size += r.size == n ? 0 : 1), this);
}
var u2 = l2;
function xi(t) {
  var e = -1,
    r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
xi.prototype.clear = Qq;
xi.prototype.delete = s2;
xi.prototype.get = i2;
xi.prototype.has = c2;
xi.prototype.set = u2;
var XS = xi,
  d2 = "Expected a function";
function Vm(t, e) {
  if (typeof t != "function" || (e != null && typeof e != "function"))
    throw new TypeError(d2);
  var r = function () {
    var n = arguments,
      s = e ? e.apply(this, n) : n[0],
      a = r.cache;
    if (a.has(s)) return a.get(s);
    var i = t.apply(this, n);
    return ((r.cache = a.set(s, i) || a), i);
  };
  return ((r.cache = new (Vm.Cache || XS)()), r);
}
Vm.Cache = XS;
var ac = Vm,
  Kw = 2e3;
function p2(t) {
  for (let e = 0; e < t.length; e += Kw)
    process.stderr.write(t.substring(e, e + Kw));
}
var f2 = ac((t) => {
  if (!t || t.trim() === "") return null;
  let e = t
    .split(",")
    .map((a) => a.trim())
    .filter(Boolean);
  if (e.length === 0) return null;
  let r = e.some((a) => a.startsWith("!")),
    n = e.some((a) => !a.startsWith("!"));
  if (r && n) return null;
  let s = e.map((a) => a.replace(/^!/, "").toLowerCase());
  return { include: r ? [] : s, exclude: r ? s : [], isExclusive: r };
});
function m2(t) {
  let e = [],
    r = t.match(/^MCP server ["']([^"']+)["']/);
  if (r && r[1]) (e.push("mcp"), e.push(r[1].toLowerCase()));
  else {
    let a = t.match(/^([^:[]+):/);
    a && a[1] && e.push(a[1].trim().toLowerCase());
  }
  let n = t.match(/^\[([^\]]+)]/);
  (n && n[1] && e.push(n[1].trim().toLowerCase()),
    t.toLowerCase().includes("statsig event:") && e.push("statsig"));
  let s = t.match(/:\s*([^:]+?)(?:\s+(?:type|mode|status|event))?:/);
  if (s && s[1]) {
    let a = s[1].trim().toLowerCase();
    a.length < 30 && !a.includes(" ") && e.push(a);
  }
  return Array.from(new Set(e));
}
function h2(t, e) {
  return e
    ? t.length === 0
      ? !1
      : e.isExclusive
        ? !t.some((r) => e.exclude.includes(r))
        : t.some((r) => e.include.includes(r))
    : !0;
}
function g2(t, e) {
  if (!e) return !0;
  let r = m2(t);
  return h2(r, e);
}
function e0() {
  return (
    process.env.CLAUDE_CONFIG_DIR ?? (0, YS.join)((0, QS.homedir)(), ".claude")
  );
}
function Jw(t) {
  if (!t) return !1;
  if (typeof t == "boolean") return t;
  let e = t.toLowerCase().trim();
  return ["1", "true", "yes", "on"].includes(e);
}
var v2 = {
    name: "BASH_MAX_OUTPUT_LENGTH",
    default: 3e4,
    validate: (t) => {
      if (!t) return { effective: 3e4, status: "valid" };
      let n = parseInt(t, 10);
      return isNaN(n) || n <= 0
        ? {
            effective: 3e4,
            status: "invalid",
            message: `Invalid value "${t}" (using default: 30000)`,
          }
        : n > 15e4
          ? {
              effective: 15e4,
              status: "capped",
              message: `Capped from ${n} to 150000`,
            }
          : { effective: n, status: "valid" };
    },
  },
  y2 = {
    name: "CLAUDE_CODE_MAX_OUTPUT_TOKENS",
    default: 32e3,
    validate: (t) => {
      if (!t) return { effective: 32e3, status: "valid" };
      let n = parseInt(t, 10);
      return isNaN(n) || n <= 0
        ? {
            effective: 32e3,
            status: "invalid",
            message: `Invalid value "${t}" (using default: 32000)`,
          }
        : n > 64e3
          ? {
              effective: 64e3,
              status: "capped",
              message: `Capped from ${n} to 64000`,
            }
          : { effective: n, status: "valid" };
    },
  };
function b2() {
  let t = "";
  return (
    typeof process < "u" &&
      typeof process.cwd == "function" &&
      (t = (0, r0.realpathSync)((0, t0.cwd)())),
    {
      originalCwd: t,
      totalCostUSD: 0,
      totalAPIDuration: 0,
      totalAPIDurationWithoutRetries: 0,
      totalToolDuration: 0,
      startTime: Date.now(),
      lastInteractionTime: Date.now(),
      totalLinesAdded: 0,
      totalLinesRemoved: 0,
      hasUnknownModelCost: !1,
      cwd: t,
      modelUsage: {},
      mainLoopModelOverride: void 0,
      initialMainLoopModel: null,
      modelStrings: null,
      isInteractive: !1,
      clientType: "cli",
      sessionIngressToken: void 0,
      oauthTokenFromFd: void 0,
      apiKeyFromFd: void 0,
      flagSettingsPath: void 0,
      allowedSettingSources: [
        "userSettings",
        "projectSettings",
        "localSettings",
        "flagSettings",
        "policySettings",
      ],
      meter: null,
      sessionCounter: null,
      locCounter: null,
      prCounter: null,
      commitCounter: null,
      costCounter: null,
      tokenCounter: null,
      codeEditToolDecisionCounter: null,
      activeTimeCounter: null,
      sessionId: (0, n0.randomUUID)(),
      loggerProvider: null,
      eventLogger: null,
      meterProvider: null,
      tracerProvider: null,
      agentColorMap: new Map(),
      agentColorIndex: 0,
      envVarValidators: [v2, y2],
      lastAPIRequest: null,
      inMemoryErrorLog: [],
      inlinePlugins: [],
      sessionBypassPermissionsMode: !1,
      sessionPersistenceDisabled: !1,
      hasExitedPlanMode: !1,
      needsPlanModeExitAttachment: !1,
      hasExitedDelegateMode: !1,
      needsDelegateModeExitAttachment: !1,
      lspRecommendationShownThisSession: !1,
      initJsonSchema: null,
      registeredHooks: null,
      planSlugCache: new Map(),
      teleportedSessionInfo: null,
      invokedSkills: new Map(),
    }
  );
}
var _2 = b2();
function x2() {
  return _2.sessionId;
}
function w2({
  writeFn: t,
  flushIntervalMs: e = 1e3,
  maxBufferSize: r = 100,
  immediateMode: n = !1,
}) {
  let s = [],
    a = null;
  function i() {
    a && (clearTimeout(a), (a = null));
  }
  function o() {
    s.length !== 0 && (t(s.join("")), (s = []), i());
  }
  function c() {
    a || (a = setTimeout(o, e));
  }
  return {
    write(l) {
      if (n) {
        t(l);
        return;
      }
      (s.push(l), c(), s.length >= r && o());
    },
    flush: o,
    dispose() {
      o();
    },
  };
}
var Xw = new Set();
function S2(t) {
  return (Xw.add(t), () => Xw.delete(t));
}
var E2 = ac(
    () =>
      Jw(process.env.DEBUG) ||
      Jw(process.env.DEBUG_SDK) ||
      process.argv.includes("--debug") ||
      process.argv.includes("-d") ||
      s0() ||
      process.argv.some((t) => t.startsWith("--debug=")),
  ),
  T2 = ac(() => {
    let t = process.argv.find((r) => r.startsWith("--debug="));
    if (!t) return null;
    let e = t.substring(8);
    return f2(e);
  }),
  s0 = ac(
    () =>
      process.argv.includes("--debug-to-stderr") ||
      process.argv.includes("-d2e"),
  );
function C2(t) {
  if (
    typeof process > "u" ||
    typeof process.versions > "u" ||
    typeof process.versions.node > "u"
  )
    return !1;
  let e = T2();
  return g2(t, e);
}
var P2 = !1,
  Fl = null;
function k2() {
  return (
    Fl ||
      ((Fl = w2({
        writeFn: (t) => {
          let e = a0();
          (Zn().existsSync((0, Qs.dirname)(e)) ||
            Zn().mkdirSync((0, Qs.dirname)(e)),
            Zn().appendFileSync(e, t),
            R2());
        },
        flushIntervalMs: 1e3,
        maxBufferSize: 100,
        immediateMode: E2(),
      })),
      S2(async () => Fl?.dispose())),
    Fl
  );
}
function bs(t, { level: e } = { level: "debug" }) {
  if (!C2(t)) return;
  P2 &&
    t.includes(`
`) &&
    (t = JSON.stringify(t));
  let n = `${new Date().toISOString()} [${e.toUpperCase()}] ${t.trim()}
`;
  if (s0()) {
    p2(n);
    return;
  }
  k2().write(n);
}
function a0() {
  return (
    process.env.CLAUDE_CODE_DEBUG_LOGS_DIR ??
    (0, Qs.join)(e0(), "debug", `${x2()}.txt`)
  );
}
var R2 = ac(() => {
    if (process.argv[2] !== "--ripgrep")
      try {
        let t = a0(),
          e = (0, Qs.dirname)(t),
          r = (0, Qs.join)(e, "latest");
        if ((Zn().existsSync(e) || Zn().mkdirSync(e), Zn().existsSync(r)))
          try {
            Zn().unlinkSync(r);
          } catch {}
        Zn().symlinkSync(t, r);
      } catch {}
  }),
  O2 = 5;
function jt(t, e) {
  let r = performance.now();
  try {
    return e();
  } finally {
    let n = performance.now() - r;
    n > O2 && bs(`[SLOW OPERATION DETECTED] fs.${t} (${n.toFixed(1)}ms)`);
  }
}
var I2 = {
    cwd() {
      return process.cwd();
    },
    existsSync(t) {
      return jt("existsSync", () => Re.existsSync(t));
    },
    async stat(t) {
      return (0, GS.stat)(t);
    },
    statSync(t) {
      return jt("statSync", () => Re.statSync(t));
    },
    lstatSync(t) {
      return jt("lstatSync", () => Re.lstatSync(t));
    },
    readFileSync(t, e) {
      return jt("readFileSync", () =>
        Re.readFileSync(t, { encoding: e.encoding }),
      );
    },
    readFileBytesSync(t) {
      return jt("readFileBytesSync", () => Re.readFileSync(t));
    },
    readSync(t, e) {
      return jt("readSync", () => {
        let r;
        try {
          r = Re.openSync(t, "r");
          let n = Buffer.alloc(e.length),
            s = Re.readSync(r, n, 0, e.length, 0);
          return { buffer: n, bytesRead: s };
        } finally {
          r && Re.closeSync(r);
        }
      });
    },
    writeFileSync(t, e, r) {
      return jt("writeFileSync", () => {
        let n = Re.existsSync(t);
        if (!r.flush) {
          let a = { encoding: r.encoding };
          (n
            ? r.mode !== void 0 && (a.mode = r.mode)
            : (a.mode = r.mode ?? 384),
            Re.writeFileSync(t, e, a));
          return;
        }
        let s;
        try {
          let a = n ? r.mode : (r.mode ?? 384);
          ((s = Re.openSync(t, "w", a)),
            Re.writeFileSync(s, e, { encoding: r.encoding }),
            Re.fsyncSync(s));
        } finally {
          s && Re.closeSync(s);
        }
      });
    },
    appendFileSync(t, e, r) {
      return jt("appendFileSync", () => {
        if (Re.existsSync(t)) Re.appendFileSync(t, e);
        else {
          let n = r?.mode ?? 384,
            s = Re.openSync(t, "a", n);
          try {
            Re.appendFileSync(s, e);
          } finally {
            Re.closeSync(s);
          }
        }
      });
    },
    copyFileSync(t, e) {
      return jt("copyFileSync", () => Re.copyFileSync(t, e));
    },
    unlinkSync(t) {
      return jt("unlinkSync", () => Re.unlinkSync(t));
    },
    renameSync(t, e) {
      return jt("renameSync", () => Re.renameSync(t, e));
    },
    linkSync(t, e) {
      return jt("linkSync", () => Re.linkSync(t, e));
    },
    symlinkSync(t, e) {
      return jt("symlinkSync", () => Re.symlinkSync(t, e));
    },
    readlinkSync(t) {
      return jt("readlinkSync", () => Re.readlinkSync(t));
    },
    realpathSync(t) {
      return jt("realpathSync", () => Re.realpathSync(t));
    },
    mkdirSync(t) {
      return jt("mkdirSync", () => {
        Re.existsSync(t) || Re.mkdirSync(t, { recursive: !0, mode: 448 });
      });
    },
    readdirSync(t) {
      return jt("readdirSync", () => Re.readdirSync(t, { withFileTypes: !0 }));
    },
    readdirStringSync(t) {
      return jt("readdirStringSync", () => Re.readdirSync(t));
    },
    isDirEmptySync(t) {
      return jt("isDirEmptySync", () => this.readdirSync(t).length === 0);
    },
    rmdirSync(t) {
      return jt("rmdirSync", () => Re.rmdirSync(t));
    },
    rmSync(t, e) {
      return jt("rmSync", () => Re.rmSync(t, e));
    },
    createWriteStream(t) {
      return Re.createWriteStream(t);
    },
  },
  $2 = I2;
function Zn() {
  return $2;
}
var Ys = class extends Error {};
function i0() {
  return process.versions.bun !== void 0;
}
var Ul = null,
  Yw = !1;
function A2() {
  if (Yw) return Ul;
  if (((Yw = !0), !process.env.DEBUG_CLAUDE_AGENT_SDK)) return null;
  let t = (0, om.join)(e0(), "debug");
  return (
    (Ul = (0, om.join)(t, `sdk-${(0, o0.randomUUID)()}.txt`)),
    (0, wi.existsSync)(t) || (0, wi.mkdirSync)(t, { recursive: !0 }),
    process.stderr.write(`SDK debug logs: ${Ul}
`),
    Ul
  );
}
function Js(t) {
  let e = A2();
  if (!e) return;
  let n = `${new Date().toISOString()} ${t}
`;
  (0, wi.appendFileSync)(e, n);
}
function N2(t, e) {
  let r = { ...t };
  if (e) {
    let n = { sandbox: e };
    if (r.settings)
      try {
        n = { ...JSON.parse(r.settings), sandbox: e };
      } catch {}
    r.settings = JSON.stringify(n);
  }
  return r;
}
var cm = class {
  options;
  process;
  processStdin;
  processStdout;
  ready = !1;
  abortController;
  exitError;
  exitListeners = [];
  processExitHandler;
  abortHandler;
  constructor(e) {
    ((this.options = e),
      (this.abortController = e.abortController || HS()),
      this.initialize());
  }
  getDefaultExecutable() {
    return i0() ? "bun" : "node";
  }
  spawnLocalProcess(e) {
    let { command: r, args: n, cwd: s, env: a, signal: i } = e,
      o = a.DEBUG_CLAUDE_AGENT_SDK || this.options.stderr ? "pipe" : "ignore",
      c = (0, VS.spawn)(r, n, {
        cwd: s,
        stdio: ["pipe", "pipe", o],
        signal: i,
        env: a,
        windowsHide: !0,
      });
    return (
      (a.DEBUG_CLAUDE_AGENT_SDK || this.options.stderr) &&
        c.stderr.on("data", (u) => {
          let d = u.toString();
          (Js(d), this.options.stderr && this.options.stderr(d));
        }),
      {
        stdin: c.stdin,
        stdout: c.stdout,
        get killed() {
          return c.killed;
        },
        get exitCode() {
          return c.exitCode;
        },
        kill: c.kill.bind(c),
        on: c.on.bind(c),
        once: c.once.bind(c),
        off: c.off.bind(c),
      }
    );
  }
  initialize() {
    try {
      let {
          additionalDirectories: e = [],
          betas: r,
          cwd: n,
          executable: s = this.getDefaultExecutable(),
          executableArgs: a = [],
          extraArgs: i = {},
          pathToClaudeCodeExecutable: o,
          env: c = { ...process.env },
          maxThinkingTokens: l,
          maxTurns: u,
          maxBudgetUsd: d,
          model: m,
          fallbackModel: p,
          jsonSchema: f,
          permissionMode: y,
          allowDangerouslySkipPermissions: h,
          permissionPromptToolName: g,
          continueConversation: _,
          resume: v,
          settingSources: b,
          allowedTools: x = [],
          disallowedTools: w = [],
          tools: S,
          mcpServers: C,
          strictMcpConfig: P,
          canUseTool: A,
          includePartialMessages: R,
          plugins: D,
          sandbox: F,
        } = this.options,
        I = [
          "--output-format",
          "stream-json",
          "--verbose",
          "--input-format",
          "stream-json",
        ];
      if (
        (l !== void 0 && I.push("--max-thinking-tokens", l.toString()),
        u && I.push("--max-turns", u.toString()),
        d !== void 0 && I.push("--max-budget-usd", d.toString()),
        m && I.push("--model", m),
        r && r.length > 0 && I.push("--betas", r.join(",")),
        f && I.push("--json-schema", JSON.stringify(f)),
        c.DEBUG_CLAUDE_AGENT_SDK && I.push("--debug-to-stderr"),
        A)
      ) {
        if (g)
          throw new Error(
            "canUseTool callback cannot be used with permissionPromptToolName. Please use one or the other.",
          );
        I.push("--permission-prompt-tool", "stdio");
      } else g && I.push("--permission-prompt-tool", g);
      if (
        (_ && I.push("--continue"),
        v && I.push("--resume", v),
        x.length > 0 && I.push("--allowedTools", x.join(",")),
        w.length > 0 && I.push("--disallowedTools", w.join(",")),
        S !== void 0 &&
          (Array.isArray(S)
            ? S.length === 0
              ? I.push("--tools", "")
              : I.push("--tools", S.join(","))
            : I.push("--tools", "default")),
        C &&
          Object.keys(C).length > 0 &&
          I.push("--mcp-config", JSON.stringify({ mcpServers: C })),
        b && I.push("--setting-sources", b.join(",")),
        P && I.push("--strict-mcp-config"),
        y && I.push("--permission-mode", y),
        h && I.push("--allow-dangerously-skip-permissions"),
        p)
      ) {
        if (m && p === m)
          throw new Error(
            "Fallback model cannot be the same as the main model. Please specify a different model for fallbackModel option.",
          );
        I.push("--fallback-model", p);
      }
      R && I.push("--include-partial-messages");
      for (let $ of e) I.push("--add-dir", $);
      if (D && D.length > 0)
        for (let $ of D)
          if ($.type === "local") I.push("--plugin-dir", $.path);
          else throw new Error(`Unsupported plugin type: ${$.type}`);
      (this.options.forkSession && I.push("--fork-session"),
        this.options.resumeSessionAt &&
          I.push("--resume-session-at", this.options.resumeSessionAt),
        this.options.persistSession === !1 &&
          I.push("--no-session-persistence"));
      let K = N2(i ?? {}, F);
      for (let [$, G] of Object.entries(K))
        G === null ? I.push(`--${$}`) : I.push(`--${$}`, G);
      (c.CLAUDE_CODE_ENTRYPOINT || (c.CLAUDE_CODE_ENTRYPOINT = "sdk-ts"),
        delete c.NODE_OPTIONS,
        c.DEBUG_CLAUDE_AGENT_SDK ? (c.DEBUG = "1") : delete c.DEBUG);
      let ee = D2(o),
        Y = ee ? o : s,
        Q = ee ? [...a, ...I] : [...a, o, ...I],
        ae = {
          command: Y,
          args: Q,
          cwd: n,
          env: c,
          signal: this.abortController.signal,
        };
      if (this.options.spawnClaudeCodeProcess)
        (Js(`Spawning Claude Code (custom): ${Y} ${Q.join(" ")}`),
          (this.process = this.options.spawnClaudeCodeProcess(ae)));
      else {
        if (!Zn().existsSync(o)) {
          let G = ee
            ? `Claude Code native binary not found at ${o}. Please ensure Claude Code is installed via native installer or specify a valid path with options.pathToClaudeCodeExecutable.`
            : `Claude Code executable not found at ${o}. Is options.pathToClaudeCodeExecutable set?`;
          throw new ReferenceError(G);
        }
        (Js(`Spawning Claude Code: ${Y} ${Q.join(" ")}`),
          (this.process = this.spawnLocalProcess(ae)));
      }
      ((this.processStdin = this.process.stdin),
        (this.processStdout = this.process.stdout));
      let B = () => {
        this.process && !this.process.killed && this.process.kill("SIGTERM");
      };
      ((this.processExitHandler = B),
        (this.abortHandler = B),
        process.on("exit", this.processExitHandler),
        this.abortController.signal.addEventListener(
          "abort",
          this.abortHandler,
        ),
        this.process.on("error", ($) => {
          ((this.ready = !1),
            this.abortController.signal.aborted
              ? (this.exitError = new Ys("Claude Code process aborted by user"))
              : ((this.exitError = new Error(
                  `Failed to spawn Claude Code process: ${$.message}`,
                )),
                Js(this.exitError.message)));
        }),
        this.process.on("exit", ($, G) => {
          if (((this.ready = !1), this.abortController.signal.aborted))
            this.exitError = new Ys("Claude Code process aborted by user");
          else {
            let U = this.getProcessExitError($, G);
            U && ((this.exitError = U), Js(U.message));
          }
        }),
        (this.ready = !0));
    } catch (e) {
      throw ((this.ready = !1), e);
    }
  }
  getProcessExitError(e, r) {
    if (e !== 0 && e !== null)
      return new Error(`Claude Code process exited with code ${e}`);
    if (r) return new Error(`Claude Code process terminated by signal ${r}`);
  }
  write(e) {
    if (this.abortController.signal.aborted) throw new Ys("Operation aborted");
    if (!this.ready || !this.processStdin)
      throw new Error("ProcessTransport is not ready for writing");
    if (this.process?.killed || this.process?.exitCode !== null)
      throw new Error("Cannot write to terminated process");
    if (this.exitError)
      throw new Error(
        `Cannot write to process that exited with error: ${this.exitError.message}`,
      );
    Js(`[ProcessTransport] Writing to stdin: ${e.substring(0, 100)}`);
    try {
      this.processStdin.write(e) ||
        Js("[ProcessTransport] Write buffer full, data queued");
    } catch (r) {
      throw (
        (this.ready = !1),
        new Error(`Failed to write to process stdin: ${r.message}`)
      );
    }
  }
  close() {
    (this.processStdin &&
      (this.processStdin.end(), (this.processStdin = void 0)),
      this.abortHandler &&
        (this.abortController.signal.removeEventListener(
          "abort",
          this.abortHandler,
        ),
        (this.abortHandler = void 0)));
    for (let { handler: e } of this.exitListeners) this.process?.off("exit", e);
    ((this.exitListeners = []),
      this.process &&
        !this.process.killed &&
        (this.process.kill("SIGTERM"),
        setTimeout(() => {
          this.process && !this.process.killed && this.process.kill("SIGKILL");
        }, 5e3)),
      (this.ready = !1),
      this.processExitHandler &&
        (process.off("exit", this.processExitHandler),
        (this.processExitHandler = void 0)));
  }
  isReady() {
    return this.ready;
  }
  async *readMessages() {
    if (!this.processStdout)
      throw new Error("ProcessTransport output stream not available");
    let e = (0, ZS.createInterface)({ input: this.processStdout });
    try {
      for await (let r of e) r.trim() && (yield JSON.parse(r));
      await this.waitForExit();
    } catch (r) {
      throw r;
    } finally {
      e.close();
    }
  }
  endInput() {
    this.processStdin && this.processStdin.end();
  }
  getInputStream() {
    return this.processStdin;
  }
  onExit(e) {
    if (!this.process) return () => {};
    let r = (n, s) => {
      let a = this.getProcessExitError(n, s);
      e(a);
    };
    return (
      this.process.on("exit", r),
      this.exitListeners.push({ callback: e, handler: r }),
      () => {
        this.process && this.process.off("exit", r);
        let n = this.exitListeners.findIndex((s) => s.handler === r);
        n !== -1 && this.exitListeners.splice(n, 1);
      }
    );
  }
  async waitForExit() {
    if (!this.process) {
      if (this.exitError) throw this.exitError;
      return;
    }
    if (this.process.exitCode !== null || this.process.killed) {
      if (this.exitError) throw this.exitError;
      return;
    }
    return new Promise((e, r) => {
      let n = (a, i) => {
        if (this.abortController.signal.aborted) {
          r(new Ys("Operation aborted"));
          return;
        }
        let o = this.getProcessExitError(a, i);
        o ? r(o) : e();
      };
      this.process.once("exit", n);
      let s = (a) => {
        (this.process.off("exit", n), r(a));
      };
      (this.process.once("error", s),
        this.process.once("exit", () => {
          this.process.off("error", s);
        }));
    });
  }
};
function D2(t) {
  return ![".js", ".mjs", ".tsx", ".ts", ".jsx"].some((r) => t.endsWith(r));
}
var lm = class {
    returned;
    queue = [];
    readResolve;
    readReject;
    isDone = !1;
    hasError;
    started = !1;
    constructor(e) {
      this.returned = e;
    }
    [Symbol.asyncIterator]() {
      if (this.started) throw new Error("Stream can only be iterated once");
      return ((this.started = !0), this);
    }
    next() {
      return this.queue.length > 0
        ? Promise.resolve({ done: !1, value: this.queue.shift() })
        : this.isDone
          ? Promise.resolve({ done: !0, value: void 0 })
          : this.hasError
            ? Promise.reject(this.hasError)
            : new Promise((e, r) => {
                ((this.readResolve = e), (this.readReject = r));
              });
    }
    enqueue(e) {
      if (this.readResolve) {
        let r = this.readResolve;
        ((this.readResolve = void 0),
          (this.readReject = void 0),
          r({ done: !1, value: e }));
      } else this.queue.push(e);
    }
    done() {
      if (((this.isDone = !0), this.readResolve)) {
        let e = this.readResolve;
        ((this.readResolve = void 0),
          (this.readReject = void 0),
          e({ done: !0, value: void 0 }));
      }
    }
    error(e) {
      if (((this.hasError = e), this.readReject)) {
        let r = this.readReject;
        ((this.readResolve = void 0), (this.readReject = void 0), r(e));
      }
    }
    return() {
      return (
        (this.isDone = !0),
        this.returned && this.returned(),
        Promise.resolve({ done: !0, value: void 0 })
      );
    }
  },
  um = class {
    sendMcpMessage;
    isClosed = !1;
    constructor(e) {
      this.sendMcpMessage = e;
    }
    onclose;
    onerror;
    onmessage;
    async start() {}
    async send(e) {
      if (this.isClosed) throw new Error("Transport is closed");
      this.sendMcpMessage(e);
    }
    async close() {
      this.isClosed || ((this.isClosed = !0), this.onclose?.());
    }
  },
  dm = class {
    transport;
    isSingleUserTurn;
    canUseTool;
    hooks;
    abortController;
    jsonSchema;
    initConfig;
    pendingControlResponses = new Map();
    cleanupPerformed = !1;
    sdkMessages;
    inputStream = new lm();
    initialization;
    cancelControllers = new Map();
    hookCallbacks = new Map();
    nextCallbackId = 0;
    sdkMcpTransports = new Map();
    sdkMcpServerInstances = new Map();
    pendingMcpResponses = new Map();
    firstResultReceivedResolve;
    firstResultReceived = !1;
    hasBidirectionalNeeds() {
      return (
        this.sdkMcpTransports.size > 0 ||
        (this.hooks !== void 0 && Object.keys(this.hooks).length > 0) ||
        this.canUseTool !== void 0
      );
    }
    constructor(e, r, n, s, a, i = new Map(), o, c) {
      ((this.transport = e),
        (this.isSingleUserTurn = r),
        (this.canUseTool = n),
        (this.hooks = s),
        (this.abortController = a),
        (this.jsonSchema = o),
        (this.initConfig = c));
      for (let [l, u] of i) this.connectSdkMcpServer(l, u);
      ((this.sdkMessages = this.readSdkMessages()),
        this.readMessages(),
        (this.initialization = this.initialize()),
        this.initialization.catch(() => {}));
    }
    setError(e) {
      this.inputStream.error(e);
    }
    cleanup(e) {
      if (!this.cleanupPerformed) {
        this.cleanupPerformed = !0;
        try {
          (this.transport.close(),
            this.pendingControlResponses.clear(),
            this.pendingMcpResponses.clear(),
            this.cancelControllers.clear(),
            this.hookCallbacks.clear());
          for (let r of this.sdkMcpTransports.values())
            try {
              r.close();
            } catch {}
          (this.sdkMcpTransports.clear(),
            e ? this.inputStream.error(e) : this.inputStream.done());
        } catch {}
      }
    }
    next(...[e]) {
      return this.sdkMessages.next(e);
    }
    return(e) {
      return this.sdkMessages.return(e);
    }
    throw(e) {
      return this.sdkMessages.throw(e);
    }
    [Symbol.asyncIterator]() {
      return this.sdkMessages;
    }
    [Symbol.asyncDispose]() {
      return this.sdkMessages[Symbol.asyncDispose]();
    }
    async readMessages() {
      try {
        for await (let e of this.transport.readMessages()) {
          if (e.type === "control_response") {
            let r = this.pendingControlResponses.get(e.response.request_id);
            r && r(e.response);
            continue;
          } else if (e.type === "control_request") {
            this.handleControlRequest(e);
            continue;
          } else if (e.type === "control_cancel_request") {
            this.handleControlCancelRequest(e);
            continue;
          } else if (e.type === "keep_alive") continue;
          (e.type === "result" &&
            ((this.firstResultReceived = !0),
            this.firstResultReceivedResolve &&
              this.firstResultReceivedResolve(),
            this.isSingleUserTurn &&
              (bs(
                "[Query.readMessages] First result received for single-turn query, closing stdin",
              ),
              this.transport.endInput())),
            this.inputStream.enqueue(e));
        }
        (this.firstResultReceivedResolve && this.firstResultReceivedResolve(),
          this.inputStream.done(),
          this.cleanup());
      } catch (e) {
        (this.firstResultReceivedResolve && this.firstResultReceivedResolve(),
          this.inputStream.error(e),
          this.cleanup(e));
      }
    }
    async handleControlRequest(e) {
      let r = new AbortController();
      this.cancelControllers.set(e.request_id, r);
      try {
        let n = await this.processControlRequest(e, r.signal),
          s = {
            type: "control_response",
            response: {
              subtype: "success",
              request_id: e.request_id,
              response: n,
            },
          };
        await Promise.resolve(
          this.transport.write(
            JSON.stringify(s) +
              `
`,
          ),
        );
      } catch (n) {
        let s = {
          type: "control_response",
          response: {
            subtype: "error",
            request_id: e.request_id,
            error: n.message || String(n),
          },
        };
        await Promise.resolve(
          this.transport.write(
            JSON.stringify(s) +
              `
`,
          ),
        );
      } finally {
        this.cancelControllers.delete(e.request_id);
      }
    }
    handleControlCancelRequest(e) {
      let r = this.cancelControllers.get(e.request_id);
      r && (r.abort(), this.cancelControllers.delete(e.request_id));
    }
    async processControlRequest(e, r) {
      if (e.request.subtype === "can_use_tool") {
        if (!this.canUseTool)
          throw new Error("canUseTool callback is not provided.");
        return {
          ...(await this.canUseTool(e.request.tool_name, e.request.input, {
            signal: r,
            suggestions: e.request.permission_suggestions,
            blockedPath: e.request.blocked_path,
            decisionReason: e.request.decision_reason,
            toolUseID: e.request.tool_use_id,
            agentID: e.request.agent_id,
          })),
          toolUseID: e.request.tool_use_id,
        };
      } else {
        if (e.request.subtype === "hook_callback")
          return await this.handleHookCallbacks(
            e.request.callback_id,
            e.request.input,
            e.request.tool_use_id,
            r,
          );
        if (e.request.subtype === "mcp_message") {
          let n = e.request,
            s = this.sdkMcpTransports.get(n.server_name);
          if (!s) throw new Error(`SDK MCP server not found: ${n.server_name}`);
          return "method" in n.message &&
            "id" in n.message &&
            n.message.id !== null
            ? {
                mcp_response: await this.handleMcpControlRequest(
                  n.server_name,
                  n,
                  s,
                ),
              }
            : (s.onmessage && s.onmessage(n.message),
              { mcp_response: { jsonrpc: "2.0", result: {}, id: 0 } });
        }
      }
      throw new Error(
        "Unsupported control request subtype: " + e.request.subtype,
      );
    }
    async *readSdkMessages() {
      for await (let e of this.inputStream) yield e;
    }
    async initialize() {
      let e;
      if (this.hooks) {
        e = {};
        for (let [a, i] of Object.entries(this.hooks))
          i.length > 0 &&
            (e[a] = i.map((o) => {
              let c = [];
              for (let l of o.hooks) {
                let u = `hook_${this.nextCallbackId++}`;
                (this.hookCallbacks.set(u, l), c.push(u));
              }
              return {
                matcher: o.matcher,
                hookCallbackIds: c,
                timeout: o.timeout,
              };
            }));
      }
      let r =
          this.sdkMcpTransports.size > 0
            ? Array.from(this.sdkMcpTransports.keys())
            : void 0,
        n = {
          subtype: "initialize",
          hooks: e,
          sdkMcpServers: r,
          jsonSchema: this.jsonSchema,
          systemPrompt: this.initConfig?.systemPrompt,
          appendSystemPrompt: this.initConfig?.appendSystemPrompt,
          agents: this.initConfig?.agents,
        };
      return (await this.request(n)).response;
    }
    async interrupt() {
      await this.request({ subtype: "interrupt" });
    }
    async setPermissionMode(e) {
      await this.request({ subtype: "set_permission_mode", mode: e });
    }
    async setModel(e) {
      await this.request({ subtype: "set_model", model: e });
    }
    async setMaxThinkingTokens(e) {
      await this.request({
        subtype: "set_max_thinking_tokens",
        max_thinking_tokens: e,
      });
    }
    async rewindFiles(e) {
      await this.request({ subtype: "rewind_files", user_message_id: e });
    }
    async processPendingPermissionRequests(e) {
      for (let r of e)
        r.request.subtype === "can_use_tool" &&
          this.handleControlRequest(r).catch(() => {});
    }
    request(e) {
      let r = Math.random().toString(36).substring(2, 15),
        n = { request_id: r, type: "control_request", request: e };
      return new Promise((s, a) => {
        (this.pendingControlResponses.set(r, (i) => {
          i.subtype === "success"
            ? s(i)
            : (a(new Error(i.error)),
              i.pending_permission_requests &&
                this.processPendingPermissionRequests(
                  i.pending_permission_requests,
                ));
        }),
          Promise.resolve(
            this.transport.write(
              JSON.stringify(n) +
                `
`,
            ),
          ));
      });
    }
    async supportedCommands() {
      return (await this.initialization).commands;
    }
    async supportedModels() {
      return (await this.initialization).models;
    }
    async mcpServerStatus() {
      return (await this.request({ subtype: "mcp_status" })).response
        .mcpServers;
    }
    async setMcpServers(e) {
      let r = {},
        n = {};
      for (let [c, l] of Object.entries(e))
        l.type === "sdk" && "instance" in l ? (r[c] = l.instance) : (n[c] = l);
      let s = new Set(this.sdkMcpServerInstances.keys()),
        a = new Set(Object.keys(r));
      for (let c of s) a.has(c) || (await this.disconnectSdkMcpServer(c));
      for (let [c, l] of Object.entries(r))
        s.has(c) || this.connectSdkMcpServer(c, l);
      let i = {};
      for (let c of Object.keys(r)) i[c] = { type: "sdk", name: c };
      return (
        await this.request({
          subtype: "mcp_set_servers",
          servers: { ...n, ...i },
        })
      ).response;
    }
    async accountInfo() {
      return (await this.initialization).account;
    }
    async streamInput(e) {
      bs("[Query.streamInput] Starting to process input stream");
      try {
        let r = 0;
        for await (let n of e) {
          if (
            (r++,
            bs(`[Query.streamInput] Processing message ${r}: ${n.type}`),
            this.abortController?.signal.aborted)
          )
            break;
          await Promise.resolve(
            this.transport.write(
              JSON.stringify(n) +
                `
`,
            ),
          );
        }
        (bs(
          `[Query.streamInput] Finished processing ${r} messages from input stream`,
        ),
          this.hasBidirectionalNeeds() &&
            (bs(
              "[Query.streamInput] Has bidirectional needs, waiting for first result",
            ),
            await this.waitForFirstResult()),
          bs(
            "[Query] Calling transport.endInput() to close stdin to CLI process",
          ),
          this.transport.endInput());
      } catch (r) {
        if (!(r instanceof Ys)) throw r;
      }
    }
    waitForFirstResult() {
      return this.firstResultReceived
        ? (bs(
            "[Query.waitForFirstResult] Result already received, returning immediately",
          ),
          Promise.resolve())
        : new Promise((e) => {
            if (this.abortController?.signal.aborted) {
              e();
              return;
            }
            (this.abortController?.signal.addEventListener("abort", () => e(), {
              once: !0,
            }),
              (this.firstResultReceivedResolve = e));
          });
    }
    handleHookCallbacks(e, r, n, s) {
      let a = this.hookCallbacks.get(e);
      if (!a) throw new Error(`No hook callback found for ID: ${e}`);
      return a(r, n, { signal: s });
    }
    connectSdkMcpServer(e, r) {
      let n = new um((s) => this.sendMcpServerMessageToCli(e, s));
      (this.sdkMcpTransports.set(e, n),
        this.sdkMcpServerInstances.set(e, r),
        r.connect(n));
    }
    async disconnectSdkMcpServer(e) {
      let r = this.sdkMcpTransports.get(e);
      (r && (await r.close(), this.sdkMcpTransports.delete(e)),
        this.sdkMcpServerInstances.delete(e));
    }
    sendMcpServerMessageToCli(e, r) {
      if ("id" in r && r.id !== null && r.id !== void 0) {
        let s = `${e}:${r.id}`,
          a = this.pendingMcpResponses.get(s);
        if (a) {
          (a.resolve(r), this.pendingMcpResponses.delete(s));
          return;
        }
      }
      let n = {
        type: "control_request",
        request_id: (0, c0.randomUUID)(),
        request: { subtype: "mcp_message", server_name: e, message: r },
      };
      this.transport.write(
        JSON.stringify(n) +
          `
`,
      );
    }
    handleMcpControlRequest(e, r, n) {
      let s = "id" in r.message ? r.message.id : null,
        a = `${e}:${s}`;
      return new Promise((i, o) => {
        let c = () => {
            this.pendingMcpResponses.delete(a);
          },
          l = (d) => {
            (c(), i(d));
          },
          u = (d) => {
            (c(), o(d));
          };
        if (
          (this.pendingMcpResponses.set(a, { resolve: l, reject: u }),
          n.onmessage)
        )
          n.onmessage(r.message);
        else {
          (c(), o(new Error("No message handler registered")));
          return;
        }
      });
    }
  };
var rt;
(function (t) {
  t.assertEqual = (s) => {};
  function e(s) {}
  t.assertIs = e;
  function r(s) {
    throw new Error();
  }
  ((t.assertNever = r),
    (t.arrayToEnum = (s) => {
      let a = {};
      for (let i of s) a[i] = i;
      return a;
    }),
    (t.getValidEnumValues = (s) => {
      let a = t.objectKeys(s).filter((o) => typeof s[s[o]] != "number"),
        i = {};
      for (let o of a) i[o] = s[o];
      return t.objectValues(i);
    }),
    (t.objectValues = (s) =>
      t.objectKeys(s).map(function (a) {
        return s[a];
      })),
    (t.objectKeys =
      typeof Object.keys == "function"
        ? (s) => Object.keys(s)
        : (s) => {
            let a = [];
            for (let i in s)
              Object.prototype.hasOwnProperty.call(s, i) && a.push(i);
            return a;
          }),
    (t.find = (s, a) => {
      for (let i of s) if (a(i)) return i;
    }),
    (t.isInteger =
      typeof Number.isInteger == "function"
        ? (s) => Number.isInteger(s)
        : (s) =>
            typeof s == "number" && Number.isFinite(s) && Math.floor(s) === s));
  function n(s, a = " | ") {
    return s.map((i) => (typeof i == "string" ? `'${i}'` : i)).join(a);
  }
  ((t.joinValues = n),
    (t.jsonStringifyReplacer = (s, a) =>
      typeof a == "bigint" ? a.toString() : a));
})(rt || (rt = {}));
var Qw;
(function (t) {
  t.mergeShapes = (e, r) => ({ ...e, ...r });
})(Qw || (Qw = {}));
var xe = rt.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
  ]),
  _s = (t) => {
    switch (typeof t) {
      case "undefined":
        return xe.undefined;
      case "string":
        return xe.string;
      case "number":
        return Number.isNaN(t) ? xe.nan : xe.number;
      case "boolean":
        return xe.boolean;
      case "function":
        return xe.function;
      case "bigint":
        return xe.bigint;
      case "symbol":
        return xe.symbol;
      case "object":
        return Array.isArray(t)
          ? xe.array
          : t === null
            ? xe.null
            : t.then &&
                typeof t.then == "function" &&
                t.catch &&
                typeof t.catch == "function"
              ? xe.promise
              : typeof Map < "u" && t instanceof Map
                ? xe.map
                : typeof Set < "u" && t instanceof Set
                  ? xe.set
                  : typeof Date < "u" && t instanceof Date
                    ? xe.date
                    : xe.object;
      default:
        return xe.unknown;
    }
  },
  ne = rt.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
  ]),
  Gr = class t extends Error {
    get errors() {
      return this.issues;
    }
    constructor(e) {
      (super(),
        (this.issues = []),
        (this.addIssue = (n) => {
          this.issues = [...this.issues, n];
        }),
        (this.addIssues = (n = []) => {
          this.issues = [...this.issues, ...n];
        }));
      let r = new.target.prototype;
      (Object.setPrototypeOf
        ? Object.setPrototypeOf(this, r)
        : (this.__proto__ = r),
        (this.name = "ZodError"),
        (this.issues = e));
    }
    format(e) {
      let r =
          e ||
          function (a) {
            return a.message;
          },
        n = { _errors: [] },
        s = (a) => {
          for (let i of a.issues)
            if (i.code === "invalid_union") i.unionErrors.map(s);
            else if (i.code === "invalid_return_type") s(i.returnTypeError);
            else if (i.code === "invalid_arguments") s(i.argumentsError);
            else if (i.path.length === 0) n._errors.push(r(i));
            else {
              let o = n,
                c = 0;
              for (; c < i.path.length; ) {
                let l = i.path[c];
                (c === i.path.length - 1
                  ? ((o[l] = o[l] || { _errors: [] }), o[l]._errors.push(r(i)))
                  : (o[l] = o[l] || { _errors: [] }),
                  (o = o[l]),
                  c++);
              }
            }
        };
      return (s(this), n);
    }
    static assert(e) {
      if (!(e instanceof t)) throw new Error(`Not a ZodError: ${e}`);
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, rt.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(e = (r) => r.message) {
      let r = {},
        n = [];
      for (let s of this.issues)
        if (s.path.length > 0) {
          let a = s.path[0];
          ((r[a] = r[a] || []), r[a].push(e(s)));
        } else n.push(e(s));
      return { formErrors: n, fieldErrors: r };
    }
    get formErrors() {
      return this.flatten();
    }
  };
Gr.create = (t) => new Gr(t);
var L2 = (t, e) => {
    let r;
    switch (t.code) {
      case ne.invalid_type:
        t.received === xe.undefined
          ? (r = "Required")
          : (r = `Expected ${t.expected}, received ${t.received}`);
        break;
      case ne.invalid_literal:
        r = `Invalid literal value, expected ${JSON.stringify(t.expected, rt.jsonStringifyReplacer)}`;
        break;
      case ne.unrecognized_keys:
        r = `Unrecognized key(s) in object: ${rt.joinValues(t.keys, ", ")}`;
        break;
      case ne.invalid_union:
        r = "Invalid input";
        break;
      case ne.invalid_union_discriminator:
        r = `Invalid discriminator value. Expected ${rt.joinValues(t.options)}`;
        break;
      case ne.invalid_enum_value:
        r = `Invalid enum value. Expected ${rt.joinValues(t.options)}, received '${t.received}'`;
        break;
      case ne.invalid_arguments:
        r = "Invalid function arguments";
        break;
      case ne.invalid_return_type:
        r = "Invalid function return type";
        break;
      case ne.invalid_date:
        r = "Invalid date";
        break;
      case ne.invalid_string:
        typeof t.validation == "object"
          ? "includes" in t.validation
            ? ((r = `Invalid input: must include "${t.validation.includes}"`),
              typeof t.validation.position == "number" &&
                (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`))
            : "startsWith" in t.validation
              ? (r = `Invalid input: must start with "${t.validation.startsWith}"`)
              : "endsWith" in t.validation
                ? (r = `Invalid input: must end with "${t.validation.endsWith}"`)
                : rt.assertNever(t.validation)
          : t.validation !== "regex"
            ? (r = `Invalid ${t.validation}`)
            : (r = "Invalid");
        break;
      case ne.too_small:
        t.type === "array"
          ? (r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)`)
          : t.type === "string"
            ? (r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)`)
            : t.type === "number"
              ? (r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}`)
              : t.type === "bigint"
                ? (r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}`)
                : t.type === "date"
                  ? (r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}`)
                  : (r = "Invalid input");
        break;
      case ne.too_big:
        t.type === "array"
          ? (r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)`)
          : t.type === "string"
            ? (r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)`)
            : t.type === "number"
              ? (r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}`)
              : t.type === "bigint"
                ? (r = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}`)
                : t.type === "date"
                  ? (r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}`)
                  : (r = "Invalid input");
        break;
      case ne.custom:
        r = "Invalid input";
        break;
      case ne.invalid_intersection_types:
        r = "Intersection results could not be merged";
        break;
      case ne.not_multiple_of:
        r = `Number must be a multiple of ${t.multipleOf}`;
        break;
      case ne.not_finite:
        r = "Number must be finite";
        break;
      default:
        ((r = e.defaultError), rt.assertNever(t));
    }
    return { message: r };
  },
  Zo = L2,
  M2 = Zo;
function pm() {
  return M2;
}
var fm = (t) => {
  let { data: e, path: r, errorMaps: n, issueData: s } = t,
    a = [...r, ...(s.path || [])],
    i = { ...s, path: a };
  if (s.message !== void 0) return { ...s, path: a, message: s.message };
  let o = "",
    c = n
      .filter((l) => !!l)
      .slice()
      .reverse();
  for (let l of c) o = l(i, { data: e, defaultError: o }).message;
  return { ...s, path: a, message: o };
};
function me(t, e) {
  let r = pm(),
    n = fm({
      issueData: e,
      data: t.data,
      path: t.path,
      errorMaps: [
        t.common.contextualErrorMap,
        t.schemaErrorMap,
        r,
        r === Zo ? void 0 : Zo,
      ].filter((s) => !!s),
    });
  t.common.issues.push(n);
}
var fr = class t {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      this.value === "valid" && (this.value = "dirty");
    }
    abort() {
      this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(e, r) {
      let n = [];
      for (let s of r) {
        if (s.status === "aborted") return De;
        (s.status === "dirty" && e.dirty(), n.push(s.value));
      }
      return { status: e.value, value: n };
    }
    static async mergeObjectAsync(e, r) {
      let n = [];
      for (let s of r) {
        let a = await s.key,
          i = await s.value;
        n.push({ key: a, value: i });
      }
      return t.mergeObjectSync(e, n);
    }
    static mergeObjectSync(e, r) {
      let n = {};
      for (let s of r) {
        let { key: a, value: i } = s;
        if (a.status === "aborted" || i.status === "aborted") return De;
        (a.status === "dirty" && e.dirty(),
          i.status === "dirty" && e.dirty(),
          a.value !== "__proto__" &&
            (typeof i.value < "u" || s.alwaysSet) &&
            (n[a.value] = i.value));
      }
      return { status: e.value, value: n };
    }
  },
  De = Object.freeze({ status: "aborted" }),
  Uo = (t) => ({ status: "dirty", value: t }),
  vr = (t) => ({ status: "valid", value: t }),
  eS = (t) => t.status === "aborted",
  tS = (t) => t.status === "dirty",
  ai = (t) => t.status === "valid",
  Gl = (t) => typeof Promise < "u" && t instanceof Promise,
  Se;
(function (t) {
  ((t.errToObj = (e) => (typeof e == "string" ? { message: e } : e || {})),
    (t.toString = (e) => (typeof e == "string" ? e : e?.message)));
})(Se || (Se = {}));
var Wr = class {
    constructor(e, r, n, s) {
      ((this._cachedPath = []),
        (this.parent = e),
        (this.data = r),
        (this._path = n),
        (this._key = s));
    }
    get path() {
      return (
        this._cachedPath.length ||
          (Array.isArray(this._key)
            ? this._cachedPath.push(...this._path, ...this._key)
            : this._cachedPath.push(...this._path, this._key)),
        this._cachedPath
      );
    }
  },
  rS = (t, e) => {
    if (ai(e)) return { success: !0, data: e.value };
    if (!t.common.issues.length)
      throw new Error("Validation failed but no issues detected.");
    return {
      success: !1,
      get error() {
        if (this._error) return this._error;
        let r = new Gr(t.common.issues);
        return ((this._error = r), this._error);
      },
    };
  };
function ze(t) {
  if (!t) return {};
  let {
    errorMap: e,
    invalid_type_error: r,
    required_error: n,
    description: s,
  } = t;
  if (e && (r || n))
    throw new Error(
      `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`,
    );
  return e
    ? { errorMap: e, description: s }
    : {
        errorMap: (i, o) => {
          let { message: c } = t;
          return i.code === "invalid_enum_value"
            ? { message: c ?? o.defaultError }
            : typeof o.data > "u"
              ? { message: c ?? n ?? o.defaultError }
              : i.code !== "invalid_type"
                ? { message: o.defaultError }
                : { message: c ?? r ?? o.defaultError };
        },
        description: s,
      };
}
var Ge = class {
    get description() {
      return this._def.description;
    }
    _getType(e) {
      return _s(e.data);
    }
    _getOrReturnCtx(e, r) {
      return (
        r || {
          common: e.parent.common,
          data: e.data,
          parsedType: _s(e.data),
          schemaErrorMap: this._def.errorMap,
          path: e.path,
          parent: e.parent,
        }
      );
    }
    _processInputParams(e) {
      return {
        status: new fr(),
        ctx: {
          common: e.parent.common,
          data: e.data,
          parsedType: _s(e.data),
          schemaErrorMap: this._def.errorMap,
          path: e.path,
          parent: e.parent,
        },
      };
    }
    _parseSync(e) {
      let r = this._parse(e);
      if (Gl(r)) throw new Error("Synchronous parse encountered promise.");
      return r;
    }
    _parseAsync(e) {
      let r = this._parse(e);
      return Promise.resolve(r);
    }
    parse(e, r) {
      let n = this.safeParse(e, r);
      if (n.success) return n.data;
      throw n.error;
    }
    safeParse(e, r) {
      let n = {
          common: {
            issues: [],
            async: r?.async ?? !1,
            contextualErrorMap: r?.errorMap,
          },
          path: r?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data: e,
          parsedType: _s(e),
        },
        s = this._parseSync({ data: e, path: n.path, parent: n });
      return rS(n, s);
    }
    "~validate"(e) {
      let r = {
        common: { issues: [], async: !!this["~standard"].async },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: _s(e),
      };
      if (!this["~standard"].async)
        try {
          let n = this._parseSync({ data: e, path: [], parent: r });
          return ai(n) ? { value: n.value } : { issues: r.common.issues };
        } catch (n) {
          (n?.message?.toLowerCase()?.includes("encountered") &&
            (this["~standard"].async = !0),
            (r.common = { issues: [], async: !0 }));
        }
      return this._parseAsync({ data: e, path: [], parent: r }).then((n) =>
        ai(n) ? { value: n.value } : { issues: r.common.issues },
      );
    }
    async parseAsync(e, r) {
      let n = await this.safeParseAsync(e, r);
      if (n.success) return n.data;
      throw n.error;
    }
    async safeParseAsync(e, r) {
      let n = {
          common: { issues: [], contextualErrorMap: r?.errorMap, async: !0 },
          path: r?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data: e,
          parsedType: _s(e),
        },
        s = this._parse({ data: e, path: n.path, parent: n }),
        a = await (Gl(s) ? s : Promise.resolve(s));
      return rS(n, a);
    }
    refine(e, r) {
      let n = (s) =>
        typeof r == "string" || typeof r > "u"
          ? { message: r }
          : typeof r == "function"
            ? r(s)
            : r;
      return this._refinement((s, a) => {
        let i = e(s),
          o = () => a.addIssue({ code: ne.custom, ...n(s) });
        return typeof Promise < "u" && i instanceof Promise
          ? i.then((c) => (c ? !0 : (o(), !1)))
          : i
            ? !0
            : (o(), !1);
      });
    }
    refinement(e, r) {
      return this._refinement((n, s) =>
        e(n) ? !0 : (s.addIssue(typeof r == "function" ? r(n, s) : r), !1),
      );
    }
    _refinement(e) {
      return new un({
        schema: this,
        typeName: ie.ZodEffects,
        effect: { type: "refinement", refinement: e },
      });
    }
    superRefine(e) {
      return this._refinement(e);
    }
    constructor(e) {
      ((this.spa = this.safeParseAsync),
        (this._def = e),
        (this.parse = this.parse.bind(this)),
        (this.safeParse = this.safeParse.bind(this)),
        (this.parseAsync = this.parseAsync.bind(this)),
        (this.safeParseAsync = this.safeParseAsync.bind(this)),
        (this.spa = this.spa.bind(this)),
        (this.refine = this.refine.bind(this)),
        (this.refinement = this.refinement.bind(this)),
        (this.superRefine = this.superRefine.bind(this)),
        (this.optional = this.optional.bind(this)),
        (this.nullable = this.nullable.bind(this)),
        (this.nullish = this.nullish.bind(this)),
        (this.array = this.array.bind(this)),
        (this.promise = this.promise.bind(this)),
        (this.or = this.or.bind(this)),
        (this.and = this.and.bind(this)),
        (this.transform = this.transform.bind(this)),
        (this.brand = this.brand.bind(this)),
        (this.default = this.default.bind(this)),
        (this.catch = this.catch.bind(this)),
        (this.describe = this.describe.bind(this)),
        (this.pipe = this.pipe.bind(this)),
        (this.readonly = this.readonly.bind(this)),
        (this.isNullable = this.isNullable.bind(this)),
        (this.isOptional = this.isOptional.bind(this)),
        (this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: (r) => this["~validate"](r),
        }));
    }
    optional() {
      return ln.create(this, this._def);
    }
    nullable() {
      return Wn.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return Ss.create(this);
    }
    promise() {
      return ea.create(this, this._def);
    }
    or(e) {
      return li.create([this, e], this._def);
    }
    and(e) {
      return ui.create(this, e, this._def);
    }
    transform(e) {
      return new un({
        ...ze(this._def),
        schema: this,
        typeName: ie.ZodEffects,
        effect: { type: "transform", transform: e },
      });
    }
    default(e) {
      let r = typeof e == "function" ? e : () => e;
      return new hi({
        ...ze(this._def),
        innerType: this,
        defaultValue: r,
        typeName: ie.ZodDefault,
      });
    }
    brand() {
      return new Wl({ typeName: ie.ZodBranded, type: this, ...ze(this._def) });
    }
    catch(e) {
      let r = typeof e == "function" ? e : () => e;
      return new gi({
        ...ze(this._def),
        innerType: this,
        catchValue: r,
        typeName: ie.ZodCatch,
      });
    }
    describe(e) {
      let r = this.constructor;
      return new r({ ...this._def, description: e });
    }
    pipe(e) {
      return Kl.create(this, e);
    }
    readonly() {
      return vi.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  },
  j2 = /^c[^\s-]{8,}$/i,
  F2 = /^[0-9a-z]+$/,
  U2 = /^[0-9A-HJKMNP-TV-Z]{26}$/i,
  q2 =
    /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
  z2 = /^[a-z0-9_-]{21}$/i,
  B2 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
  H2 =
    /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
  V2 =
    /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
  Z2 = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
  Yf,
  G2 =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  W2 =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  K2 =
    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,
  J2 =
    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  X2 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  Y2 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  l0 =
    "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
  Q2 = new RegExp(`^${l0}$`);
function u0(t) {
  let e = "[0-5]\\d";
  t.precision
    ? (e = `${e}\\.\\d{${t.precision}}`)
    : t.precision == null && (e = `${e}(\\.\\d+)?`);
  let r = t.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${e})${r}`;
}
function ez(t) {
  return new RegExp(`^${u0(t)}$`);
}
function tz(t) {
  let e = `${l0}T${u0(t)}`,
    r = [];
  return (
    r.push(t.local ? "Z?" : "Z"),
    t.offset && r.push("([+-]\\d{2}:?\\d{2})"),
    (e = `${e}(${r.join("|")})`),
    new RegExp(`^${e}$`)
  );
}
function rz(t, e) {
  return !!(
    ((e === "v4" || !e) && G2.test(t)) ||
    ((e === "v6" || !e) && K2.test(t))
  );
}
function nz(t, e) {
  if (!B2.test(t)) return !1;
  try {
    let [r] = t.split(".");
    if (!r) return !1;
    let n = r
        .replace(/-/g, "+")
        .replace(/_/g, "/")
        .padEnd(r.length + ((4 - (r.length % 4)) % 4), "="),
      s = JSON.parse(atob(n));
    return !(
      typeof s != "object" ||
      s === null ||
      ("typ" in s && s?.typ !== "JWT") ||
      !s.alg ||
      (e && s.alg !== e)
    );
  } catch {
    return !1;
  }
}
function sz(t, e) {
  return !!(
    ((e === "v4" || !e) && W2.test(t)) ||
    ((e === "v6" || !e) && J2.test(t))
  );
}
var ii = class t extends Ge {
  _parse(e) {
    if (
      (this._def.coerce && (e.data = String(e.data)),
      this._getType(e) !== xe.string)
    ) {
      let a = this._getOrReturnCtx(e);
      return (
        me(a, {
          code: ne.invalid_type,
          expected: xe.string,
          received: a.parsedType,
        }),
        De
      );
    }
    let n = new fr(),
      s;
    for (let a of this._def.checks)
      if (a.kind === "min")
        e.data.length < a.value &&
          ((s = this._getOrReturnCtx(e, s)),
          me(s, {
            code: ne.too_small,
            minimum: a.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "max")
        e.data.length > a.value &&
          ((s = this._getOrReturnCtx(e, s)),
          me(s, {
            code: ne.too_big,
            maximum: a.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "length") {
        let i = e.data.length > a.value,
          o = e.data.length < a.value;
        (i || o) &&
          ((s = this._getOrReturnCtx(e, s)),
          i
            ? me(s, {
                code: ne.too_big,
                maximum: a.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: a.message,
              })
            : o &&
              me(s, {
                code: ne.too_small,
                minimum: a.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: a.message,
              }),
          n.dirty());
      } else if (a.kind === "email")
        V2.test(e.data) ||
          ((s = this._getOrReturnCtx(e, s)),
          me(s, {
            validation: "email",
            code: ne.invalid_string,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "emoji")
        (Yf || (Yf = new RegExp(Z2, "u")),
          Yf.test(e.data) ||
            ((s = this._getOrReturnCtx(e, s)),
            me(s, {
              validation: "emoji",
              code: ne.invalid_string,
              message: a.message,
            }),
            n.dirty()));
      else if (a.kind === "uuid")
        q2.test(e.data) ||
          ((s = this._getOrReturnCtx(e, s)),
          me(s, {
            validation: "uuid",
            code: ne.invalid_string,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "nanoid")
        z2.test(e.data) ||
          ((s = this._getOrReturnCtx(e, s)),
          me(s, {
            validation: "nanoid",
            code: ne.invalid_string,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "cuid")
        j2.test(e.data) ||
          ((s = this._getOrReturnCtx(e, s)),
          me(s, {
            validation: "cuid",
            code: ne.invalid_string,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "cuid2")
        F2.test(e.data) ||
          ((s = this._getOrReturnCtx(e, s)),
          me(s, {
            validation: "cuid2",
            code: ne.invalid_string,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "ulid")
        U2.test(e.data) ||
          ((s = this._getOrReturnCtx(e, s)),
          me(s, {
            validation: "ulid",
            code: ne.invalid_string,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "url")
        try {
          new URL(e.data);
        } catch {
          ((s = this._getOrReturnCtx(e, s)),
            me(s, {
              validation: "url",
              code: ne.invalid_string,
              message: a.message,
            }),
            n.dirty());
        }
      else
        a.kind === "regex"
          ? ((a.regex.lastIndex = 0),
            a.regex.test(e.data) ||
              ((s = this._getOrReturnCtx(e, s)),
              me(s, {
                validation: "regex",
                code: ne.invalid_string,
                message: a.message,
              }),
              n.dirty()))
          : a.kind === "trim"
            ? (e.data = e.data.trim())
            : a.kind === "includes"
              ? e.data.includes(a.value, a.position) ||
                ((s = this._getOrReturnCtx(e, s)),
                me(s, {
                  code: ne.invalid_string,
                  validation: { includes: a.value, position: a.position },
                  message: a.message,
                }),
                n.dirty())
              : a.kind === "toLowerCase"
                ? (e.data = e.data.toLowerCase())
                : a.kind === "toUpperCase"
                  ? (e.data = e.data.toUpperCase())
                  : a.kind === "startsWith"
                    ? e.data.startsWith(a.value) ||
                      ((s = this._getOrReturnCtx(e, s)),
                      me(s, {
                        code: ne.invalid_string,
                        validation: { startsWith: a.value },
                        message: a.message,
                      }),
                      n.dirty())
                    : a.kind === "endsWith"
                      ? e.data.endsWith(a.value) ||
                        ((s = this._getOrReturnCtx(e, s)),
                        me(s, {
                          code: ne.invalid_string,
                          validation: { endsWith: a.value },
                          message: a.message,
                        }),
                        n.dirty())
                      : a.kind === "datetime"
                        ? tz(a).test(e.data) ||
                          ((s = this._getOrReturnCtx(e, s)),
                          me(s, {
                            code: ne.invalid_string,
                            validation: "datetime",
                            message: a.message,
                          }),
                          n.dirty())
                        : a.kind === "date"
                          ? Q2.test(e.data) ||
                            ((s = this._getOrReturnCtx(e, s)),
                            me(s, {
                              code: ne.invalid_string,
                              validation: "date",
                              message: a.message,
                            }),
                            n.dirty())
                          : a.kind === "time"
                            ? ez(a).test(e.data) ||
                              ((s = this._getOrReturnCtx(e, s)),
                              me(s, {
                                code: ne.invalid_string,
                                validation: "time",
                                message: a.message,
                              }),
                              n.dirty())
                            : a.kind === "duration"
                              ? H2.test(e.data) ||
                                ((s = this._getOrReturnCtx(e, s)),
                                me(s, {
                                  validation: "duration",
                                  code: ne.invalid_string,
                                  message: a.message,
                                }),
                                n.dirty())
                              : a.kind === "ip"
                                ? rz(e.data, a.version) ||
                                  ((s = this._getOrReturnCtx(e, s)),
                                  me(s, {
                                    validation: "ip",
                                    code: ne.invalid_string,
                                    message: a.message,
                                  }),
                                  n.dirty())
                                : a.kind === "jwt"
                                  ? nz(e.data, a.alg) ||
                                    ((s = this._getOrReturnCtx(e, s)),
                                    me(s, {
                                      validation: "jwt",
                                      code: ne.invalid_string,
                                      message: a.message,
                                    }),
                                    n.dirty())
                                  : a.kind === "cidr"
                                    ? sz(e.data, a.version) ||
                                      ((s = this._getOrReturnCtx(e, s)),
                                      me(s, {
                                        validation: "cidr",
                                        code: ne.invalid_string,
                                        message: a.message,
                                      }),
                                      n.dirty())
                                    : a.kind === "base64"
                                      ? X2.test(e.data) ||
                                        ((s = this._getOrReturnCtx(e, s)),
                                        me(s, {
                                          validation: "base64",
                                          code: ne.invalid_string,
                                          message: a.message,
                                        }),
                                        n.dirty())
                                      : a.kind === "base64url"
                                        ? Y2.test(e.data) ||
                                          ((s = this._getOrReturnCtx(e, s)),
                                          me(s, {
                                            validation: "base64url",
                                            code: ne.invalid_string,
                                            message: a.message,
                                          }),
                                          n.dirty())
                                        : rt.assertNever(a);
    return { status: n.value, value: e.data };
  }
  _regex(e, r, n) {
    return this.refinement((s) => e.test(s), {
      validation: r,
      code: ne.invalid_string,
      ...Se.errToObj(n),
    });
  }
  _addCheck(e) {
    return new t({ ...this._def, checks: [...this._def.checks, e] });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...Se.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...Se.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...Se.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...Se.errToObj(e) });
  }
  nanoid(e) {
    return this._addCheck({ kind: "nanoid", ...Se.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...Se.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...Se.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...Se.errToObj(e) });
  }
  base64(e) {
    return this._addCheck({ kind: "base64", ...Se.errToObj(e) });
  }
  base64url(e) {
    return this._addCheck({ kind: "base64url", ...Se.errToObj(e) });
  }
  jwt(e) {
    return this._addCheck({ kind: "jwt", ...Se.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...Se.errToObj(e) });
  }
  cidr(e) {
    return this._addCheck({ kind: "cidr", ...Se.errToObj(e) });
  }
  datetime(e) {
    return typeof e == "string"
      ? this._addCheck({
          kind: "datetime",
          precision: null,
          offset: !1,
          local: !1,
          message: e,
        })
      : this._addCheck({
          kind: "datetime",
          precision: typeof e?.precision > "u" ? null : e?.precision,
          offset: e?.offset ?? !1,
          local: e?.local ?? !1,
          ...Se.errToObj(e?.message),
        });
  }
  date(e) {
    return this._addCheck({ kind: "date", message: e });
  }
  time(e) {
    return typeof e == "string"
      ? this._addCheck({ kind: "time", precision: null, message: e })
      : this._addCheck({
          kind: "time",
          precision: typeof e?.precision > "u" ? null : e?.precision,
          ...Se.errToObj(e?.message),
        });
  }
  duration(e) {
    return this._addCheck({ kind: "duration", ...Se.errToObj(e) });
  }
  regex(e, r) {
    return this._addCheck({ kind: "regex", regex: e, ...Se.errToObj(r) });
  }
  includes(e, r) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: r?.position,
      ...Se.errToObj(r?.message),
    });
  }
  startsWith(e, r) {
    return this._addCheck({ kind: "startsWith", value: e, ...Se.errToObj(r) });
  }
  endsWith(e, r) {
    return this._addCheck({ kind: "endsWith", value: e, ...Se.errToObj(r) });
  }
  min(e, r) {
    return this._addCheck({ kind: "min", value: e, ...Se.errToObj(r) });
  }
  max(e, r) {
    return this._addCheck({ kind: "max", value: e, ...Se.errToObj(r) });
  }
  length(e, r) {
    return this._addCheck({ kind: "length", value: e, ...Se.errToObj(r) });
  }
  nonempty(e) {
    return this.min(1, Se.errToObj(e));
  }
  trim() {
    return new t({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }],
    });
  }
  toLowerCase() {
    return new t({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }],
    });
  }
  toUpperCase() {
    return new t({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }],
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e) => e.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e) => e.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e) => e.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e) => e.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((e) => e.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((e) => e.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((e) => e.kind === "base64url");
  }
  get minLength() {
    let e = null;
    for (let r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (let r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
};
ii.create = (t) =>
  new ii({
    checks: [],
    typeName: ie.ZodString,
    coerce: t?.coerce ?? !1,
    ...ze(t),
  });
function az(t, e) {
  let r = (t.toString().split(".")[1] || "").length,
    n = (e.toString().split(".")[1] || "").length,
    s = r > n ? r : n,
    a = Number.parseInt(t.toFixed(s).replace(".", "")),
    i = Number.parseInt(e.toFixed(s).replace(".", ""));
  return (a % i) / 10 ** s;
}
var Go = class t extends Ge {
  constructor() {
    (super(...arguments),
      (this.min = this.gte),
      (this.max = this.lte),
      (this.step = this.multipleOf));
  }
  _parse(e) {
    if (
      (this._def.coerce && (e.data = Number(e.data)),
      this._getType(e) !== xe.number)
    ) {
      let a = this._getOrReturnCtx(e);
      return (
        me(a, {
          code: ne.invalid_type,
          expected: xe.number,
          received: a.parsedType,
        }),
        De
      );
    }
    let n,
      s = new fr();
    for (let a of this._def.checks)
      a.kind === "int"
        ? rt.isInteger(e.data) ||
          ((n = this._getOrReturnCtx(e, n)),
          me(n, {
            code: ne.invalid_type,
            expected: "integer",
            received: "float",
            message: a.message,
          }),
          s.dirty())
        : a.kind === "min"
          ? (a.inclusive ? e.data < a.value : e.data <= a.value) &&
            ((n = this._getOrReturnCtx(e, n)),
            me(n, {
              code: ne.too_small,
              minimum: a.value,
              type: "number",
              inclusive: a.inclusive,
              exact: !1,
              message: a.message,
            }),
            s.dirty())
          : a.kind === "max"
            ? (a.inclusive ? e.data > a.value : e.data >= a.value) &&
              ((n = this._getOrReturnCtx(e, n)),
              me(n, {
                code: ne.too_big,
                maximum: a.value,
                type: "number",
                inclusive: a.inclusive,
                exact: !1,
                message: a.message,
              }),
              s.dirty())
            : a.kind === "multipleOf"
              ? az(e.data, a.value) !== 0 &&
                ((n = this._getOrReturnCtx(e, n)),
                me(n, {
                  code: ne.not_multiple_of,
                  multipleOf: a.value,
                  message: a.message,
                }),
                s.dirty())
              : a.kind === "finite"
                ? Number.isFinite(e.data) ||
                  ((n = this._getOrReturnCtx(e, n)),
                  me(n, { code: ne.not_finite, message: a.message }),
                  s.dirty())
                : rt.assertNever(a);
    return { status: s.value, value: e.data };
  }
  gte(e, r) {
    return this.setLimit("min", e, !0, Se.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, !1, Se.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, !0, Se.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, !1, Se.toString(r));
  }
  setLimit(e, r, n, s) {
    return new t({
      ...this._def,
      checks: [
        ...this._def.checks,
        { kind: e, value: r, inclusive: n, message: Se.toString(s) },
      ],
    });
  }
  _addCheck(e) {
    return new t({ ...this._def, checks: [...this._def.checks, e] });
  }
  int(e) {
    return this._addCheck({ kind: "int", message: Se.toString(e) });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: Se.toString(e),
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: Se.toString(e),
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: Se.toString(e),
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: Se.toString(e),
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: Se.toString(r),
    });
  }
  finite(e) {
    return this._addCheck({ kind: "finite", message: Se.toString(e) });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: Se.toString(e),
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: Se.toString(e),
    });
  }
  get minValue() {
    let e = null;
    for (let r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (let r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find(
      (e) =>
        e.kind === "int" || (e.kind === "multipleOf" && rt.isInteger(e.value)),
    );
  }
  get isFinite() {
    let e = null,
      r = null;
    for (let n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min"
        ? (r === null || n.value > r) && (r = n.value)
        : n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    }
    return Number.isFinite(r) && Number.isFinite(e);
  }
};
Go.create = (t) =>
  new Go({
    checks: [],
    typeName: ie.ZodNumber,
    coerce: t?.coerce || !1,
    ...ze(t),
  });
var Wo = class t extends Ge {
  constructor() {
    (super(...arguments), (this.min = this.gte), (this.max = this.lte));
  }
  _parse(e) {
    if (this._def.coerce)
      try {
        e.data = BigInt(e.data);
      } catch {
        return this._getInvalidInput(e);
      }
    if (this._getType(e) !== xe.bigint) return this._getInvalidInput(e);
    let n,
      s = new fr();
    for (let a of this._def.checks)
      a.kind === "min"
        ? (a.inclusive ? e.data < a.value : e.data <= a.value) &&
          ((n = this._getOrReturnCtx(e, n)),
          me(n, {
            code: ne.too_small,
            type: "bigint",
            minimum: a.value,
            inclusive: a.inclusive,
            message: a.message,
          }),
          s.dirty())
        : a.kind === "max"
          ? (a.inclusive ? e.data > a.value : e.data >= a.value) &&
            ((n = this._getOrReturnCtx(e, n)),
            me(n, {
              code: ne.too_big,
              type: "bigint",
              maximum: a.value,
              inclusive: a.inclusive,
              message: a.message,
            }),
            s.dirty())
          : a.kind === "multipleOf"
            ? e.data % a.value !== BigInt(0) &&
              ((n = this._getOrReturnCtx(e, n)),
              me(n, {
                code: ne.not_multiple_of,
                multipleOf: a.value,
                message: a.message,
              }),
              s.dirty())
            : rt.assertNever(a);
    return { status: s.value, value: e.data };
  }
  _getInvalidInput(e) {
    let r = this._getOrReturnCtx(e);
    return (
      me(r, {
        code: ne.invalid_type,
        expected: xe.bigint,
        received: r.parsedType,
      }),
      De
    );
  }
  gte(e, r) {
    return this.setLimit("min", e, !0, Se.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, !1, Se.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, !0, Se.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, !1, Se.toString(r));
  }
  setLimit(e, r, n, s) {
    return new t({
      ...this._def,
      checks: [
        ...this._def.checks,
        { kind: e, value: r, inclusive: n, message: Se.toString(s) },
      ],
    });
  }
  _addCheck(e) {
    return new t({ ...this._def, checks: [...this._def.checks, e] });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: Se.toString(e),
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: Se.toString(e),
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: Se.toString(e),
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: Se.toString(e),
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: Se.toString(r),
    });
  }
  get minValue() {
    let e = null;
    for (let r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (let r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
};
Wo.create = (t) =>
  new Wo({
    checks: [],
    typeName: ie.ZodBigInt,
    coerce: t?.coerce ?? !1,
    ...ze(t),
  });
var Ko = class extends Ge {
  _parse(e) {
    if (
      (this._def.coerce && (e.data = !!e.data), this._getType(e) !== xe.boolean)
    ) {
      let n = this._getOrReturnCtx(e);
      return (
        me(n, {
          code: ne.invalid_type,
          expected: xe.boolean,
          received: n.parsedType,
        }),
        De
      );
    }
    return vr(e.data);
  }
};
Ko.create = (t) =>
  new Ko({ typeName: ie.ZodBoolean, coerce: t?.coerce || !1, ...ze(t) });
var Jo = class t extends Ge {
  _parse(e) {
    if (
      (this._def.coerce && (e.data = new Date(e.data)),
      this._getType(e) !== xe.date)
    ) {
      let a = this._getOrReturnCtx(e);
      return (
        me(a, {
          code: ne.invalid_type,
          expected: xe.date,
          received: a.parsedType,
        }),
        De
      );
    }
    if (Number.isNaN(e.data.getTime())) {
      let a = this._getOrReturnCtx(e);
      return (me(a, { code: ne.invalid_date }), De);
    }
    let n = new fr(),
      s;
    for (let a of this._def.checks)
      a.kind === "min"
        ? e.data.getTime() < a.value &&
          ((s = this._getOrReturnCtx(e, s)),
          me(s, {
            code: ne.too_small,
            message: a.message,
            inclusive: !0,
            exact: !1,
            minimum: a.value,
            type: "date",
          }),
          n.dirty())
        : a.kind === "max"
          ? e.data.getTime() > a.value &&
            ((s = this._getOrReturnCtx(e, s)),
            me(s, {
              code: ne.too_big,
              message: a.message,
              inclusive: !0,
              exact: !1,
              maximum: a.value,
              type: "date",
            }),
            n.dirty())
          : rt.assertNever(a);
    return { status: n.value, value: new Date(e.data.getTime()) };
  }
  _addCheck(e) {
    return new t({ ...this._def, checks: [...this._def.checks, e] });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: Se.toString(r),
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: Se.toString(r),
    });
  }
  get minDate() {
    let e = null;
    for (let r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (let r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
};
Jo.create = (t) =>
  new Jo({
    checks: [],
    coerce: t?.coerce || !1,
    typeName: ie.ZodDate,
    ...ze(t),
  });
var Xo = class extends Ge {
  _parse(e) {
    if (this._getType(e) !== xe.symbol) {
      let n = this._getOrReturnCtx(e);
      return (
        me(n, {
          code: ne.invalid_type,
          expected: xe.symbol,
          received: n.parsedType,
        }),
        De
      );
    }
    return vr(e.data);
  }
};
Xo.create = (t) => new Xo({ typeName: ie.ZodSymbol, ...ze(t) });
var oi = class extends Ge {
  _parse(e) {
    if (this._getType(e) !== xe.undefined) {
      let n = this._getOrReturnCtx(e);
      return (
        me(n, {
          code: ne.invalid_type,
          expected: xe.undefined,
          received: n.parsedType,
        }),
        De
      );
    }
    return vr(e.data);
  }
};
oi.create = (t) => new oi({ typeName: ie.ZodUndefined, ...ze(t) });
var ci = class extends Ge {
  _parse(e) {
    if (this._getType(e) !== xe.null) {
      let n = this._getOrReturnCtx(e);
      return (
        me(n, {
          code: ne.invalid_type,
          expected: xe.null,
          received: n.parsedType,
        }),
        De
      );
    }
    return vr(e.data);
  }
};
ci.create = (t) => new ci({ typeName: ie.ZodNull, ...ze(t) });
var Yo = class extends Ge {
  constructor() {
    (super(...arguments), (this._any = !0));
  }
  _parse(e) {
    return vr(e.data);
  }
};
Yo.create = (t) => new Yo({ typeName: ie.ZodAny, ...ze(t) });
var ws = class extends Ge {
  constructor() {
    (super(...arguments), (this._unknown = !0));
  }
  _parse(e) {
    return vr(e.data);
  }
};
ws.create = (t) => new ws({ typeName: ie.ZodUnknown, ...ze(t) });
var kn = class extends Ge {
  _parse(e) {
    let r = this._getOrReturnCtx(e);
    return (
      me(r, {
        code: ne.invalid_type,
        expected: xe.never,
        received: r.parsedType,
      }),
      De
    );
  }
};
kn.create = (t) => new kn({ typeName: ie.ZodNever, ...ze(t) });
var Qo = class extends Ge {
  _parse(e) {
    if (this._getType(e) !== xe.undefined) {
      let n = this._getOrReturnCtx(e);
      return (
        me(n, {
          code: ne.invalid_type,
          expected: xe.void,
          received: n.parsedType,
        }),
        De
      );
    }
    return vr(e.data);
  }
};
Qo.create = (t) => new Qo({ typeName: ie.ZodVoid, ...ze(t) });
var Ss = class t extends Ge {
  _parse(e) {
    let { ctx: r, status: n } = this._processInputParams(e),
      s = this._def;
    if (r.parsedType !== xe.array)
      return (
        me(r, {
          code: ne.invalid_type,
          expected: xe.array,
          received: r.parsedType,
        }),
        De
      );
    if (s.exactLength !== null) {
      let i = r.data.length > s.exactLength.value,
        o = r.data.length < s.exactLength.value;
      (i || o) &&
        (me(r, {
          code: i ? ne.too_big : ne.too_small,
          minimum: o ? s.exactLength.value : void 0,
          maximum: i ? s.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: s.exactLength.message,
        }),
        n.dirty());
    }
    if (
      (s.minLength !== null &&
        r.data.length < s.minLength.value &&
        (me(r, {
          code: ne.too_small,
          minimum: s.minLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: s.minLength.message,
        }),
        n.dirty()),
      s.maxLength !== null &&
        r.data.length > s.maxLength.value &&
        (me(r, {
          code: ne.too_big,
          maximum: s.maxLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: s.maxLength.message,
        }),
        n.dirty()),
      r.common.async)
    )
      return Promise.all(
        [...r.data].map((i, o) => s.type._parseAsync(new Wr(r, i, r.path, o))),
      ).then((i) => fr.mergeArray(n, i));
    let a = [...r.data].map((i, o) =>
      s.type._parseSync(new Wr(r, i, r.path, o)),
    );
    return fr.mergeArray(n, a);
  }
  get element() {
    return this._def.type;
  }
  min(e, r) {
    return new t({
      ...this._def,
      minLength: { value: e, message: Se.toString(r) },
    });
  }
  max(e, r) {
    return new t({
      ...this._def,
      maxLength: { value: e, message: Se.toString(r) },
    });
  }
  length(e, r) {
    return new t({
      ...this._def,
      exactLength: { value: e, message: Se.toString(r) },
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
};
Ss.create = (t, e) =>
  new Ss({
    type: t,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ie.ZodArray,
    ...ze(e),
  });
function ri(t) {
  if (t instanceof Lr) {
    let e = {};
    for (let r in t.shape) {
      let n = t.shape[r];
      e[r] = ln.create(ri(n));
    }
    return new Lr({ ...t._def, shape: () => e });
  } else
    return t instanceof Ss
      ? new Ss({ ...t._def, type: ri(t.element) })
      : t instanceof ln
        ? ln.create(ri(t.unwrap()))
        : t instanceof Wn
          ? Wn.create(ri(t.unwrap()))
          : t instanceof Gn
            ? Gn.create(t.items.map((e) => ri(e)))
            : t;
}
var Lr = class t extends Ge {
  constructor() {
    (super(...arguments),
      (this._cached = null),
      (this.nonstrict = this.passthrough),
      (this.augment = this.extend));
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    let e = this._def.shape(),
      r = rt.objectKeys(e);
    return ((this._cached = { shape: e, keys: r }), this._cached);
  }
  _parse(e) {
    if (this._getType(e) !== xe.object) {
      let l = this._getOrReturnCtx(e);
      return (
        me(l, {
          code: ne.invalid_type,
          expected: xe.object,
          received: l.parsedType,
        }),
        De
      );
    }
    let { status: n, ctx: s } = this._processInputParams(e),
      { shape: a, keys: i } = this._getCached(),
      o = [];
    if (
      !(this._def.catchall instanceof kn && this._def.unknownKeys === "strip")
    )
      for (let l in s.data) i.includes(l) || o.push(l);
    let c = [];
    for (let l of i) {
      let u = a[l],
        d = s.data[l];
      c.push({
        key: { status: "valid", value: l },
        value: u._parse(new Wr(s, d, s.path, l)),
        alwaysSet: l in s.data,
      });
    }
    if (this._def.catchall instanceof kn) {
      let l = this._def.unknownKeys;
      if (l === "passthrough")
        for (let u of o)
          c.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: s.data[u] },
          });
      else if (l === "strict")
        o.length > 0 &&
          (me(s, { code: ne.unrecognized_keys, keys: o }), n.dirty());
      else if (l !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      let l = this._def.catchall;
      for (let u of o) {
        let d = s.data[u];
        c.push({
          key: { status: "valid", value: u },
          value: l._parse(new Wr(s, d, s.path, u)),
          alwaysSet: u in s.data,
        });
      }
    }
    return s.common.async
      ? Promise.resolve()
          .then(async () => {
            let l = [];
            for (let u of c) {
              let d = await u.key,
                m = await u.value;
              l.push({ key: d, value: m, alwaysSet: u.alwaysSet });
            }
            return l;
          })
          .then((l) => fr.mergeObjectSync(n, l))
      : fr.mergeObjectSync(n, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return (
      Se.errToObj,
      new t({
        ...this._def,
        unknownKeys: "strict",
        ...(e !== void 0
          ? {
              errorMap: (r, n) => {
                let s = this._def.errorMap?.(r, n).message ?? n.defaultError;
                return r.code === "unrecognized_keys"
                  ? { message: Se.errToObj(e).message ?? s }
                  : { message: s };
              },
            }
          : {}),
      })
    );
  }
  strip() {
    return new t({ ...this._def, unknownKeys: "strip" });
  }
  passthrough() {
    return new t({ ...this._def, unknownKeys: "passthrough" });
  }
  extend(e) {
    return new t({
      ...this._def,
      shape: () => ({ ...this._def.shape(), ...e }),
    });
  }
  merge(e) {
    return new t({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({ ...this._def.shape(), ...e._def.shape() }),
      typeName: ie.ZodObject,
    });
  }
  setKey(e, r) {
    return this.augment({ [e]: r });
  }
  catchall(e) {
    return new t({ ...this._def, catchall: e });
  }
  pick(e) {
    let r = {};
    for (let n of rt.objectKeys(e))
      e[n] && this.shape[n] && (r[n] = this.shape[n]);
    return new t({ ...this._def, shape: () => r });
  }
  omit(e) {
    let r = {};
    for (let n of rt.objectKeys(this.shape)) e[n] || (r[n] = this.shape[n]);
    return new t({ ...this._def, shape: () => r });
  }
  deepPartial() {
    return ri(this);
  }
  partial(e) {
    let r = {};
    for (let n of rt.objectKeys(this.shape)) {
      let s = this.shape[n];
      e && !e[n] ? (r[n] = s) : (r[n] = s.optional());
    }
    return new t({ ...this._def, shape: () => r });
  }
  required(e) {
    let r = {};
    for (let n of rt.objectKeys(this.shape))
      if (e && !e[n]) r[n] = this.shape[n];
      else {
        let a = this.shape[n];
        for (; a instanceof ln; ) a = a._def.innerType;
        r[n] = a;
      }
    return new t({ ...this._def, shape: () => r });
  }
  keyof() {
    return d0(rt.objectKeys(this.shape));
  }
};
Lr.create = (t, e) =>
  new Lr({
    shape: () => t,
    unknownKeys: "strip",
    catchall: kn.create(),
    typeName: ie.ZodObject,
    ...ze(e),
  });
Lr.strictCreate = (t, e) =>
  new Lr({
    shape: () => t,
    unknownKeys: "strict",
    catchall: kn.create(),
    typeName: ie.ZodObject,
    ...ze(e),
  });
Lr.lazycreate = (t, e) =>
  new Lr({
    shape: t,
    unknownKeys: "strip",
    catchall: kn.create(),
    typeName: ie.ZodObject,
    ...ze(e),
  });
var li = class extends Ge {
  _parse(e) {
    let { ctx: r } = this._processInputParams(e),
      n = this._def.options;
    function s(a) {
      for (let o of a) if (o.result.status === "valid") return o.result;
      for (let o of a)
        if (o.result.status === "dirty")
          return (r.common.issues.push(...o.ctx.common.issues), o.result);
      let i = a.map((o) => new Gr(o.ctx.common.issues));
      return (me(r, { code: ne.invalid_union, unionErrors: i }), De);
    }
    if (r.common.async)
      return Promise.all(
        n.map(async (a) => {
          let i = { ...r, common: { ...r.common, issues: [] }, parent: null };
          return {
            result: await a._parseAsync({
              data: r.data,
              path: r.path,
              parent: i,
            }),
            ctx: i,
          };
        }),
      ).then(s);
    {
      let a,
        i = [];
      for (let c of n) {
        let l = { ...r, common: { ...r.common, issues: [] }, parent: null },
          u = c._parseSync({ data: r.data, path: r.path, parent: l });
        if (u.status === "valid") return u;
        (u.status === "dirty" && !a && (a = { result: u, ctx: l }),
          l.common.issues.length && i.push(l.common.issues));
      }
      if (a) return (r.common.issues.push(...a.ctx.common.issues), a.result);
      let o = i.map((c) => new Gr(c));
      return (me(r, { code: ne.invalid_union, unionErrors: o }), De);
    }
  }
  get options() {
    return this._def.options;
  }
};
li.create = (t, e) => new li({ options: t, typeName: ie.ZodUnion, ...ze(e) });
var Hn = (t) =>
    t instanceof di
      ? Hn(t.schema)
      : t instanceof un
        ? Hn(t.innerType())
        : t instanceof pi
          ? [t.value]
          : t instanceof fi
            ? t.options
            : t instanceof mi
              ? rt.objectValues(t.enum)
              : t instanceof hi
                ? Hn(t._def.innerType)
                : t instanceof oi
                  ? [void 0]
                  : t instanceof ci
                    ? [null]
                    : t instanceof ln
                      ? [void 0, ...Hn(t.unwrap())]
                      : t instanceof Wn
                        ? [null, ...Hn(t.unwrap())]
                        : t instanceof Wl || t instanceof vi
                          ? Hn(t.unwrap())
                          : t instanceof gi
                            ? Hn(t._def.innerType)
                            : [],
  mm = class t extends Ge {
    _parse(e) {
      let { ctx: r } = this._processInputParams(e);
      if (r.parsedType !== xe.object)
        return (
          me(r, {
            code: ne.invalid_type,
            expected: xe.object,
            received: r.parsedType,
          }),
          De
        );
      let n = this.discriminator,
        s = r.data[n],
        a = this.optionsMap.get(s);
      return a
        ? r.common.async
          ? a._parseAsync({ data: r.data, path: r.path, parent: r })
          : a._parseSync({ data: r.data, path: r.path, parent: r })
        : (me(r, {
            code: ne.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [n],
          }),
          De);
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    static create(e, r, n) {
      let s = new Map();
      for (let a of r) {
        let i = Hn(a.shape[e]);
        if (!i.length)
          throw new Error(
            `A discriminator value for key \`${e}\` could not be extracted from all schema options`,
          );
        for (let o of i) {
          if (s.has(o))
            throw new Error(
              `Discriminator property ${String(e)} has duplicate value ${String(o)}`,
            );
          s.set(o, a);
        }
      }
      return new t({
        typeName: ie.ZodDiscriminatedUnion,
        discriminator: e,
        options: r,
        optionsMap: s,
        ...ze(n),
      });
    }
  };
function hm(t, e) {
  let r = _s(t),
    n = _s(e);
  if (t === e) return { valid: !0, data: t };
  if (r === xe.object && n === xe.object) {
    let s = rt.objectKeys(e),
      a = rt.objectKeys(t).filter((o) => s.indexOf(o) !== -1),
      i = { ...t, ...e };
    for (let o of a) {
      let c = hm(t[o], e[o]);
      if (!c.valid) return { valid: !1 };
      i[o] = c.data;
    }
    return { valid: !0, data: i };
  } else if (r === xe.array && n === xe.array) {
    if (t.length !== e.length) return { valid: !1 };
    let s = [];
    for (let a = 0; a < t.length; a++) {
      let i = t[a],
        o = e[a],
        c = hm(i, o);
      if (!c.valid) return { valid: !1 };
      s.push(c.data);
    }
    return { valid: !0, data: s };
  } else
    return r === xe.date && n === xe.date && +t == +e
      ? { valid: !0, data: t }
      : { valid: !1 };
}
var ui = class extends Ge {
  _parse(e) {
    let { status: r, ctx: n } = this._processInputParams(e),
      s = (a, i) => {
        if (eS(a) || eS(i)) return De;
        let o = hm(a.value, i.value);
        return o.valid
          ? ((tS(a) || tS(i)) && r.dirty(), { status: r.value, value: o.data })
          : (me(n, { code: ne.invalid_intersection_types }), De);
      };
    return n.common.async
      ? Promise.all([
          this._def.left._parseAsync({ data: n.data, path: n.path, parent: n }),
          this._def.right._parseAsync({
            data: n.data,
            path: n.path,
            parent: n,
          }),
        ]).then(([a, i]) => s(a, i))
      : s(
          this._def.left._parseSync({ data: n.data, path: n.path, parent: n }),
          this._def.right._parseSync({ data: n.data, path: n.path, parent: n }),
        );
  }
};
ui.create = (t, e, r) =>
  new ui({ left: t, right: e, typeName: ie.ZodIntersection, ...ze(r) });
var Gn = class t extends Ge {
  _parse(e) {
    let { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== xe.array)
      return (
        me(n, {
          code: ne.invalid_type,
          expected: xe.array,
          received: n.parsedType,
        }),
        De
      );
    if (n.data.length < this._def.items.length)
      return (
        me(n, {
          code: ne.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array",
        }),
        De
      );
    !this._def.rest &&
      n.data.length > this._def.items.length &&
      (me(n, {
        code: ne.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array",
      }),
      r.dirty());
    let a = [...n.data]
      .map((i, o) => {
        let c = this._def.items[o] || this._def.rest;
        return c ? c._parse(new Wr(n, i, n.path, o)) : null;
      })
      .filter((i) => !!i);
    return n.common.async
      ? Promise.all(a).then((i) => fr.mergeArray(r, i))
      : fr.mergeArray(r, a);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new t({ ...this._def, rest: e });
  }
};
Gn.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Gn({ items: t, typeName: ie.ZodTuple, rest: null, ...ze(e) });
};
var gm = class t extends Ge {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(e) {
      let { status: r, ctx: n } = this._processInputParams(e);
      if (n.parsedType !== xe.object)
        return (
          me(n, {
            code: ne.invalid_type,
            expected: xe.object,
            received: n.parsedType,
          }),
          De
        );
      let s = [],
        a = this._def.keyType,
        i = this._def.valueType;
      for (let o in n.data)
        s.push({
          key: a._parse(new Wr(n, o, n.path, o)),
          value: i._parse(new Wr(n, n.data[o], n.path, o)),
          alwaysSet: o in n.data,
        });
      return n.common.async
        ? fr.mergeObjectAsync(r, s)
        : fr.mergeObjectSync(r, s);
    }
    get element() {
      return this._def.valueType;
    }
    static create(e, r, n) {
      return r instanceof Ge
        ? new t({ keyType: e, valueType: r, typeName: ie.ZodRecord, ...ze(n) })
        : new t({
            keyType: ii.create(),
            valueType: e,
            typeName: ie.ZodRecord,
            ...ze(r),
          });
    }
  },
  ec = class extends Ge {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(e) {
      let { status: r, ctx: n } = this._processInputParams(e);
      if (n.parsedType !== xe.map)
        return (
          me(n, {
            code: ne.invalid_type,
            expected: xe.map,
            received: n.parsedType,
          }),
          De
        );
      let s = this._def.keyType,
        a = this._def.valueType,
        i = [...n.data.entries()].map(([o, c], l) => ({
          key: s._parse(new Wr(n, o, n.path, [l, "key"])),
          value: a._parse(new Wr(n, c, n.path, [l, "value"])),
        }));
      if (n.common.async) {
        let o = new Map();
        return Promise.resolve().then(async () => {
          for (let c of i) {
            let l = await c.key,
              u = await c.value;
            if (l.status === "aborted" || u.status === "aborted") return De;
            ((l.status === "dirty" || u.status === "dirty") && r.dirty(),
              o.set(l.value, u.value));
          }
          return { status: r.value, value: o };
        });
      } else {
        let o = new Map();
        for (let c of i) {
          let l = c.key,
            u = c.value;
          if (l.status === "aborted" || u.status === "aborted") return De;
          ((l.status === "dirty" || u.status === "dirty") && r.dirty(),
            o.set(l.value, u.value));
        }
        return { status: r.value, value: o };
      }
    }
  };
ec.create = (t, e, r) =>
  new ec({ valueType: e, keyType: t, typeName: ie.ZodMap, ...ze(r) });
var tc = class t extends Ge {
  _parse(e) {
    let { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== xe.set)
      return (
        me(n, {
          code: ne.invalid_type,
          expected: xe.set,
          received: n.parsedType,
        }),
        De
      );
    let s = this._def;
    (s.minSize !== null &&
      n.data.size < s.minSize.value &&
      (me(n, {
        code: ne.too_small,
        minimum: s.minSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: s.minSize.message,
      }),
      r.dirty()),
      s.maxSize !== null &&
        n.data.size > s.maxSize.value &&
        (me(n, {
          code: ne.too_big,
          maximum: s.maxSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: s.maxSize.message,
        }),
        r.dirty()));
    let a = this._def.valueType;
    function i(c) {
      let l = new Set();
      for (let u of c) {
        if (u.status === "aborted") return De;
        (u.status === "dirty" && r.dirty(), l.add(u.value));
      }
      return { status: r.value, value: l };
    }
    let o = [...n.data.values()].map((c, l) =>
      a._parse(new Wr(n, c, n.path, l)),
    );
    return n.common.async ? Promise.all(o).then((c) => i(c)) : i(o);
  }
  min(e, r) {
    return new t({
      ...this._def,
      minSize: { value: e, message: Se.toString(r) },
    });
  }
  max(e, r) {
    return new t({
      ...this._def,
      maxSize: { value: e, message: Se.toString(r) },
    });
  }
  size(e, r) {
    return this.min(e, r).max(e, r);
  }
  nonempty(e) {
    return this.min(1, e);
  }
};
tc.create = (t, e) =>
  new tc({
    valueType: t,
    minSize: null,
    maxSize: null,
    typeName: ie.ZodSet,
    ...ze(e),
  });
var vm = class t extends Ge {
    constructor() {
      (super(...arguments), (this.validate = this.implement));
    }
    _parse(e) {
      let { ctx: r } = this._processInputParams(e);
      if (r.parsedType !== xe.function)
        return (
          me(r, {
            code: ne.invalid_type,
            expected: xe.function,
            received: r.parsedType,
          }),
          De
        );
      function n(o, c) {
        return fm({
          data: o,
          path: r.path,
          errorMaps: [
            r.common.contextualErrorMap,
            r.schemaErrorMap,
            pm(),
            Zo,
          ].filter((l) => !!l),
          issueData: { code: ne.invalid_arguments, argumentsError: c },
        });
      }
      function s(o, c) {
        return fm({
          data: o,
          path: r.path,
          errorMaps: [
            r.common.contextualErrorMap,
            r.schemaErrorMap,
            pm(),
            Zo,
          ].filter((l) => !!l),
          issueData: { code: ne.invalid_return_type, returnTypeError: c },
        });
      }
      let a = { errorMap: r.common.contextualErrorMap },
        i = r.data;
      if (this._def.returns instanceof ea) {
        let o = this;
        return vr(async function (...c) {
          let l = new Gr([]),
            u = await o._def.args.parseAsync(c, a).catch((p) => {
              throw (l.addIssue(n(c, p)), l);
            }),
            d = await Reflect.apply(i, this, u);
          return await o._def.returns._def.type.parseAsync(d, a).catch((p) => {
            throw (l.addIssue(s(d, p)), l);
          });
        });
      } else {
        let o = this;
        return vr(function (...c) {
          let l = o._def.args.safeParse(c, a);
          if (!l.success) throw new Gr([n(c, l.error)]);
          let u = Reflect.apply(i, this, l.data),
            d = o._def.returns.safeParse(u, a);
          if (!d.success) throw new Gr([s(u, d.error)]);
          return d.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...e) {
      return new t({ ...this._def, args: Gn.create(e).rest(ws.create()) });
    }
    returns(e) {
      return new t({ ...this._def, returns: e });
    }
    implement(e) {
      return this.parse(e);
    }
    strictImplement(e) {
      return this.parse(e);
    }
    static create(e, r, n) {
      return new t({
        args: e || Gn.create([]).rest(ws.create()),
        returns: r || ws.create(),
        typeName: ie.ZodFunction,
        ...ze(n),
      });
    }
  },
  di = class extends Ge {
    get schema() {
      return this._def.getter();
    }
    _parse(e) {
      let { ctx: r } = this._processInputParams(e);
      return this._def
        .getter()
        ._parse({ data: r.data, path: r.path, parent: r });
    }
  };
di.create = (t, e) => new di({ getter: t, typeName: ie.ZodLazy, ...ze(e) });
var pi = class extends Ge {
  _parse(e) {
    if (e.data !== this._def.value) {
      let r = this._getOrReturnCtx(e);
      return (
        me(r, {
          received: r.data,
          code: ne.invalid_literal,
          expected: this._def.value,
        }),
        De
      );
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
};
pi.create = (t, e) => new pi({ value: t, typeName: ie.ZodLiteral, ...ze(e) });
function d0(t, e) {
  return new fi({ values: t, typeName: ie.ZodEnum, ...ze(e) });
}
var fi = class t extends Ge {
  _parse(e) {
    if (typeof e.data != "string") {
      let r = this._getOrReturnCtx(e),
        n = this._def.values;
      return (
        me(r, {
          expected: rt.joinValues(n),
          received: r.parsedType,
          code: ne.invalid_type,
        }),
        De
      );
    }
    if (
      (this._cache || (this._cache = new Set(this._def.values)),
      !this._cache.has(e.data))
    ) {
      let r = this._getOrReturnCtx(e),
        n = this._def.values;
      return (
        me(r, { received: r.data, code: ne.invalid_enum_value, options: n }),
        De
      );
    }
    return vr(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    let e = {};
    for (let r of this._def.values) e[r] = r;
    return e;
  }
  get Values() {
    let e = {};
    for (let r of this._def.values) e[r] = r;
    return e;
  }
  get Enum() {
    let e = {};
    for (let r of this._def.values) e[r] = r;
    return e;
  }
  extract(e, r = this._def) {
    return t.create(e, { ...this._def, ...r });
  }
  exclude(e, r = this._def) {
    return t.create(
      this.options.filter((n) => !e.includes(n)),
      { ...this._def, ...r },
    );
  }
};
fi.create = d0;
var mi = class extends Ge {
  _parse(e) {
    let r = rt.getValidEnumValues(this._def.values),
      n = this._getOrReturnCtx(e);
    if (n.parsedType !== xe.string && n.parsedType !== xe.number) {
      let s = rt.objectValues(r);
      return (
        me(n, {
          expected: rt.joinValues(s),
          received: n.parsedType,
          code: ne.invalid_type,
        }),
        De
      );
    }
    if (
      (this._cache ||
        (this._cache = new Set(rt.getValidEnumValues(this._def.values))),
      !this._cache.has(e.data))
    ) {
      let s = rt.objectValues(r);
      return (
        me(n, { received: n.data, code: ne.invalid_enum_value, options: s }),
        De
      );
    }
    return vr(e.data);
  }
  get enum() {
    return this._def.values;
  }
};
mi.create = (t, e) =>
  new mi({ values: t, typeName: ie.ZodNativeEnum, ...ze(e) });
var ea = class extends Ge {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    let { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== xe.promise && r.common.async === !1)
      return (
        me(r, {
          code: ne.invalid_type,
          expected: xe.promise,
          received: r.parsedType,
        }),
        De
      );
    let n = r.parsedType === xe.promise ? r.data : Promise.resolve(r.data);
    return vr(
      n.then((s) =>
        this._def.type.parseAsync(s, {
          path: r.path,
          errorMap: r.common.contextualErrorMap,
        }),
      ),
    );
  }
};
ea.create = (t, e) => new ea({ type: t, typeName: ie.ZodPromise, ...ze(e) });
var un = class extends Ge {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ie.ZodEffects
      ? this._def.schema.sourceType()
      : this._def.schema;
  }
  _parse(e) {
    let { status: r, ctx: n } = this._processInputParams(e),
      s = this._def.effect || null,
      a = {
        addIssue: (i) => {
          (me(n, i), i.fatal ? r.abort() : r.dirty());
        },
        get path() {
          return n.path;
        },
      };
    if (((a.addIssue = a.addIssue.bind(a)), s.type === "preprocess")) {
      let i = s.transform(n.data, a);
      if (n.common.async)
        return Promise.resolve(i).then(async (o) => {
          if (r.value === "aborted") return De;
          let c = await this._def.schema._parseAsync({
            data: o,
            path: n.path,
            parent: n,
          });
          return c.status === "aborted"
            ? De
            : c.status === "dirty" || r.value === "dirty"
              ? Uo(c.value)
              : c;
        });
      {
        if (r.value === "aborted") return De;
        let o = this._def.schema._parseSync({
          data: i,
          path: n.path,
          parent: n,
        });
        return o.status === "aborted"
          ? De
          : o.status === "dirty" || r.value === "dirty"
            ? Uo(o.value)
            : o;
      }
    }
    if (s.type === "refinement") {
      let i = (o) => {
        let c = s.refinement(o, a);
        if (n.common.async) return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error(
            "Async refinement encountered during synchronous parse operation. Use .parseAsync instead.",
          );
        return o;
      };
      if (n.common.async === !1) {
        let o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n,
        });
        return o.status === "aborted"
          ? De
          : (o.status === "dirty" && r.dirty(),
            i(o.value),
            { status: r.value, value: o.value });
      } else
        return this._def.schema
          ._parseAsync({ data: n.data, path: n.path, parent: n })
          .then((o) =>
            o.status === "aborted"
              ? De
              : (o.status === "dirty" && r.dirty(),
                i(o.value).then(() => ({ status: r.value, value: o.value }))),
          );
    }
    if (s.type === "transform")
      if (n.common.async === !1) {
        let i = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n,
        });
        if (!ai(i)) return De;
        let o = s.transform(i.value, a);
        if (o instanceof Promise)
          throw new Error(
            "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.",
          );
        return { status: r.value, value: o };
      } else
        return this._def.schema
          ._parseAsync({ data: n.data, path: n.path, parent: n })
          .then((i) =>
            ai(i)
              ? Promise.resolve(s.transform(i.value, a)).then((o) => ({
                  status: r.value,
                  value: o,
                }))
              : De,
          );
    rt.assertNever(s);
  }
};
un.create = (t, e, r) =>
  new un({ schema: t, typeName: ie.ZodEffects, effect: e, ...ze(r) });
un.createWithPreprocess = (t, e, r) =>
  new un({
    schema: e,
    effect: { type: "preprocess", transform: t },
    typeName: ie.ZodEffects,
    ...ze(r),
  });
var ln = class extends Ge {
  _parse(e) {
    return this._getType(e) === xe.undefined
      ? vr(void 0)
      : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ln.create = (t, e) =>
  new ln({ innerType: t, typeName: ie.ZodOptional, ...ze(e) });
var Wn = class extends Ge {
  _parse(e) {
    return this._getType(e) === xe.null
      ? vr(null)
      : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
Wn.create = (t, e) =>
  new Wn({ innerType: t, typeName: ie.ZodNullable, ...ze(e) });
var hi = class extends Ge {
  _parse(e) {
    let { ctx: r } = this._processInputParams(e),
      n = r.data;
    return (
      r.parsedType === xe.undefined && (n = this._def.defaultValue()),
      this._def.innerType._parse({ data: n, path: r.path, parent: r })
    );
  }
  removeDefault() {
    return this._def.innerType;
  }
};
hi.create = (t, e) =>
  new hi({
    innerType: t,
    typeName: ie.ZodDefault,
    defaultValue: typeof e.default == "function" ? e.default : () => e.default,
    ...ze(e),
  });
var gi = class extends Ge {
  _parse(e) {
    let { ctx: r } = this._processInputParams(e),
      n = { ...r, common: { ...r.common, issues: [] } },
      s = this._def.innerType._parse({
        data: n.data,
        path: n.path,
        parent: { ...n },
      });
    return Gl(s)
      ? s.then((a) => ({
          status: "valid",
          value:
            a.status === "valid"
              ? a.value
              : this._def.catchValue({
                  get error() {
                    return new Gr(n.common.issues);
                  },
                  input: n.data,
                }),
        }))
      : {
          status: "valid",
          value:
            s.status === "valid"
              ? s.value
              : this._def.catchValue({
                  get error() {
                    return new Gr(n.common.issues);
                  },
                  input: n.data,
                }),
        };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
gi.create = (t, e) =>
  new gi({
    innerType: t,
    typeName: ie.ZodCatch,
    catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
    ...ze(e),
  });
var rc = class extends Ge {
  _parse(e) {
    if (this._getType(e) !== xe.nan) {
      let n = this._getOrReturnCtx(e);
      return (
        me(n, {
          code: ne.invalid_type,
          expected: xe.nan,
          received: n.parsedType,
        }),
        De
      );
    }
    return { status: "valid", value: e.data };
  }
};
rc.create = (t) => new rc({ typeName: ie.ZodNaN, ...ze(t) });
var nne = Symbol("zod_brand"),
  Wl = class extends Ge {
    _parse(e) {
      let { ctx: r } = this._processInputParams(e),
        n = r.data;
      return this._def.type._parse({ data: n, path: r.path, parent: r });
    }
    unwrap() {
      return this._def.type;
    }
  },
  Kl = class t extends Ge {
    _parse(e) {
      let { status: r, ctx: n } = this._processInputParams(e);
      if (n.common.async)
        return (async () => {
          let a = await this._def.in._parseAsync({
            data: n.data,
            path: n.path,
            parent: n,
          });
          return a.status === "aborted"
            ? De
            : a.status === "dirty"
              ? (r.dirty(), Uo(a.value))
              : this._def.out._parseAsync({
                  data: a.value,
                  path: n.path,
                  parent: n,
                });
        })();
      {
        let s = this._def.in._parseSync({
          data: n.data,
          path: n.path,
          parent: n,
        });
        return s.status === "aborted"
          ? De
          : s.status === "dirty"
            ? (r.dirty(), { status: "dirty", value: s.value })
            : this._def.out._parseSync({
                data: s.value,
                path: n.path,
                parent: n,
              });
      }
    }
    static create(e, r) {
      return new t({ in: e, out: r, typeName: ie.ZodPipeline });
    }
  },
  vi = class extends Ge {
    _parse(e) {
      let r = this._def.innerType._parse(e),
        n = (s) => (ai(s) && (s.value = Object.freeze(s.value)), s);
      return Gl(r) ? r.then((s) => n(s)) : n(r);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
vi.create = (t, e) =>
  new vi({ innerType: t, typeName: ie.ZodReadonly, ...ze(e) });
var sne = { object: Lr.lazycreate },
  ie;
(function (t) {
  ((t.ZodString = "ZodString"),
    (t.ZodNumber = "ZodNumber"),
    (t.ZodNaN = "ZodNaN"),
    (t.ZodBigInt = "ZodBigInt"),
    (t.ZodBoolean = "ZodBoolean"),
    (t.ZodDate = "ZodDate"),
    (t.ZodSymbol = "ZodSymbol"),
    (t.ZodUndefined = "ZodUndefined"),
    (t.ZodNull = "ZodNull"),
    (t.ZodAny = "ZodAny"),
    (t.ZodUnknown = "ZodUnknown"),
    (t.ZodNever = "ZodNever"),
    (t.ZodVoid = "ZodVoid"),
    (t.ZodArray = "ZodArray"),
    (t.ZodObject = "ZodObject"),
    (t.ZodUnion = "ZodUnion"),
    (t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
    (t.ZodIntersection = "ZodIntersection"),
    (t.ZodTuple = "ZodTuple"),
    (t.ZodRecord = "ZodRecord"),
    (t.ZodMap = "ZodMap"),
    (t.ZodSet = "ZodSet"),
    (t.ZodFunction = "ZodFunction"),
    (t.ZodLazy = "ZodLazy"),
    (t.ZodLiteral = "ZodLiteral"),
    (t.ZodEnum = "ZodEnum"),
    (t.ZodEffects = "ZodEffects"),
    (t.ZodNativeEnum = "ZodNativeEnum"),
    (t.ZodOptional = "ZodOptional"),
    (t.ZodNullable = "ZodNullable"),
    (t.ZodDefault = "ZodDefault"),
    (t.ZodCatch = "ZodCatch"),
    (t.ZodPromise = "ZodPromise"),
    (t.ZodBranded = "ZodBranded"),
    (t.ZodPipeline = "ZodPipeline"),
    (t.ZodReadonly = "ZodReadonly"));
})(ie || (ie = {}));
var ane = ii.create,
  ine = Go.create,
  one = rc.create,
  cne = Wo.create,
  lne = Ko.create,
  une = Jo.create,
  dne = Xo.create,
  pne = oi.create,
  fne = ci.create,
  mne = Yo.create,
  hne = ws.create,
  gne = kn.create,
  vne = Qo.create,
  yne = Ss.create,
  iz = Lr.create,
  bne = Lr.strictCreate,
  _ne = li.create,
  xne = mm.create,
  wne = ui.create,
  Sne = Gn.create,
  Ene = gm.create,
  Tne = ec.create,
  Cne = tc.create,
  Pne = vm.create,
  kne = di.create,
  Rne = pi.create,
  One = fi.create,
  Ine = mi.create,
  $ne = ea.create,
  Ane = un.create,
  Nne = ln.create,
  Dne = Wn.create,
  Lne = un.createWithPreprocess,
  Mne = Kl.create,
  jne = Object.freeze({ status: "aborted" });
function X(t, e, r) {
  function n(o, c) {
    var l;
    (Object.defineProperty(o, "_zod", { value: o._zod ?? {}, enumerable: !1 }),
      (l = o._zod).traits ?? (l.traits = new Set()),
      o._zod.traits.add(t),
      e(o, c));
    for (let u in i.prototype)
      u in o || Object.defineProperty(o, u, { value: i.prototype[u].bind(o) });
    ((o._zod.constr = i), (o._zod.def = c));
  }
  let s = r?.Parent ?? Object;
  class a extends s {}
  Object.defineProperty(a, "name", { value: t });
  function i(o) {
    var c;
    let l = r?.Parent ? new a() : this;
    (n(l, o), (c = l._zod).deferred ?? (c.deferred = []));
    for (let u of l._zod.deferred) u();
    return l;
  }
  return (
    Object.defineProperty(i, "init", { value: n }),
    Object.defineProperty(i, Symbol.hasInstance, {
      value: (o) =>
        r?.Parent && o instanceof r.Parent ? !0 : o?._zod?.traits?.has(t),
    }),
    Object.defineProperty(i, "name", { value: t }),
    i
  );
}
var Fne = Symbol("zod_brand"),
  ta = class extends Error {
    constructor() {
      super(
        "Encountered Promise during synchronous parse. Use .parseAsync() instead.",
      );
    }
  },
  ym = {};
function Kn(t) {
  return (t && Object.assign(ym, t), ym);
}
var ht = {};
NS(ht, {
  unwrapMessage: () => qo,
  stringifyPrimitive: () => Km,
  required: () => Tz,
  randomString: () => mz,
  propertyKeyTypes: () => h0,
  promiseAllObject: () => fz,
  primitiveTypes: () => vz,
  prefixIssues: () => xs,
  pick: () => _z,
  partial: () => Ez,
  optionalKeys: () => g0,
  omit: () => xz,
  numKeys: () => hz,
  nullish: () => du,
  normalizeParams: () => Ae,
  merge: () => Sz,
  jsonStringifyReplacer: () => p0,
  joinValues: () => bm,
  issue: () => y0,
  isPlainObject: () => sc,
  isObject: () => nc,
  getSizableOrigin: () => Cz,
  getParsedType: () => gz,
  getLengthableOrigin: () => fu,
  getEnumValues: () => Zm,
  getElementAtPath: () => pz,
  floatSafeRemainder: () => f0,
  finalizeIssue: () => Jn,
  extend: () => wz,
  escapeRegex: () => Si,
  esc: () => ni,
  defineLazy: () => Et,
  createTransparentProxy: () => yz,
  clone: () => Xn,
  cleanRegex: () => pu,
  cleanEnum: () => Pz,
  captureStackTrace: () => Wm,
  cached: () => uu,
  assignProp: () => Gm,
  assertNotEqual: () => cz,
  assertNever: () => uz,
  assertIs: () => lz,
  assertEqual: () => oz,
  assert: () => dz,
  allowsEval: () => m0,
  aborted: () => si,
  NUMBER_FORMAT_RANGES: () => v0,
  Class: () => _m,
  BIGINT_FORMAT_RANGES: () => bz,
});
function oz(t) {
  return t;
}
function cz(t) {
  return t;
}
function lz(t) {}
function uz(t) {
  throw new Error();
}
function dz(t) {}
function Zm(t) {
  let e = Object.values(t).filter((n) => typeof n == "number");
  return Object.entries(t)
    .filter(([n, s]) => e.indexOf(+n) === -1)
    .map(([n, s]) => s);
}
function bm(t, e = "|") {
  return t.map((r) => Km(r)).join(e);
}
function p0(t, e) {
  return typeof e == "bigint" ? e.toString() : e;
}
function uu(t) {
  return {
    get value() {
      {
        let r = t();
        return (Object.defineProperty(this, "value", { value: r }), r);
      }
      throw new Error("cached value already set");
    },
  };
}
function du(t) {
  return t == null;
}
function pu(t) {
  let e = t.startsWith("^") ? 1 : 0,
    r = t.endsWith("$") ? t.length - 1 : t.length;
  return t.slice(e, r);
}
function f0(t, e) {
  let r = (t.toString().split(".")[1] || "").length,
    n = (e.toString().split(".")[1] || "").length,
    s = r > n ? r : n,
    a = Number.parseInt(t.toFixed(s).replace(".", "")),
    i = Number.parseInt(e.toFixed(s).replace(".", ""));
  return (a % i) / 10 ** s;
}
function Et(t, e, r) {
  Object.defineProperty(t, e, {
    get() {
      {
        let s = r();
        return ((t[e] = s), s);
      }
      throw new Error("cached value already set");
    },
    set(s) {
      Object.defineProperty(t, e, { value: s });
    },
    configurable: !0,
  });
}
function Gm(t, e, r) {
  Object.defineProperty(t, e, {
    value: r,
    writable: !0,
    enumerable: !0,
    configurable: !0,
  });
}
function pz(t, e) {
  return e ? e.reduce((r, n) => r?.[n], t) : t;
}
function fz(t) {
  let e = Object.keys(t),
    r = e.map((n) => t[n]);
  return Promise.all(r).then((n) => {
    let s = {};
    for (let a = 0; a < e.length; a++) s[e[a]] = n[a];
    return s;
  });
}
function mz(t = 10) {
  let e = "abcdefghijklmnopqrstuvwxyz",
    r = "";
  for (let n = 0; n < t; n++) r += e[Math.floor(Math.random() * e.length)];
  return r;
}
function ni(t) {
  return JSON.stringify(t);
}
var Wm = Error.captureStackTrace ? Error.captureStackTrace : (...t) => {};
function nc(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t);
}
var m0 = uu(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    let t = Function;
    return (new t(""), !0);
  } catch {
    return !1;
  }
});
function sc(t) {
  if (nc(t) === !1) return !1;
  let e = t.constructor;
  if (e === void 0) return !0;
  let r = e.prototype;
  return !(
    nc(r) === !1 ||
    Object.prototype.hasOwnProperty.call(r, "isPrototypeOf") === !1
  );
}
function hz(t) {
  let e = 0;
  for (let r in t) Object.prototype.hasOwnProperty.call(t, r) && e++;
  return e;
}
var gz = (t) => {
    let e = typeof t;
    switch (e) {
      case "undefined":
        return "undefined";
      case "string":
        return "string";
      case "number":
        return Number.isNaN(t) ? "nan" : "number";
      case "boolean":
        return "boolean";
      case "function":
        return "function";
      case "bigint":
        return "bigint";
      case "symbol":
        return "symbol";
      case "object":
        return Array.isArray(t)
          ? "array"
          : t === null
            ? "null"
            : t.then &&
                typeof t.then == "function" &&
                t.catch &&
                typeof t.catch == "function"
              ? "promise"
              : typeof Map < "u" && t instanceof Map
                ? "map"
                : typeof Set < "u" && t instanceof Set
                  ? "set"
                  : typeof Date < "u" && t instanceof Date
                    ? "date"
                    : typeof File < "u" && t instanceof File
                      ? "file"
                      : "object";
      default:
        throw new Error(`Unknown data type: ${e}`);
    }
  },
  h0 = new Set(["string", "number", "symbol"]),
  vz = new Set([
    "string",
    "number",
    "bigint",
    "boolean",
    "symbol",
    "undefined",
  ]);
function Si(t) {
  return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Xn(t, e, r) {
  let n = new t._zod.constr(e ?? t._zod.def);
  return ((!e || r?.parent) && (n._zod.parent = t), n);
}
function Ae(t) {
  let e = t;
  if (!e) return {};
  if (typeof e == "string") return { error: () => e };
  if (e?.message !== void 0) {
    if (e?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    e.error = e.message;
  }
  return (
    delete e.message,
    typeof e.error == "string" ? { ...e, error: () => e.error } : e
  );
}
function yz(t) {
  let e;
  return new Proxy(
    {},
    {
      get(r, n, s) {
        return (e ?? (e = t()), Reflect.get(e, n, s));
      },
      set(r, n, s, a) {
        return (e ?? (e = t()), Reflect.set(e, n, s, a));
      },
      has(r, n) {
        return (e ?? (e = t()), Reflect.has(e, n));
      },
      deleteProperty(r, n) {
        return (e ?? (e = t()), Reflect.deleteProperty(e, n));
      },
      ownKeys(r) {
        return (e ?? (e = t()), Reflect.ownKeys(e));
      },
      getOwnPropertyDescriptor(r, n) {
        return (e ?? (e = t()), Reflect.getOwnPropertyDescriptor(e, n));
      },
      defineProperty(r, n, s) {
        return (e ?? (e = t()), Reflect.defineProperty(e, n, s));
      },
    },
  );
}
function Km(t) {
  return typeof t == "bigint"
    ? t.toString() + "n"
    : typeof t == "string"
      ? `"${t}"`
      : `${t}`;
}
function g0(t) {
  return Object.keys(t).filter(
    (e) => t[e]._zod.optin === "optional" && t[e]._zod.optout === "optional",
  );
}
var v0 = {
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
    int32: [-2147483648, 2147483647],
    uint32: [0, 4294967295],
    float32: [-34028234663852886e22, 34028234663852886e22],
    float64: [-Number.MAX_VALUE, Number.MAX_VALUE],
  },
  bz = {
    int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")],
    uint64: [BigInt(0), BigInt("18446744073709551615")],
  };
function _z(t, e) {
  let r = {},
    n = t._zod.def;
  for (let s in e) {
    if (!(s in n.shape)) throw new Error(`Unrecognized key: "${s}"`);
    e[s] && (r[s] = n.shape[s]);
  }
  return Xn(t, { ...t._zod.def, shape: r, checks: [] });
}
function xz(t, e) {
  let r = { ...t._zod.def.shape },
    n = t._zod.def;
  for (let s in e) {
    if (!(s in n.shape)) throw new Error(`Unrecognized key: "${s}"`);
    e[s] && delete r[s];
  }
  return Xn(t, { ...t._zod.def, shape: r, checks: [] });
}
function wz(t, e) {
  if (!sc(e))
    throw new Error("Invalid input to extend: expected a plain object");
  let r = {
    ...t._zod.def,
    get shape() {
      let n = { ...t._zod.def.shape, ...e };
      return (Gm(this, "shape", n), n);
    },
    checks: [],
  };
  return Xn(t, r);
}
function Sz(t, e) {
  return Xn(t, {
    ...t._zod.def,
    get shape() {
      let r = { ...t._zod.def.shape, ...e._zod.def.shape };
      return (Gm(this, "shape", r), r);
    },
    catchall: e._zod.def.catchall,
    checks: [],
  });
}
function Ez(t, e, r) {
  let n = e._zod.def.shape,
    s = { ...n };
  if (r)
    for (let a in r) {
      if (!(a in n)) throw new Error(`Unrecognized key: "${a}"`);
      r[a] && (s[a] = t ? new t({ type: "optional", innerType: n[a] }) : n[a]);
    }
  else
    for (let a in n)
      s[a] = t ? new t({ type: "optional", innerType: n[a] }) : n[a];
  return Xn(e, { ...e._zod.def, shape: s, checks: [] });
}
function Tz(t, e, r) {
  let n = e._zod.def.shape,
    s = { ...n };
  if (r)
    for (let a in r) {
      if (!(a in s)) throw new Error(`Unrecognized key: "${a}"`);
      r[a] && (s[a] = new t({ type: "nonoptional", innerType: n[a] }));
    }
  else for (let a in n) s[a] = new t({ type: "nonoptional", innerType: n[a] });
  return Xn(e, { ...e._zod.def, shape: s, checks: [] });
}
function si(t, e = 0) {
  for (let r = e; r < t.issues.length; r++)
    if (t.issues[r]?.continue !== !0) return !0;
  return !1;
}
function xs(t, e) {
  return e.map((r) => {
    var n;
    return ((n = r).path ?? (n.path = []), r.path.unshift(t), r);
  });
}
function qo(t) {
  return typeof t == "string" ? t : t?.message;
}
function Jn(t, e, r) {
  let n = { ...t, path: t.path ?? [] };
  if (!t.message) {
    let s =
      qo(t.inst?._zod.def?.error?.(t)) ??
      qo(e?.error?.(t)) ??
      qo(r.customError?.(t)) ??
      qo(r.localeError?.(t)) ??
      "Invalid input";
    n.message = s;
  }
  return (
    delete n.inst,
    delete n.continue,
    e?.reportInput || delete n.input,
    n
  );
}
function Cz(t) {
  return t instanceof Set
    ? "set"
    : t instanceof Map
      ? "map"
      : t instanceof File
        ? "file"
        : "unknown";
}
function fu(t) {
  return Array.isArray(t)
    ? "array"
    : typeof t == "string"
      ? "string"
      : "unknown";
}
function y0(...t) {
  let [e, r, n] = t;
  return typeof e == "string"
    ? { message: e, code: "custom", input: r, inst: n }
    : { ...e };
}
function Pz(t) {
  return Object.entries(t)
    .filter(([e, r]) => Number.isNaN(Number.parseInt(e, 10)))
    .map((e) => e[1]);
}
var _m = class {
    constructor(...e) {}
  },
  b0 = (t, e) => {
    ((t.name = "$ZodError"),
      Object.defineProperty(t, "_zod", { value: t._zod, enumerable: !1 }),
      Object.defineProperty(t, "issues", { value: e, enumerable: !1 }),
      Object.defineProperty(t, "message", {
        get() {
          return JSON.stringify(e, p0, 2);
        },
        enumerable: !0,
      }));
  },
  _0 = X("$ZodError", b0),
  mu = X("$ZodError", b0, { Parent: Error });
function kz(t, e = (r) => r.message) {
  let r = {},
    n = [];
  for (let s of t.issues)
    s.path.length > 0
      ? ((r[s.path[0]] = r[s.path[0]] || []), r[s.path[0]].push(e(s)))
      : n.push(e(s));
  return { formErrors: n, fieldErrors: r };
}
function Rz(t, e) {
  let r =
      e ||
      function (a) {
        return a.message;
      },
    n = { _errors: [] },
    s = (a) => {
      for (let i of a.issues)
        if (i.code === "invalid_union" && i.errors.length)
          i.errors.map((o) => s({ issues: o }));
        else if (i.code === "invalid_key") s({ issues: i.issues });
        else if (i.code === "invalid_element") s({ issues: i.issues });
        else if (i.path.length === 0) n._errors.push(r(i));
        else {
          let o = n,
            c = 0;
          for (; c < i.path.length; ) {
            let l = i.path[c];
            (c === i.path.length - 1
              ? ((o[l] = o[l] || { _errors: [] }), o[l]._errors.push(r(i)))
              : (o[l] = o[l] || { _errors: [] }),
              (o = o[l]),
              c++);
          }
        }
    };
  return (s(t), n);
}
var x0 = (t) => (e, r, n, s) => {
    let a = n ? Object.assign(n, { async: !1 }) : { async: !1 },
      i = e._zod.run({ value: r, issues: [] }, a);
    if (i instanceof Promise) throw new ta();
    if (i.issues.length) {
      let o = new (s?.Err ?? t)(i.issues.map((c) => Jn(c, a, Kn())));
      throw (Wm(o, s?.callee), o);
    }
    return i.value;
  },
  Oz = x0(mu),
  w0 = (t) => async (e, r, n, s) => {
    let a = n ? Object.assign(n, { async: !0 }) : { async: !0 },
      i = e._zod.run({ value: r, issues: [] }, a);
    if ((i instanceof Promise && (i = await i), i.issues.length)) {
      let o = new (s?.Err ?? t)(i.issues.map((c) => Jn(c, a, Kn())));
      throw (Wm(o, s?.callee), o);
    }
    return i.value;
  },
  Iz = w0(mu),
  S0 = (t) => (e, r, n) => {
    let s = n ? { ...n, async: !1 } : { async: !1 },
      a = e._zod.run({ value: r, issues: [] }, s);
    if (a instanceof Promise) throw new ta();
    return a.issues.length
      ? {
          success: !1,
          error: new (t ?? _0)(a.issues.map((i) => Jn(i, s, Kn()))),
        }
      : { success: !0, data: a.value };
  },
  Jm = S0(mu),
  E0 = (t) => async (e, r, n) => {
    let s = n ? Object.assign(n, { async: !0 }) : { async: !0 },
      a = e._zod.run({ value: r, issues: [] }, s);
    return (
      a instanceof Promise && (a = await a),
      a.issues.length
        ? { success: !1, error: new t(a.issues.map((i) => Jn(i, s, Kn()))) }
        : { success: !0, data: a.value }
    );
  },
  Xm = E0(mu),
  $z = /^[cC][^\s-]{8,}$/,
  Az = /^[0-9a-z]+$/,
  Nz = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/,
  Dz = /^[0-9a-vA-V]{20}$/,
  Lz = /^[A-Za-z0-9]{27}$/,
  Mz = /^[a-zA-Z0-9_-]{21}$/,
  jz =
    /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/,
  Fz =
    /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/,
  nS = (t) =>
    t
      ? new RegExp(
          `^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${t}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`,
        )
      : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/,
  Uz =
    /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/,
  qz = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function zz() {
  return new RegExp(qz, "u");
}
var Bz =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  Hz =
    /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/,
  Vz =
    /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/,
  Zz =
    /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  Gz =
    /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/,
  T0 = /^[A-Za-z0-9_-]*$/,
  Wz = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/,
  Kz = /^\+(?:[0-9]){6,14}[0-9]$/,
  C0 =
    "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))",
  Jz = new RegExp(`^${C0}$`);
function P0(t) {
  let e = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof t.precision == "number"
    ? t.precision === -1
      ? `${e}`
      : t.precision === 0
        ? `${e}:[0-5]\\d`
        : `${e}:[0-5]\\d\\.\\d{${t.precision}}`
    : `${e}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function Xz(t) {
  return new RegExp(`^${P0(t)}$`);
}
function Yz(t) {
  let e = P0({ precision: t.precision }),
    r = ["Z"];
  (t.local && r.push(""), t.offset && r.push("([+-]\\d{2}:\\d{2})"));
  let n = `${e}(?:${r.join("|")})`;
  return new RegExp(`^${C0}T(?:${n})$`);
}
var Qz = (t) => {
    let e = t
      ? `[\\s\\S]{${t?.minimum ?? 0},${t?.maximum ?? ""}}`
      : "[\\s\\S]*";
    return new RegExp(`^${e}$`);
  },
  e9 = /^\d+$/,
  t9 = /^-?\d+(?:\.\d+)?/i,
  r9 = /true|false/i,
  n9 = /null/i,
  s9 = /^[^A-Z]*$/,
  a9 = /^[^a-z]*$/,
  br = X("$ZodCheck", (t, e) => {
    var r;
    (t._zod ?? (t._zod = {}),
      (t._zod.def = e),
      (r = t._zod).onattach ?? (r.onattach = []));
  }),
  k0 = { number: "number", bigint: "bigint", object: "date" },
  R0 = X("$ZodCheckLessThan", (t, e) => {
    br.init(t, e);
    let r = k0[typeof e.value];
    (t._zod.onattach.push((n) => {
      let s = n._zod.bag,
        a =
          (e.inclusive ? s.maximum : s.exclusiveMaximum) ??
          Number.POSITIVE_INFINITY;
      e.value < a &&
        (e.inclusive ? (s.maximum = e.value) : (s.exclusiveMaximum = e.value));
    }),
      (t._zod.check = (n) => {
        (e.inclusive ? n.value <= e.value : n.value < e.value) ||
          n.issues.push({
            origin: r,
            code: "too_big",
            maximum: e.value,
            input: n.value,
            inclusive: e.inclusive,
            inst: t,
            continue: !e.abort,
          });
      }));
  }),
  O0 = X("$ZodCheckGreaterThan", (t, e) => {
    br.init(t, e);
    let r = k0[typeof e.value];
    (t._zod.onattach.push((n) => {
      let s = n._zod.bag,
        a =
          (e.inclusive ? s.minimum : s.exclusiveMinimum) ??
          Number.NEGATIVE_INFINITY;
      e.value > a &&
        (e.inclusive ? (s.minimum = e.value) : (s.exclusiveMinimum = e.value));
    }),
      (t._zod.check = (n) => {
        (e.inclusive ? n.value >= e.value : n.value > e.value) ||
          n.issues.push({
            origin: r,
            code: "too_small",
            minimum: e.value,
            input: n.value,
            inclusive: e.inclusive,
            inst: t,
            continue: !e.abort,
          });
      }));
  }),
  i9 = X("$ZodCheckMultipleOf", (t, e) => {
    (br.init(t, e),
      t._zod.onattach.push((r) => {
        var n;
        (n = r._zod.bag).multipleOf ?? (n.multipleOf = e.value);
      }),
      (t._zod.check = (r) => {
        if (typeof r.value != typeof e.value)
          throw new Error("Cannot mix number and bigint in multiple_of check.");
        (typeof r.value == "bigint"
          ? r.value % e.value === BigInt(0)
          : f0(r.value, e.value) === 0) ||
          r.issues.push({
            origin: typeof r.value,
            code: "not_multiple_of",
            divisor: e.value,
            input: r.value,
            inst: t,
            continue: !e.abort,
          });
      }));
  }),
  o9 = X("$ZodCheckNumberFormat", (t, e) => {
    (br.init(t, e), (e.format = e.format || "float64"));
    let r = e.format?.includes("int"),
      n = r ? "int" : "number",
      [s, a] = v0[e.format];
    (t._zod.onattach.push((i) => {
      let o = i._zod.bag;
      ((o.format = e.format),
        (o.minimum = s),
        (o.maximum = a),
        r && (o.pattern = e9));
    }),
      (t._zod.check = (i) => {
        let o = i.value;
        if (r) {
          if (!Number.isInteger(o)) {
            i.issues.push({
              expected: n,
              format: e.format,
              code: "invalid_type",
              input: o,
              inst: t,
            });
            return;
          }
          if (!Number.isSafeInteger(o)) {
            o > 0
              ? i.issues.push({
                  input: o,
                  code: "too_big",
                  maximum: Number.MAX_SAFE_INTEGER,
                  note: "Integers must be within the safe integer range.",
                  inst: t,
                  origin: n,
                  continue: !e.abort,
                })
              : i.issues.push({
                  input: o,
                  code: "too_small",
                  minimum: Number.MIN_SAFE_INTEGER,
                  note: "Integers must be within the safe integer range.",
                  inst: t,
                  origin: n,
                  continue: !e.abort,
                });
            return;
          }
        }
        (o < s &&
          i.issues.push({
            origin: "number",
            input: o,
            code: "too_small",
            minimum: s,
            inclusive: !0,
            inst: t,
            continue: !e.abort,
          }),
          o > a &&
            i.issues.push({
              origin: "number",
              input: o,
              code: "too_big",
              maximum: a,
              inst: t,
            }));
      }));
  }),
  c9 = X("$ZodCheckMaxLength", (t, e) => {
    (br.init(t, e),
      (t._zod.when = (r) => {
        let n = r.value;
        return !du(n) && n.length !== void 0;
      }),
      t._zod.onattach.push((r) => {
        let n = r._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        e.maximum < n && (r._zod.bag.maximum = e.maximum);
      }),
      (t._zod.check = (r) => {
        let n = r.value;
        if (n.length <= e.maximum) return;
        let a = fu(n);
        r.issues.push({
          origin: a,
          code: "too_big",
          maximum: e.maximum,
          inclusive: !0,
          input: n,
          inst: t,
          continue: !e.abort,
        });
      }));
  }),
  l9 = X("$ZodCheckMinLength", (t, e) => {
    (br.init(t, e),
      (t._zod.when = (r) => {
        let n = r.value;
        return !du(n) && n.length !== void 0;
      }),
      t._zod.onattach.push((r) => {
        let n = r._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        e.minimum > n && (r._zod.bag.minimum = e.minimum);
      }),
      (t._zod.check = (r) => {
        let n = r.value;
        if (n.length >= e.minimum) return;
        let a = fu(n);
        r.issues.push({
          origin: a,
          code: "too_small",
          minimum: e.minimum,
          inclusive: !0,
          input: n,
          inst: t,
          continue: !e.abort,
        });
      }));
  }),
  u9 = X("$ZodCheckLengthEquals", (t, e) => {
    (br.init(t, e),
      (t._zod.when = (r) => {
        let n = r.value;
        return !du(n) && n.length !== void 0;
      }),
      t._zod.onattach.push((r) => {
        let n = r._zod.bag;
        ((n.minimum = e.length), (n.maximum = e.length), (n.length = e.length));
      }),
      (t._zod.check = (r) => {
        let n = r.value,
          s = n.length;
        if (s === e.length) return;
        let a = fu(n),
          i = s > e.length;
        r.issues.push({
          origin: a,
          ...(i
            ? { code: "too_big", maximum: e.length }
            : { code: "too_small", minimum: e.length }),
          inclusive: !0,
          exact: !0,
          input: r.value,
          inst: t,
          continue: !e.abort,
        });
      }));
  }),
  hu = X("$ZodCheckStringFormat", (t, e) => {
    var r, n;
    (br.init(t, e),
      t._zod.onattach.push((s) => {
        let a = s._zod.bag;
        ((a.format = e.format),
          e.pattern &&
            (a.patterns ?? (a.patterns = new Set()),
            a.patterns.add(e.pattern)));
      }),
      e.pattern
        ? ((r = t._zod).check ??
          (r.check = (s) => {
            ((e.pattern.lastIndex = 0),
              !e.pattern.test(s.value) &&
                s.issues.push({
                  origin: "string",
                  code: "invalid_format",
                  format: e.format,
                  input: s.value,
                  ...(e.pattern ? { pattern: e.pattern.toString() } : {}),
                  inst: t,
                  continue: !e.abort,
                }));
          }))
        : ((n = t._zod).check ?? (n.check = () => {})));
  }),
  d9 = X("$ZodCheckRegex", (t, e) => {
    (hu.init(t, e),
      (t._zod.check = (r) => {
        ((e.pattern.lastIndex = 0),
          !e.pattern.test(r.value) &&
            r.issues.push({
              origin: "string",
              code: "invalid_format",
              format: "regex",
              input: r.value,
              pattern: e.pattern.toString(),
              inst: t,
              continue: !e.abort,
            }));
      }));
  }),
  p9 = X("$ZodCheckLowerCase", (t, e) => {
    (e.pattern ?? (e.pattern = s9), hu.init(t, e));
  }),
  f9 = X("$ZodCheckUpperCase", (t, e) => {
    (e.pattern ?? (e.pattern = a9), hu.init(t, e));
  }),
  m9 = X("$ZodCheckIncludes", (t, e) => {
    br.init(t, e);
    let r = Si(e.includes),
      n = new RegExp(
        typeof e.position == "number" ? `^.{${e.position}}${r}` : r,
      );
    ((e.pattern = n),
      t._zod.onattach.push((s) => {
        let a = s._zod.bag;
        (a.patterns ?? (a.patterns = new Set()), a.patterns.add(n));
      }),
      (t._zod.check = (s) => {
        s.value.includes(e.includes, e.position) ||
          s.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "includes",
            includes: e.includes,
            input: s.value,
            inst: t,
            continue: !e.abort,
          });
      }));
  }),
  h9 = X("$ZodCheckStartsWith", (t, e) => {
    br.init(t, e);
    let r = new RegExp(`^${Si(e.prefix)}.*`);
    (e.pattern ?? (e.pattern = r),
      t._zod.onattach.push((n) => {
        let s = n._zod.bag;
        (s.patterns ?? (s.patterns = new Set()), s.patterns.add(r));
      }),
      (t._zod.check = (n) => {
        n.value.startsWith(e.prefix) ||
          n.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "starts_with",
            prefix: e.prefix,
            input: n.value,
            inst: t,
            continue: !e.abort,
          });
      }));
  }),
  g9 = X("$ZodCheckEndsWith", (t, e) => {
    br.init(t, e);
    let r = new RegExp(`.*${Si(e.suffix)}$`);
    (e.pattern ?? (e.pattern = r),
      t._zod.onattach.push((n) => {
        let s = n._zod.bag;
        (s.patterns ?? (s.patterns = new Set()), s.patterns.add(r));
      }),
      (t._zod.check = (n) => {
        n.value.endsWith(e.suffix) ||
          n.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "ends_with",
            suffix: e.suffix,
            input: n.value,
            inst: t,
            continue: !e.abort,
          });
      }));
  }),
  v9 = X("$ZodCheckOverwrite", (t, e) => {
    (br.init(t, e),
      (t._zod.check = (r) => {
        r.value = e.tx(r.value);
      }));
  }),
  xm = class {
    constructor(e = []) {
      ((this.content = []), (this.indent = 0), this && (this.args = e));
    }
    indented(e) {
      ((this.indent += 1), e(this), (this.indent -= 1));
    }
    write(e) {
      if (typeof e == "function") {
        (e(this, { execution: "sync" }), e(this, { execution: "async" }));
        return;
      }
      let n = e
          .split(
            `
`,
          )
          .filter((i) => i),
        s = Math.min(...n.map((i) => i.length - i.trimStart().length)),
        a = n
          .map((i) => i.slice(s))
          .map((i) => " ".repeat(this.indent * 2) + i);
      for (let i of a) this.content.push(i);
    }
    compile() {
      let e = Function,
        r = this?.args,
        s = [...(this?.content ?? [""]).map((a) => `  ${a}`)];
      return new e(
        ...r,
        s.join(`
`),
      );
    }
  },
  y9 = { major: 4, minor: 0, patch: 0 },
  xt = X("$ZodType", (t, e) => {
    var r;
    (t ?? (t = {}),
      (t._zod.def = e),
      (t._zod.bag = t._zod.bag || {}),
      (t._zod.version = y9));
    let n = [...(t._zod.def.checks ?? [])];
    t._zod.traits.has("$ZodCheck") && n.unshift(t);
    for (let s of n) for (let a of s._zod.onattach) a(t);
    if (n.length === 0)
      ((r = t._zod).deferred ?? (r.deferred = []),
        t._zod.deferred?.push(() => {
          t._zod.run = t._zod.parse;
        }));
    else {
      let s = (a, i, o) => {
        let c = si(a),
          l;
        for (let u of i) {
          if (u._zod.when) {
            if (!u._zod.when(a)) continue;
          } else if (c) continue;
          let d = a.issues.length,
            m = u._zod.check(a);
          if (m instanceof Promise && o?.async === !1) throw new ta();
          if (l || m instanceof Promise)
            l = (l ?? Promise.resolve()).then(async () => {
              (await m, a.issues.length !== d && (c || (c = si(a, d))));
            });
          else {
            if (a.issues.length === d) continue;
            c || (c = si(a, d));
          }
        }
        return l ? l.then(() => a) : a;
      };
      t._zod.run = (a, i) => {
        let o = t._zod.parse(a, i);
        if (o instanceof Promise) {
          if (i.async === !1) throw new ta();
          return o.then((c) => s(c, n, i));
        }
        return s(o, n, i);
      };
    }
    t["~standard"] = {
      validate: (s) => {
        try {
          let a = Jm(t, s);
          return a.success ? { value: a.data } : { issues: a.error?.issues };
        } catch {
          return Xm(t, s).then((i) =>
            i.success ? { value: i.data } : { issues: i.error?.issues },
          );
        }
      },
      vendor: "zod",
      version: 1,
    };
  }),
  Ym = X("$ZodString", (t, e) => {
    (xt.init(t, e),
      (t._zod.pattern =
        [...(t?._zod.bag?.patterns ?? [])].pop() ?? Qz(t._zod.bag)),
      (t._zod.parse = (r, n) => {
        if (e.coerce)
          try {
            r.value = String(r.value);
          } catch {}
        return (
          typeof r.value == "string" ||
            r.issues.push({
              expected: "string",
              code: "invalid_type",
              input: r.value,
              inst: t,
            }),
          r
        );
      }));
  }),
  Ct = X("$ZodStringFormat", (t, e) => {
    (hu.init(t, e), Ym.init(t, e));
  }),
  b9 = X("$ZodGUID", (t, e) => {
    (e.pattern ?? (e.pattern = Fz), Ct.init(t, e));
  }),
  _9 = X("$ZodUUID", (t, e) => {
    if (e.version) {
      let n = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[
        e.version
      ];
      if (n === void 0) throw new Error(`Invalid UUID version: "${e.version}"`);
      e.pattern ?? (e.pattern = nS(n));
    } else e.pattern ?? (e.pattern = nS());
    Ct.init(t, e);
  }),
  x9 = X("$ZodEmail", (t, e) => {
    (e.pattern ?? (e.pattern = Uz), Ct.init(t, e));
  }),
  w9 = X("$ZodURL", (t, e) => {
    (Ct.init(t, e),
      (t._zod.check = (r) => {
        try {
          let n = r.value,
            s = new URL(n),
            a = s.href;
          (e.hostname &&
            ((e.hostname.lastIndex = 0),
            e.hostname.test(s.hostname) ||
              r.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid hostname",
                pattern: Wz.source,
                input: r.value,
                inst: t,
                continue: !e.abort,
              })),
            e.protocol &&
              ((e.protocol.lastIndex = 0),
              e.protocol.test(
                s.protocol.endsWith(":") ? s.protocol.slice(0, -1) : s.protocol,
              ) ||
                r.issues.push({
                  code: "invalid_format",
                  format: "url",
                  note: "Invalid protocol",
                  pattern: e.protocol.source,
                  input: r.value,
                  inst: t,
                  continue: !e.abort,
                })),
            !n.endsWith("/") && a.endsWith("/")
              ? (r.value = a.slice(0, -1))
              : (r.value = a));
          return;
        } catch {
          r.issues.push({
            code: "invalid_format",
            format: "url",
            input: r.value,
            inst: t,
            continue: !e.abort,
          });
        }
      }));
  }),
  S9 = X("$ZodEmoji", (t, e) => {
    (e.pattern ?? (e.pattern = zz()), Ct.init(t, e));
  }),
  E9 = X("$ZodNanoID", (t, e) => {
    (e.pattern ?? (e.pattern = Mz), Ct.init(t, e));
  }),
  T9 = X("$ZodCUID", (t, e) => {
    (e.pattern ?? (e.pattern = $z), Ct.init(t, e));
  }),
  C9 = X("$ZodCUID2", (t, e) => {
    (e.pattern ?? (e.pattern = Az), Ct.init(t, e));
  }),
  P9 = X("$ZodULID", (t, e) => {
    (e.pattern ?? (e.pattern = Nz), Ct.init(t, e));
  }),
  k9 = X("$ZodXID", (t, e) => {
    (e.pattern ?? (e.pattern = Dz), Ct.init(t, e));
  }),
  R9 = X("$ZodKSUID", (t, e) => {
    (e.pattern ?? (e.pattern = Lz), Ct.init(t, e));
  }),
  O9 = X("$ZodISODateTime", (t, e) => {
    (e.pattern ?? (e.pattern = Yz(e)), Ct.init(t, e));
  }),
  I9 = X("$ZodISODate", (t, e) => {
    (e.pattern ?? (e.pattern = Jz), Ct.init(t, e));
  }),
  $9 = X("$ZodISOTime", (t, e) => {
    (e.pattern ?? (e.pattern = Xz(e)), Ct.init(t, e));
  }),
  A9 = X("$ZodISODuration", (t, e) => {
    (e.pattern ?? (e.pattern = jz), Ct.init(t, e));
  }),
  N9 = X("$ZodIPv4", (t, e) => {
    (e.pattern ?? (e.pattern = Bz),
      Ct.init(t, e),
      t._zod.onattach.push((r) => {
        let n = r._zod.bag;
        n.format = "ipv4";
      }));
  }),
  D9 = X("$ZodIPv6", (t, e) => {
    (e.pattern ?? (e.pattern = Hz),
      Ct.init(t, e),
      t._zod.onattach.push((r) => {
        let n = r._zod.bag;
        n.format = "ipv6";
      }),
      (t._zod.check = (r) => {
        try {
          new URL(`http://[${r.value}]`);
        } catch {
          r.issues.push({
            code: "invalid_format",
            format: "ipv6",
            input: r.value,
            inst: t,
            continue: !e.abort,
          });
        }
      }));
  }),
  L9 = X("$ZodCIDRv4", (t, e) => {
    (e.pattern ?? (e.pattern = Vz), Ct.init(t, e));
  }),
  M9 = X("$ZodCIDRv6", (t, e) => {
    (e.pattern ?? (e.pattern = Zz),
      Ct.init(t, e),
      (t._zod.check = (r) => {
        let [n, s] = r.value.split("/");
        try {
          if (!s) throw new Error();
          let a = Number(s);
          if (`${a}` !== s) throw new Error();
          if (a < 0 || a > 128) throw new Error();
          new URL(`http://[${n}]`);
        } catch {
          r.issues.push({
            code: "invalid_format",
            format: "cidrv6",
            input: r.value,
            inst: t,
            continue: !e.abort,
          });
        }
      }));
  });
function I0(t) {
  if (t === "") return !0;
  if (t.length % 4 !== 0) return !1;
  try {
    return (atob(t), !0);
  } catch {
    return !1;
  }
}
var j9 = X("$ZodBase64", (t, e) => {
  (e.pattern ?? (e.pattern = Gz),
    Ct.init(t, e),
    t._zod.onattach.push((r) => {
      r._zod.bag.contentEncoding = "base64";
    }),
    (t._zod.check = (r) => {
      I0(r.value) ||
        r.issues.push({
          code: "invalid_format",
          format: "base64",
          input: r.value,
          inst: t,
          continue: !e.abort,
        });
    }));
});
function F9(t) {
  if (!T0.test(t)) return !1;
  let e = t.replace(/[-_]/g, (n) => (n === "-" ? "+" : "/")),
    r = e.padEnd(Math.ceil(e.length / 4) * 4, "=");
  return I0(r);
}
var U9 = X("$ZodBase64URL", (t, e) => {
    (e.pattern ?? (e.pattern = T0),
      Ct.init(t, e),
      t._zod.onattach.push((r) => {
        r._zod.bag.contentEncoding = "base64url";
      }),
      (t._zod.check = (r) => {
        F9(r.value) ||
          r.issues.push({
            code: "invalid_format",
            format: "base64url",
            input: r.value,
            inst: t,
            continue: !e.abort,
          });
      }));
  }),
  q9 = X("$ZodE164", (t, e) => {
    (e.pattern ?? (e.pattern = Kz), Ct.init(t, e));
  });
function z9(t, e = null) {
  try {
    let r = t.split(".");
    if (r.length !== 3) return !1;
    let [n] = r;
    if (!n) return !1;
    let s = JSON.parse(atob(n));
    return !(
      ("typ" in s && s?.typ !== "JWT") ||
      !s.alg ||
      (e && (!("alg" in s) || s.alg !== e))
    );
  } catch {
    return !1;
  }
}
var B9 = X("$ZodJWT", (t, e) => {
    (Ct.init(t, e),
      (t._zod.check = (r) => {
        z9(r.value, e.alg) ||
          r.issues.push({
            code: "invalid_format",
            format: "jwt",
            input: r.value,
            inst: t,
            continue: !e.abort,
          });
      }));
  }),
  $0 = X("$ZodNumber", (t, e) => {
    (xt.init(t, e),
      (t._zod.pattern = t._zod.bag.pattern ?? t9),
      (t._zod.parse = (r, n) => {
        if (e.coerce)
          try {
            r.value = Number(r.value);
          } catch {}
        let s = r.value;
        if (typeof s == "number" && !Number.isNaN(s) && Number.isFinite(s))
          return r;
        let a =
          typeof s == "number"
            ? Number.isNaN(s)
              ? "NaN"
              : Number.isFinite(s)
                ? void 0
                : "Infinity"
            : void 0;
        return (
          r.issues.push({
            expected: "number",
            code: "invalid_type",
            input: s,
            inst: t,
            ...(a ? { received: a } : {}),
          }),
          r
        );
      }));
  }),
  H9 = X("$ZodNumber", (t, e) => {
    (o9.init(t, e), $0.init(t, e));
  }),
  V9 = X("$ZodBoolean", (t, e) => {
    (xt.init(t, e),
      (t._zod.pattern = r9),
      (t._zod.parse = (r, n) => {
        if (e.coerce)
          try {
            r.value = !!r.value;
          } catch {}
        let s = r.value;
        return (
          typeof s == "boolean" ||
            r.issues.push({
              expected: "boolean",
              code: "invalid_type",
              input: s,
              inst: t,
            }),
          r
        );
      }));
  }),
  Z9 = X("$ZodNull", (t, e) => {
    (xt.init(t, e),
      (t._zod.pattern = n9),
      (t._zod.values = new Set([null])),
      (t._zod.parse = (r, n) => {
        let s = r.value;
        return (
          s === null ||
            r.issues.push({
              expected: "null",
              code: "invalid_type",
              input: s,
              inst: t,
            }),
          r
        );
      }));
  }),
  G9 = X("$ZodUnknown", (t, e) => {
    (xt.init(t, e), (t._zod.parse = (r) => r));
  }),
  W9 = X("$ZodNever", (t, e) => {
    (xt.init(t, e),
      (t._zod.parse = (r, n) => (
        r.issues.push({
          expected: "never",
          code: "invalid_type",
          input: r.value,
          inst: t,
        }),
        r
      )));
  });
function sS(t, e, r) {
  (t.issues.length && e.issues.push(...xs(r, t.issues)),
    (e.value[r] = t.value));
}
var K9 = X("$ZodArray", (t, e) => {
  (xt.init(t, e),
    (t._zod.parse = (r, n) => {
      let s = r.value;
      if (!Array.isArray(s))
        return (
          r.issues.push({
            expected: "array",
            code: "invalid_type",
            input: s,
            inst: t,
          }),
          r
        );
      r.value = Array(s.length);
      let a = [];
      for (let i = 0; i < s.length; i++) {
        let o = s[i],
          c = e.element._zod.run({ value: o, issues: [] }, n);
        c instanceof Promise ? a.push(c.then((l) => sS(l, r, i))) : sS(c, r, i);
      }
      return a.length ? Promise.all(a).then(() => r) : r;
    }));
});
function ql(t, e, r) {
  (t.issues.length && e.issues.push(...xs(r, t.issues)),
    (e.value[r] = t.value));
}
function aS(t, e, r, n) {
  t.issues.length
    ? n[r] === void 0
      ? r in n
        ? (e.value[r] = void 0)
        : (e.value[r] = t.value)
      : e.issues.push(...xs(r, t.issues))
    : t.value === void 0
      ? r in n && (e.value[r] = void 0)
      : (e.value[r] = t.value);
}
var A0 = X("$ZodObject", (t, e) => {
  xt.init(t, e);
  let r = uu(() => {
    let d = Object.keys(e.shape);
    for (let p of d)
      if (!(e.shape[p] instanceof xt))
        throw new Error(`Invalid element at key "${p}": expected a Zod schema`);
    let m = g0(e.shape);
    return {
      shape: e.shape,
      keys: d,
      keySet: new Set(d),
      numKeys: d.length,
      optionalKeys: new Set(m),
    };
  });
  Et(t._zod, "propValues", () => {
    let d = e.shape,
      m = {};
    for (let p in d) {
      let f = d[p]._zod;
      if (f.values) {
        m[p] ?? (m[p] = new Set());
        for (let y of f.values) m[p].add(y);
      }
    }
    return m;
  });
  let n = (d) => {
      let m = new xm(["shape", "payload", "ctx"]),
        p = r.value,
        f = (_) => {
          let v = ni(_);
          return `shape[${v}]._zod.run({ value: input[${v}], issues: [] }, ctx)`;
        };
      m.write("const input = payload.value;");
      let y = Object.create(null),
        h = 0;
      for (let _ of p.keys) y[_] = `key_${h++}`;
      m.write("const newResult = {}");
      for (let _ of p.keys)
        if (p.optionalKeys.has(_)) {
          let v = y[_];
          m.write(`const ${v} = ${f(_)};`);
          let b = ni(_);
          m.write(`
        if (${v}.issues.length) {
          if (input[${b}] === undefined) {
            if (${b} in input) {
              newResult[${b}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${v}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${b}, ...iss.path] : [${b}],
              }))
            );
          }
        } else if (${v}.value === undefined) {
          if (${b} in input) newResult[${b}] = undefined;
        } else {
          newResult[${b}] = ${v}.value;
        }
        `);
        } else {
          let v = y[_];
          (m.write(`const ${v} = ${f(_)};`),
            m.write(`
          if (${v}.issues.length) payload.issues = payload.issues.concat(${v}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${ni(_)}, ...iss.path] : [${ni(_)}]
          })));`),
            m.write(`newResult[${ni(_)}] = ${v}.value`));
        }
      (m.write("payload.value = newResult;"), m.write("return payload;"));
      let g = m.compile();
      return (_, v) => g(d, _, v);
    },
    s,
    a = nc,
    i = !ym.jitless,
    c = i && m0.value,
    l = e.catchall,
    u;
  t._zod.parse = (d, m) => {
    u ?? (u = r.value);
    let p = d.value;
    if (!a(p))
      return (
        d.issues.push({
          expected: "object",
          code: "invalid_type",
          input: p,
          inst: t,
        }),
        d
      );
    let f = [];
    if (i && c && m?.async === !1 && m.jitless !== !0)
      (s || (s = n(e.shape)), (d = s(d, m)));
    else {
      d.value = {};
      let v = u.shape;
      for (let b of u.keys) {
        let x = v[b],
          w = x._zod.run({ value: p[b], issues: [] }, m),
          S = x._zod.optin === "optional" && x._zod.optout === "optional";
        w instanceof Promise
          ? f.push(w.then((C) => (S ? aS(C, d, b, p) : ql(C, d, b))))
          : S
            ? aS(w, d, b, p)
            : ql(w, d, b);
      }
    }
    if (!l) return f.length ? Promise.all(f).then(() => d) : d;
    let y = [],
      h = u.keySet,
      g = l._zod,
      _ = g.def.type;
    for (let v of Object.keys(p)) {
      if (h.has(v)) continue;
      if (_ === "never") {
        y.push(v);
        continue;
      }
      let b = g.run({ value: p[v], issues: [] }, m);
      b instanceof Promise ? f.push(b.then((x) => ql(x, d, v))) : ql(b, d, v);
    }
    return (
      y.length &&
        d.issues.push({
          code: "unrecognized_keys",
          keys: y,
          input: p,
          inst: t,
        }),
      f.length ? Promise.all(f).then(() => d) : d
    );
  };
});
function iS(t, e, r, n) {
  for (let s of t) if (s.issues.length === 0) return ((e.value = s.value), e);
  return (
    e.issues.push({
      code: "invalid_union",
      input: e.value,
      inst: r,
      errors: t.map((s) => s.issues.map((a) => Jn(a, n, Kn()))),
    }),
    e
  );
}
var N0 = X("$ZodUnion", (t, e) => {
    (xt.init(t, e),
      Et(t._zod, "optin", () =>
        e.options.some((r) => r._zod.optin === "optional")
          ? "optional"
          : void 0,
      ),
      Et(t._zod, "optout", () =>
        e.options.some((r) => r._zod.optout === "optional")
          ? "optional"
          : void 0,
      ),
      Et(t._zod, "values", () => {
        if (e.options.every((r) => r._zod.values))
          return new Set(e.options.flatMap((r) => Array.from(r._zod.values)));
      }),
      Et(t._zod, "pattern", () => {
        if (e.options.every((r) => r._zod.pattern)) {
          let r = e.options.map((n) => n._zod.pattern);
          return new RegExp(`^(${r.map((n) => pu(n.source)).join("|")})$`);
        }
      }),
      (t._zod.parse = (r, n) => {
        let s = !1,
          a = [];
        for (let i of e.options) {
          let o = i._zod.run({ value: r.value, issues: [] }, n);
          if (o instanceof Promise) (a.push(o), (s = !0));
          else {
            if (o.issues.length === 0) return o;
            a.push(o);
          }
        }
        return s ? Promise.all(a).then((i) => iS(i, r, t, n)) : iS(a, r, t, n);
      }));
  }),
  J9 = X("$ZodDiscriminatedUnion", (t, e) => {
    N0.init(t, e);
    let r = t._zod.parse;
    Et(t._zod, "propValues", () => {
      let s = {};
      for (let a of e.options) {
        let i = a._zod.propValues;
        if (!i || Object.keys(i).length === 0)
          throw new Error(
            `Invalid discriminated union option at index "${e.options.indexOf(a)}"`,
          );
        for (let [o, c] of Object.entries(i)) {
          s[o] || (s[o] = new Set());
          for (let l of c) s[o].add(l);
        }
      }
      return s;
    });
    let n = uu(() => {
      let s = e.options,
        a = new Map();
      for (let i of s) {
        let o = i._zod.propValues[e.discriminator];
        if (!o || o.size === 0)
          throw new Error(
            `Invalid discriminated union option at index "${e.options.indexOf(i)}"`,
          );
        for (let c of o) {
          if (a.has(c))
            throw new Error(`Duplicate discriminator value "${String(c)}"`);
          a.set(c, i);
        }
      }
      return a;
    });
    t._zod.parse = (s, a) => {
      let i = s.value;
      if (!nc(i))
        return (
          s.issues.push({
            code: "invalid_type",
            expected: "object",
            input: i,
            inst: t,
          }),
          s
        );
      let o = n.value.get(i?.[e.discriminator]);
      return o
        ? o._zod.run(s, a)
        : e.unionFallback
          ? r(s, a)
          : (s.issues.push({
              code: "invalid_union",
              errors: [],
              note: "No matching discriminator",
              input: i,
              path: [e.discriminator],
              inst: t,
            }),
            s);
    };
  }),
  X9 = X("$ZodIntersection", (t, e) => {
    (xt.init(t, e),
      (t._zod.parse = (r, n) => {
        let s = r.value,
          a = e.left._zod.run({ value: s, issues: [] }, n),
          i = e.right._zod.run({ value: s, issues: [] }, n);
        return a instanceof Promise || i instanceof Promise
          ? Promise.all([a, i]).then(([c, l]) => oS(r, c, l))
          : oS(r, a, i);
      }));
  });
function wm(t, e) {
  if (t === e) return { valid: !0, data: t };
  if (t instanceof Date && e instanceof Date && +t == +e)
    return { valid: !0, data: t };
  if (sc(t) && sc(e)) {
    let r = Object.keys(e),
      n = Object.keys(t).filter((a) => r.indexOf(a) !== -1),
      s = { ...t, ...e };
    for (let a of n) {
      let i = wm(t[a], e[a]);
      if (!i.valid)
        return { valid: !1, mergeErrorPath: [a, ...i.mergeErrorPath] };
      s[a] = i.data;
    }
    return { valid: !0, data: s };
  }
  if (Array.isArray(t) && Array.isArray(e)) {
    if (t.length !== e.length) return { valid: !1, mergeErrorPath: [] };
    let r = [];
    for (let n = 0; n < t.length; n++) {
      let s = t[n],
        a = e[n],
        i = wm(s, a);
      if (!i.valid)
        return { valid: !1, mergeErrorPath: [n, ...i.mergeErrorPath] };
      r.push(i.data);
    }
    return { valid: !0, data: r };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function oS(t, e, r) {
  if (
    (e.issues.length && t.issues.push(...e.issues),
    r.issues.length && t.issues.push(...r.issues),
    si(t))
  )
    return t;
  let n = wm(e.value, r.value);
  if (!n.valid)
    throw new Error(
      `Unmergable intersection. Error path: ${JSON.stringify(n.mergeErrorPath)}`,
    );
  return ((t.value = n.data), t);
}
var Y9 = X("$ZodRecord", (t, e) => {
    (xt.init(t, e),
      (t._zod.parse = (r, n) => {
        let s = r.value;
        if (!sc(s))
          return (
            r.issues.push({
              expected: "record",
              code: "invalid_type",
              input: s,
              inst: t,
            }),
            r
          );
        let a = [];
        if (e.keyType._zod.values) {
          let i = e.keyType._zod.values;
          r.value = {};
          for (let c of i)
            if (
              typeof c == "string" ||
              typeof c == "number" ||
              typeof c == "symbol"
            ) {
              let l = e.valueType._zod.run({ value: s[c], issues: [] }, n);
              l instanceof Promise
                ? a.push(
                    l.then((u) => {
                      (u.issues.length && r.issues.push(...xs(c, u.issues)),
                        (r.value[c] = u.value));
                    }),
                  )
                : (l.issues.length && r.issues.push(...xs(c, l.issues)),
                  (r.value[c] = l.value));
            }
          let o;
          for (let c in s) i.has(c) || ((o = o ?? []), o.push(c));
          o &&
            o.length > 0 &&
            r.issues.push({
              code: "unrecognized_keys",
              input: s,
              inst: t,
              keys: o,
            });
        } else {
          r.value = {};
          for (let i of Reflect.ownKeys(s)) {
            if (i === "__proto__") continue;
            let o = e.keyType._zod.run({ value: i, issues: [] }, n);
            if (o instanceof Promise)
              throw new Error(
                "Async schemas not supported in object keys currently",
              );
            if (o.issues.length) {
              (r.issues.push({
                origin: "record",
                code: "invalid_key",
                issues: o.issues.map((l) => Jn(l, n, Kn())),
                input: i,
                path: [i],
                inst: t,
              }),
                (r.value[o.value] = o.value));
              continue;
            }
            let c = e.valueType._zod.run({ value: s[i], issues: [] }, n);
            c instanceof Promise
              ? a.push(
                  c.then((l) => {
                    (l.issues.length && r.issues.push(...xs(i, l.issues)),
                      (r.value[o.value] = l.value));
                  }),
                )
              : (c.issues.length && r.issues.push(...xs(i, c.issues)),
                (r.value[o.value] = c.value));
          }
        }
        return a.length ? Promise.all(a).then(() => r) : r;
      }));
  }),
  Q9 = X("$ZodEnum", (t, e) => {
    xt.init(t, e);
    let r = Zm(e.entries);
    ((t._zod.values = new Set(r)),
      (t._zod.pattern = new RegExp(
        `^(${r
          .filter((n) => h0.has(typeof n))
          .map((n) => (typeof n == "string" ? Si(n) : n.toString()))
          .join("|")})$`,
      )),
      (t._zod.parse = (n, s) => {
        let a = n.value;
        return (
          t._zod.values.has(a) ||
            n.issues.push({
              code: "invalid_value",
              values: r,
              input: a,
              inst: t,
            }),
          n
        );
      }));
  }),
  e4 = X("$ZodLiteral", (t, e) => {
    (xt.init(t, e),
      (t._zod.values = new Set(e.values)),
      (t._zod.pattern = new RegExp(
        `^(${e.values.map((r) => (typeof r == "string" ? Si(r) : r ? r.toString() : String(r))).join("|")})$`,
      )),
      (t._zod.parse = (r, n) => {
        let s = r.value;
        return (
          t._zod.values.has(s) ||
            r.issues.push({
              code: "invalid_value",
              values: e.values,
              input: s,
              inst: t,
            }),
          r
        );
      }));
  }),
  t4 = X("$ZodTransform", (t, e) => {
    (xt.init(t, e),
      (t._zod.parse = (r, n) => {
        let s = e.transform(r.value, r);
        if (n.async)
          return (s instanceof Promise ? s : Promise.resolve(s)).then(
            (i) => ((r.value = i), r),
          );
        if (s instanceof Promise) throw new ta();
        return ((r.value = s), r);
      }));
  }),
  r4 = X("$ZodOptional", (t, e) => {
    (xt.init(t, e),
      (t._zod.optin = "optional"),
      (t._zod.optout = "optional"),
      Et(t._zod, "values", () =>
        e.innerType._zod.values
          ? new Set([...e.innerType._zod.values, void 0])
          : void 0,
      ),
      Et(t._zod, "pattern", () => {
        let r = e.innerType._zod.pattern;
        return r ? new RegExp(`^(${pu(r.source)})?$`) : void 0;
      }),
      (t._zod.parse = (r, n) =>
        e.innerType._zod.optin === "optional"
          ? e.innerType._zod.run(r, n)
          : r.value === void 0
            ? r
            : e.innerType._zod.run(r, n)));
  }),
  n4 = X("$ZodNullable", (t, e) => {
    (xt.init(t, e),
      Et(t._zod, "optin", () => e.innerType._zod.optin),
      Et(t._zod, "optout", () => e.innerType._zod.optout),
      Et(t._zod, "pattern", () => {
        let r = e.innerType._zod.pattern;
        return r ? new RegExp(`^(${pu(r.source)}|null)$`) : void 0;
      }),
      Et(t._zod, "values", () =>
        e.innerType._zod.values
          ? new Set([...e.innerType._zod.values, null])
          : void 0,
      ),
      (t._zod.parse = (r, n) =>
        r.value === null ? r : e.innerType._zod.run(r, n)));
  }),
  s4 = X("$ZodDefault", (t, e) => {
    (xt.init(t, e),
      (t._zod.optin = "optional"),
      Et(t._zod, "values", () => e.innerType._zod.values),
      (t._zod.parse = (r, n) => {
        if (r.value === void 0) return ((r.value = e.defaultValue), r);
        let s = e.innerType._zod.run(r, n);
        return s instanceof Promise ? s.then((a) => cS(a, e)) : cS(s, e);
      }));
  });
function cS(t, e) {
  return (t.value === void 0 && (t.value = e.defaultValue), t);
}
var a4 = X("$ZodPrefault", (t, e) => {
    (xt.init(t, e),
      (t._zod.optin = "optional"),
      Et(t._zod, "values", () => e.innerType._zod.values),
      (t._zod.parse = (r, n) => (
        r.value === void 0 && (r.value = e.defaultValue),
        e.innerType._zod.run(r, n)
      )));
  }),
  i4 = X("$ZodNonOptional", (t, e) => {
    (xt.init(t, e),
      Et(t._zod, "values", () => {
        let r = e.innerType._zod.values;
        return r ? new Set([...r].filter((n) => n !== void 0)) : void 0;
      }),
      (t._zod.parse = (r, n) => {
        let s = e.innerType._zod.run(r, n);
        return s instanceof Promise ? s.then((a) => lS(a, t)) : lS(s, t);
      }));
  });
function lS(t, e) {
  return (
    !t.issues.length &&
      t.value === void 0 &&
      t.issues.push({
        code: "invalid_type",
        expected: "nonoptional",
        input: t.value,
        inst: e,
      }),
    t
  );
}
var o4 = X("$ZodCatch", (t, e) => {
    (xt.init(t, e),
      (t._zod.optin = "optional"),
      Et(t._zod, "optout", () => e.innerType._zod.optout),
      Et(t._zod, "values", () => e.innerType._zod.values),
      (t._zod.parse = (r, n) => {
        let s = e.innerType._zod.run(r, n);
        return s instanceof Promise
          ? s.then(
              (a) => (
                (r.value = a.value),
                a.issues.length &&
                  ((r.value = e.catchValue({
                    ...r,
                    error: { issues: a.issues.map((i) => Jn(i, n, Kn())) },
                    input: r.value,
                  })),
                  (r.issues = [])),
                r
              ),
            )
          : ((r.value = s.value),
            s.issues.length &&
              ((r.value = e.catchValue({
                ...r,
                error: { issues: s.issues.map((a) => Jn(a, n, Kn())) },
                input: r.value,
              })),
              (r.issues = [])),
            r);
      }));
  }),
  c4 = X("$ZodPipe", (t, e) => {
    (xt.init(t, e),
      Et(t._zod, "values", () => e.in._zod.values),
      Et(t._zod, "optin", () => e.in._zod.optin),
      Et(t._zod, "optout", () => e.out._zod.optout),
      (t._zod.parse = (r, n) => {
        let s = e.in._zod.run(r, n);
        return s instanceof Promise ? s.then((a) => uS(a, e, n)) : uS(s, e, n);
      }));
  });
function uS(t, e, r) {
  return si(t) ? t : e.out._zod.run({ value: t.value, issues: t.issues }, r);
}
var l4 = X("$ZodReadonly", (t, e) => {
  (xt.init(t, e),
    Et(t._zod, "propValues", () => e.innerType._zod.propValues),
    Et(t._zod, "values", () => e.innerType._zod.values),
    Et(t._zod, "optin", () => e.innerType._zod.optin),
    Et(t._zod, "optout", () => e.innerType._zod.optout),
    (t._zod.parse = (r, n) => {
      let s = e.innerType._zod.run(r, n);
      return s instanceof Promise ? s.then(dS) : dS(s);
    }));
});
function dS(t) {
  return ((t.value = Object.freeze(t.value)), t);
}
var u4 = X("$ZodCustom", (t, e) => {
  (br.init(t, e),
    xt.init(t, e),
    (t._zod.parse = (r, n) => r),
    (t._zod.check = (r) => {
      let n = r.value,
        s = e.fn(n);
      if (s instanceof Promise) return s.then((a) => pS(a, r, n, t));
      pS(s, r, n, t);
    }));
});
function pS(t, e, r, n) {
  if (!t) {
    let s = {
      code: "custom",
      input: r,
      inst: n,
      path: [...(n._zod.def.path ?? [])],
      continue: !n._zod.def.abort,
    };
    (n._zod.def.params && (s.params = n._zod.def.params), e.issues.push(y0(s)));
  }
}
var d4 = (t) => {
    let e = typeof t;
    switch (e) {
      case "number":
        return Number.isNaN(t) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(t)) return "array";
        if (t === null) return "null";
        if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
          return t.constructor.name;
      }
    }
    return e;
  },
  p4 = () => {
    let t = {
      string: { unit: "characters", verb: "to have" },
      file: { unit: "bytes", verb: "to have" },
      array: { unit: "items", verb: "to have" },
      set: { unit: "items", verb: "to have" },
    };
    function e(n) {
      return t[n] ?? null;
    }
    let r = {
      regex: "input",
      email: "email address",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datetime",
      date: "ISO date",
      time: "ISO time",
      duration: "ISO duration",
      ipv4: "IPv4 address",
      ipv6: "IPv6 address",
      cidrv4: "IPv4 range",
      cidrv6: "IPv6 range",
      base64: "base64-encoded string",
      base64url: "base64url-encoded string",
      json_string: "JSON string",
      e164: "E.164 number",
      jwt: "JWT",
      template_literal: "input",
    };
    return (n) => {
      switch (n.code) {
        case "invalid_type":
          return `Invalid input: expected ${n.expected}, received ${d4(n.input)}`;
        case "invalid_value":
          return n.values.length === 1
            ? `Invalid input: expected ${Km(n.values[0])}`
            : `Invalid option: expected one of ${bm(n.values, "|")}`;
        case "too_big": {
          let s = n.inclusive ? "<=" : "<",
            a = e(n.origin);
          return a
            ? `Too big: expected ${n.origin ?? "value"} to have ${s}${n.maximum.toString()} ${a.unit ?? "elements"}`
            : `Too big: expected ${n.origin ?? "value"} to be ${s}${n.maximum.toString()}`;
        }
        case "too_small": {
          let s = n.inclusive ? ">=" : ">",
            a = e(n.origin);
          return a
            ? `Too small: expected ${n.origin} to have ${s}${n.minimum.toString()} ${a.unit}`
            : `Too small: expected ${n.origin} to be ${s}${n.minimum.toString()}`;
        }
        case "invalid_format": {
          let s = n;
          return s.format === "starts_with"
            ? `Invalid string: must start with "${s.prefix}"`
            : s.format === "ends_with"
              ? `Invalid string: must end with "${s.suffix}"`
              : s.format === "includes"
                ? `Invalid string: must include "${s.includes}"`
                : s.format === "regex"
                  ? `Invalid string: must match pattern ${s.pattern}`
                  : `Invalid ${r[s.format] ?? n.format}`;
        }
        case "not_multiple_of":
          return `Invalid number: must be a multiple of ${n.divisor}`;
        case "unrecognized_keys":
          return `Unrecognized key${n.keys.length > 1 ? "s" : ""}: ${bm(n.keys, ", ")}`;
        case "invalid_key":
          return `Invalid key in ${n.origin}`;
        case "invalid_union":
          return "Invalid input";
        case "invalid_element":
          return `Invalid value in ${n.origin}`;
        default:
          return "Invalid input";
      }
    };
  };
function f4() {
  return { localeError: p4() };
}
var Une = Symbol("ZodOutput"),
  qne = Symbol("ZodInput"),
  Jl = class {
    constructor() {
      ((this._map = new WeakMap()), (this._idmap = new Map()));
    }
    add(e, ...r) {
      let n = r[0];
      if ((this._map.set(e, n), n && typeof n == "object" && "id" in n)) {
        if (this._idmap.has(n.id))
          throw new Error(`ID ${n.id} already exists in the registry`);
        this._idmap.set(n.id, e);
      }
      return this;
    }
    remove(e) {
      return (this._map.delete(e), this);
    }
    get(e) {
      let r = e._zod.parent;
      if (r) {
        let n = { ...(this.get(r) ?? {}) };
        return (delete n.id, { ...n, ...this._map.get(e) });
      }
      return this._map.get(e);
    }
    has(e) {
      return this._map.has(e);
    }
  };
function m4() {
  return new Jl();
}
var zo = m4();
function h4(t, e) {
  return new t({ type: "string", ...Ae(e) });
}
function g4(t, e) {
  return new t({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...Ae(e),
  });
}
function fS(t, e) {
  return new t({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...Ae(e),
  });
}
function v4(t, e) {
  return new t({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...Ae(e),
  });
}
function y4(t, e) {
  return new t({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...Ae(e),
  });
}
function b4(t, e) {
  return new t({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...Ae(e),
  });
}
function _4(t, e) {
  return new t({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...Ae(e),
  });
}
function x4(t, e) {
  return new t({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...Ae(e),
  });
}
function w4(t, e) {
  return new t({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...Ae(e),
  });
}
function S4(t, e) {
  return new t({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...Ae(e),
  });
}
function E4(t, e) {
  return new t({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...Ae(e),
  });
}
function T4(t, e) {
  return new t({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...Ae(e),
  });
}
function C4(t, e) {
  return new t({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...Ae(e),
  });
}
function P4(t, e) {
  return new t({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...Ae(e),
  });
}
function k4(t, e) {
  return new t({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...Ae(e),
  });
}
function R4(t, e) {
  return new t({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...Ae(e),
  });
}
function O4(t, e) {
  return new t({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...Ae(e),
  });
}
function I4(t, e) {
  return new t({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...Ae(e),
  });
}
function $4(t, e) {
  return new t({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...Ae(e),
  });
}
function A4(t, e) {
  return new t({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...Ae(e),
  });
}
function N4(t, e) {
  return new t({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...Ae(e),
  });
}
function D4(t, e) {
  return new t({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...Ae(e),
  });
}
function L4(t, e) {
  return new t({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...Ae(e),
  });
}
function M4(t, e) {
  return new t({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...Ae(e),
  });
}
function j4(t, e) {
  return new t({
    type: "string",
    format: "date",
    check: "string_format",
    ...Ae(e),
  });
}
function F4(t, e) {
  return new t({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...Ae(e),
  });
}
function U4(t, e) {
  return new t({
    type: "string",
    format: "duration",
    check: "string_format",
    ...Ae(e),
  });
}
function q4(t, e) {
  return new t({ type: "number", checks: [], ...Ae(e) });
}
function z4(t, e) {
  return new t({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...Ae(e),
  });
}
function B4(t, e) {
  return new t({ type: "boolean", ...Ae(e) });
}
function H4(t, e) {
  return new t({ type: "null", ...Ae(e) });
}
function V4(t) {
  return new t({ type: "unknown" });
}
function Z4(t, e) {
  return new t({ type: "never", ...Ae(e) });
}
function mS(t, e) {
  return new R0({ check: "less_than", ...Ae(e), value: t, inclusive: !1 });
}
function Qf(t, e) {
  return new R0({ check: "less_than", ...Ae(e), value: t, inclusive: !0 });
}
function hS(t, e) {
  return new O0({ check: "greater_than", ...Ae(e), value: t, inclusive: !1 });
}
function em(t, e) {
  return new O0({ check: "greater_than", ...Ae(e), value: t, inclusive: !0 });
}
function gS(t, e) {
  return new i9({ check: "multiple_of", ...Ae(e), value: t });
}
function D0(t, e) {
  return new c9({ check: "max_length", ...Ae(e), maximum: t });
}
function Xl(t, e) {
  return new l9({ check: "min_length", ...Ae(e), minimum: t });
}
function L0(t, e) {
  return new u9({ check: "length_equals", ...Ae(e), length: t });
}
function G4(t, e) {
  return new d9({
    check: "string_format",
    format: "regex",
    ...Ae(e),
    pattern: t,
  });
}
function W4(t) {
  return new p9({ check: "string_format", format: "lowercase", ...Ae(t) });
}
function K4(t) {
  return new f9({ check: "string_format", format: "uppercase", ...Ae(t) });
}
function J4(t, e) {
  return new m9({
    check: "string_format",
    format: "includes",
    ...Ae(e),
    includes: t,
  });
}
function X4(t, e) {
  return new h9({
    check: "string_format",
    format: "starts_with",
    ...Ae(e),
    prefix: t,
  });
}
function Y4(t, e) {
  return new g9({
    check: "string_format",
    format: "ends_with",
    ...Ae(e),
    suffix: t,
  });
}
function ic(t) {
  return new v9({ check: "overwrite", tx: t });
}
function Q4(t) {
  return ic((e) => e.normalize(t));
}
function eB() {
  return ic((t) => t.trim());
}
function tB() {
  return ic((t) => t.toLowerCase());
}
function rB() {
  return ic((t) => t.toUpperCase());
}
function nB(t, e, r) {
  return new t({ type: "array", element: e, ...Ae(r) });
}
function sB(t, e, r) {
  let n = Ae(r);
  return (
    n.abort ?? (n.abort = !0),
    new t({ type: "custom", check: "custom", fn: e, ...n })
  );
}
function aB(t, e, r) {
  return new t({ type: "custom", check: "custom", fn: e, ...Ae(r) });
}
var Yl = class {
  constructor(e) {
    ((this.counter = 0),
      (this.metadataRegistry = e?.metadata ?? zo),
      (this.target = e?.target ?? "draft-2020-12"),
      (this.unrepresentable = e?.unrepresentable ?? "throw"),
      (this.override = e?.override ?? (() => {})),
      (this.io = e?.io ?? "output"),
      (this.seen = new Map()));
  }
  process(e, r = { path: [], schemaPath: [] }) {
    var n;
    let s = e._zod.def,
      a = {
        guid: "uuid",
        url: "uri",
        datetime: "date-time",
        json_string: "json-string",
        regex: "",
      },
      i = this.seen.get(e);
    if (i)
      return (
        i.count++,
        r.schemaPath.includes(e) && (i.cycle = r.path),
        i.schema
      );
    let o = { schema: {}, count: 1, cycle: void 0, path: r.path };
    this.seen.set(e, o);
    let c = e._zod.toJSONSchema?.();
    if (c) o.schema = c;
    else {
      let d = { ...r, schemaPath: [...r.schemaPath, e], path: r.path },
        m = e._zod.parent;
      if (m)
        ((o.ref = m), this.process(m, d), (this.seen.get(m).isParent = !0));
      else {
        let p = o.schema;
        switch (s.type) {
          case "string": {
            let f = p;
            f.type = "string";
            let {
              minimum: y,
              maximum: h,
              format: g,
              patterns: _,
              contentEncoding: v,
            } = e._zod.bag;
            if (
              (typeof y == "number" && (f.minLength = y),
              typeof h == "number" && (f.maxLength = h),
              g && ((f.format = a[g] ?? g), f.format === "" && delete f.format),
              v && (f.contentEncoding = v),
              _ && _.size > 0)
            ) {
              let b = [..._];
              b.length === 1
                ? (f.pattern = b[0].source)
                : b.length > 1 &&
                  (o.schema.allOf = [
                    ...b.map((x) => ({
                      ...(this.target === "draft-7" ? { type: "string" } : {}),
                      pattern: x.source,
                    })),
                  ]);
            }
            break;
          }
          case "number": {
            let f = p,
              {
                minimum: y,
                maximum: h,
                format: g,
                multipleOf: _,
                exclusiveMaximum: v,
                exclusiveMinimum: b,
              } = e._zod.bag;
            (typeof g == "string" && g.includes("int")
              ? (f.type = "integer")
              : (f.type = "number"),
              typeof b == "number" && (f.exclusiveMinimum = b),
              typeof y == "number" &&
                ((f.minimum = y),
                typeof b == "number" &&
                  (b >= y ? delete f.minimum : delete f.exclusiveMinimum)),
              typeof v == "number" && (f.exclusiveMaximum = v),
              typeof h == "number" &&
                ((f.maximum = h),
                typeof v == "number" &&
                  (v <= h ? delete f.maximum : delete f.exclusiveMaximum)),
              typeof _ == "number" && (f.multipleOf = _));
            break;
          }
          case "boolean": {
            let f = p;
            f.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw")
              throw new Error("BigInt cannot be represented in JSON Schema");
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw")
              throw new Error("Symbols cannot be represented in JSON Schema");
            break;
          }
          case "null": {
            p.type = "null";
            break;
          }
          case "any":
            break;
          case "unknown":
            break;
          case "undefined":
          case "never": {
            p.not = {};
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw")
              throw new Error("Void cannot be represented in JSON Schema");
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw")
              throw new Error("Date cannot be represented in JSON Schema");
            break;
          }
          case "array": {
            let f = p,
              { minimum: y, maximum: h } = e._zod.bag;
            (typeof y == "number" && (f.minItems = y),
              typeof h == "number" && (f.maxItems = h),
              (f.type = "array"),
              (f.items = this.process(s.element, {
                ...d,
                path: [...d.path, "items"],
              })));
            break;
          }
          case "object": {
            let f = p;
            ((f.type = "object"), (f.properties = {}));
            let y = s.shape;
            for (let _ in y)
              f.properties[_] = this.process(y[_], {
                ...d,
                path: [...d.path, "properties", _],
              });
            let h = new Set(Object.keys(y)),
              g = new Set(
                [...h].filter((_) => {
                  let v = s.shape[_]._zod;
                  return this.io === "input"
                    ? v.optin === void 0
                    : v.optout === void 0;
                }),
              );
            (g.size > 0 && (f.required = Array.from(g)),
              s.catchall?._zod.def.type === "never"
                ? (f.additionalProperties = !1)
                : s.catchall
                  ? s.catchall &&
                    (f.additionalProperties = this.process(s.catchall, {
                      ...d,
                      path: [...d.path, "additionalProperties"],
                    }))
                  : this.io === "output" && (f.additionalProperties = !1));
            break;
          }
          case "union": {
            let f = p;
            f.anyOf = s.options.map((y, h) =>
              this.process(y, { ...d, path: [...d.path, "anyOf", h] }),
            );
            break;
          }
          case "intersection": {
            let f = p,
              y = this.process(s.left, { ...d, path: [...d.path, "allOf", 0] }),
              h = this.process(s.right, {
                ...d,
                path: [...d.path, "allOf", 1],
              }),
              g = (v) => "allOf" in v && Object.keys(v).length === 1,
              _ = [...(g(y) ? y.allOf : [y]), ...(g(h) ? h.allOf : [h])];
            f.allOf = _;
            break;
          }
          case "tuple": {
            let f = p;
            f.type = "array";
            let y = s.items.map((_, v) =>
              this.process(_, { ...d, path: [...d.path, "prefixItems", v] }),
            );
            if (
              (this.target === "draft-2020-12"
                ? (f.prefixItems = y)
                : (f.items = y),
              s.rest)
            ) {
              let _ = this.process(s.rest, {
                ...d,
                path: [...d.path, "items"],
              });
              this.target === "draft-2020-12"
                ? (f.items = _)
                : (f.additionalItems = _);
            }
            s.rest &&
              (f.items = this.process(s.rest, {
                ...d,
                path: [...d.path, "items"],
              }));
            let { minimum: h, maximum: g } = e._zod.bag;
            (typeof h == "number" && (f.minItems = h),
              typeof g == "number" && (f.maxItems = g));
            break;
          }
          case "record": {
            let f = p;
            ((f.type = "object"),
              (f.propertyNames = this.process(s.keyType, {
                ...d,
                path: [...d.path, "propertyNames"],
              })),
              (f.additionalProperties = this.process(s.valueType, {
                ...d,
                path: [...d.path, "additionalProperties"],
              })));
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw")
              throw new Error("Map cannot be represented in JSON Schema");
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw")
              throw new Error("Set cannot be represented in JSON Schema");
            break;
          }
          case "enum": {
            let f = p,
              y = Zm(s.entries);
            (y.every((h) => typeof h == "number") && (f.type = "number"),
              y.every((h) => typeof h == "string") && (f.type = "string"),
              (f.enum = y));
            break;
          }
          case "literal": {
            let f = p,
              y = [];
            for (let h of s.values)
              if (h === void 0) {
                if (this.unrepresentable === "throw")
                  throw new Error(
                    "Literal `undefined` cannot be represented in JSON Schema",
                  );
              } else if (typeof h == "bigint") {
                if (this.unrepresentable === "throw")
                  throw new Error(
                    "BigInt literals cannot be represented in JSON Schema",
                  );
                y.push(Number(h));
              } else y.push(h);
            if (y.length !== 0)
              if (y.length === 1) {
                let h = y[0];
                ((f.type = h === null ? "null" : typeof h), (f.const = h));
              } else
                (y.every((h) => typeof h == "number") && (f.type = "number"),
                  y.every((h) => typeof h == "string") && (f.type = "string"),
                  y.every((h) => typeof h == "boolean") && (f.type = "string"),
                  y.every((h) => h === null) && (f.type = "null"),
                  (f.enum = y));
            break;
          }
          case "file": {
            let f = p,
              y = {
                type: "string",
                format: "binary",
                contentEncoding: "binary",
              },
              { minimum: h, maximum: g, mime: _ } = e._zod.bag;
            (h !== void 0 && (y.minLength = h),
              g !== void 0 && (y.maxLength = g),
              _
                ? _.length === 1
                  ? ((y.contentMediaType = _[0]), Object.assign(f, y))
                  : (f.anyOf = _.map((v) => ({ ...y, contentMediaType: v })))
                : Object.assign(f, y));
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw")
              throw new Error(
                "Transforms cannot be represented in JSON Schema",
              );
            break;
          }
          case "nullable": {
            let f = this.process(s.innerType, d);
            p.anyOf = [f, { type: "null" }];
            break;
          }
          case "nonoptional": {
            (this.process(s.innerType, d), (o.ref = s.innerType));
            break;
          }
          case "success": {
            let f = p;
            f.type = "boolean";
            break;
          }
          case "default": {
            (this.process(s.innerType, d),
              (o.ref = s.innerType),
              (p.default = JSON.parse(JSON.stringify(s.defaultValue))));
            break;
          }
          case "prefault": {
            (this.process(s.innerType, d),
              (o.ref = s.innerType),
              this.io === "input" &&
                (p._prefault = JSON.parse(JSON.stringify(s.defaultValue))));
            break;
          }
          case "catch": {
            (this.process(s.innerType, d), (o.ref = s.innerType));
            let f;
            try {
              f = s.catchValue(void 0);
            } catch {
              throw new Error(
                "Dynamic catch values are not supported in JSON Schema",
              );
            }
            p.default = f;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw")
              throw new Error("NaN cannot be represented in JSON Schema");
            break;
          }
          case "template_literal": {
            let f = p,
              y = e._zod.pattern;
            if (!y) throw new Error("Pattern not found in template literal");
            ((f.type = "string"), (f.pattern = y.source));
            break;
          }
          case "pipe": {
            let f =
              this.io === "input"
                ? s.in._zod.def.type === "transform"
                  ? s.out
                  : s.in
                : s.out;
            (this.process(f, d), (o.ref = f));
            break;
          }
          case "readonly": {
            (this.process(s.innerType, d),
              (o.ref = s.innerType),
              (p.readOnly = !0));
            break;
          }
          case "promise": {
            (this.process(s.innerType, d), (o.ref = s.innerType));
            break;
          }
          case "optional": {
            (this.process(s.innerType, d), (o.ref = s.innerType));
            break;
          }
          case "lazy": {
            let f = e._zod.innerType;
            (this.process(f, d), (o.ref = f));
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw")
              throw new Error(
                "Custom types cannot be represented in JSON Schema",
              );
            break;
          }
          default:
        }
      }
    }
    let l = this.metadataRegistry.get(e);
    return (
      l && Object.assign(o.schema, l),
      this.io === "input" &&
        Zt(e) &&
        (delete o.schema.examples, delete o.schema.default),
      this.io === "input" &&
        o.schema._prefault &&
        ((n = o.schema).default ?? (n.default = o.schema._prefault)),
      delete o.schema._prefault,
      this.seen.get(e).schema
    );
  }
  emit(e, r) {
    let n = {
        cycles: r?.cycles ?? "ref",
        reused: r?.reused ?? "inline",
        external: r?.external ?? void 0,
      },
      s = this.seen.get(e);
    if (!s) throw new Error("Unprocessed schema. This is a bug in Zod.");
    let a = (u) => {
        let d = this.target === "draft-2020-12" ? "$defs" : "definitions";
        if (n.external) {
          let y = n.external.registry.get(u[0])?.id;
          if (y) return { ref: n.external.uri(y) };
          let h = u[1].defId ?? u[1].schema.id ?? `schema${this.counter++}`;
          return (
            (u[1].defId = h),
            { defId: h, ref: `${n.external.uri("__shared")}#/${d}/${h}` }
          );
        }
        if (u[1] === s) return { ref: "#" };
        let p = `#/${d}/`,
          f = u[1].schema.id ?? `__schema${this.counter++}`;
        return { defId: f, ref: p + f };
      },
      i = (u) => {
        if (u[1].schema.$ref) return;
        let d = u[1],
          { ref: m, defId: p } = a(u);
        ((d.def = { ...d.schema }), p && (d.defId = p));
        let f = d.schema;
        for (let y in f) delete f[y];
        f.$ref = m;
      };
    for (let u of this.seen.entries()) {
      let d = u[1];
      if (e === u[0]) {
        i(u);
        continue;
      }
      if (n.external) {
        let p = n.external.registry.get(u[0])?.id;
        if (e !== u[0] && p) {
          i(u);
          continue;
        }
      }
      if (this.metadataRegistry.get(u[0])?.id) {
        i(u);
        continue;
      }
      if (d.cycle) {
        if (n.cycles === "throw")
          throw new Error(`Cycle detected: #/${d.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
        n.cycles === "ref" && i(u);
        continue;
      }
      if (d.count > 1 && n.reused === "ref") {
        i(u);
        continue;
      }
    }
    let o = (u, d) => {
      let m = this.seen.get(u),
        p = m.def ?? m.schema,
        f = { ...p };
      if (m.ref === null) return;
      let y = m.ref;
      if (((m.ref = null), y)) {
        o(y, d);
        let h = this.seen.get(y).schema;
        h.$ref && d.target === "draft-7"
          ? ((p.allOf = p.allOf ?? []), p.allOf.push(h))
          : (Object.assign(p, h), Object.assign(p, f));
      }
      m.isParent ||
        this.override({ zodSchema: u, jsonSchema: p, path: m.path ?? [] });
    };
    for (let u of [...this.seen.entries()].reverse())
      o(u[0], { target: this.target });
    let c = {};
    (this.target === "draft-2020-12"
      ? (c.$schema = "https://json-schema.org/draft/2020-12/schema")
      : this.target === "draft-7"
        ? (c.$schema = "http://json-schema.org/draft-07/schema#")
        : console.warn(`Invalid target: ${this.target}`),
      Object.assign(c, s.def));
    let l = n.external?.defs ?? {};
    for (let u of this.seen.entries()) {
      let d = u[1];
      d.def && d.defId && (l[d.defId] = d.def);
    }
    !n.external &&
      Object.keys(l).length > 0 &&
      (this.target === "draft-2020-12" ? (c.$defs = l) : (c.definitions = l));
    try {
      return JSON.parse(JSON.stringify(c));
    } catch {
      throw new Error("Error converting schema to JSON.");
    }
  }
};
function iB(t, e) {
  if (t instanceof Jl) {
    let n = new Yl(e),
      s = {};
    for (let o of t._idmap.entries()) {
      let [c, l] = o;
      n.process(l);
    }
    let a = {},
      i = { registry: t, uri: e?.uri || ((o) => o), defs: s };
    for (let o of t._idmap.entries()) {
      let [c, l] = o;
      a[c] = n.emit(l, { ...e, external: i });
    }
    if (Object.keys(s).length > 0) {
      let o = n.target === "draft-2020-12" ? "$defs" : "definitions";
      a.__shared = { [o]: s };
    }
    return { schemas: a };
  }
  let r = new Yl(e);
  return (r.process(t), r.emit(t, e));
}
function Zt(t, e) {
  let r = e ?? { seen: new Set() };
  if (r.seen.has(t)) return !1;
  r.seen.add(t);
  let s = t._zod.def;
  switch (s.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return !1;
    case "array":
      return Zt(s.element, r);
    case "object": {
      for (let a in s.shape) if (Zt(s.shape[a], r)) return !0;
      return !1;
    }
    case "union": {
      for (let a of s.options) if (Zt(a, r)) return !0;
      return !1;
    }
    case "intersection":
      return Zt(s.left, r) || Zt(s.right, r);
    case "tuple": {
      for (let a of s.items) if (Zt(a, r)) return !0;
      return !!(s.rest && Zt(s.rest, r));
    }
    case "record":
      return Zt(s.keyType, r) || Zt(s.valueType, r);
    case "map":
      return Zt(s.keyType, r) || Zt(s.valueType, r);
    case "set":
      return Zt(s.valueType, r);
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return Zt(s.innerType, r);
    case "lazy":
      return Zt(s.getter(), r);
    case "default":
      return Zt(s.innerType, r);
    case "prefault":
      return Zt(s.innerType, r);
    case "custom":
      return !1;
    case "transform":
      return !0;
    case "pipe":
      return Zt(s.in, r) || Zt(s.out, r);
    case "success":
      return !1;
    case "catch":
      return !1;
    default:
  }
  throw new Error(`Unknown schema type: ${s.type}`);
}
var oB = X("ZodMiniType", (t, e) => {
    if (!t._zod) throw new Error("Uninitialized schema in ZodMiniType.");
    (xt.init(t, e),
      (t.def = e),
      (t.parse = (r, n) => Oz(t, r, n, { callee: t.parse })),
      (t.safeParse = (r, n) => Jm(t, r, n)),
      (t.parseAsync = async (r, n) => Iz(t, r, n, { callee: t.parseAsync })),
      (t.safeParseAsync = async (r, n) => Xm(t, r, n)),
      (t.check = (...r) =>
        t.clone({
          ...e,
          checks: [
            ...(e.checks ?? []),
            ...r.map((n) =>
              typeof n == "function"
                ? { _zod: { check: n, def: { check: "custom" }, onattach: [] } }
                : n,
            ),
          ],
        })),
      (t.clone = (r, n) => Xn(t, r, n)),
      (t.brand = () => t),
      (t.register = (r, n) => (r.add(t, n), t)));
  }),
  cB = X("ZodMiniObject", (t, e) => {
    (A0.init(t, e), oB.init(t, e), ht.defineLazy(t, "shape", () => e.shape));
  });
function vS(t, e) {
  let r = {
    type: "object",
    get shape() {
      return (ht.assignProp(this, "shape", { ...t }), this.shape);
    },
    ...ht.normalizeParams(e),
  };
  return new cB(r);
}
function dn(t) {
  return !!t._zod;
}
function Bo(t) {
  let e = Object.values(t);
  if (e.length === 0) return vS({});
  let r = e.every(dn),
    n = e.every((s) => !dn(s));
  if (r) return vS(t);
  if (n) return iz(t);
  throw new Error("Mixed Zod versions detected in object shape.");
}
function Ho(t, e) {
  return dn(t) ? Jm(t, e) : t.safeParse(e);
}
async function tm(t, e) {
  return dn(t) ? await Xm(t, e) : await t.safeParseAsync(e);
}
function oc(t) {
  var e, r;
  if (!t) return;
  let n;
  if (
    (dn(t)
      ? (n =
          (r = (e = t._zod) === null || e === void 0 ? void 0 : e.def) ===
            null || r === void 0
            ? void 0
            : r.shape)
      : (n = t.shape),
    !!n)
  ) {
    if (typeof n == "function")
      try {
        return n();
      } catch {
        return;
      }
    return n;
  }
}
function jo(t) {
  var e;
  if (t) {
    if (typeof t == "object") {
      let r = t,
        n = t;
      if (!r._def && !n._zod) {
        let s = Object.values(t);
        if (
          s.length > 0 &&
          s.every(
            (a) =>
              typeof a == "object" &&
              a !== null &&
              (a._def !== void 0 ||
                a._zod !== void 0 ||
                typeof a.parse == "function"),
          )
        )
          return Bo(t);
      }
    }
    if (dn(t)) {
      let n = (e = t._zod) === null || e === void 0 ? void 0 : e.def;
      if (n && (n.type === "object" || n.shape !== void 0)) return t;
    } else if (t.shape !== void 0) return t;
  }
}
function rm(t) {
  if (t && typeof t == "object") {
    if ("message" in t && typeof t.message == "string") return t.message;
    if ("issues" in t && Array.isArray(t.issues) && t.issues.length > 0) {
      let e = t.issues[0];
      if (e && typeof e == "object" && "message" in e) return String(e.message);
    }
    try {
      return JSON.stringify(t);
    } catch {
      return String(t);
    }
  }
  return String(t);
}
function lB(t) {
  var e, r, n, s;
  if (dn(t))
    return (r = (e = t._zod) === null || e === void 0 ? void 0 : e.def) ===
      null || r === void 0
      ? void 0
      : r.description;
  let a = t;
  return (n = t.description) !== null && n !== void 0
    ? n
    : (s = a._def) === null || s === void 0
      ? void 0
      : s.description;
}
function uB(t) {
  var e, r, n;
  if (dn(t))
    return (
      ((r = (e = t._zod) === null || e === void 0 ? void 0 : e.def) === null ||
      r === void 0
        ? void 0
        : r.type) === "optional"
    );
  let s = t;
  return typeof t.isOptional == "function"
    ? t.isOptional()
    : ((n = s._def) === null || n === void 0 ? void 0 : n.typeName) ===
        "ZodOptional";
}
function M0(t) {
  var e;
  if (dn(t)) {
    let i = (e = t._zod) === null || e === void 0 ? void 0 : e.def;
    if (i) {
      if (i.value !== void 0) return i.value;
      if (Array.isArray(i.values) && i.values.length > 0) return i.values[0];
    }
  }
  let n = t._def;
  if (n) {
    if (n.value !== void 0) return n.value;
    if (Array.isArray(n.values) && n.values.length > 0) return n.values[0];
  }
  let s = t.value;
  if (s !== void 0) return s;
}
var j0 = {};
NS(j0, {
  time: () => H0,
  duration: () => Z0,
  datetime: () => U0,
  date: () => z0,
  ZodISOTime: () => B0,
  ZodISODuration: () => V0,
  ZodISODateTime: () => F0,
  ZodISODate: () => q0,
});
var F0 = X("ZodISODateTime", (t, e) => {
  (O9.init(t, e), $t.init(t, e));
});
function U0(t) {
  return M4(F0, t);
}
var q0 = X("ZodISODate", (t, e) => {
  (I9.init(t, e), $t.init(t, e));
});
function z0(t) {
  return j4(q0, t);
}
var B0 = X("ZodISOTime", (t, e) => {
  ($9.init(t, e), $t.init(t, e));
});
function H0(t) {
  return F4(B0, t);
}
var V0 = X("ZodISODuration", (t, e) => {
  (A9.init(t, e), $t.init(t, e));
});
function Z0(t) {
  return U4(V0, t);
}
var G0 = (t, e) => {
    (_0.init(t, e),
      (t.name = "ZodError"),
      Object.defineProperties(t, {
        format: { value: (r) => Rz(t, r) },
        flatten: { value: (r) => kz(t, r) },
        addIssue: { value: (r) => t.issues.push(r) },
        addIssues: { value: (r) => t.issues.push(...r) },
        isEmpty: {
          get() {
            return t.issues.length === 0;
          },
        },
      }));
  },
  zne = X("ZodError", G0),
  gu = X("ZodError", G0, { Parent: Error }),
  dB = x0(gu),
  pB = w0(gu),
  fB = S0(gu),
  mB = E0(gu),
  It = X(
    "ZodType",
    (t, e) => (
      xt.init(t, e),
      (t.def = e),
      Object.defineProperty(t, "_def", { value: e }),
      (t.check = (...r) =>
        t.clone({
          ...e,
          checks: [
            ...(e.checks ?? []),
            ...r.map((n) =>
              typeof n == "function"
                ? { _zod: { check: n, def: { check: "custom" }, onattach: [] } }
                : n,
            ),
          ],
        })),
      (t.clone = (r, n) => Xn(t, r, n)),
      (t.brand = () => t),
      (t.register = (r, n) => (r.add(t, n), t)),
      (t.parse = (r, n) => dB(t, r, n, { callee: t.parse })),
      (t.safeParse = (r, n) => fB(t, r, n)),
      (t.parseAsync = async (r, n) => pB(t, r, n, { callee: t.parseAsync })),
      (t.safeParseAsync = async (r, n) => mB(t, r, n)),
      (t.spa = t.safeParseAsync),
      (t.refine = (r, n) => t.check(sH(r, n))),
      (t.superRefine = (r) => t.check(aH(r))),
      (t.overwrite = (r) => t.check(ic(r))),
      (t.optional = () => Te(t)),
      (t.nullable = () => _S(t)),
      (t.nullish = () => Te(_S(t))),
      (t.nonoptional = (r) => JB(t, r)),
      (t.array = () => Ye(t)),
      (t.or = (r) => Pt([t, r])),
      (t.and = (r) => Qm(t, r)),
      (t.transform = (r) => Em(t, eE(r))),
      (t.default = (r) => GB(t, r)),
      (t.prefault = (r) => KB(t, r)),
      (t.catch = (r) => YB(t, r)),
      (t.pipe = (r) => Em(t, r)),
      (t.readonly = () => tH(t)),
      (t.describe = (r) => {
        let n = t.clone();
        return (zo.add(n, { description: r }), n);
      }),
      Object.defineProperty(t, "description", {
        get() {
          return zo.get(t)?.description;
        },
        configurable: !0,
      }),
      (t.meta = (...r) => {
        if (r.length === 0) return zo.get(t);
        let n = t.clone();
        return (zo.add(n, r[0]), n);
      }),
      (t.isOptional = () => t.safeParse(void 0).success),
      (t.isNullable = () => t.safeParse(null).success),
      t
    ),
  ),
  W0 = X("_ZodString", (t, e) => {
    (Ym.init(t, e), It.init(t, e));
    let r = t._zod.bag;
    ((t.format = r.format ?? null),
      (t.minLength = r.minimum ?? null),
      (t.maxLength = r.maximum ?? null),
      (t.regex = (...n) => t.check(G4(...n))),
      (t.includes = (...n) => t.check(J4(...n))),
      (t.startsWith = (...n) => t.check(X4(...n))),
      (t.endsWith = (...n) => t.check(Y4(...n))),
      (t.min = (...n) => t.check(Xl(...n))),
      (t.max = (...n) => t.check(D0(...n))),
      (t.length = (...n) => t.check(L0(...n))),
      (t.nonempty = (...n) => t.check(Xl(1, ...n))),
      (t.lowercase = (n) => t.check(W4(n))),
      (t.uppercase = (n) => t.check(K4(n))),
      (t.trim = () => t.check(eB())),
      (t.normalize = (...n) => t.check(Q4(...n))),
      (t.toLowerCase = () => t.check(tB())),
      (t.toUpperCase = () => t.check(rB())));
  }),
  hB = X("ZodString", (t, e) => {
    (Ym.init(t, e),
      W0.init(t, e),
      (t.email = (r) => t.check(g4(gB, r))),
      (t.url = (r) => t.check(x4(vB, r))),
      (t.jwt = (r) => t.check(L4($B, r))),
      (t.emoji = (r) => t.check(w4(yB, r))),
      (t.guid = (r) => t.check(fS(yS, r))),
      (t.uuid = (r) => t.check(v4(zl, r))),
      (t.uuidv4 = (r) => t.check(y4(zl, r))),
      (t.uuidv6 = (r) => t.check(b4(zl, r))),
      (t.uuidv7 = (r) => t.check(_4(zl, r))),
      (t.nanoid = (r) => t.check(S4(bB, r))),
      (t.guid = (r) => t.check(fS(yS, r))),
      (t.cuid = (r) => t.check(E4(_B, r))),
      (t.cuid2 = (r) => t.check(T4(xB, r))),
      (t.ulid = (r) => t.check(C4(wB, r))),
      (t.base64 = (r) => t.check(A4(RB, r))),
      (t.base64url = (r) => t.check(N4(OB, r))),
      (t.xid = (r) => t.check(P4(SB, r))),
      (t.ksuid = (r) => t.check(k4(EB, r))),
      (t.ipv4 = (r) => t.check(R4(TB, r))),
      (t.ipv6 = (r) => t.check(O4(CB, r))),
      (t.cidrv4 = (r) => t.check(I4(PB, r))),
      (t.cidrv6 = (r) => t.check($4(kB, r))),
      (t.e164 = (r) => t.check(D4(IB, r))),
      (t.datetime = (r) => t.check(U0(r))),
      (t.date = (r) => t.check(z0(r))),
      (t.time = (r) => t.check(H0(r))),
      (t.duration = (r) => t.check(Z0(r))));
  });
function J(t) {
  return h4(hB, t);
}
var $t = X("ZodStringFormat", (t, e) => {
    (Ct.init(t, e), W0.init(t, e));
  }),
  gB = X("ZodEmail", (t, e) => {
    (x9.init(t, e), $t.init(t, e));
  }),
  yS = X("ZodGUID", (t, e) => {
    (b9.init(t, e), $t.init(t, e));
  }),
  zl = X("ZodUUID", (t, e) => {
    (_9.init(t, e), $t.init(t, e));
  }),
  vB = X("ZodURL", (t, e) => {
    (w9.init(t, e), $t.init(t, e));
  }),
  yB = X("ZodEmoji", (t, e) => {
    (S9.init(t, e), $t.init(t, e));
  }),
  bB = X("ZodNanoID", (t, e) => {
    (E9.init(t, e), $t.init(t, e));
  }),
  _B = X("ZodCUID", (t, e) => {
    (T9.init(t, e), $t.init(t, e));
  }),
  xB = X("ZodCUID2", (t, e) => {
    (C9.init(t, e), $t.init(t, e));
  }),
  wB = X("ZodULID", (t, e) => {
    (P9.init(t, e), $t.init(t, e));
  }),
  SB = X("ZodXID", (t, e) => {
    (k9.init(t, e), $t.init(t, e));
  }),
  EB = X("ZodKSUID", (t, e) => {
    (R9.init(t, e), $t.init(t, e));
  }),
  TB = X("ZodIPv4", (t, e) => {
    (N9.init(t, e), $t.init(t, e));
  }),
  CB = X("ZodIPv6", (t, e) => {
    (D9.init(t, e), $t.init(t, e));
  }),
  PB = X("ZodCIDRv4", (t, e) => {
    (L9.init(t, e), $t.init(t, e));
  }),
  kB = X("ZodCIDRv6", (t, e) => {
    (M9.init(t, e), $t.init(t, e));
  }),
  RB = X("ZodBase64", (t, e) => {
    (j9.init(t, e), $t.init(t, e));
  }),
  OB = X("ZodBase64URL", (t, e) => {
    (U9.init(t, e), $t.init(t, e));
  }),
  IB = X("ZodE164", (t, e) => {
    (q9.init(t, e), $t.init(t, e));
  }),
  $B = X("ZodJWT", (t, e) => {
    (B9.init(t, e), $t.init(t, e));
  }),
  K0 = X("ZodNumber", (t, e) => {
    ($0.init(t, e),
      It.init(t, e),
      (t.gt = (n, s) => t.check(hS(n, s))),
      (t.gte = (n, s) => t.check(em(n, s))),
      (t.min = (n, s) => t.check(em(n, s))),
      (t.lt = (n, s) => t.check(mS(n, s))),
      (t.lte = (n, s) => t.check(Qf(n, s))),
      (t.max = (n, s) => t.check(Qf(n, s))),
      (t.int = (n) => t.check(bS(n))),
      (t.safe = (n) => t.check(bS(n))),
      (t.positive = (n) => t.check(hS(0, n))),
      (t.nonnegative = (n) => t.check(em(0, n))),
      (t.negative = (n) => t.check(mS(0, n))),
      (t.nonpositive = (n) => t.check(Qf(0, n))),
      (t.multipleOf = (n, s) => t.check(gS(n, s))),
      (t.step = (n, s) => t.check(gS(n, s))),
      (t.finite = () => t));
    let r = t._zod.bag;
    ((t.minValue =
      Math.max(
        r.minimum ?? Number.NEGATIVE_INFINITY,
        r.exclusiveMinimum ?? Number.NEGATIVE_INFINITY,
      ) ?? null),
      (t.maxValue =
        Math.min(
          r.maximum ?? Number.POSITIVE_INFINITY,
          r.exclusiveMaximum ?? Number.POSITIVE_INFINITY,
        ) ?? null),
      (t.isInt =
        (r.format ?? "").includes("int") ||
        Number.isSafeInteger(r.multipleOf ?? 0.5)),
      (t.isFinite = !0),
      (t.format = r.format ?? null));
  });
function _t(t) {
  return q4(K0, t);
}
var AB = X("ZodNumberFormat", (t, e) => {
  (H9.init(t, e), K0.init(t, e));
});
function bS(t) {
  return z4(AB, t);
}
var NB = X("ZodBoolean", (t, e) => {
  (V9.init(t, e), It.init(t, e));
});
function ar(t) {
  return B4(NB, t);
}
var DB = X("ZodNull", (t, e) => {
  (Z9.init(t, e), It.init(t, e));
});
function J0(t) {
  return H4(DB, t);
}
var LB = X("ZodUnknown", (t, e) => {
  (G9.init(t, e), It.init(t, e));
});
function Gt() {
  return V4(LB);
}
var MB = X("ZodNever", (t, e) => {
  (W9.init(t, e), It.init(t, e));
});
function jB(t) {
  return Z4(MB, t);
}
var FB = X("ZodArray", (t, e) => {
  (K9.init(t, e),
    It.init(t, e),
    (t.element = e.element),
    (t.min = (r, n) => t.check(Xl(r, n))),
    (t.nonempty = (r) => t.check(Xl(1, r))),
    (t.max = (r, n) => t.check(D0(r, n))),
    (t.length = (r, n) => t.check(L0(r, n))),
    (t.unwrap = () => t.element));
});
function Ye(t, e) {
  return nB(FB, t, e);
}
var X0 = X("ZodObject", (t, e) => {
  (A0.init(t, e),
    It.init(t, e),
    ht.defineLazy(t, "shape", () => e.shape),
    (t.keyof = () => ir(Object.keys(t._zod.def.shape))),
    (t.catchall = (r) => t.clone({ ...t._zod.def, catchall: r })),
    (t.passthrough = () => t.clone({ ...t._zod.def, catchall: Gt() })),
    (t.loose = () => t.clone({ ...t._zod.def, catchall: Gt() })),
    (t.strict = () => t.clone({ ...t._zod.def, catchall: jB() })),
    (t.strip = () => t.clone({ ...t._zod.def, catchall: void 0 })),
    (t.extend = (r) => ht.extend(t, r)),
    (t.merge = (r) => ht.merge(t, r)),
    (t.pick = (r) => ht.pick(t, r)),
    (t.omit = (r) => ht.omit(t, r)),
    (t.partial = (...r) => ht.partial(tE, t, r[0])),
    (t.required = (...r) => ht.required(rE, t, r[0])));
});
function ue(t, e) {
  let r = {
    type: "object",
    get shape() {
      return (ht.assignProp(this, "shape", { ...t }), this.shape);
    },
    ...ht.normalizeParams(e),
  };
  return new X0(r);
}
function pn(t, e) {
  return new X0({
    type: "object",
    get shape() {
      return (ht.assignProp(this, "shape", { ...t }), this.shape);
    },
    catchall: Gt(),
    ...ht.normalizeParams(e),
  });
}
var Y0 = X("ZodUnion", (t, e) => {
  (N0.init(t, e), It.init(t, e), (t.options = e.options));
});
function Pt(t, e) {
  return new Y0({ type: "union", options: t, ...ht.normalizeParams(e) });
}
var UB = X("ZodDiscriminatedUnion", (t, e) => {
  (Y0.init(t, e), J9.init(t, e));
});
function Q0(t, e, r) {
  return new UB({
    type: "union",
    options: e,
    discriminator: t,
    ...ht.normalizeParams(r),
  });
}
var qB = X("ZodIntersection", (t, e) => {
  (X9.init(t, e), It.init(t, e));
});
function Qm(t, e) {
  return new qB({ type: "intersection", left: t, right: e });
}
var zB = X("ZodRecord", (t, e) => {
  (Y9.init(t, e),
    It.init(t, e),
    (t.keyType = e.keyType),
    (t.valueType = e.valueType));
});
function Wt(t, e, r) {
  return new zB({
    type: "record",
    keyType: t,
    valueType: e,
    ...ht.normalizeParams(r),
  });
}
var Sm = X("ZodEnum", (t, e) => {
  (Q9.init(t, e),
    It.init(t, e),
    (t.enum = e.entries),
    (t.options = Object.values(e.entries)));
  let r = new Set(Object.keys(e.entries));
  ((t.extract = (n, s) => {
    let a = {};
    for (let i of n)
      if (r.has(i)) a[i] = e.entries[i];
      else throw new Error(`Key ${i} not found in enum`);
    return new Sm({ ...e, checks: [], ...ht.normalizeParams(s), entries: a });
  }),
    (t.exclude = (n, s) => {
      let a = { ...e.entries };
      for (let i of n)
        if (r.has(i)) delete a[i];
        else throw new Error(`Key ${i} not found in enum`);
      return new Sm({ ...e, checks: [], ...ht.normalizeParams(s), entries: a });
    }));
});
function ir(t, e) {
  let r = Array.isArray(t) ? Object.fromEntries(t.map((n) => [n, n])) : t;
  return new Sm({ type: "enum", entries: r, ...ht.normalizeParams(e) });
}
var BB = X("ZodLiteral", (t, e) => {
  (e4.init(t, e),
    It.init(t, e),
    (t.values = new Set(e.values)),
    Object.defineProperty(t, "value", {
      get() {
        if (e.values.length > 1)
          throw new Error(
            "This schema contains multiple valid literal values. Use `.values` instead.",
          );
        return e.values[0];
      },
    }));
});
function Ce(t, e) {
  return new BB({
    type: "literal",
    values: Array.isArray(t) ? t : [t],
    ...ht.normalizeParams(e),
  });
}
var HB = X("ZodTransform", (t, e) => {
  (t4.init(t, e),
    It.init(t, e),
    (t._zod.parse = (r, n) => {
      r.addIssue = (a) => {
        if (typeof a == "string") r.issues.push(ht.issue(a, r.value, e));
        else {
          let i = a;
          (i.fatal && (i.continue = !1),
            i.code ?? (i.code = "custom"),
            i.input ?? (i.input = r.value),
            i.inst ?? (i.inst = t),
            i.continue ?? (i.continue = !0),
            r.issues.push(ht.issue(i)));
        }
      };
      let s = e.transform(r.value, r);
      return s instanceof Promise
        ? s.then((a) => ((r.value = a), r))
        : ((r.value = s), r);
    }));
});
function eE(t) {
  return new HB({ type: "transform", transform: t });
}
var tE = X("ZodOptional", (t, e) => {
  (r4.init(t, e), It.init(t, e), (t.unwrap = () => t._zod.def.innerType));
});
function Te(t) {
  return new tE({ type: "optional", innerType: t });
}
var VB = X("ZodNullable", (t, e) => {
  (n4.init(t, e), It.init(t, e), (t.unwrap = () => t._zod.def.innerType));
});
function _S(t) {
  return new VB({ type: "nullable", innerType: t });
}
var ZB = X("ZodDefault", (t, e) => {
  (s4.init(t, e),
    It.init(t, e),
    (t.unwrap = () => t._zod.def.innerType),
    (t.removeDefault = t.unwrap));
});
function GB(t, e) {
  return new ZB({
    type: "default",
    innerType: t,
    get defaultValue() {
      return typeof e == "function" ? e() : e;
    },
  });
}
var WB = X("ZodPrefault", (t, e) => {
  (a4.init(t, e), It.init(t, e), (t.unwrap = () => t._zod.def.innerType));
});
function KB(t, e) {
  return new WB({
    type: "prefault",
    innerType: t,
    get defaultValue() {
      return typeof e == "function" ? e() : e;
    },
  });
}
var rE = X("ZodNonOptional", (t, e) => {
  (i4.init(t, e), It.init(t, e), (t.unwrap = () => t._zod.def.innerType));
});
function JB(t, e) {
  return new rE({
    type: "nonoptional",
    innerType: t,
    ...ht.normalizeParams(e),
  });
}
var XB = X("ZodCatch", (t, e) => {
  (o4.init(t, e),
    It.init(t, e),
    (t.unwrap = () => t._zod.def.innerType),
    (t.removeCatch = t.unwrap));
});
function YB(t, e) {
  return new XB({
    type: "catch",
    innerType: t,
    catchValue: typeof e == "function" ? e : () => e,
  });
}
var QB = X("ZodPipe", (t, e) => {
  (c4.init(t, e), It.init(t, e), (t.in = e.in), (t.out = e.out));
});
function Em(t, e) {
  return new QB({ type: "pipe", in: t, out: e });
}
var eH = X("ZodReadonly", (t, e) => {
  (l4.init(t, e), It.init(t, e));
});
function tH(t) {
  return new eH({ type: "readonly", innerType: t });
}
var nE = X("ZodCustom", (t, e) => {
  (u4.init(t, e), It.init(t, e));
});
function rH(t, e) {
  let r = new br({ check: "custom", ...ht.normalizeParams(e) });
  return ((r._zod.check = t), r);
}
function nH(t, e) {
  return sB(nE, t ?? (() => !0), e);
}
function sH(t, e = {}) {
  return aB(nE, t, e);
}
function aH(t, e) {
  let r = rH(
    (n) => (
      (n.addIssue = (s) => {
        if (typeof s == "string")
          n.issues.push(ht.issue(s, n.value, r._zod.def));
        else {
          let a = s;
          (a.fatal && (a.continue = !1),
            a.code ?? (a.code = "custom"),
            a.input ?? (a.input = n.value),
            a.inst ?? (a.inst = r),
            a.continue ?? (a.continue = !r._zod.def.abort),
            n.issues.push(ht.issue(a)));
        }
      }),
      t(n.value, n)
    ),
    e,
  );
  return r;
}
function sE(t, e) {
  return Em(eE(t), e);
}
Kn(f4());
var aE = "2025-11-25",
  iH = [aE, "2025-06-18", "2025-03-26", "2024-11-05", "2024-10-07"],
  Vn = "io.modelcontextprotocol/related-task",
  vu = "2.0",
  Pn = nH(
    (t) => t !== null && (typeof t == "object" || typeof t == "function"),
  ),
  iE = Pt([J(), _t().int()]),
  oE = J(),
  oH = pn({ ttl: Pt([_t(), J0()]).optional(), pollInterval: _t().optional() }),
  eh = pn({ taskId: J() }),
  cH = pn({ progressToken: iE.optional(), [Vn]: eh.optional() }),
  _r = pn({ task: oH.optional(), _meta: cH.optional() }),
  tr = ue({ method: J(), params: _r.optional() }),
  ra = pn({
    _meta: ue({ [Vn]: Te(eh) })
      .passthrough()
      .optional(),
  }),
  Kr = ue({ method: J(), params: ra.optional() }),
  or = pn({ _meta: pn({ [Vn]: eh.optional() }).optional() }),
  yu = Pt([J(), _t().int()]),
  cE = ue({ jsonrpc: Ce(vu), id: yu, ...tr.shape }).strict(),
  xS = (t) => cE.safeParse(t).success,
  lE = ue({ jsonrpc: Ce(vu), ...Kr.shape }).strict(),
  lH = (t) => lE.safeParse(t).success,
  uE = ue({ jsonrpc: Ce(vu), id: yu, result: or }).strict(),
  Bl = (t) => uE.safeParse(t).success,
  Ie;
(function (t) {
  ((t[(t.ConnectionClosed = -32e3)] = "ConnectionClosed"),
    (t[(t.RequestTimeout = -32001)] = "RequestTimeout"),
    (t[(t.ParseError = -32700)] = "ParseError"),
    (t[(t.InvalidRequest = -32600)] = "InvalidRequest"),
    (t[(t.MethodNotFound = -32601)] = "MethodNotFound"),
    (t[(t.InvalidParams = -32602)] = "InvalidParams"),
    (t[(t.InternalError = -32603)] = "InternalError"),
    (t[(t.UrlElicitationRequired = -32042)] = "UrlElicitationRequired"));
})(Ie || (Ie = {}));
var dE = ue({
    jsonrpc: Ce(vu),
    id: yu,
    error: ue({ code: _t().int(), message: J(), data: Te(Gt()) }),
  }).strict(),
  uH = (t) => dE.safeParse(t).success,
  Bne = Pt([cE, lE, uE, dE]),
  th = or.strict(),
  dH = ra.extend({ requestId: yu, reason: J().optional() }),
  rh = Kr.extend({ method: Ce("notifications/cancelled"), params: dH }),
  pH = ue({ src: J(), mimeType: J().optional(), sizes: Ye(J()).optional() }),
  cc = ue({ icons: Ye(pH).optional() }),
  yi = ue({ name: J(), title: J().optional() }),
  pE = yi.extend({
    ...yi.shape,
    ...cc.shape,
    version: J(),
    websiteUrl: J().optional(),
  }),
  fH = Qm(ue({ applyDefaults: ar().optional() }), Wt(J(), Gt())),
  mH = sE(
    (t) =>
      t &&
      typeof t == "object" &&
      !Array.isArray(t) &&
      Object.keys(t).length === 0
        ? { form: {} }
        : t,
    Qm(
      ue({ form: fH.optional(), url: Pn.optional() }),
      Wt(J(), Gt()).optional(),
    ),
  ),
  hH = ue({
    list: Te(ue({}).passthrough()),
    cancel: Te(ue({}).passthrough()),
    requests: Te(
      ue({
        sampling: Te(
          ue({ createMessage: Te(ue({}).passthrough()) }).passthrough(),
        ),
        elicitation: Te(ue({ create: Te(ue({}).passthrough()) }).passthrough()),
      }).passthrough(),
    ),
  }).passthrough(),
  gH = ue({
    list: Te(ue({}).passthrough()),
    cancel: Te(ue({}).passthrough()),
    requests: Te(
      ue({
        tools: Te(ue({ call: Te(ue({}).passthrough()) }).passthrough()),
      }).passthrough(),
    ),
  }).passthrough(),
  vH = ue({
    experimental: Wt(J(), Pn).optional(),
    sampling: ue({ context: Pn.optional(), tools: Pn.optional() }).optional(),
    elicitation: mH.optional(),
    roots: ue({ listChanged: ar().optional() }).optional(),
    tasks: Te(hH),
  }),
  yH = _r.extend({ protocolVersion: J(), capabilities: vH, clientInfo: pE }),
  fE = tr.extend({ method: Ce("initialize"), params: yH }),
  bH = ue({
    experimental: Wt(J(), Pn).optional(),
    logging: Pn.optional(),
    completions: Pn.optional(),
    prompts: Te(ue({ listChanged: Te(ar()) })),
    resources: ue({
      subscribe: ar().optional(),
      listChanged: ar().optional(),
    }).optional(),
    tools: ue({ listChanged: ar().optional() }).optional(),
    tasks: Te(gH),
  }).passthrough(),
  _H = or.extend({
    protocolVersion: J(),
    capabilities: bH,
    serverInfo: pE,
    instructions: J().optional(),
  }),
  mE = Kr.extend({ method: Ce("notifications/initialized") }),
  nh = tr.extend({ method: Ce("ping") }),
  xH = ue({ progress: _t(), total: Te(_t()), message: Te(J()) }),
  wH = ue({ ...ra.shape, ...xH.shape, progressToken: iE }),
  sh = Kr.extend({ method: Ce("notifications/progress"), params: wH }),
  SH = _r.extend({ cursor: oE.optional() }),
  lc = tr.extend({ params: SH.optional() }),
  uc = or.extend({ nextCursor: Te(oE) }),
  dc = ue({
    taskId: J(),
    status: ir([
      "working",
      "input_required",
      "completed",
      "failed",
      "cancelled",
    ]),
    ttl: Pt([_t(), J0()]),
    createdAt: J(),
    lastUpdatedAt: J(),
    pollInterval: Te(_t()),
    statusMessage: Te(J()),
  }),
  bu = or.extend({ task: dc }),
  EH = ra.merge(dc),
  Ql = Kr.extend({ method: Ce("notifications/tasks/status"), params: EH }),
  ah = tr.extend({
    method: Ce("tasks/get"),
    params: _r.extend({ taskId: J() }),
  }),
  ih = or.merge(dc),
  oh = tr.extend({
    method: Ce("tasks/result"),
    params: _r.extend({ taskId: J() }),
  }),
  ch = lc.extend({ method: Ce("tasks/list") }),
  lh = uc.extend({ tasks: Ye(dc) }),
  TH = tr.extend({
    method: Ce("tasks/cancel"),
    params: _r.extend({ taskId: J() }),
  }),
  CH = or.merge(dc),
  hE = ue({ uri: J(), mimeType: Te(J()), _meta: Wt(J(), Gt()).optional() }),
  gE = hE.extend({ text: J() }),
  uh = J().refine(
    (t) => {
      try {
        return (atob(t), !0);
      } catch {
        return !1;
      }
    },
    { message: "Invalid Base64 string" },
  ),
  vE = hE.extend({ blob: uh }),
  Ei = ue({
    audience: Ye(ir(["user", "assistant"])).optional(),
    priority: _t().min(0).max(1).optional(),
    lastModified: j0.datetime({ offset: !0 }).optional(),
  }),
  yE = ue({
    ...yi.shape,
    ...cc.shape,
    uri: J(),
    description: Te(J()),
    mimeType: Te(J()),
    annotations: Ei.optional(),
    _meta: Te(pn({})),
  }),
  PH = ue({
    ...yi.shape,
    ...cc.shape,
    uriTemplate: J(),
    description: Te(J()),
    mimeType: Te(J()),
    annotations: Ei.optional(),
    _meta: Te(pn({})),
  }),
  Tm = lc.extend({ method: Ce("resources/list") }),
  kH = uc.extend({ resources: Ye(yE) }),
  Cm = lc.extend({ method: Ce("resources/templates/list") }),
  RH = uc.extend({ resourceTemplates: Ye(PH) }),
  dh = _r.extend({ uri: J() }),
  OH = dh,
  Pm = tr.extend({ method: Ce("resources/read"), params: OH }),
  IH = or.extend({ contents: Ye(Pt([gE, vE])) }),
  $H = Kr.extend({ method: Ce("notifications/resources/list_changed") }),
  AH = dh,
  NH = tr.extend({ method: Ce("resources/subscribe"), params: AH }),
  DH = dh,
  LH = tr.extend({ method: Ce("resources/unsubscribe"), params: DH }),
  MH = ra.extend({ uri: J() }),
  jH = Kr.extend({ method: Ce("notifications/resources/updated"), params: MH }),
  FH = ue({ name: J(), description: Te(J()), required: Te(ar()) }),
  UH = ue({
    ...yi.shape,
    ...cc.shape,
    description: Te(J()),
    arguments: Te(Ye(FH)),
    _meta: Te(pn({})),
  }),
  km = lc.extend({ method: Ce("prompts/list") }),
  qH = uc.extend({ prompts: Ye(UH) }),
  zH = _r.extend({ name: J(), arguments: Wt(J(), J()).optional() }),
  Rm = tr.extend({ method: Ce("prompts/get"), params: zH }),
  ph = ue({
    type: Ce("text"),
    text: J(),
    annotations: Ei.optional(),
    _meta: Wt(J(), Gt()).optional(),
  }),
  fh = ue({
    type: Ce("image"),
    data: uh,
    mimeType: J(),
    annotations: Ei.optional(),
    _meta: Wt(J(), Gt()).optional(),
  }),
  mh = ue({
    type: Ce("audio"),
    data: uh,
    mimeType: J(),
    annotations: Ei.optional(),
    _meta: Wt(J(), Gt()).optional(),
  }),
  BH = ue({
    type: Ce("tool_use"),
    name: J(),
    id: J(),
    input: ue({}).passthrough(),
    _meta: Te(ue({}).passthrough()),
  }).passthrough(),
  HH = ue({
    type: Ce("resource"),
    resource: Pt([gE, vE]),
    annotations: Ei.optional(),
    _meta: Wt(J(), Gt()).optional(),
  }),
  VH = yE.extend({ type: Ce("resource_link") }),
  hh = Pt([ph, fh, mh, VH, HH]),
  ZH = ue({ role: ir(["user", "assistant"]), content: hh }),
  GH = or.extend({ description: Te(J()), messages: Ye(ZH) }),
  WH = Kr.extend({ method: Ce("notifications/prompts/list_changed") }),
  KH = ue({
    title: J().optional(),
    readOnlyHint: ar().optional(),
    destructiveHint: ar().optional(),
    idempotentHint: ar().optional(),
    openWorldHint: ar().optional(),
  }),
  JH = ue({
    taskSupport: ir(["required", "optional", "forbidden"]).optional(),
  }),
  bE = ue({
    ...yi.shape,
    ...cc.shape,
    description: J().optional(),
    inputSchema: ue({
      type: Ce("object"),
      properties: Wt(J(), Pn).optional(),
      required: Ye(J()).optional(),
    }).catchall(Gt()),
    outputSchema: ue({
      type: Ce("object"),
      properties: Wt(J(), Pn).optional(),
      required: Ye(J()).optional(),
    })
      .catchall(Gt())
      .optional(),
    annotations: Te(KH),
    execution: Te(JH),
    _meta: Wt(J(), Gt()).optional(),
  }),
  Om = lc.extend({ method: Ce("tools/list") }),
  XH = uc.extend({ tools: Ye(bE) }),
  gh = or.extend({
    content: Ye(hh).default([]),
    structuredContent: Wt(J(), Gt()).optional(),
    isError: Te(ar()),
  }),
  Hne = gh.or(or.extend({ toolResult: Gt() })),
  YH = _r.extend({ name: J(), arguments: Te(Wt(J(), Gt())) }),
  eu = tr.extend({ method: Ce("tools/call"), params: YH }),
  QH = Kr.extend({ method: Ce("notifications/tools/list_changed") }),
  tu = ir([
    "debug",
    "info",
    "notice",
    "warning",
    "error",
    "critical",
    "alert",
    "emergency",
  ]),
  eV = _r.extend({ level: tu }),
  _E = tr.extend({ method: Ce("logging/setLevel"), params: eV }),
  tV = ra.extend({ level: tu, logger: J().optional(), data: Gt() }),
  rV = Kr.extend({ method: Ce("notifications/message"), params: tV }),
  nV = ue({ name: J().optional() }),
  sV = ue({
    hints: Te(Ye(nV)),
    costPriority: Te(_t().min(0).max(1)),
    speedPriority: Te(_t().min(0).max(1)),
    intelligencePriority: Te(_t().min(0).max(1)),
  }),
  aV = ue({ mode: Te(ir(["auto", "required", "none"])) }),
  iV = ue({
    type: Ce("tool_result"),
    toolUseId: J().describe(
      "The unique identifier for the corresponding tool call.",
    ),
    content: Ye(hh).default([]),
    structuredContent: ue({}).passthrough().optional(),
    isError: Te(ar()),
    _meta: Te(ue({}).passthrough()),
  }).passthrough(),
  oV = Q0("type", [ph, fh, mh]),
  ru = Q0("type", [ph, fh, mh, BH, iV]),
  cV = ue({
    role: ir(["user", "assistant"]),
    content: Pt([ru, Ye(ru)]),
    _meta: Te(ue({}).passthrough()),
  }).passthrough(),
  lV = _r.extend({
    messages: Ye(cV),
    modelPreferences: sV.optional(),
    systemPrompt: J().optional(),
    includeContext: ir(["none", "thisServer", "allServers"]).optional(),
    temperature: _t().optional(),
    maxTokens: _t().int(),
    stopSequences: Ye(J()).optional(),
    metadata: Pn.optional(),
    tools: Te(Ye(bE)),
    toolChoice: Te(aV),
  }),
  uV = tr.extend({ method: Ce("sampling/createMessage"), params: lV }),
  xE = or.extend({
    model: J(),
    stopReason: Te(ir(["endTurn", "stopSequence", "maxTokens"]).or(J())),
    role: ir(["user", "assistant"]),
    content: oV,
  }),
  wE = or.extend({
    model: J(),
    stopReason: Te(
      ir(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(J()),
    ),
    role: ir(["user", "assistant"]),
    content: Pt([ru, Ye(ru)]),
  }),
  dV = ue({
    type: Ce("boolean"),
    title: J().optional(),
    description: J().optional(),
    default: ar().optional(),
  }),
  pV = ue({
    type: Ce("string"),
    title: J().optional(),
    description: J().optional(),
    minLength: _t().optional(),
    maxLength: _t().optional(),
    format: ir(["email", "uri", "date", "date-time"]).optional(),
    default: J().optional(),
  }),
  fV = ue({
    type: ir(["number", "integer"]),
    title: J().optional(),
    description: J().optional(),
    minimum: _t().optional(),
    maximum: _t().optional(),
    default: _t().optional(),
  }),
  mV = ue({
    type: Ce("string"),
    title: J().optional(),
    description: J().optional(),
    enum: Ye(J()),
    default: J().optional(),
  }),
  hV = ue({
    type: Ce("string"),
    title: J().optional(),
    description: J().optional(),
    oneOf: Ye(ue({ const: J(), title: J() })),
    default: J().optional(),
  }),
  gV = ue({
    type: Ce("string"),
    title: J().optional(),
    description: J().optional(),
    enum: Ye(J()),
    enumNames: Ye(J()).optional(),
    default: J().optional(),
  }),
  vV = Pt([mV, hV]),
  yV = ue({
    type: Ce("array"),
    title: J().optional(),
    description: J().optional(),
    minItems: _t().optional(),
    maxItems: _t().optional(),
    items: ue({ type: Ce("string"), enum: Ye(J()) }),
    default: Ye(J()).optional(),
  }),
  bV = ue({
    type: Ce("array"),
    title: J().optional(),
    description: J().optional(),
    minItems: _t().optional(),
    maxItems: _t().optional(),
    items: ue({ anyOf: Ye(ue({ const: J(), title: J() })) }),
    default: Ye(J()).optional(),
  }),
  _V = Pt([yV, bV]),
  xV = Pt([gV, vV, _V]),
  wV = Pt([xV, dV, pV, fV]),
  SV = _r.extend({
    mode: Ce("form").optional(),
    message: J(),
    requestedSchema: ue({
      type: Ce("object"),
      properties: Wt(J(), wV),
      required: Ye(J()).optional(),
    }),
  }),
  EV = _r.extend({
    mode: Ce("url"),
    message: J(),
    elicitationId: J(),
    url: J().url(),
  }),
  TV = Pt([SV, EV]),
  CV = tr.extend({ method: Ce("elicitation/create"), params: TV }),
  PV = ra.extend({ elicitationId: J() }),
  kV = Kr.extend({
    method: Ce("notifications/elicitation/complete"),
    params: PV,
  }),
  Im = or.extend({
    action: ir(["accept", "decline", "cancel"]),
    content: sE(
      (t) => (t === null ? void 0 : t),
      Wt(J(), Pt([J(), _t(), ar(), Ye(J())])).optional(),
    ),
  }),
  RV = ue({ type: Ce("ref/resource"), uri: J() }),
  OV = ue({ type: Ce("ref/prompt"), name: J() }),
  IV = _r.extend({
    ref: Pt([OV, RV]),
    argument: ue({ name: J(), value: J() }),
    context: ue({ arguments: Wt(J(), J()).optional() }).optional(),
  }),
  $m = tr.extend({ method: Ce("completion/complete"), params: IV });
function $V(t) {
  if (t.params.ref.type !== "ref/prompt")
    throw new TypeError(
      `Expected CompleteRequestPrompt, but got ${t.params.ref.type}`,
    );
}
function AV(t) {
  if (t.params.ref.type !== "ref/resource")
    throw new TypeError(
      `Expected CompleteRequestResourceTemplate, but got ${t.params.ref.type}`,
    );
}
var NV = or.extend({
    completion: pn({
      values: Ye(J()).max(100),
      total: Te(_t().int()),
      hasMore: Te(ar()),
    }),
  }),
  DV = ue({
    uri: J().startsWith("file://"),
    name: J().optional(),
    _meta: Wt(J(), Gt()).optional(),
  }),
  LV = tr.extend({ method: Ce("roots/list") }),
  SE = or.extend({ roots: Ye(DV) }),
  MV = Kr.extend({ method: Ce("notifications/roots/list_changed") }),
  Vne = Pt([nh, fE, $m, _E, Rm, km, Tm, Cm, Pm, NH, LH, eu, Om, ah, oh, ch]),
  Zne = Pt([rh, sh, mE, MV, Ql]),
  Gne = Pt([th, xE, wE, Im, SE, ih, lh, bu]),
  Wne = Pt([nh, uV, CV, LV, ah, oh, ch]),
  Kne = Pt([rh, sh, rV, jH, $H, QH, WH, Ql, kV]),
  Jne = Pt([th, _H, NV, GH, qH, kH, RH, IH, gh, XH, ih, lh, bu]),
  Pe = class t extends Error {
    constructor(e, r, n) {
      (super(`MCP error ${e}: ${r}`),
        (this.code = e),
        (this.data = n),
        (this.name = "McpError"));
    }
    static fromError(e, r, n) {
      if (e === Ie.UrlElicitationRequired && n) {
        let s = n;
        if (s.elicitations) return new Am(s.elicitations, r);
      }
      return new t(e, r, n);
    }
  },
  Am = class extends Pe {
    constructor(e, r = `URL elicitation${e.length > 1 ? "s" : ""} required`) {
      super(Ie.UrlElicitationRequired, r, { elicitations: e });
    }
    get elicitations() {
      var e, r;
      return (r =
        (e = this.data) === null || e === void 0 ? void 0 : e.elicitations) !==
        null && r !== void 0
        ? r
        : [];
    }
  };
function Xs(t) {
  return t === "completed" || t === "failed" || t === "cancelled";
}
var jV = Symbol("Let zodToJsonSchema decide on which parser to use"),
  wS = {
    name: void 0,
    $refStrategy: "root",
    basePath: ["#"],
    effectStrategy: "input",
    pipeStrategy: "all",
    dateStrategy: "format:date-time",
    mapStrategy: "entries",
    removeAdditionalStrategy: "passthrough",
    allowedAdditionalProperties: !0,
    rejectedAdditionalProperties: !1,
    definitionPath: "definitions",
    target: "jsonSchema7",
    strictUnions: !1,
    definitions: {},
    errorMessages: !1,
    markdownDescription: !1,
    patternStrategy: "escape",
    applyRegexFlags: !1,
    emailStrategy: "format:email",
    base64Strategy: "contentEncoding:base64",
    nameStrategy: "ref",
    openAiAnyTypeName: "OpenAiAnyType",
  },
  FV = (t) => (typeof t == "string" ? { ...wS, name: t } : { ...wS, ...t }),
  UV = (t) => {
    let e = FV(t),
      r =
        e.name !== void 0
          ? [...e.basePath, e.definitionPath, e.name]
          : e.basePath;
    return {
      ...e,
      flags: { hasReferencedOpenAiAnyType: !1 },
      currentPath: r,
      propertyPath: void 0,
      seen: new Map(
        Object.entries(e.definitions).map(([n, s]) => [
          s._def,
          {
            def: s._def,
            path: [...e.basePath, e.definitionPath, n],
            jsonSchema: void 0,
          },
        ]),
      ),
    };
  };
function EE(t, e, r, n) {
  n?.errorMessages && r && (t.errorMessage = { ...t.errorMessage, [e]: r });
}
function ft(t, e, r, n, s) {
  ((t[e] = r), EE(t, e, n, s));
}
var TE = (t, e) => {
  let r = 0;
  for (; r < t.length && r < e.length && t[r] === e[r]; r++);
  return [(t.length - r).toString(), ...e.slice(r)].join("/");
};
function yr(t) {
  if (t.target !== "openAi") return {};
  let e = [...t.basePath, t.definitionPath, t.openAiAnyTypeName];
  return (
    (t.flags.hasReferencedOpenAiAnyType = !0),
    { $ref: t.$refStrategy === "relative" ? TE(e, t.currentPath) : e.join("/") }
  );
}
function qV(t, e) {
  let r = { type: "array" };
  return (
    t.type?._def &&
      t.type?._def?.typeName !== ie.ZodAny &&
      (r.items = it(t.type._def, {
        ...e,
        currentPath: [...e.currentPath, "items"],
      })),
    t.minLength && ft(r, "minItems", t.minLength.value, t.minLength.message, e),
    t.maxLength && ft(r, "maxItems", t.maxLength.value, t.maxLength.message, e),
    t.exactLength &&
      (ft(r, "minItems", t.exactLength.value, t.exactLength.message, e),
      ft(r, "maxItems", t.exactLength.value, t.exactLength.message, e)),
    r
  );
}
function zV(t, e) {
  let r = { type: "integer", format: "int64" };
  if (!t.checks) return r;
  for (let n of t.checks)
    switch (n.kind) {
      case "min":
        e.target === "jsonSchema7"
          ? n.inclusive
            ? ft(r, "minimum", n.value, n.message, e)
            : ft(r, "exclusiveMinimum", n.value, n.message, e)
          : (n.inclusive || (r.exclusiveMinimum = !0),
            ft(r, "minimum", n.value, n.message, e));
        break;
      case "max":
        e.target === "jsonSchema7"
          ? n.inclusive
            ? ft(r, "maximum", n.value, n.message, e)
            : ft(r, "exclusiveMaximum", n.value, n.message, e)
          : (n.inclusive || (r.exclusiveMaximum = !0),
            ft(r, "maximum", n.value, n.message, e));
        break;
      case "multipleOf":
        ft(r, "multipleOf", n.value, n.message, e);
        break;
    }
  return r;
}
function BV() {
  return { type: "boolean" };
}
function CE(t, e) {
  return it(t.type._def, e);
}
var HV = (t, e) => it(t.innerType._def, e);
function PE(t, e, r) {
  let n = r ?? e.dateStrategy;
  if (Array.isArray(n)) return { anyOf: n.map((s, a) => PE(t, e, s)) };
  switch (n) {
    case "string":
    case "format:date-time":
      return { type: "string", format: "date-time" };
    case "format:date":
      return { type: "string", format: "date" };
    case "integer":
      return VV(t, e);
  }
}
var VV = (t, e) => {
  let r = { type: "integer", format: "unix-time" };
  if (e.target === "openApi3") return r;
  for (let n of t.checks)
    switch (n.kind) {
      case "min":
        ft(r, "minimum", n.value, n.message, e);
        break;
      case "max":
        ft(r, "maximum", n.value, n.message, e);
        break;
    }
  return r;
};
function ZV(t, e) {
  return { ...it(t.innerType._def, e), default: t.defaultValue() };
}
function GV(t, e) {
  return e.effectStrategy === "input" ? it(t.schema._def, e) : yr(e);
}
function WV(t) {
  return { type: "string", enum: Array.from(t.values) };
}
var KV = (t) => ("type" in t && t.type === "string" ? !1 : "allOf" in t);
function JV(t, e) {
  let r = [
      it(t.left._def, { ...e, currentPath: [...e.currentPath, "allOf", "0"] }),
      it(t.right._def, { ...e, currentPath: [...e.currentPath, "allOf", "1"] }),
    ].filter((a) => !!a),
    n =
      e.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0,
    s = [];
  return (
    r.forEach((a) => {
      if (KV(a))
        (s.push(...a.allOf),
          a.unevaluatedProperties === void 0 && (n = void 0));
      else {
        let i = a;
        if ("additionalProperties" in a && a.additionalProperties === !1) {
          let { additionalProperties: o, ...c } = a;
          i = c;
        } else n = void 0;
        s.push(i);
      }
    }),
    s.length ? { allOf: s, ...n } : void 0
  );
}
function XV(t, e) {
  let r = typeof t.value;
  return r !== "bigint" && r !== "number" && r !== "boolean" && r !== "string"
    ? { type: Array.isArray(t.value) ? "array" : "object" }
    : e.target === "openApi3"
      ? { type: r === "bigint" ? "integer" : r, enum: [t.value] }
      : { type: r === "bigint" ? "integer" : r, const: t.value };
}
var nm = void 0,
  on = {
    cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    email:
      /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    emoji: () => (
      nm === void 0 &&
        (nm = RegExp(
          "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
          "u",
        )),
      nm
    ),
    uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    ipv4Cidr:
      /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    ipv6Cidr:
      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    base64url:
      /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/,
    jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
  };
function kE(t, e) {
  let r = { type: "string" };
  if (t.checks)
    for (let n of t.checks)
      switch (n.kind) {
        case "min":
          ft(
            r,
            "minLength",
            typeof r.minLength == "number"
              ? Math.max(r.minLength, n.value)
              : n.value,
            n.message,
            e,
          );
          break;
        case "max":
          ft(
            r,
            "maxLength",
            typeof r.maxLength == "number"
              ? Math.min(r.maxLength, n.value)
              : n.value,
            n.message,
            e,
          );
          break;
        case "email":
          switch (e.emailStrategy) {
            case "format:email":
              cn(r, "email", n.message, e);
              break;
            case "format:idn-email":
              cn(r, "idn-email", n.message, e);
              break;
            case "pattern:zod":
              pr(r, on.email, n.message, e);
              break;
          }
          break;
        case "url":
          cn(r, "uri", n.message, e);
          break;
        case "uuid":
          cn(r, "uuid", n.message, e);
          break;
        case "regex":
          pr(r, n.regex, n.message, e);
          break;
        case "cuid":
          pr(r, on.cuid, n.message, e);
          break;
        case "cuid2":
          pr(r, on.cuid2, n.message, e);
          break;
        case "startsWith":
          pr(r, RegExp(`^${sm(n.value, e)}`), n.message, e);
          break;
        case "endsWith":
          pr(r, RegExp(`${sm(n.value, e)}$`), n.message, e);
          break;
        case "datetime":
          cn(r, "date-time", n.message, e);
          break;
        case "date":
          cn(r, "date", n.message, e);
          break;
        case "time":
          cn(r, "time", n.message, e);
          break;
        case "duration":
          cn(r, "duration", n.message, e);
          break;
        case "length":
          (ft(
            r,
            "minLength",
            typeof r.minLength == "number"
              ? Math.max(r.minLength, n.value)
              : n.value,
            n.message,
            e,
          ),
            ft(
              r,
              "maxLength",
              typeof r.maxLength == "number"
                ? Math.min(r.maxLength, n.value)
                : n.value,
              n.message,
              e,
            ));
          break;
        case "includes": {
          pr(r, RegExp(sm(n.value, e)), n.message, e);
          break;
        }
        case "ip": {
          (n.version !== "v6" && cn(r, "ipv4", n.message, e),
            n.version !== "v4" && cn(r, "ipv6", n.message, e));
          break;
        }
        case "base64url":
          pr(r, on.base64url, n.message, e);
          break;
        case "jwt":
          pr(r, on.jwt, n.message, e);
          break;
        case "cidr": {
          (n.version !== "v6" && pr(r, on.ipv4Cidr, n.message, e),
            n.version !== "v4" && pr(r, on.ipv6Cidr, n.message, e));
          break;
        }
        case "emoji":
          pr(r, on.emoji(), n.message, e);
          break;
        case "ulid": {
          pr(r, on.ulid, n.message, e);
          break;
        }
        case "base64": {
          switch (e.base64Strategy) {
            case "format:binary": {
              cn(r, "binary", n.message, e);
              break;
            }
            case "contentEncoding:base64": {
              ft(r, "contentEncoding", "base64", n.message, e);
              break;
            }
            case "pattern:zod": {
              pr(r, on.base64, n.message, e);
              break;
            }
          }
          break;
        }
        case "nanoid":
          pr(r, on.nanoid, n.message, e);
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
      }
  return r;
}
function sm(t, e) {
  return e.patternStrategy === "escape" ? QV(t) : t;
}
var YV = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789",
);
function QV(t) {
  let e = "";
  for (let r = 0; r < t.length; r++) (YV.has(t[r]) || (e += "\\"), (e += t[r]));
  return e;
}
function cn(t, e, r, n) {
  t.format || t.anyOf?.some((s) => s.format)
    ? (t.anyOf || (t.anyOf = []),
      t.format &&
        (t.anyOf.push({
          format: t.format,
          ...(t.errorMessage &&
            n.errorMessages && {
              errorMessage: { format: t.errorMessage.format },
            }),
        }),
        delete t.format,
        t.errorMessage &&
          (delete t.errorMessage.format,
          Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)),
      t.anyOf.push({
        format: e,
        ...(r && n.errorMessages && { errorMessage: { format: r } }),
      }))
    : ft(t, "format", e, r, n);
}
function pr(t, e, r, n) {
  t.pattern || t.allOf?.some((s) => s.pattern)
    ? (t.allOf || (t.allOf = []),
      t.pattern &&
        (t.allOf.push({
          pattern: t.pattern,
          ...(t.errorMessage &&
            n.errorMessages && {
              errorMessage: { pattern: t.errorMessage.pattern },
            }),
        }),
        delete t.pattern,
        t.errorMessage &&
          (delete t.errorMessage.pattern,
          Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)),
      t.allOf.push({
        pattern: SS(e, n),
        ...(r && n.errorMessages && { errorMessage: { pattern: r } }),
      }))
    : ft(t, "pattern", SS(e, n), r, n);
}
function SS(t, e) {
  if (!e.applyRegexFlags || !t.flags) return t.source;
  let r = {
      i: t.flags.includes("i"),
      m: t.flags.includes("m"),
      s: t.flags.includes("s"),
    },
    n = r.i ? t.source.toLowerCase() : t.source,
    s = "",
    a = !1,
    i = !1,
    o = !1;
  for (let c = 0; c < n.length; c++) {
    if (a) {
      ((s += n[c]), (a = !1));
      continue;
    }
    if (r.i) {
      if (i) {
        if (n[c].match(/[a-z]/)) {
          o
            ? ((s += n[c]),
              (s += `${n[c - 2]}-${n[c]}`.toUpperCase()),
              (o = !1))
            : n[c + 1] === "-" && n[c + 2]?.match(/[a-z]/)
              ? ((s += n[c]), (o = !0))
              : (s += `${n[c]}${n[c].toUpperCase()}`);
          continue;
        }
      } else if (n[c].match(/[a-z]/)) {
        s += `[${n[c]}${n[c].toUpperCase()}]`;
        continue;
      }
    }
    if (r.m) {
      if (n[c] === "^") {
        s += `(^|(?<=[\r
]))`;
        continue;
      } else if (n[c] === "$") {
        s += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (r.s && n[c] === ".") {
      s += i
        ? `${n[c]}\r
`
        : `[${n[c]}\r
]`;
      continue;
    }
    ((s += n[c]),
      n[c] === "\\"
        ? (a = !0)
        : i && n[c] === "]"
          ? (i = !1)
          : !i && n[c] === "[" && (i = !0));
  }
  try {
    new RegExp(s);
  } catch {
    return (
      console.warn(
        `Could not convert regex pattern at ${e.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`,
      ),
      t.source
    );
  }
  return s;
}
function RE(t, e) {
  if (
    (e.target === "openAi" &&
      console.warn(
        "Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.",
      ),
    e.target === "openApi3" && t.keyType?._def.typeName === ie.ZodEnum)
  )
    return {
      type: "object",
      required: t.keyType._def.values,
      properties: t.keyType._def.values.reduce(
        (n, s) => ({
          ...n,
          [s]:
            it(t.valueType._def, {
              ...e,
              currentPath: [...e.currentPath, "properties", s],
            }) ?? yr(e),
        }),
        {},
      ),
      additionalProperties: e.rejectedAdditionalProperties,
    };
  let r = {
    type: "object",
    additionalProperties:
      it(t.valueType._def, {
        ...e,
        currentPath: [...e.currentPath, "additionalProperties"],
      }) ?? e.allowedAdditionalProperties,
  };
  if (e.target === "openApi3") return r;
  if (
    t.keyType?._def.typeName === ie.ZodString &&
    t.keyType._def.checks?.length
  ) {
    let { type: n, ...s } = kE(t.keyType._def, e);
    return { ...r, propertyNames: s };
  } else {
    if (t.keyType?._def.typeName === ie.ZodEnum)
      return { ...r, propertyNames: { enum: t.keyType._def.values } };
    if (
      t.keyType?._def.typeName === ie.ZodBranded &&
      t.keyType._def.type._def.typeName === ie.ZodString &&
      t.keyType._def.type._def.checks?.length
    ) {
      let { type: n, ...s } = CE(t.keyType._def, e);
      return { ...r, propertyNames: s };
    }
  }
  return r;
}
function e3(t, e) {
  if (e.mapStrategy === "record") return RE(t, e);
  let r =
      it(t.keyType._def, {
        ...e,
        currentPath: [...e.currentPath, "items", "items", "0"],
      }) || yr(e),
    n =
      it(t.valueType._def, {
        ...e,
        currentPath: [...e.currentPath, "items", "items", "1"],
      }) || yr(e);
  return {
    type: "array",
    maxItems: 125,
    items: { type: "array", items: [r, n], minItems: 2, maxItems: 2 },
  };
}
function t3(t) {
  let e = t.values,
    n = Object.keys(t.values)
      .filter((a) => typeof e[e[a]] != "number")
      .map((a) => e[a]),
    s = Array.from(new Set(n.map((a) => typeof a)));
  return {
    type:
      s.length === 1
        ? s[0] === "string"
          ? "string"
          : "number"
        : ["string", "number"],
    enum: n,
  };
}
function r3(t) {
  return t.target === "openAi"
    ? void 0
    : { not: yr({ ...t, currentPath: [...t.currentPath, "not"] }) };
}
function n3(t) {
  return t.target === "openApi3"
    ? { enum: ["null"], nullable: !0 }
    : { type: "null" };
}
var nu = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null",
};
function s3(t, e) {
  if (e.target === "openApi3") return ES(t, e);
  let r = t.options instanceof Map ? Array.from(t.options.values()) : t.options;
  if (
    r.every(
      (n) => n._def.typeName in nu && (!n._def.checks || !n._def.checks.length),
    )
  ) {
    let n = r.reduce((s, a) => {
      let i = nu[a._def.typeName];
      return i && !s.includes(i) ? [...s, i] : s;
    }, []);
    return { type: n.length > 1 ? n : n[0] };
  } else if (
    r.every((n) => n._def.typeName === "ZodLiteral" && !n.description)
  ) {
    let n = r.reduce((s, a) => {
      let i = typeof a._def.value;
      switch (i) {
        case "string":
        case "number":
        case "boolean":
          return [...s, i];
        case "bigint":
          return [...s, "integer"];
        case "object":
          if (a._def.value === null) return [...s, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return s;
      }
    }, []);
    if (n.length === r.length) {
      let s = n.filter((a, i, o) => o.indexOf(a) === i);
      return {
        type: s.length > 1 ? s : s[0],
        enum: r.reduce(
          (a, i) => (a.includes(i._def.value) ? a : [...a, i._def.value]),
          [],
        ),
      };
    }
  } else if (r.every((n) => n._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: r.reduce(
        (n, s) => [...n, ...s._def.values.filter((a) => !n.includes(a))],
        [],
      ),
    };
  return ES(t, e);
}
var ES = (t, e) => {
  let r = (
    t.options instanceof Map ? Array.from(t.options.values()) : t.options
  )
    .map((n, s) =>
      it(n._def, { ...e, currentPath: [...e.currentPath, "anyOf", `${s}`] }),
    )
    .filter(
      (n) =>
        !!n &&
        (!e.strictUnions ||
          (typeof n == "object" && Object.keys(n).length > 0)),
    );
  return r.length ? { anyOf: r } : void 0;
};
function a3(t, e) {
  if (
    ["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
      t.innerType._def.typeName,
    ) &&
    (!t.innerType._def.checks || !t.innerType._def.checks.length)
  )
    return e.target === "openApi3"
      ? { type: nu[t.innerType._def.typeName], nullable: !0 }
      : { type: [nu[t.innerType._def.typeName], "null"] };
  if (e.target === "openApi3") {
    let n = it(t.innerType._def, { ...e, currentPath: [...e.currentPath] });
    return n && "$ref" in n
      ? { allOf: [n], nullable: !0 }
      : n && { ...n, nullable: !0 };
  }
  let r = it(t.innerType._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", "0"],
  });
  return r && { anyOf: [r, { type: "null" }] };
}
function i3(t, e) {
  let r = { type: "number" };
  if (!t.checks) return r;
  for (let n of t.checks)
    switch (n.kind) {
      case "int":
        ((r.type = "integer"), EE(r, "type", n.message, e));
        break;
      case "min":
        e.target === "jsonSchema7"
          ? n.inclusive
            ? ft(r, "minimum", n.value, n.message, e)
            : ft(r, "exclusiveMinimum", n.value, n.message, e)
          : (n.inclusive || (r.exclusiveMinimum = !0),
            ft(r, "minimum", n.value, n.message, e));
        break;
      case "max":
        e.target === "jsonSchema7"
          ? n.inclusive
            ? ft(r, "maximum", n.value, n.message, e)
            : ft(r, "exclusiveMaximum", n.value, n.message, e)
          : (n.inclusive || (r.exclusiveMaximum = !0),
            ft(r, "maximum", n.value, n.message, e));
        break;
      case "multipleOf":
        ft(r, "multipleOf", n.value, n.message, e);
        break;
    }
  return r;
}
function o3(t, e) {
  let r = e.target === "openAi",
    n = { type: "object", properties: {} },
    s = [],
    a = t.shape();
  for (let o in a) {
    let c = a[o];
    if (c === void 0 || c._def === void 0) continue;
    let l = l3(c);
    l &&
      r &&
      (c._def.typeName === "ZodOptional" && (c = c._def.innerType),
      c.isNullable() || (c = c.nullable()),
      (l = !1));
    let u = it(c._def, {
      ...e,
      currentPath: [...e.currentPath, "properties", o],
      propertyPath: [...e.currentPath, "properties", o],
    });
    u !== void 0 && ((n.properties[o] = u), l || s.push(o));
  }
  s.length && (n.required = s);
  let i = c3(t, e);
  return (i !== void 0 && (n.additionalProperties = i), n);
}
function c3(t, e) {
  if (t.catchall._def.typeName !== "ZodNever")
    return it(t.catchall._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalProperties"],
    });
  switch (t.unknownKeys) {
    case "passthrough":
      return e.allowedAdditionalProperties;
    case "strict":
      return e.rejectedAdditionalProperties;
    case "strip":
      return e.removeAdditionalStrategy === "strict"
        ? e.allowedAdditionalProperties
        : e.rejectedAdditionalProperties;
  }
}
function l3(t) {
  try {
    return t.isOptional();
  } catch {
    return !0;
  }
}
var u3 = (t, e) => {
    if (e.currentPath.toString() === e.propertyPath?.toString())
      return it(t.innerType._def, e);
    let r = it(t.innerType._def, {
      ...e,
      currentPath: [...e.currentPath, "anyOf", "1"],
    });
    return r ? { anyOf: [{ not: yr(e) }, r] } : yr(e);
  },
  d3 = (t, e) => {
    if (e.pipeStrategy === "input") return it(t.in._def, e);
    if (e.pipeStrategy === "output") return it(t.out._def, e);
    let r = it(t.in._def, {
        ...e,
        currentPath: [...e.currentPath, "allOf", "0"],
      }),
      n = it(t.out._def, {
        ...e,
        currentPath: [...e.currentPath, "allOf", r ? "1" : "0"],
      });
    return { allOf: [r, n].filter((s) => s !== void 0) };
  };
function p3(t, e) {
  return it(t.type._def, e);
}
function f3(t, e) {
  let n = {
    type: "array",
    uniqueItems: !0,
    items: it(t.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "items"],
    }),
  };
  return (
    t.minSize && ft(n, "minItems", t.minSize.value, t.minSize.message, e),
    t.maxSize && ft(n, "maxItems", t.maxSize.value, t.maxSize.message, e),
    n
  );
}
function m3(t, e) {
  return t.rest
    ? {
        type: "array",
        minItems: t.items.length,
        items: t.items
          .map((r, n) =>
            it(r._def, {
              ...e,
              currentPath: [...e.currentPath, "items", `${n}`],
            }),
          )
          .reduce((r, n) => (n === void 0 ? r : [...r, n]), []),
        additionalItems: it(t.rest._def, {
          ...e,
          currentPath: [...e.currentPath, "additionalItems"],
        }),
      }
    : {
        type: "array",
        minItems: t.items.length,
        maxItems: t.items.length,
        items: t.items
          .map((r, n) =>
            it(r._def, {
              ...e,
              currentPath: [...e.currentPath, "items", `${n}`],
            }),
          )
          .reduce((r, n) => (n === void 0 ? r : [...r, n]), []),
      };
}
function h3(t) {
  return { not: yr(t) };
}
function g3(t) {
  return yr(t);
}
var v3 = (t, e) => it(t.innerType._def, e),
  y3 = (t, e, r) => {
    switch (e) {
      case ie.ZodString:
        return kE(t, r);
      case ie.ZodNumber:
        return i3(t, r);
      case ie.ZodObject:
        return o3(t, r);
      case ie.ZodBigInt:
        return zV(t, r);
      case ie.ZodBoolean:
        return BV();
      case ie.ZodDate:
        return PE(t, r);
      case ie.ZodUndefined:
        return h3(r);
      case ie.ZodNull:
        return n3(r);
      case ie.ZodArray:
        return qV(t, r);
      case ie.ZodUnion:
      case ie.ZodDiscriminatedUnion:
        return s3(t, r);
      case ie.ZodIntersection:
        return JV(t, r);
      case ie.ZodTuple:
        return m3(t, r);
      case ie.ZodRecord:
        return RE(t, r);
      case ie.ZodLiteral:
        return XV(t, r);
      case ie.ZodEnum:
        return WV(t);
      case ie.ZodNativeEnum:
        return t3(t);
      case ie.ZodNullable:
        return a3(t, r);
      case ie.ZodOptional:
        return u3(t, r);
      case ie.ZodMap:
        return e3(t, r);
      case ie.ZodSet:
        return f3(t, r);
      case ie.ZodLazy:
        return () => t.getter()._def;
      case ie.ZodPromise:
        return p3(t, r);
      case ie.ZodNaN:
      case ie.ZodNever:
        return r3(r);
      case ie.ZodEffects:
        return GV(t, r);
      case ie.ZodAny:
        return yr(r);
      case ie.ZodUnknown:
        return g3(r);
      case ie.ZodDefault:
        return ZV(t, r);
      case ie.ZodBranded:
        return CE(t, r);
      case ie.ZodReadonly:
        return v3(t, r);
      case ie.ZodCatch:
        return HV(t, r);
      case ie.ZodPipeline:
        return d3(t, r);
      case ie.ZodFunction:
      case ie.ZodVoid:
      case ie.ZodSymbol:
        return;
      default:
        return ((n) => {})(e);
    }
  };
function it(t, e, r = !1) {
  let n = e.seen.get(t);
  if (e.override) {
    let o = e.override?.(t, e, n, r);
    if (o !== jV) return o;
  }
  if (n && !r) {
    let o = b3(n, e);
    if (o !== void 0) return o;
  }
  let s = { def: t, path: e.currentPath, jsonSchema: void 0 };
  e.seen.set(t, s);
  let a = y3(t, t.typeName, e),
    i = typeof a == "function" ? it(a(), e) : a;
  if ((i && _3(t, e, i), e.postProcess)) {
    let o = e.postProcess(i, t, e);
    return ((s.jsonSchema = i), o);
  }
  return ((s.jsonSchema = i), i);
}
var b3 = (t, e) => {
    switch (e.$refStrategy) {
      case "root":
        return { $ref: t.path.join("/") };
      case "relative":
        return { $ref: TE(e.currentPath, t.path) };
      case "none":
      case "seen":
        return t.path.length < e.currentPath.length &&
          t.path.every((r, n) => e.currentPath[n] === r)
          ? (console.warn(
              `Recursive reference detected at ${e.currentPath.join("/")}! Defaulting to any`,
            ),
            yr(e))
          : e.$refStrategy === "seen"
            ? yr(e)
            : void 0;
    }
  },
  _3 = (t, e, r) => (
    t.description &&
      ((r.description = t.description),
      e.markdownDescription && (r.markdownDescription = t.description)),
    r
  ),
  x3 = (t, e) => {
    let r = UV(e),
      n =
        typeof e == "object" && e.definitions
          ? Object.entries(e.definitions).reduce(
              (c, [l, u]) => ({
                ...c,
                [l]:
                  it(
                    u._def,
                    { ...r, currentPath: [...r.basePath, r.definitionPath, l] },
                    !0,
                  ) ?? yr(r),
              }),
              {},
            )
          : void 0,
      s =
        typeof e == "string"
          ? e
          : e?.nameStrategy === "title"
            ? void 0
            : e?.name,
      a =
        it(
          t._def,
          s === void 0
            ? r
            : { ...r, currentPath: [...r.basePath, r.definitionPath, s] },
          !1,
        ) ?? yr(r),
      i =
        typeof e == "object" && e.name !== void 0 && e.nameStrategy === "title"
          ? e.name
          : void 0;
    (i !== void 0 && (a.title = i),
      r.flags.hasReferencedOpenAiAnyType &&
        (n || (n = {}),
        n[r.openAiAnyTypeName] ||
          (n[r.openAiAnyTypeName] = {
            type: ["string", "number", "integer", "boolean", "array", "null"],
            items: {
              $ref:
                r.$refStrategy === "relative"
                  ? "1"
                  : [...r.basePath, r.definitionPath, r.openAiAnyTypeName].join(
                      "/",
                    ),
            },
          })));
    let o =
      s === void 0
        ? n
          ? { ...a, [r.definitionPath]: n }
          : a
        : {
            $ref: [
              ...(r.$refStrategy === "relative" ? [] : r.basePath),
              r.definitionPath,
              s,
            ].join("/"),
            [r.definitionPath]: { ...n, [s]: a },
          };
    return (
      r.target === "jsonSchema7"
        ? (o.$schema = "http://json-schema.org/draft-07/schema#")
        : (r.target === "jsonSchema2019-09" || r.target === "openAi") &&
          (o.$schema = "https://json-schema.org/draft/2019-09/schema#"),
      r.target === "openAi" &&
        ("anyOf" in o ||
          "oneOf" in o ||
          "allOf" in o ||
          ("type" in o && Array.isArray(o.type))) &&
        console.warn(
          "Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.",
        ),
      o
    );
  };
function w3(t) {
  return !t || t === "jsonSchema7" || t === "draft-7"
    ? "draft-7"
    : t === "jsonSchema2019-09" || t === "draft-2020-12"
      ? "draft-2020-12"
      : "draft-7";
}
function TS(t, e) {
  var r, n, s;
  return dn(t)
    ? iB(t, {
        target: w3(e?.target),
        io: (r = e?.pipeStrategy) !== null && r !== void 0 ? r : "input",
      })
    : x3(t, {
        strictUnions: (n = e?.strictUnions) !== null && n !== void 0 ? n : !0,
        pipeStrategy:
          (s = e?.pipeStrategy) !== null && s !== void 0 ? s : "input",
      });
}
function CS(t) {
  let e = oc(t),
    r = e?.method;
  if (!r) throw new Error("Schema is missing a method literal");
  let n = M0(r);
  if (typeof n != "string")
    throw new Error("Schema method literal must be a string");
  return n;
}
function PS(t, e) {
  let r = Ho(t, e);
  if (!r.success) throw r.error;
  return r.data;
}
var S3 = 6e4,
  Nm = class {
    constructor(e) {
      ((this._options = e),
        (this._requestMessageId = 0),
        (this._requestHandlers = new Map()),
        (this._requestHandlerAbortControllers = new Map()),
        (this._notificationHandlers = new Map()),
        (this._responseHandlers = new Map()),
        (this._progressHandlers = new Map()),
        (this._timeoutInfo = new Map()),
        (this._pendingDebouncedNotifications = new Set()),
        (this._taskProgressTokens = new Map()),
        (this._requestResolvers = new Map()),
        this.setNotificationHandler(rh, (r) => {
          this._oncancel(r);
        }),
        this.setNotificationHandler(sh, (r) => {
          this._onprogress(r);
        }),
        this.setRequestHandler(nh, (r) => ({})),
        (this._taskStore = e?.taskStore),
        (this._taskMessageQueue = e?.taskMessageQueue),
        this._taskStore &&
          (this.setRequestHandler(ah, async (r, n) => {
            let s = await this._taskStore.getTask(r.params.taskId, n.sessionId);
            if (!s)
              throw new Pe(
                Ie.InvalidParams,
                "Failed to retrieve task: Task not found",
              );
            return { ...s };
          }),
          this.setRequestHandler(oh, async (r, n) => {
            let s = async () => {
              var a;
              let i = r.params.taskId;
              if (this._taskMessageQueue) {
                let c;
                for (
                  ;
                  (c = await this._taskMessageQueue.dequeue(i, n.sessionId));
                ) {
                  if (c.type === "response" || c.type === "error") {
                    let l = c.message,
                      u = l.id,
                      d = this._requestResolvers.get(u);
                    if (d)
                      if (
                        (this._requestResolvers.delete(u),
                        c.type === "response")
                      )
                        d(l);
                      else {
                        let m = l,
                          p = new Pe(
                            m.error.code,
                            m.error.message,
                            m.error.data,
                          );
                        d(p);
                      }
                    else {
                      let m = c.type === "response" ? "Response" : "Error";
                      this._onerror(
                        new Error(`${m} handler missing for request ${u}`),
                      );
                    }
                    continue;
                  }
                  await ((a = this._transport) === null || a === void 0
                    ? void 0
                    : a.send(c.message, { relatedRequestId: n.requestId }));
                }
              }
              let o = await this._taskStore.getTask(i, n.sessionId);
              if (!o) throw new Pe(Ie.InvalidParams, `Task not found: ${i}`);
              if (!Xs(o.status))
                return (await this._waitForTaskUpdate(i, n.signal), await s());
              if (Xs(o.status)) {
                let c = await this._taskStore.getTaskResult(i, n.sessionId);
                return (
                  this._clearTaskQueue(i),
                  { ...c, _meta: { ...c._meta, [Vn]: { taskId: i } } }
                );
              }
              return await s();
            };
            return await s();
          }),
          this.setRequestHandler(ch, async (r, n) => {
            var s;
            try {
              let { tasks: a, nextCursor: i } = await this._taskStore.listTasks(
                (s = r.params) === null || s === void 0 ? void 0 : s.cursor,
                n.sessionId,
              );
              return { tasks: a, nextCursor: i, _meta: {} };
            } catch (a) {
              throw new Pe(
                Ie.InvalidParams,
                `Failed to list tasks: ${a instanceof Error ? a.message : String(a)}`,
              );
            }
          }),
          this.setRequestHandler(TH, async (r, n) => {
            try {
              let s = await this._taskStore.getTask(
                r.params.taskId,
                n.sessionId,
              );
              if (!s)
                throw new Pe(
                  Ie.InvalidParams,
                  `Task not found: ${r.params.taskId}`,
                );
              if (Xs(s.status))
                throw new Pe(
                  Ie.InvalidParams,
                  `Cannot cancel task in terminal status: ${s.status}`,
                );
              (await this._taskStore.updateTaskStatus(
                r.params.taskId,
                "cancelled",
                "Client cancelled task execution.",
                n.sessionId,
              ),
                this._clearTaskQueue(r.params.taskId));
              let a = await this._taskStore.getTask(
                r.params.taskId,
                n.sessionId,
              );
              if (!a)
                throw new Pe(
                  Ie.InvalidParams,
                  `Task not found after cancellation: ${r.params.taskId}`,
                );
              return { _meta: {}, ...a };
            } catch (s) {
              throw s instanceof Pe
                ? s
                : new Pe(
                    Ie.InvalidRequest,
                    `Failed to cancel task: ${s instanceof Error ? s.message : String(s)}`,
                  );
            }
          })));
    }
    async _oncancel(e) {
      let r = this._requestHandlerAbortControllers.get(e.params.requestId);
      r?.abort(e.params.reason);
    }
    _setupTimeout(e, r, n, s, a = !1) {
      this._timeoutInfo.set(e, {
        timeoutId: setTimeout(s, r),
        startTime: Date.now(),
        timeout: r,
        maxTotalTimeout: n,
        resetTimeoutOnProgress: a,
        onTimeout: s,
      });
    }
    _resetTimeout(e) {
      let r = this._timeoutInfo.get(e);
      if (!r) return !1;
      let n = Date.now() - r.startTime;
      if (r.maxTotalTimeout && n >= r.maxTotalTimeout)
        throw (
          this._timeoutInfo.delete(e),
          Pe.fromError(Ie.RequestTimeout, "Maximum total timeout exceeded", {
            maxTotalTimeout: r.maxTotalTimeout,
            totalElapsed: n,
          })
        );
      return (
        clearTimeout(r.timeoutId),
        (r.timeoutId = setTimeout(r.onTimeout, r.timeout)),
        !0
      );
    }
    _cleanupTimeout(e) {
      let r = this._timeoutInfo.get(e);
      r && (clearTimeout(r.timeoutId), this._timeoutInfo.delete(e));
    }
    async connect(e) {
      var r, n, s;
      this._transport = e;
      let a =
        (r = this.transport) === null || r === void 0 ? void 0 : r.onclose;
      this._transport.onclose = () => {
        (a?.(), this._onclose());
      };
      let i =
        (n = this.transport) === null || n === void 0 ? void 0 : n.onerror;
      this._transport.onerror = (c) => {
        (i?.(c), this._onerror(c));
      };
      let o =
        (s = this._transport) === null || s === void 0 ? void 0 : s.onmessage;
      ((this._transport.onmessage = (c, l) => {
        (o?.(c, l),
          Bl(c) || uH(c)
            ? this._onresponse(c)
            : xS(c)
              ? this._onrequest(c, l)
              : lH(c)
                ? this._onnotification(c)
                : this._onerror(
                    new Error(`Unknown message type: ${JSON.stringify(c)}`),
                  ));
      }),
        await this._transport.start());
    }
    _onclose() {
      var e;
      let r = this._responseHandlers;
      ((this._responseHandlers = new Map()),
        this._progressHandlers.clear(),
        this._taskProgressTokens.clear(),
        this._pendingDebouncedNotifications.clear());
      let n = Pe.fromError(Ie.ConnectionClosed, "Connection closed");
      ((this._transport = void 0),
        (e = this.onclose) === null || e === void 0 || e.call(this));
      for (let s of r.values()) s(n);
    }
    _onerror(e) {
      var r;
      (r = this.onerror) === null || r === void 0 || r.call(this, e);
    }
    _onnotification(e) {
      var r;
      let n =
        (r = this._notificationHandlers.get(e.method)) !== null && r !== void 0
          ? r
          : this.fallbackNotificationHandler;
      n !== void 0 &&
        Promise.resolve()
          .then(() => n(e))
          .catch((s) =>
            this._onerror(
              new Error(`Uncaught error in notification handler: ${s}`),
            ),
          );
    }
    _onrequest(e, r) {
      var n, s, a, i, o, c;
      let l =
          (n = this._requestHandlers.get(e.method)) !== null && n !== void 0
            ? n
            : this.fallbackRequestHandler,
        u = this._transport,
        d =
          (i =
            (a = (s = e.params) === null || s === void 0 ? void 0 : s._meta) ===
              null || a === void 0
              ? void 0
              : a[Vn]) === null || i === void 0
            ? void 0
            : i.taskId;
      if (l === void 0) {
        let h = {
          jsonrpc: "2.0",
          id: e.id,
          error: { code: Ie.MethodNotFound, message: "Method not found" },
        };
        d && this._taskMessageQueue
          ? this._enqueueTaskMessage(
              d,
              { type: "error", message: h, timestamp: Date.now() },
              u?.sessionId,
            ).catch((g) =>
              this._onerror(
                new Error(`Failed to enqueue error response: ${g}`),
              ),
            )
          : u
              ?.send(h)
              .catch((g) =>
                this._onerror(
                  new Error(`Failed to send an error response: ${g}`),
                ),
              );
        return;
      }
      let m = new AbortController();
      this._requestHandlerAbortControllers.set(e.id, m);
      let p = (o = e.params) === null || o === void 0 ? void 0 : o.task,
        f = this._taskStore ? this.requestTaskStore(e, u?.sessionId) : void 0,
        y = {
          signal: m.signal,
          sessionId: u?.sessionId,
          _meta: (c = e.params) === null || c === void 0 ? void 0 : c._meta,
          sendNotification: async (h) => {
            let g = { relatedRequestId: e.id };
            (d && (g.relatedTask = { taskId: d }),
              await this.notification(h, g));
          },
          sendRequest: async (h, g, _) => {
            var v, b;
            let x = { ..._, relatedRequestId: e.id };
            d && !x.relatedTask && (x.relatedTask = { taskId: d });
            let w =
              (b =
                (v = x.relatedTask) === null || v === void 0
                  ? void 0
                  : v.taskId) !== null && b !== void 0
                ? b
                : d;
            return (
              w && f && (await f.updateTaskStatus(w, "input_required")),
              await this.request(h, g, x)
            );
          },
          authInfo: r?.authInfo,
          requestId: e.id,
          requestInfo: r?.requestInfo,
          taskId: d,
          taskStore: f,
          taskRequestedTtl: p?.ttl,
          closeSSEStream: r?.closeSSEStream,
          closeStandaloneSSEStream: r?.closeStandaloneSSEStream,
        };
      Promise.resolve()
        .then(() => {
          p && this.assertTaskHandlerCapability(e.method);
        })
        .then(() => l(e, y))
        .then(
          async (h) => {
            if (m.signal.aborted) return;
            let g = { result: h, jsonrpc: "2.0", id: e.id };
            d && this._taskMessageQueue
              ? await this._enqueueTaskMessage(
                  d,
                  { type: "response", message: g, timestamp: Date.now() },
                  u?.sessionId,
                )
              : await u?.send(g);
          },
          async (h) => {
            var g;
            if (m.signal.aborted) return;
            let _ = {
              jsonrpc: "2.0",
              id: e.id,
              error: {
                code: Number.isSafeInteger(h.code) ? h.code : Ie.InternalError,
                message:
                  (g = h.message) !== null && g !== void 0
                    ? g
                    : "Internal error",
                ...(h.data !== void 0 && { data: h.data }),
              },
            };
            d && this._taskMessageQueue
              ? await this._enqueueTaskMessage(
                  d,
                  { type: "error", message: _, timestamp: Date.now() },
                  u?.sessionId,
                )
              : await u?.send(_);
          },
        )
        .catch((h) => this._onerror(new Error(`Failed to send response: ${h}`)))
        .finally(() => {
          this._requestHandlerAbortControllers.delete(e.id);
        });
    }
    _onprogress(e) {
      let { progressToken: r, ...n } = e.params,
        s = Number(r),
        a = this._progressHandlers.get(s);
      if (!a) {
        this._onerror(
          new Error(
            `Received a progress notification for an unknown token: ${JSON.stringify(e)}`,
          ),
        );
        return;
      }
      let i = this._responseHandlers.get(s),
        o = this._timeoutInfo.get(s);
      if (o && i && o.resetTimeoutOnProgress)
        try {
          this._resetTimeout(s);
        } catch (c) {
          (this._responseHandlers.delete(s),
            this._progressHandlers.delete(s),
            this._cleanupTimeout(s),
            i(c));
          return;
        }
      a(n);
    }
    _onresponse(e) {
      let r = Number(e.id),
        n = this._requestResolvers.get(r);
      if (n) {
        if ((this._requestResolvers.delete(r), Bl(e))) n(e);
        else {
          let i = new Pe(e.error.code, e.error.message, e.error.data);
          n(i);
        }
        return;
      }
      let s = this._responseHandlers.get(r);
      if (s === void 0) {
        this._onerror(
          new Error(
            `Received a response for an unknown message ID: ${JSON.stringify(e)}`,
          ),
        );
        return;
      }
      (this._responseHandlers.delete(r), this._cleanupTimeout(r));
      let a = !1;
      if (Bl(e) && e.result && typeof e.result == "object") {
        let i = e.result;
        if (i.task && typeof i.task == "object") {
          let o = i.task;
          typeof o.taskId == "string" &&
            ((a = !0), this._taskProgressTokens.set(o.taskId, r));
        }
      }
      if ((a || this._progressHandlers.delete(r), Bl(e))) s(e);
      else {
        let i = Pe.fromError(e.error.code, e.error.message, e.error.data);
        s(i);
      }
    }
    get transport() {
      return this._transport;
    }
    async close() {
      var e;
      await ((e = this._transport) === null || e === void 0
        ? void 0
        : e.close());
    }
    async *requestStream(e, r, n) {
      var s, a, i, o;
      let { task: c } = n ?? {};
      if (!c) {
        try {
          yield { type: "result", result: await this.request(e, r, n) };
        } catch (u) {
          yield {
            type: "error",
            error: u instanceof Pe ? u : new Pe(Ie.InternalError, String(u)),
          };
        }
        return;
      }
      let l;
      try {
        let u = await this.request(e, bu, n);
        if (u.task)
          ((l = u.task.taskId), yield { type: "taskCreated", task: u.task });
        else
          throw new Pe(Ie.InternalError, "Task creation did not return a task");
        for (;;) {
          let d = await this.getTask({ taskId: l }, n);
          if ((yield { type: "taskStatus", task: d }, Xs(d.status))) {
            d.status === "completed"
              ? yield {
                  type: "result",
                  result: await this.getTaskResult({ taskId: l }, r, n),
                }
              : d.status === "failed"
                ? yield {
                    type: "error",
                    error: new Pe(Ie.InternalError, `Task ${l} failed`),
                  }
                : d.status === "cancelled" &&
                  (yield {
                    type: "error",
                    error: new Pe(Ie.InternalError, `Task ${l} was cancelled`),
                  });
            return;
          }
          if (d.status === "input_required") {
            yield {
              type: "result",
              result: await this.getTaskResult({ taskId: l }, r, n),
            };
            return;
          }
          let m =
            (i =
              (s = d.pollInterval) !== null && s !== void 0
                ? s
                : (a = this._options) === null || a === void 0
                  ? void 0
                  : a.defaultTaskPollInterval) !== null && i !== void 0
              ? i
              : 1e3;
          (await new Promise((p) => setTimeout(p, m)),
            (o = n?.signal) === null || o === void 0 || o.throwIfAborted());
        }
      } catch (u) {
        yield {
          type: "error",
          error: u instanceof Pe ? u : new Pe(Ie.InternalError, String(u)),
        };
      }
    }
    request(e, r, n) {
      let {
        relatedRequestId: s,
        resumptionToken: a,
        onresumptiontoken: i,
        task: o,
        relatedTask: c,
      } = n ?? {};
      return new Promise((l, u) => {
        var d, m, p, f, y, h, g;
        let _ = (P) => {
          u(P);
        };
        if (!this._transport) {
          _(new Error("Not connected"));
          return;
        }
        if (
          ((d = this._options) === null || d === void 0
            ? void 0
            : d.enforceStrictCapabilities) === !0
        )
          try {
            (this.assertCapabilityForMethod(e.method),
              o && this.assertTaskCapability(e.method));
          } catch (P) {
            _(P);
            return;
          }
        (m = n?.signal) === null || m === void 0 || m.throwIfAborted();
        let v = this._requestMessageId++,
          b = { ...e, jsonrpc: "2.0", id: v };
        (n?.onprogress &&
          (this._progressHandlers.set(v, n.onprogress),
          (b.params = {
            ...e.params,
            _meta: {
              ...(((p = e.params) === null || p === void 0
                ? void 0
                : p._meta) || {}),
              progressToken: v,
            },
          })),
          o && (b.params = { ...b.params, task: o }),
          c &&
            (b.params = {
              ...b.params,
              _meta: {
                ...(((f = b.params) === null || f === void 0
                  ? void 0
                  : f._meta) || {}),
                [Vn]: c,
              },
            }));
        let x = (P) => {
          var A;
          (this._responseHandlers.delete(v),
            this._progressHandlers.delete(v),
            this._cleanupTimeout(v),
            (A = this._transport) === null ||
              A === void 0 ||
              A.send(
                {
                  jsonrpc: "2.0",
                  method: "notifications/cancelled",
                  params: { requestId: v, reason: String(P) },
                },
                {
                  relatedRequestId: s,
                  resumptionToken: a,
                  onresumptiontoken: i,
                },
              ).catch((D) =>
                this._onerror(new Error(`Failed to send cancellation: ${D}`)),
              ));
          let R = P instanceof Pe ? P : new Pe(Ie.RequestTimeout, String(P));
          u(R);
        };
        (this._responseHandlers.set(v, (P) => {
          var A;
          if (!(!((A = n?.signal) === null || A === void 0) && A.aborted)) {
            if (P instanceof Error) return u(P);
            try {
              let R = Ho(r, P.result);
              R.success ? l(R.data) : u(R.error);
            } catch (R) {
              u(R);
            }
          }
        }),
          (y = n?.signal) === null ||
            y === void 0 ||
            y.addEventListener("abort", () => {
              var P;
              x((P = n?.signal) === null || P === void 0 ? void 0 : P.reason);
            }));
        let w = (h = n?.timeout) !== null && h !== void 0 ? h : S3,
          S = () =>
            x(
              Pe.fromError(Ie.RequestTimeout, "Request timed out", {
                timeout: w,
              }),
            );
        this._setupTimeout(
          v,
          w,
          n?.maxTotalTimeout,
          S,
          (g = n?.resetTimeoutOnProgress) !== null && g !== void 0 ? g : !1,
        );
        let C = c?.taskId;
        if (C) {
          let P = (A) => {
            let R = this._responseHandlers.get(v);
            R
              ? R(A)
              : this._onerror(
                  new Error(
                    `Response handler missing for side-channeled request ${v}`,
                  ),
                );
          };
          (this._requestResolvers.set(v, P),
            this._enqueueTaskMessage(C, {
              type: "request",
              message: b,
              timestamp: Date.now(),
            }).catch((A) => {
              (this._cleanupTimeout(v), u(A));
            }));
        } else
          this._transport
            .send(b, {
              relatedRequestId: s,
              resumptionToken: a,
              onresumptiontoken: i,
            })
            .catch((P) => {
              (this._cleanupTimeout(v), u(P));
            });
      });
    }
    async getTask(e, r) {
      return this.request({ method: "tasks/get", params: e }, ih, r);
    }
    async getTaskResult(e, r, n) {
      return this.request({ method: "tasks/result", params: e }, r, n);
    }
    async listTasks(e, r) {
      return this.request({ method: "tasks/list", params: e }, lh, r);
    }
    async cancelTask(e, r) {
      return this.request({ method: "tasks/cancel", params: e }, CH, r);
    }
    async notification(e, r) {
      var n, s, a, i, o;
      if (!this._transport) throw new Error("Not connected");
      this.assertNotificationCapability(e.method);
      let c = (n = r?.relatedTask) === null || n === void 0 ? void 0 : n.taskId;
      if (c) {
        let m = {
          ...e,
          jsonrpc: "2.0",
          params: {
            ...e.params,
            _meta: {
              ...(((s = e.params) === null || s === void 0
                ? void 0
                : s._meta) || {}),
              [Vn]: r.relatedTask,
            },
          },
        };
        await this._enqueueTaskMessage(c, {
          type: "notification",
          message: m,
          timestamp: Date.now(),
        });
        return;
      }
      if (
        ((i =
          (a = this._options) === null || a === void 0
            ? void 0
            : a.debouncedNotificationMethods) !== null && i !== void 0
          ? i
          : []
        ).includes(e.method) &&
        !e.params &&
        !r?.relatedRequestId &&
        !r?.relatedTask
      ) {
        if (this._pendingDebouncedNotifications.has(e.method)) return;
        (this._pendingDebouncedNotifications.add(e.method),
          Promise.resolve().then(() => {
            var m, p;
            if (
              (this._pendingDebouncedNotifications.delete(e.method),
              !this._transport)
            )
              return;
            let f = { ...e, jsonrpc: "2.0" };
            (r?.relatedTask &&
              (f = {
                ...f,
                params: {
                  ...f.params,
                  _meta: {
                    ...(((m = f.params) === null || m === void 0
                      ? void 0
                      : m._meta) || {}),
                    [Vn]: r.relatedTask,
                  },
                },
              }),
              (p = this._transport) === null ||
                p === void 0 ||
                p.send(f, r).catch((y) => this._onerror(y)));
          }));
        return;
      }
      let d = { ...e, jsonrpc: "2.0" };
      (r?.relatedTask &&
        (d = {
          ...d,
          params: {
            ...d.params,
            _meta: {
              ...(((o = d.params) === null || o === void 0
                ? void 0
                : o._meta) || {}),
              [Vn]: r.relatedTask,
            },
          },
        }),
        await this._transport.send(d, r));
    }
    setRequestHandler(e, r) {
      let n = CS(e);
      (this.assertRequestHandlerCapability(n),
        this._requestHandlers.set(n, (s, a) => {
          let i = PS(e, s);
          return Promise.resolve(r(i, a));
        }));
    }
    removeRequestHandler(e) {
      this._requestHandlers.delete(e);
    }
    assertCanSetRequestHandler(e) {
      if (this._requestHandlers.has(e))
        throw new Error(
          `A request handler for ${e} already exists, which would be overridden`,
        );
    }
    setNotificationHandler(e, r) {
      let n = CS(e);
      this._notificationHandlers.set(n, (s) => {
        let a = PS(e, s);
        return Promise.resolve(r(a));
      });
    }
    removeNotificationHandler(e) {
      this._notificationHandlers.delete(e);
    }
    _cleanupTaskProgressHandler(e) {
      let r = this._taskProgressTokens.get(e);
      r !== void 0 &&
        (this._progressHandlers.delete(r), this._taskProgressTokens.delete(e));
    }
    async _enqueueTaskMessage(e, r, n) {
      var s;
      if (!this._taskStore || !this._taskMessageQueue)
        throw new Error(
          "Cannot enqueue task message: taskStore and taskMessageQueue are not configured",
        );
      let a =
        (s = this._options) === null || s === void 0
          ? void 0
          : s.maxTaskQueueSize;
      await this._taskMessageQueue.enqueue(e, r, n, a);
    }
    async _clearTaskQueue(e, r) {
      if (this._taskMessageQueue) {
        let n = await this._taskMessageQueue.dequeueAll(e, r);
        for (let s of n)
          if (s.type === "request" && xS(s.message)) {
            let a = s.message.id,
              i = this._requestResolvers.get(a);
            i
              ? (i(new Pe(Ie.InternalError, "Task cancelled or completed")),
                this._requestResolvers.delete(a))
              : this._onerror(
                  new Error(
                    `Resolver missing for request ${a} during task ${e} cleanup`,
                  ),
                );
          }
      }
    }
    async _waitForTaskUpdate(e, r) {
      var n, s, a;
      let i =
        (s =
          (n = this._options) === null || n === void 0
            ? void 0
            : n.defaultTaskPollInterval) !== null && s !== void 0
          ? s
          : 1e3;
      try {
        let o = await ((a = this._taskStore) === null || a === void 0
          ? void 0
          : a.getTask(e));
        o?.pollInterval && (i = o.pollInterval);
      } catch {}
      return new Promise((o, c) => {
        if (r.aborted) {
          c(new Pe(Ie.InvalidRequest, "Request cancelled"));
          return;
        }
        let l = setTimeout(o, i);
        r.addEventListener(
          "abort",
          () => {
            (clearTimeout(l),
              c(new Pe(Ie.InvalidRequest, "Request cancelled")));
          },
          { once: !0 },
        );
      });
    }
    requestTaskStore(e, r) {
      let n = this._taskStore;
      if (!n) throw new Error("No task store configured");
      return {
        createTask: async (s) => {
          if (!e) throw new Error("No request provided");
          return await n.createTask(
            s,
            e.id,
            { method: e.method, params: e.params },
            r,
          );
        },
        getTask: async (s) => {
          let a = await n.getTask(s, r);
          if (!a)
            throw new Pe(
              Ie.InvalidParams,
              "Failed to retrieve task: Task not found",
            );
          return a;
        },
        storeTaskResult: async (s, a, i) => {
          await n.storeTaskResult(s, a, i, r);
          let o = await n.getTask(s, r);
          if (o) {
            let c = Ql.parse({
              method: "notifications/tasks/status",
              params: o,
            });
            (await this.notification(c),
              Xs(o.status) && this._cleanupTaskProgressHandler(s));
          }
        },
        getTaskResult: (s) => n.getTaskResult(s, r),
        updateTaskStatus: async (s, a, i) => {
          let o = await n.getTask(s, r);
          if (!o)
            throw new Pe(
              Ie.InvalidParams,
              `Task "${s}" not found - it may have been cleaned up`,
            );
          if (Xs(o.status))
            throw new Pe(
              Ie.InvalidParams,
              `Cannot update task "${s}" from terminal status "${o.status}" to "${a}". Terminal states (completed, failed, cancelled) cannot transition to other states.`,
            );
          await n.updateTaskStatus(s, a, i, r);
          let c = await n.getTask(s, r);
          if (c) {
            let l = Ql.parse({
              method: "notifications/tasks/status",
              params: c,
            });
            (await this.notification(l),
              Xs(c.status) && this._cleanupTaskProgressHandler(s));
          }
        },
        listTasks: (s) => n.listTasks(s, r),
      };
    }
  };
function kS(t) {
  return t !== null && typeof t == "object" && !Array.isArray(t);
}
function E3(t, e) {
  let r = { ...t };
  for (let n in e) {
    let s = n,
      a = e[s];
    if (a === void 0) continue;
    let i = r[s];
    kS(i) && kS(a) ? (r[s] = { ...i, ...a }) : (r[s] = a);
  }
  return r;
}
var T3 = AS(qS(), 1),
  C3 = AS(CU(), 1);
function P3() {
  let t = new T3.Ajv({
      strict: !1,
      validateFormats: !0,
      validateSchema: !1,
      allErrors: !0,
    }),
    e = C3.default;
  return (e(t), t);
}
var Dm = class {
    constructor(e) {
      this._ajv = e ?? P3();
    }
    getValidator(e) {
      var r;
      let n =
        "$id" in e && typeof e.$id == "string"
          ? (r = this._ajv.getSchema(e.$id)) !== null && r !== void 0
            ? r
            : this._ajv.compile(e)
          : this._ajv.compile(e);
      return (s) =>
        n(s)
          ? { valid: !0, data: s, errorMessage: void 0 }
          : {
              valid: !1,
              data: void 0,
              errorMessage: this._ajv.errorsText(n.errors),
            };
    }
  },
  Lm = class {
    constructor(e) {
      this._server = e;
    }
    requestStream(e, r, n) {
      return this._server.requestStream(e, r, n);
    }
    async getTask(e, r) {
      return this._server.getTask({ taskId: e }, r);
    }
    async getTaskResult(e, r, n) {
      return this._server.getTaskResult({ taskId: e }, r, n);
    }
    async listTasks(e, r) {
      return this._server.listTasks(e ? { cursor: e } : void 0, r);
    }
    async cancelTask(e, r) {
      return this._server.cancelTask({ taskId: e }, r);
    }
  };
function k3(t, e, r) {
  var n;
  if (!t)
    throw new Error(`${r} does not support task creation (required for ${e})`);
  switch (e) {
    case "tools/call":
      if (!(!((n = t.tools) === null || n === void 0) && n.call))
        throw new Error(
          `${r} does not support task creation for tools/call (required for ${e})`,
        );
      break;
    default:
      break;
  }
}
function R3(t, e, r) {
  var n, s;
  if (!t)
    throw new Error(`${r} does not support task creation (required for ${e})`);
  switch (e) {
    case "sampling/createMessage":
      if (!(!((n = t.sampling) === null || n === void 0) && n.createMessage))
        throw new Error(
          `${r} does not support task creation for sampling/createMessage (required for ${e})`,
        );
      break;
    case "elicitation/create":
      if (!(!((s = t.elicitation) === null || s === void 0) && s.create))
        throw new Error(
          `${r} does not support task creation for elicitation/create (required for ${e})`,
        );
      break;
    default:
      break;
  }
}
var Mm = class extends Nm {
    constructor(e, r) {
      var n, s;
      (super(r),
        (this._serverInfo = e),
        (this._loggingLevels = new Map()),
        (this.LOG_LEVEL_SEVERITY = new Map(tu.options.map((a, i) => [a, i]))),
        (this.isMessageIgnored = (a, i) => {
          let o = this._loggingLevels.get(i);
          return o
            ? this.LOG_LEVEL_SEVERITY.get(a) < this.LOG_LEVEL_SEVERITY.get(o)
            : !1;
        }),
        (this._capabilities =
          (n = r?.capabilities) !== null && n !== void 0 ? n : {}),
        (this._instructions = r?.instructions),
        (this._jsonSchemaValidator =
          (s = r?.jsonSchemaValidator) !== null && s !== void 0 ? s : new Dm()),
        this.setRequestHandler(fE, (a) => this._oninitialize(a)),
        this.setNotificationHandler(mE, () => {
          var a;
          return (a = this.oninitialized) === null || a === void 0
            ? void 0
            : a.call(this);
        }),
        this._capabilities.logging &&
          this.setRequestHandler(_E, async (a, i) => {
            var o;
            let c =
                i.sessionId ||
                ((o = i.requestInfo) === null || o === void 0
                  ? void 0
                  : o.headers["mcp-session-id"]) ||
                void 0,
              { level: l } = a.params,
              u = tu.safeParse(l);
            return (u.success && this._loggingLevels.set(c, u.data), {});
          }));
    }
    get experimental() {
      return (
        this._experimental || (this._experimental = { tasks: new Lm(this) }),
        this._experimental
      );
    }
    registerCapabilities(e) {
      if (this.transport)
        throw new Error(
          "Cannot register capabilities after connecting to transport",
        );
      this._capabilities = E3(this._capabilities, e);
    }
    setRequestHandler(e, r) {
      var n, s, a;
      let i = oc(e),
        o = i?.method;
      if (!o) throw new Error("Schema is missing a method literal");
      let c;
      if (dn(o)) {
        let u = o,
          d = (n = u._zod) === null || n === void 0 ? void 0 : n.def;
        c = (s = d?.value) !== null && s !== void 0 ? s : u.value;
      } else {
        let u = o,
          d = u._def;
        c = (a = d?.value) !== null && a !== void 0 ? a : u.value;
      }
      if (typeof c != "string")
        throw new Error("Schema method literal must be a string");
      if (c === "tools/call") {
        let u = async (d, m) => {
          let p = Ho(eu, d);
          if (!p.success) {
            let g =
              p.error instanceof Error ? p.error.message : String(p.error);
            throw new Pe(Ie.InvalidParams, `Invalid tools/call request: ${g}`);
          }
          let { params: f } = p.data,
            y = await Promise.resolve(r(d, m));
          if (f.task) {
            let g = Ho(bu, y);
            if (!g.success) {
              let _ =
                g.error instanceof Error ? g.error.message : String(g.error);
              throw new Pe(
                Ie.InvalidParams,
                `Invalid task creation result: ${_}`,
              );
            }
            return g.data;
          }
          let h = Ho(gh, y);
          if (!h.success) {
            let g =
              h.error instanceof Error ? h.error.message : String(h.error);
            throw new Pe(Ie.InvalidParams, `Invalid tools/call result: ${g}`);
          }
          return h.data;
        };
        return super.setRequestHandler(e, u);
      }
      return super.setRequestHandler(e, r);
    }
    assertCapabilityForMethod(e) {
      var r, n, s;
      switch (e) {
        case "sampling/createMessage":
          if (
            !(
              !((r = this._clientCapabilities) === null || r === void 0) &&
              r.sampling
            )
          )
            throw new Error(
              `Client does not support sampling (required for ${e})`,
            );
          break;
        case "elicitation/create":
          if (
            !(
              !((n = this._clientCapabilities) === null || n === void 0) &&
              n.elicitation
            )
          )
            throw new Error(
              `Client does not support elicitation (required for ${e})`,
            );
          break;
        case "roots/list":
          if (
            !(
              !((s = this._clientCapabilities) === null || s === void 0) &&
              s.roots
            )
          )
            throw new Error(
              `Client does not support listing roots (required for ${e})`,
            );
          break;
        case "ping":
          break;
      }
    }
    assertNotificationCapability(e) {
      var r, n;
      switch (e) {
        case "notifications/message":
          if (!this._capabilities.logging)
            throw new Error(
              `Server does not support logging (required for ${e})`,
            );
          break;
        case "notifications/resources/updated":
        case "notifications/resources/list_changed":
          if (!this._capabilities.resources)
            throw new Error(
              `Server does not support notifying about resources (required for ${e})`,
            );
          break;
        case "notifications/tools/list_changed":
          if (!this._capabilities.tools)
            throw new Error(
              `Server does not support notifying of tool list changes (required for ${e})`,
            );
          break;
        case "notifications/prompts/list_changed":
          if (!this._capabilities.prompts)
            throw new Error(
              `Server does not support notifying of prompt list changes (required for ${e})`,
            );
          break;
        case "notifications/elicitation/complete":
          if (
            !(
              !(
                (n =
                  (r = this._clientCapabilities) === null || r === void 0
                    ? void 0
                    : r.elicitation) === null || n === void 0
              ) && n.url
            )
          )
            throw new Error(
              `Client does not support URL elicitation (required for ${e})`,
            );
          break;
        case "notifications/cancelled":
          break;
        case "notifications/progress":
          break;
      }
    }
    assertRequestHandlerCapability(e) {
      if (this._capabilities)
        switch (e) {
          case "completion/complete":
            if (!this._capabilities.completions)
              throw new Error(
                `Server does not support completions (required for ${e})`,
              );
            break;
          case "logging/setLevel":
            if (!this._capabilities.logging)
              throw new Error(
                `Server does not support logging (required for ${e})`,
              );
            break;
          case "prompts/get":
          case "prompts/list":
            if (!this._capabilities.prompts)
              throw new Error(
                `Server does not support prompts (required for ${e})`,
              );
            break;
          case "resources/list":
          case "resources/templates/list":
          case "resources/read":
            if (!this._capabilities.resources)
              throw new Error(
                `Server does not support resources (required for ${e})`,
              );
            break;
          case "tools/call":
          case "tools/list":
            if (!this._capabilities.tools)
              throw new Error(
                `Server does not support tools (required for ${e})`,
              );
            break;
          case "tasks/get":
          case "tasks/list":
          case "tasks/result":
          case "tasks/cancel":
            if (!this._capabilities.tasks)
              throw new Error(
                `Server does not support tasks capability (required for ${e})`,
              );
            break;
          case "ping":
          case "initialize":
            break;
        }
    }
    assertTaskCapability(e) {
      var r, n;
      R3(
        (n =
          (r = this._clientCapabilities) === null || r === void 0
            ? void 0
            : r.tasks) === null || n === void 0
          ? void 0
          : n.requests,
        e,
        "Client",
      );
    }
    assertTaskHandlerCapability(e) {
      var r;
      this._capabilities &&
        k3(
          (r = this._capabilities.tasks) === null || r === void 0
            ? void 0
            : r.requests,
          e,
          "Server",
        );
    }
    async _oninitialize(e) {
      let r = e.params.protocolVersion;
      return (
        (this._clientCapabilities = e.params.capabilities),
        (this._clientVersion = e.params.clientInfo),
        {
          protocolVersion: iH.includes(r) ? r : aE,
          capabilities: this.getCapabilities(),
          serverInfo: this._serverInfo,
          ...(this._instructions && { instructions: this._instructions }),
        }
      );
    }
    getClientCapabilities() {
      return this._clientCapabilities;
    }
    getClientVersion() {
      return this._clientVersion;
    }
    getCapabilities() {
      return this._capabilities;
    }
    async ping() {
      return this.request({ method: "ping" }, th);
    }
    async createMessage(e, r) {
      var n, s;
      if (
        (e.tools || e.toolChoice) &&
        !(
          !(
            (s =
              (n = this._clientCapabilities) === null || n === void 0
                ? void 0
                : n.sampling) === null || s === void 0
          ) && s.tools
        )
      )
        throw new Error("Client does not support sampling tools capability.");
      if (e.messages.length > 0) {
        let a = e.messages[e.messages.length - 1],
          i = Array.isArray(a.content) ? a.content : [a.content],
          o = i.some((d) => d.type === "tool_result"),
          c =
            e.messages.length > 1 ? e.messages[e.messages.length - 2] : void 0,
          l = c ? (Array.isArray(c.content) ? c.content : [c.content]) : [],
          u = l.some((d) => d.type === "tool_use");
        if (o) {
          if (i.some((d) => d.type !== "tool_result"))
            throw new Error(
              "The last message must contain only tool_result content if any is present",
            );
          if (!u)
            throw new Error(
              "tool_result blocks are not matching any tool_use from the previous message",
            );
        }
        if (u) {
          let d = new Set(
              l.filter((p) => p.type === "tool_use").map((p) => p.id),
            ),
            m = new Set(
              i.filter((p) => p.type === "tool_result").map((p) => p.toolUseId),
            );
          if (d.size !== m.size || ![...d].every((p) => m.has(p)))
            throw new Error(
              "ids of tool_result blocks and tool_use blocks from previous message do not match",
            );
        }
      }
      return e.tools
        ? this.request({ method: "sampling/createMessage", params: e }, wE, r)
        : this.request({ method: "sampling/createMessage", params: e }, xE, r);
    }
    async elicitInput(e, r) {
      var n, s, a, i, o;
      switch ((n = e.mode) !== null && n !== void 0 ? n : "form") {
        case "url": {
          if (
            !(
              !(
                (a =
                  (s = this._clientCapabilities) === null || s === void 0
                    ? void 0
                    : s.elicitation) === null || a === void 0
              ) && a.url
            )
          )
            throw new Error("Client does not support url elicitation.");
          let l = e;
          return this.request(
            { method: "elicitation/create", params: l },
            Im,
            r,
          );
        }
        case "form": {
          if (
            !(
              !(
                (o =
                  (i = this._clientCapabilities) === null || i === void 0
                    ? void 0
                    : i.elicitation) === null || o === void 0
              ) && o.form
            )
          )
            throw new Error("Client does not support form elicitation.");
          let l = e.mode === "form" ? e : { ...e, mode: "form" },
            u = await this.request(
              { method: "elicitation/create", params: l },
              Im,
              r,
            );
          if (u.action === "accept" && u.content && l.requestedSchema)
            try {
              let m = this._jsonSchemaValidator.getValidator(l.requestedSchema)(
                u.content,
              );
              if (!m.valid)
                throw new Pe(
                  Ie.InvalidParams,
                  `Elicitation response content does not match requested schema: ${m.errorMessage}`,
                );
            } catch (d) {
              throw d instanceof Pe
                ? d
                : new Pe(
                    Ie.InternalError,
                    `Error validating elicitation response: ${d instanceof Error ? d.message : String(d)}`,
                  );
            }
          return u;
        }
      }
    }
    createElicitationCompletionNotifier(e, r) {
      var n, s;
      if (
        !(
          !(
            (s =
              (n = this._clientCapabilities) === null || n === void 0
                ? void 0
                : n.elicitation) === null || s === void 0
          ) && s.url
        )
      )
        throw new Error(
          "Client does not support URL elicitation (required for notifications/elicitation/complete)",
        );
      return () =>
        this.notification(
          {
            method: "notifications/elicitation/complete",
            params: { elicitationId: e },
          },
          r,
        );
    }
    async listRoots(e, r) {
      return this.request({ method: "roots/list", params: e }, SE, r);
    }
    async sendLoggingMessage(e, r) {
      if (this._capabilities.logging && !this.isMessageIgnored(e.level, r))
        return this.notification({
          method: "notifications/message",
          params: e,
        });
    }
    async sendResourceUpdated(e) {
      return this.notification({
        method: "notifications/resources/updated",
        params: e,
      });
    }
    async sendResourceListChanged() {
      return this.notification({
        method: "notifications/resources/list_changed",
      });
    }
    async sendToolListChanged() {
      return this.notification({ method: "notifications/tools/list_changed" });
    }
    async sendPromptListChanged() {
      return this.notification({
        method: "notifications/prompts/list_changed",
      });
    }
  },
  OE = Symbol.for("mcp.completable");
function O3(t) {
  return !!t && typeof t == "object" && OE in t;
}
function I3(t) {
  let e = t[OE];
  return e?.complete;
}
var RS;
(function (t) {
  t.Completable = "McpCompletable";
})(RS || (RS = {}));
var $3 = /^[A-Za-z0-9._-]{1,128}$/;
function A3(t) {
  let e = [];
  if (t.length === 0)
    return { isValid: !1, warnings: ["Tool name cannot be empty"] };
  if (t.length > 128)
    return {
      isValid: !1,
      warnings: [
        `Tool name exceeds maximum length of 128 characters (current: ${t.length})`,
      ],
    };
  if (
    (t.includes(" ") &&
      e.push("Tool name contains spaces, which may cause parsing issues"),
    t.includes(",") &&
      e.push("Tool name contains commas, which may cause parsing issues"),
    (t.startsWith("-") || t.endsWith("-")) &&
      e.push(
        "Tool name starts or ends with a dash, which may cause parsing issues in some contexts",
      ),
    (t.startsWith(".") || t.endsWith(".")) &&
      e.push(
        "Tool name starts or ends with a dot, which may cause parsing issues in some contexts",
      ),
    !$3.test(t))
  ) {
    let r = t
      .split("")
      .filter((n) => !/[A-Za-z0-9._-]/.test(n))
      .filter((n, s, a) => a.indexOf(n) === s);
    return (
      e.push(
        `Tool name contains invalid characters: ${r.map((n) => `"${n}"`).join(", ")}`,
        "Allowed characters are: A-Z, a-z, 0-9, underscore (_), dash (-), and dot (.)",
      ),
      { isValid: !1, warnings: e }
    );
  }
  return { isValid: !0, warnings: e };
}
function N3(t, e) {
  if (e.length > 0) {
    console.warn(`Tool name validation warning for "${t}":`);
    for (let r of e) console.warn(`  - ${r}`);
    (console.warn(
      "Tool registration will proceed, but this may cause compatibility issues.",
    ),
      console.warn(
        "Consider updating the tool name to conform to the MCP tool naming standard.",
      ),
      console.warn(
        "See SEP: Specify Format for Tool Names (https://github.com/modelcontextprotocol/modelcontextprotocol/issues/986) for more details.",
      ));
  }
}
function OS(t) {
  let e = A3(t);
  return (N3(t, e.warnings), e.isValid);
}
var jm = class {
    constructor(e) {
      this._mcpServer = e;
    }
    registerToolTask(e, r, n) {
      let s = { taskSupport: "required", ...r.execution };
      if (s.taskSupport === "forbidden")
        throw new Error(
          `Cannot register task-based tool '${e}' with taskSupport 'forbidden'. Use registerTool() instead.`,
        );
      return this._mcpServer._createRegisteredTool(
        e,
        r.title,
        r.description,
        r.inputSchema,
        r.outputSchema,
        r.annotations,
        s,
        r._meta,
        n,
      );
    }
  },
  Fm = class {
    constructor(e, r) {
      ((this._registeredResources = {}),
        (this._registeredResourceTemplates = {}),
        (this._registeredTools = {}),
        (this._registeredPrompts = {}),
        (this._toolHandlersInitialized = !1),
        (this._completionHandlerInitialized = !1),
        (this._resourceHandlersInitialized = !1),
        (this._promptHandlersInitialized = !1),
        (this.server = new Mm(e, r)));
    }
    get experimental() {
      return (
        this._experimental || (this._experimental = { tasks: new jm(this) }),
        this._experimental
      );
    }
    async connect(e) {
      return await this.server.connect(e);
    }
    async close() {
      await this.server.close();
    }
    setToolRequestHandlers() {
      this._toolHandlersInitialized ||
        (this.server.assertCanSetRequestHandler(ys(Om)),
        this.server.assertCanSetRequestHandler(ys(eu)),
        this.server.registerCapabilities({ tools: { listChanged: !0 } }),
        this.server.setRequestHandler(Om, () => ({
          tools: Object.entries(this._registeredTools)
            .filter(([, e]) => e.enabled)
            .map(([e, r]) => {
              let n = {
                name: e,
                title: r.title,
                description: r.description,
                inputSchema: (() => {
                  let s = jo(r.inputSchema);
                  return s
                    ? TS(s, { strictUnions: !0, pipeStrategy: "input" })
                    : D3;
                })(),
                annotations: r.annotations,
                execution: r.execution,
                _meta: r._meta,
              };
              if (r.outputSchema) {
                let s = jo(r.outputSchema);
                s &&
                  (n.outputSchema = TS(s, {
                    strictUnions: !0,
                    pipeStrategy: "output",
                  }));
              }
              return n;
            }),
        })),
        this.server.setRequestHandler(eu, async (e, r) => {
          var n;
          try {
            let s = this._registeredTools[e.params.name];
            if (!s)
              throw new Pe(Ie.InvalidParams, `Tool ${e.params.name} not found`);
            if (!s.enabled)
              throw new Pe(Ie.InvalidParams, `Tool ${e.params.name} disabled`);
            let a = !!e.params.task,
              i =
                (n = s.execution) === null || n === void 0
                  ? void 0
                  : n.taskSupport,
              o = "createTask" in s.handler;
            if ((i === "required" || i === "optional") && !o)
              throw new Pe(
                Ie.InternalError,
                `Tool ${e.params.name} has taskSupport '${i}' but was not registered with registerToolTask`,
              );
            if (i === "required" && !a)
              throw new Pe(
                Ie.MethodNotFound,
                `Tool ${e.params.name} requires task augmentation (taskSupport: 'required')`,
              );
            if (i === "optional" && !a && o)
              return await this.handleAutomaticTaskPolling(s, e, r);
            let c = await this.validateToolInput(
                s,
                e.params.arguments,
                e.params.name,
              ),
              l = await this.executeToolHandler(s, c, r);
            return (
              a || (await this.validateToolOutput(s, l, e.params.name)),
              l
            );
          } catch (s) {
            if (s instanceof Pe && s.code === Ie.UrlElicitationRequired)
              throw s;
            return this.createToolError(
              s instanceof Error ? s.message : String(s),
            );
          }
        }),
        (this._toolHandlersInitialized = !0));
    }
    createToolError(e) {
      return { content: [{ type: "text", text: e }], isError: !0 };
    }
    async validateToolInput(e, r, n) {
      if (!e.inputSchema) return;
      let s = jo(e.inputSchema),
        a = s ?? e.inputSchema,
        i = await tm(a, r);
      if (!i.success) {
        let o = "error" in i ? i.error : "Unknown error",
          c = rm(o);
        throw new Pe(
          Ie.InvalidParams,
          `Input validation error: Invalid arguments for tool ${n}: ${c}`,
        );
      }
      return i.data;
    }
    async validateToolOutput(e, r, n) {
      if (!e.outputSchema || !("content" in r) || r.isError) return;
      if (!r.structuredContent)
        throw new Pe(
          Ie.InvalidParams,
          `Output validation error: Tool ${n} has an output schema but no structured content was provided`,
        );
      let s = jo(e.outputSchema),
        a = await tm(s, r.structuredContent);
      if (!a.success) {
        let i = "error" in a ? a.error : "Unknown error",
          o = rm(i);
        throw new Pe(
          Ie.InvalidParams,
          `Output validation error: Invalid structured content for tool ${n}: ${o}`,
        );
      }
    }
    async executeToolHandler(e, r, n) {
      let s = e.handler;
      if ("createTask" in s) {
        if (!n.taskStore) throw new Error("No task store provided.");
        let i = { ...n, taskStore: n.taskStore };
        if (e.inputSchema) {
          let o = s;
          return await Promise.resolve(o.createTask(r, i));
        } else {
          let o = s;
          return await Promise.resolve(o.createTask(i));
        }
      }
      if (e.inputSchema) {
        let i = s;
        return await Promise.resolve(i(r, n));
      } else {
        let i = s;
        return await Promise.resolve(i(n));
      }
    }
    async handleAutomaticTaskPolling(e, r, n) {
      var s;
      if (!n.taskStore)
        throw new Error("No task store provided for task-capable tool.");
      let a = await this.validateToolInput(
          e,
          r.params.arguments,
          r.params.name,
        ),
        i = e.handler,
        o = { ...n, taskStore: n.taskStore },
        c = a
          ? await Promise.resolve(i.createTask(a, o))
          : await Promise.resolve(i.createTask(o)),
        l = c.task.taskId,
        u = c.task,
        d = (s = u.pollInterval) !== null && s !== void 0 ? s : 5e3;
      for (
        ;
        u.status !== "completed" &&
        u.status !== "failed" &&
        u.status !== "cancelled";
      ) {
        await new Promise((p) => setTimeout(p, d));
        let m = await n.taskStore.getTask(l);
        if (!m)
          throw new Pe(Ie.InternalError, `Task ${l} not found during polling`);
        u = m;
      }
      return await n.taskStore.getTaskResult(l);
    }
    setCompletionRequestHandler() {
      this._completionHandlerInitialized ||
        (this.server.assertCanSetRequestHandler(ys($m)),
        this.server.registerCapabilities({ completions: {} }),
        this.server.setRequestHandler($m, async (e) => {
          switch (e.params.ref.type) {
            case "ref/prompt":
              return ($V(e), this.handlePromptCompletion(e, e.params.ref));
            case "ref/resource":
              return (AV(e), this.handleResourceCompletion(e, e.params.ref));
            default:
              throw new Pe(
                Ie.InvalidParams,
                `Invalid completion reference: ${e.params.ref}`,
              );
          }
        }),
        (this._completionHandlerInitialized = !0));
    }
    async handlePromptCompletion(e, r) {
      let n = this._registeredPrompts[r.name];
      if (!n) throw new Pe(Ie.InvalidParams, `Prompt ${r.name} not found`);
      if (!n.enabled)
        throw new Pe(Ie.InvalidParams, `Prompt ${r.name} disabled`);
      if (!n.argsSchema) return Fo;
      let s = oc(n.argsSchema),
        a = s?.[e.params.argument.name];
      if (!O3(a)) return Fo;
      let i = I3(a);
      if (!i) return Fo;
      let o = await i(e.params.argument.value, e.params.context);
      return $S(o);
    }
    async handleResourceCompletion(e, r) {
      let n = Object.values(this._registeredResourceTemplates).find(
        (i) => i.resourceTemplate.uriTemplate.toString() === r.uri,
      );
      if (!n) {
        if (this._registeredResources[r.uri]) return Fo;
        throw new Pe(
          Ie.InvalidParams,
          `Resource template ${e.params.ref.uri} not found`,
        );
      }
      let s = n.resourceTemplate.completeCallback(e.params.argument.name);
      if (!s) return Fo;
      let a = await s(e.params.argument.value, e.params.context);
      return $S(a);
    }
    setResourceRequestHandlers() {
      this._resourceHandlersInitialized ||
        (this.server.assertCanSetRequestHandler(ys(Tm)),
        this.server.assertCanSetRequestHandler(ys(Cm)),
        this.server.assertCanSetRequestHandler(ys(Pm)),
        this.server.registerCapabilities({ resources: { listChanged: !0 } }),
        this.server.setRequestHandler(Tm, async (e, r) => {
          let n = Object.entries(this._registeredResources)
              .filter(([a, i]) => i.enabled)
              .map(([a, i]) => ({ uri: a, name: i.name, ...i.metadata })),
            s = [];
          for (let a of Object.values(this._registeredResourceTemplates)) {
            if (!a.resourceTemplate.listCallback) continue;
            let i = await a.resourceTemplate.listCallback(r);
            for (let o of i.resources) s.push({ ...a.metadata, ...o });
          }
          return { resources: [...n, ...s] };
        }),
        this.server.setRequestHandler(Cm, async () => ({
          resourceTemplates: Object.entries(
            this._registeredResourceTemplates,
          ).map(([r, n]) => ({
            name: r,
            uriTemplate: n.resourceTemplate.uriTemplate.toString(),
            ...n.metadata,
          })),
        })),
        this.server.setRequestHandler(Pm, async (e, r) => {
          let n = new URL(e.params.uri),
            s = this._registeredResources[n.toString()];
          if (s) {
            if (!s.enabled)
              throw new Pe(Ie.InvalidParams, `Resource ${n} disabled`);
            return s.readCallback(n, r);
          }
          for (let a of Object.values(this._registeredResourceTemplates)) {
            let i = a.resourceTemplate.uriTemplate.match(n.toString());
            if (i) return a.readCallback(n, i, r);
          }
          throw new Pe(Ie.InvalidParams, `Resource ${n} not found`);
        }),
        this.setCompletionRequestHandler(),
        (this._resourceHandlersInitialized = !0));
    }
    setPromptRequestHandlers() {
      this._promptHandlersInitialized ||
        (this.server.assertCanSetRequestHandler(ys(km)),
        this.server.assertCanSetRequestHandler(ys(Rm)),
        this.server.registerCapabilities({ prompts: { listChanged: !0 } }),
        this.server.setRequestHandler(km, () => ({
          prompts: Object.entries(this._registeredPrompts)
            .filter(([, e]) => e.enabled)
            .map(([e, r]) => ({
              name: e,
              title: r.title,
              description: r.description,
              arguments: r.argsSchema ? M3(r.argsSchema) : void 0,
            })),
        })),
        this.server.setRequestHandler(Rm, async (e, r) => {
          let n = this._registeredPrompts[e.params.name];
          if (!n)
            throw new Pe(Ie.InvalidParams, `Prompt ${e.params.name} not found`);
          if (!n.enabled)
            throw new Pe(Ie.InvalidParams, `Prompt ${e.params.name} disabled`);
          if (n.argsSchema) {
            let s = jo(n.argsSchema),
              a = await tm(s, e.params.arguments);
            if (!a.success) {
              let c = "error" in a ? a.error : "Unknown error",
                l = rm(c);
              throw new Pe(
                Ie.InvalidParams,
                `Invalid arguments for prompt ${e.params.name}: ${l}`,
              );
            }
            let i = a.data,
              o = n.callback;
            return await Promise.resolve(o(i, r));
          } else {
            let s = n.callback;
            return await Promise.resolve(s(r));
          }
        }),
        this.setCompletionRequestHandler(),
        (this._promptHandlersInitialized = !0));
    }
    resource(e, r, ...n) {
      let s;
      typeof n[0] == "object" && (s = n.shift());
      let a = n[0];
      if (typeof r == "string") {
        if (this._registeredResources[r])
          throw new Error(`Resource ${r} is already registered`);
        let i = this._createRegisteredResource(e, void 0, r, s, a);
        return (
          this.setResourceRequestHandlers(),
          this.sendResourceListChanged(),
          i
        );
      } else {
        if (this._registeredResourceTemplates[e])
          throw new Error(`Resource template ${e} is already registered`);
        let i = this._createRegisteredResourceTemplate(e, void 0, r, s, a);
        return (
          this.setResourceRequestHandlers(),
          this.sendResourceListChanged(),
          i
        );
      }
    }
    registerResource(e, r, n, s) {
      if (typeof r == "string") {
        if (this._registeredResources[r])
          throw new Error(`Resource ${r} is already registered`);
        let a = this._createRegisteredResource(e, n.title, r, n, s);
        return (
          this.setResourceRequestHandlers(),
          this.sendResourceListChanged(),
          a
        );
      } else {
        if (this._registeredResourceTemplates[e])
          throw new Error(`Resource template ${e} is already registered`);
        let a = this._createRegisteredResourceTemplate(e, n.title, r, n, s);
        return (
          this.setResourceRequestHandlers(),
          this.sendResourceListChanged(),
          a
        );
      }
    }
    _createRegisteredResource(e, r, n, s, a) {
      let i = {
        name: e,
        title: r,
        metadata: s,
        readCallback: a,
        enabled: !0,
        disable: () => i.update({ enabled: !1 }),
        enable: () => i.update({ enabled: !0 }),
        remove: () => i.update({ uri: null }),
        update: (o) => {
          (typeof o.uri < "u" &&
            o.uri !== n &&
            (delete this._registeredResources[n],
            o.uri && (this._registeredResources[o.uri] = i)),
            typeof o.name < "u" && (i.name = o.name),
            typeof o.title < "u" && (i.title = o.title),
            typeof o.metadata < "u" && (i.metadata = o.metadata),
            typeof o.callback < "u" && (i.readCallback = o.callback),
            typeof o.enabled < "u" && (i.enabled = o.enabled),
            this.sendResourceListChanged());
        },
      };
      return ((this._registeredResources[n] = i), i);
    }
    _createRegisteredResourceTemplate(e, r, n, s, a) {
      let i = {
        resourceTemplate: n,
        title: r,
        metadata: s,
        readCallback: a,
        enabled: !0,
        disable: () => i.update({ enabled: !1 }),
        enable: () => i.update({ enabled: !0 }),
        remove: () => i.update({ name: null }),
        update: (o) => {
          (typeof o.name < "u" &&
            o.name !== e &&
            (delete this._registeredResourceTemplates[e],
            o.name && (this._registeredResourceTemplates[o.name] = i)),
            typeof o.title < "u" && (i.title = o.title),
            typeof o.template < "u" && (i.resourceTemplate = o.template),
            typeof o.metadata < "u" && (i.metadata = o.metadata),
            typeof o.callback < "u" && (i.readCallback = o.callback),
            typeof o.enabled < "u" && (i.enabled = o.enabled),
            this.sendResourceListChanged());
        },
      };
      return ((this._registeredResourceTemplates[e] = i), i);
    }
    _createRegisteredPrompt(e, r, n, s, a) {
      let i = {
        title: r,
        description: n,
        argsSchema: s === void 0 ? void 0 : Bo(s),
        callback: a,
        enabled: !0,
        disable: () => i.update({ enabled: !1 }),
        enable: () => i.update({ enabled: !0 }),
        remove: () => i.update({ name: null }),
        update: (o) => {
          (typeof o.name < "u" &&
            o.name !== e &&
            (delete this._registeredPrompts[e],
            o.name && (this._registeredPrompts[o.name] = i)),
            typeof o.title < "u" && (i.title = o.title),
            typeof o.description < "u" && (i.description = o.description),
            typeof o.argsSchema < "u" && (i.argsSchema = Bo(o.argsSchema)),
            typeof o.callback < "u" && (i.callback = o.callback),
            typeof o.enabled < "u" && (i.enabled = o.enabled),
            this.sendPromptListChanged());
        },
      };
      return ((this._registeredPrompts[e] = i), i);
    }
    _createRegisteredTool(e, r, n, s, a, i, o, c, l) {
      OS(e);
      let u = {
        title: r,
        description: n,
        inputSchema: IS(s),
        outputSchema: IS(a),
        annotations: i,
        execution: o,
        _meta: c,
        handler: l,
        enabled: !0,
        disable: () => u.update({ enabled: !1 }),
        enable: () => u.update({ enabled: !0 }),
        remove: () => u.update({ name: null }),
        update: (d) => {
          (typeof d.name < "u" &&
            d.name !== e &&
            (typeof d.name == "string" && OS(d.name),
            delete this._registeredTools[e],
            d.name && (this._registeredTools[d.name] = u)),
            typeof d.title < "u" && (u.title = d.title),
            typeof d.description < "u" && (u.description = d.description),
            typeof d.paramsSchema < "u" && (u.inputSchema = Bo(d.paramsSchema)),
            typeof d.callback < "u" && (u.handler = d.callback),
            typeof d.annotations < "u" && (u.annotations = d.annotations),
            typeof d._meta < "u" && (u._meta = d._meta),
            typeof d.enabled < "u" && (u.enabled = d.enabled),
            this.sendToolListChanged());
        },
      };
      return (
        (this._registeredTools[e] = u),
        this.setToolRequestHandlers(),
        this.sendToolListChanged(),
        u
      );
    }
    tool(e, ...r) {
      if (this._registeredTools[e])
        throw new Error(`Tool ${e} is already registered`);
      let n, s, a, i;
      if ((typeof r[0] == "string" && (n = r.shift()), r.length > 1)) {
        let c = r[0];
        Um(c)
          ? ((s = r.shift()),
            r.length > 1 &&
              typeof r[0] == "object" &&
              r[0] !== null &&
              !Um(r[0]) &&
              (i = r.shift()))
          : typeof c == "object" && c !== null && (i = r.shift());
      }
      let o = r[0];
      return this._createRegisteredTool(
        e,
        void 0,
        n,
        s,
        a,
        i,
        { taskSupport: "forbidden" },
        void 0,
        o,
      );
    }
    registerTool(e, r, n) {
      if (this._registeredTools[e])
        throw new Error(`Tool ${e} is already registered`);
      let {
        title: s,
        description: a,
        inputSchema: i,
        outputSchema: o,
        annotations: c,
        _meta: l,
      } = r;
      return this._createRegisteredTool(
        e,
        s,
        a,
        i,
        o,
        c,
        { taskSupport: "forbidden" },
        l,
        n,
      );
    }
    prompt(e, ...r) {
      if (this._registeredPrompts[e])
        throw new Error(`Prompt ${e} is already registered`);
      let n;
      typeof r[0] == "string" && (n = r.shift());
      let s;
      r.length > 1 && (s = r.shift());
      let a = r[0],
        i = this._createRegisteredPrompt(e, void 0, n, s, a);
      return (this.setPromptRequestHandlers(), this.sendPromptListChanged(), i);
    }
    registerPrompt(e, r, n) {
      if (this._registeredPrompts[e])
        throw new Error(`Prompt ${e} is already registered`);
      let { title: s, description: a, argsSchema: i } = r,
        o = this._createRegisteredPrompt(e, s, a, i, n);
      return (this.setPromptRequestHandlers(), this.sendPromptListChanged(), o);
    }
    isConnected() {
      return this.server.transport !== void 0;
    }
    async sendLoggingMessage(e, r) {
      return this.server.sendLoggingMessage(e, r);
    }
    sendResourceListChanged() {
      this.isConnected() && this.server.sendResourceListChanged();
    }
    sendToolListChanged() {
      this.isConnected() && this.server.sendToolListChanged();
    }
    sendPromptListChanged() {
      this.isConnected() && this.server.sendPromptListChanged();
    }
  },
  D3 = { type: "object", properties: {} };
function IE(t) {
  return (
    t !== null &&
    typeof t == "object" &&
    "parse" in t &&
    typeof t.parse == "function" &&
    "safeParse" in t &&
    typeof t.safeParse == "function"
  );
}
function L3(t) {
  return "_def" in t || "_zod" in t || IE(t);
}
function Um(t) {
  return typeof t != "object" || t === null || L3(t)
    ? !1
    : Object.keys(t).length === 0
      ? !0
      : Object.values(t).some(IE);
}
function IS(t) {
  if (t) return Um(t) ? Bo(t) : t;
}
function M3(t) {
  let e = oc(t);
  return e
    ? Object.entries(e).map(([r, n]) => {
        let s = lB(n),
          a = uB(n);
        return { name: r, description: s, required: !a };
      })
    : [];
}
function ys(t) {
  let e = oc(t),
    r = e?.method;
  if (!r) throw new Error("Schema is missing a method literal");
  let n = M0(r);
  if (typeof n == "string") return n;
  throw new Error("Schema method literal must be a string");
}
function $S(t) {
  return {
    completion: {
      values: t.slice(0, 100),
      total: t.length,
      hasMore: t.length > 100,
    },
  };
}
var Fo = { completion: { values: [], hasMore: !1 } };
function $E(t) {
  let e = new Fm(
    { name: t.name, version: t.version ?? "1.0.0" },
    { capabilities: { tools: t.tools ? {} : void 0 } },
  );
  return (
    t.tools &&
      t.tools.forEach((r) => {
        e.tool(r.name, r.description, r.inputSchema, r.handler);
      }),
    { type: "sdk", name: t.name, instance: e }
  );
}
function _u({ prompt: t, options: e }) {
  let { systemPrompt: r, settingSources: n, sandbox: s, ...a } = e ?? {},
    i,
    o;
  r === void 0
    ? (i = "")
    : typeof r == "string"
      ? (i = r)
      : r.type === "preset" && (o = r.append);
  let c = a.pathToClaudeCodeExecutable;
  if (!c) {
    let te = (0, zS.fileURLToPath)(j3.url),
      fe = (0, im.join)(te, "..");
    c = (0, im.join)(fe, "cli.js");
  }
  process.env.CLAUDE_AGENT_SDK_VERSION = "0.1.75";
  let {
      abortController: l = HS(),
      additionalDirectories: u = [],
      agents: d,
      allowedTools: m = [],
      betas: p,
      canUseTool: f,
      continue: y,
      cwd: h,
      disallowedTools: g = [],
      tools: _,
      env: v,
      executable: b = i0() ? "bun" : "node",
      executableArgs: x = [],
      extraArgs: w = {},
      fallbackModel: S,
      enableFileCheckpointing: C,
      forkSession: P,
      hooks: A,
      includePartialMessages: R,
      persistSession: D,
      maxThinkingTokens: F,
      maxTurns: I,
      maxBudgetUsd: K,
      mcpServers: ee,
      model: Y,
      outputFormat: Q,
      permissionMode: ae = "default",
      allowDangerouslySkipPermissions: B = !1,
      permissionPromptToolName: $,
      plugins: G,
      resume: U,
      resumeSessionAt: T,
      stderr: O,
      strictMcpConfig: H,
    } = a,
    ce = Q?.type === "json_schema" ? Q.schema : void 0,
    oe = v;
  if (
    (oe || (oe = { ...process.env }),
    oe.CLAUDE_CODE_ENTRYPOINT || (oe.CLAUDE_CODE_ENTRYPOINT = "sdk-ts"),
    C && (oe.CLAUDE_CODE_ENABLE_SDK_FILE_CHECKPOINTING = "true"),
    !c)
  )
    throw new Error("pathToClaudeCodeExecutable is required");
  let Fe = {},
    Ee = new Map();
  if (ee)
    for (let [te, fe] of Object.entries(ee))
      fe.type === "sdk" && "instance" in fe
        ? (Ee.set(te, fe.instance), (Fe[te] = { type: "sdk", name: te }))
        : (Fe[te] = fe);
  let Me = typeof t == "string",
    q = new cm({
      abortController: l,
      additionalDirectories: u,
      betas: p,
      cwd: h,
      executable: b,
      executableArgs: x,
      extraArgs: w,
      pathToClaudeCodeExecutable: c,
      env: oe,
      forkSession: P,
      stderr: O,
      maxThinkingTokens: F,
      maxTurns: I,
      maxBudgetUsd: K,
      model: Y,
      fallbackModel: S,
      jsonSchema: ce,
      permissionMode: ae,
      allowDangerouslySkipPermissions: B,
      permissionPromptToolName: $,
      continueConversation: y,
      resume: U,
      resumeSessionAt: T,
      settingSources: n ?? [],
      allowedTools: m,
      disallowedTools: g,
      tools: _,
      mcpServers: Fe,
      strictMcpConfig: H,
      canUseTool: !!f,
      hooks: !!A,
      includePartialMessages: R,
      persistSession: D,
      plugins: G,
      sandbox: s,
      spawnClaudeCodeProcess: a.spawnClaudeCodeProcess,
    }),
    z = { systemPrompt: i, appendSystemPrompt: o, agents: d },
    Z = new dm(q, Me, f, A, l, Ee, ce, z);
  return (
    typeof t == "string"
      ? q.write(
          JSON.stringify({
            type: "user",
            session_id: "",
            message: { role: "user", content: [{ type: "text", text: t }] },
            parent_tool_use_id: null,
          }) +
            `
`,
        )
      : Z.streamInput(t),
    Z
  );
}
var NE = require("child_process");
var F3 = `You suggest what a developer might want to do next based on their current work.

Study the diff carefully. What is this person actually building? What's the next meaningful piece of work?

Suggest real work, not tiny fixes:
- "Add error handling to the processOrder function" is a code review comment
- "Add error handling throughout the order processing flow" is real work
- Think about what would actually move the project forward, not just polish one line

Your suggestions should be honest and specific to THIS code:
- Reference actual function names, files, or patterns you see in the diff
- If something looks incomplete, offer to help finish it - not just point it out
- If you see a pattern emerging, offer to extend it to related areas

What makes a good suggestion:
- It's meaningful work that would actually help, not a nitpick
- It shows you understand what they're building
- The developer thinks "yes, that would be useful"

Think about the product, not just the code:
- What would make this feature better for users?
- Is there a related capability that would be natural to add?
- What might users expect that isn't there yet?

What to avoid:
- Tiny incremental fixes that read like code review line comments
- Generic suggestions that could apply to any codebase
- Suggesting "commit" just because there are changes
- Overpromising - be realistic about scope

Aim to delight:
- A suggestion that makes them think "oh, I hadn't thought of that but yes!"
- Noticing something clever they could do, not just the obvious next step
- Showing genuine insight into their work, not just pattern matching

If you see non-trivial changes, offering to review the approach can be valuable.

Respond with a JSON array (0-4 suggestions, fewer is fine, empty if nothing clearly helpful):
[
  {
    "title": "Short title (5-10 words)",
    "description": "What this involves, referencing their specific code",
    "prompt": "Direct prompt for this task"
  }
]

Only output the JSON array.`;
async function Ts(t, e, r) {
  return new Promise((n) => {
    let s = "",
      a = (0, NE.spawn)(t, e, { cwd: r, shell: !1 });
    (a.stdout.on("data", (i) => {
      s += i.toString();
    }),
      a.on("close", (i) => {
        n({ stdout: s, exitCode: i ?? 0 });
      }),
      a.on("error", () => {
        n({ stdout: "", exitCode: 1 });
      }));
  });
}
var U3 = 8e3,
  q3 = 2e3,
  z3 = 2e3,
  AE = 200;
function pc(t, e, r) {
  return t.length <= e
    ? t
    : t.slice(0, e) +
        `
... (${r} truncated)`;
}
async function B3(t) {
  let r = (
      await Ts("git", ["config", "user.email"], t).catch(() => ({
        stdout: "",
        exitCode: 1,
      }))
    ).stdout.trim(),
    [n, s, a, i, o] = await Promise.all([
      Ts("git", ["status", "--porcelain"], t).catch(() => ({
        stdout: "",
        exitCode: 1,
      })),
      Ts("git", ["rev-parse", "--abbrev-ref", "HEAD"], t).catch(() => ({
        stdout: "",
        exitCode: 1,
      })),
      Ts(
        "git",
        ["log", "--oneline", "-10", ...(r ? ["--author", r] : [])],
        t,
      ).catch(() => ({ stdout: "", exitCode: 1 })),
      (async () => {
        if (!r) return Ts("git", ["diff", "--stat", "HEAD~5..HEAD"], t);
        let m = (
          await Ts(
            "git",
            ["log", "--oneline", "-5", "--author", r, "--format=%H"],
            t,
          ).catch(() => ({ stdout: "", exitCode: 1 }))
        ).stdout
          .trim()
          .split(
            `
`,
          )
          .filter(Boolean);
        if (m.length === 0) return { stdout: "", exitCode: 0 };
        let p = m[m.length - 1];
        return Ts("git", ["diff", "--stat", `${p}^..HEAD`], t).catch(() => ({
          stdout: "",
          exitCode: 1,
        }));
      })(),
      Ts("git", ["diff", "HEAD"], t).catch(() => ({ stdout: "", exitCode: 1 })),
    ]),
    c = n.stdout.trim() || "No uncommitted changes",
    l = i.stdout.trim() || "No recent changes",
    u = o.stdout.trim();
  return {
    status: pc(c, q3, "status"),
    branch: s.stdout.trim() || "unknown",
    recentCommits: a.stdout.trim() || "No recent commits",
    diff: pc(l, z3, "diff stat"),
    workingTreeDiff: pc(u, U3, "diff"),
  };
}
async function H3(t, e) {
  try {
    let s = (await (await Bn.load(t, e)).fetchSessions())
        .filter((o) => !o.isSidechain)
        .sort((o, c) => c.lastModified - o.lastModified)
        .slice(0, 5),
      a = s
        .map((o) => o.summary)
        .filter((o) => o && o !== "No prompt")
        .map((o) => pc(o, AE, "prompt")),
      i = s[0]?.summary ? pc(s[0].summary, AE, "summary") : null;
    return { recentPrompts: a, lastSessionSummary: i };
  } catch (r) {
    return (
      e.warn(`Failed to gather recent activity: ${r}`),
      { recentPrompts: [], lastSessionSummary: null }
    );
  }
}
function V3(t, e) {
  let r = [];
  return (
    r.push("## Current Git State"),
    r.push(`Branch: ${t.branch}`),
    r.push(`
Uncommitted changes:
${t.status}`),
    r.push(`
Recent commits by this user:
${t.recentCommits}`),
    t.diff &&
      r.push(`
Recent changes summary (this user's work):
${t.diff}`),
    t.workingTreeDiff &&
      (r.push(`
## Current Uncommitted Changes (diff)`),
      r.push(
        "This shows the actual code changes in progress. Use this to understand what the developer is working on:",
      ),
      r.push("```diff"),
      r.push(t.workingTreeDiff),
      r.push("```")),
    e.recentPrompts.length > 0 &&
      (r.push(`
## Recent Conversation Topics`),
      e.recentPrompts.forEach((n, s) => {
        r.push(`${s + 1}. ${n}`);
      })),
    r.push(`
## Task`),
    r.push(
      "Based on this context, suggest up to 4 helpful next steps the developer is likely to want to take. Only include suggestions you are confident about - fewer is better.",
    ),
    r.join(`
`)
  );
}
function Z3(t) {
  try {
    let e = t.match(/\[[\s\S]*\]/);
    if (!e) return [];
    let r = JSON.parse(e[0]);
    return Array.isArray(r)
      ? r
          .filter(
            (n) =>
              typeof n == "object" &&
              n !== null &&
              typeof n.title == "string" &&
              typeof n.description == "string" &&
              typeof n.prompt == "string",
          )
          .slice(0, 4)
      : [];
  } catch {
    return [];
  }
}
async function DE(t) {
  let {
    cwd: e,
    logger: r,
    pathToClaudeCodeExecutable: n,
    executableArgs: s,
    env: a,
  } = t;
  try {
    let [i, o] = await Promise.all([B3(e), H3(e, r)]),
      c = V3(i, o),
      l = _u({
        prompt: c,
        options: {
          cwd: e,
          permissionMode: "default",
          model: "claude-haiku-4-5-20251001",
          systemPrompt: F3,
          maxThinkingTokens: 0,
          pathToClaudeCodeExecutable: n,
          executableArgs: s,
          env: a,
          persistSession: !1,
          stderr: (m) => {
            r.warn(`[Claude STDERR] ${m}`);
          },
        },
      }),
      u = "";
    for await (let m of l)
      if (m.type === "assistant" && m.message.content)
        for (let p of m.message.content) p.type === "text" && (u += p.text);
    return { suggestions: Z3(u) };
  } catch (i) {
    return (
      r.error(`Failed to generate suggestions: ${i}`),
      { suggestions: [] }
    );
  }
}
var E = {};
Hp(E, {
  BRAND: () => yZ,
  DIRTY: () => na,
  EMPTY_PATH: () => J3,
  INVALID: () => $e,
  NEVER: () => rG,
  OK: () => cr,
  ParseStatus: () => rr,
  Schema: () => He,
  ZodAny: () => ks,
  ZodArray: () => ts,
  ZodBigInt: () => aa,
  ZodBoolean: () => ia,
  ZodBranded: () => mc,
  ZodCatch: () => va,
  ZodDate: () => oa,
  ZodDefault: () => ga,
  ZodDiscriminatedUnion: () => Su,
  ZodEffects: () => Xr,
  ZodEnum: () => ma,
  ZodError: () => xr,
  ZodFirstPartyTypeKind: () => se,
  ZodFunction: () => Tu,
  ZodIntersection: () => da,
  ZodIssueCode: () => re,
  ZodLazy: () => pa,
  ZodLiteral: () => fa,
  ZodMap: () => Oi,
  ZodNaN: () => $i,
  ZodNativeEnum: () => ha,
  ZodNever: () => mn,
  ZodNull: () => la,
  ZodNullable: () => In,
  ZodNumber: () => sa,
  ZodObject: () => Sr,
  ZodOptional: () => wr,
  ZodParsedType: () => ve,
  ZodPipeline: () => hc,
  ZodPromise: () => Rs,
  ZodReadonly: () => ya,
  ZodRecord: () => Eu,
  ZodSchema: () => He,
  ZodSet: () => Ii,
  ZodString: () => Ps,
  ZodSymbol: () => ki,
  ZodTransformer: () => Xr,
  ZodTuple: () => On,
  ZodType: () => He,
  ZodUndefined: () => ca,
  ZodUnion: () => ua,
  ZodUnknown: () => es,
  ZodVoid: () => Ri,
  addIssueToContext: () => de,
  any: () => PZ,
  array: () => IZ,
  bigint: () => wZ,
  boolean: () => ZE,
  coerce: () => tG,
  custom: () => BE,
  date: () => SZ,
  datetimeRegex: () => qE,
  defaultErrorMap: () => Yn,
  discriminatedUnion: () => DZ,
  effect: () => GZ,
  enum: () => HZ,
  function: () => qZ,
  getErrorMap: () => Ti,
  getParsedType: () => Rn,
  instanceof: () => _Z,
  intersection: () => LZ,
  isAborted: () => xu,
  isAsync: () => Ci,
  isDirty: () => wu,
  isValid: () => Cs,
  late: () => bZ,
  lazy: () => zZ,
  literal: () => BZ,
  makeIssue: () => fc,
  map: () => FZ,
  nan: () => xZ,
  nativeEnum: () => VZ,
  never: () => RZ,
  null: () => CZ,
  nullable: () => KZ,
  number: () => VE,
  object: () => $Z,
  objectUtil: () => vh,
  oboolean: () => eG,
  onumber: () => QZ,
  optional: () => WZ,
  ostring: () => YZ,
  pipeline: () => XZ,
  preprocess: () => JZ,
  promise: () => ZZ,
  quotelessJson: () => G3,
  record: () => jZ,
  set: () => UZ,
  setErrorMap: () => K3,
  strictObject: () => AZ,
  string: () => HE,
  symbol: () => EZ,
  transformer: () => GZ,
  tuple: () => MZ,
  undefined: () => TZ,
  union: () => NZ,
  unknown: () => kZ,
  util: () => We,
  void: () => OZ,
});
var We;
(function (t) {
  t.assertEqual = (s) => {};
  function e(s) {}
  t.assertIs = e;
  function r(s) {
    throw new Error();
  }
  ((t.assertNever = r),
    (t.arrayToEnum = (s) => {
      let a = {};
      for (let i of s) a[i] = i;
      return a;
    }),
    (t.getValidEnumValues = (s) => {
      let a = t.objectKeys(s).filter((o) => typeof s[s[o]] != "number"),
        i = {};
      for (let o of a) i[o] = s[o];
      return t.objectValues(i);
    }),
    (t.objectValues = (s) =>
      t.objectKeys(s).map(function (a) {
        return s[a];
      })),
    (t.objectKeys =
      typeof Object.keys == "function"
        ? (s) => Object.keys(s)
        : (s) => {
            let a = [];
            for (let i in s)
              Object.prototype.hasOwnProperty.call(s, i) && a.push(i);
            return a;
          }),
    (t.find = (s, a) => {
      for (let i of s) if (a(i)) return i;
    }),
    (t.isInteger =
      typeof Number.isInteger == "function"
        ? (s) => Number.isInteger(s)
        : (s) =>
            typeof s == "number" && Number.isFinite(s) && Math.floor(s) === s));
  function n(s, a = " | ") {
    return s.map((i) => (typeof i == "string" ? `'${i}'` : i)).join(a);
  }
  ((t.joinValues = n),
    (t.jsonStringifyReplacer = (s, a) =>
      typeof a == "bigint" ? a.toString() : a));
})(We || (We = {}));
var vh;
(function (t) {
  t.mergeShapes = (e, r) => ({ ...e, ...r });
})(vh || (vh = {}));
var ve = We.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
  ]),
  Rn = (t) => {
    switch (typeof t) {
      case "undefined":
        return ve.undefined;
      case "string":
        return ve.string;
      case "number":
        return Number.isNaN(t) ? ve.nan : ve.number;
      case "boolean":
        return ve.boolean;
      case "function":
        return ve.function;
      case "bigint":
        return ve.bigint;
      case "symbol":
        return ve.symbol;
      case "object":
        return Array.isArray(t)
          ? ve.array
          : t === null
            ? ve.null
            : t.then &&
                typeof t.then == "function" &&
                t.catch &&
                typeof t.catch == "function"
              ? ve.promise
              : typeof Map < "u" && t instanceof Map
                ? ve.map
                : typeof Set < "u" && t instanceof Set
                  ? ve.set
                  : typeof Date < "u" && t instanceof Date
                    ? ve.date
                    : ve.object;
      default:
        return ve.unknown;
    }
  };
var re = We.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
  ]),
  G3 = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:"),
  xr = class t extends Error {
    get errors() {
      return this.issues;
    }
    constructor(e) {
      (super(),
        (this.issues = []),
        (this.addIssue = (n) => {
          this.issues = [...this.issues, n];
        }),
        (this.addIssues = (n = []) => {
          this.issues = [...this.issues, ...n];
        }));
      let r = new.target.prototype;
      (Object.setPrototypeOf
        ? Object.setPrototypeOf(this, r)
        : (this.__proto__ = r),
        (this.name = "ZodError"),
        (this.issues = e));
    }
    format(e) {
      let r =
          e ||
          function (a) {
            return a.message;
          },
        n = { _errors: [] },
        s = (a) => {
          for (let i of a.issues)
            if (i.code === "invalid_union") i.unionErrors.map(s);
            else if (i.code === "invalid_return_type") s(i.returnTypeError);
            else if (i.code === "invalid_arguments") s(i.argumentsError);
            else if (i.path.length === 0) n._errors.push(r(i));
            else {
              let o = n,
                c = 0;
              for (; c < i.path.length; ) {
                let l = i.path[c];
                (c === i.path.length - 1
                  ? ((o[l] = o[l] || { _errors: [] }), o[l]._errors.push(r(i)))
                  : (o[l] = o[l] || { _errors: [] }),
                  (o = o[l]),
                  c++);
              }
            }
        };
      return (s(this), n);
    }
    static assert(e) {
      if (!(e instanceof t)) throw new Error(`Not a ZodError: ${e}`);
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, We.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(e = (r) => r.message) {
      let r = {},
        n = [];
      for (let s of this.issues)
        if (s.path.length > 0) {
          let a = s.path[0];
          ((r[a] = r[a] || []), r[a].push(e(s)));
        } else n.push(e(s));
      return { formErrors: n, fieldErrors: r };
    }
    get formErrors() {
      return this.flatten();
    }
  };
xr.create = (t) => new xr(t);
var W3 = (t, e) => {
    let r;
    switch (t.code) {
      case re.invalid_type:
        t.received === ve.undefined
          ? (r = "Required")
          : (r = `Expected ${t.expected}, received ${t.received}`);
        break;
      case re.invalid_literal:
        r = `Invalid literal value, expected ${JSON.stringify(t.expected, We.jsonStringifyReplacer)}`;
        break;
      case re.unrecognized_keys:
        r = `Unrecognized key(s) in object: ${We.joinValues(t.keys, ", ")}`;
        break;
      case re.invalid_union:
        r = "Invalid input";
        break;
      case re.invalid_union_discriminator:
        r = `Invalid discriminator value. Expected ${We.joinValues(t.options)}`;
        break;
      case re.invalid_enum_value:
        r = `Invalid enum value. Expected ${We.joinValues(t.options)}, received '${t.received}'`;
        break;
      case re.invalid_arguments:
        r = "Invalid function arguments";
        break;
      case re.invalid_return_type:
        r = "Invalid function return type";
        break;
      case re.invalid_date:
        r = "Invalid date";
        break;
      case re.invalid_string:
        typeof t.validation == "object"
          ? "includes" in t.validation
            ? ((r = `Invalid input: must include "${t.validation.includes}"`),
              typeof t.validation.position == "number" &&
                (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`))
            : "startsWith" in t.validation
              ? (r = `Invalid input: must start with "${t.validation.startsWith}"`)
              : "endsWith" in t.validation
                ? (r = `Invalid input: must end with "${t.validation.endsWith}"`)
                : We.assertNever(t.validation)
          : t.validation !== "regex"
            ? (r = `Invalid ${t.validation}`)
            : (r = "Invalid");
        break;
      case re.too_small:
        t.type === "array"
          ? (r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)`)
          : t.type === "string"
            ? (r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)`)
            : t.type === "number"
              ? (r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}`)
              : t.type === "bigint"
                ? (r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}`)
                : t.type === "date"
                  ? (r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}`)
                  : (r = "Invalid input");
        break;
      case re.too_big:
        t.type === "array"
          ? (r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)`)
          : t.type === "string"
            ? (r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)`)
            : t.type === "number"
              ? (r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}`)
              : t.type === "bigint"
                ? (r = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}`)
                : t.type === "date"
                  ? (r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}`)
                  : (r = "Invalid input");
        break;
      case re.custom:
        r = "Invalid input";
        break;
      case re.invalid_intersection_types:
        r = "Intersection results could not be merged";
        break;
      case re.not_multiple_of:
        r = `Number must be a multiple of ${t.multipleOf}`;
        break;
      case re.not_finite:
        r = "Number must be finite";
        break;
      default:
        ((r = e.defaultError), We.assertNever(t));
    }
    return { message: r };
  },
  Yn = W3;
var LE = Yn;
function K3(t) {
  LE = t;
}
function Ti() {
  return LE;
}
var fc = (t) => {
    let { data: e, path: r, errorMaps: n, issueData: s } = t,
      a = [...r, ...(s.path || [])],
      i = { ...s, path: a };
    if (s.message !== void 0) return { ...s, path: a, message: s.message };
    let o = "",
      c = n
        .filter((l) => !!l)
        .slice()
        .reverse();
    for (let l of c) o = l(i, { data: e, defaultError: o }).message;
    return { ...s, path: a, message: o };
  },
  J3 = [];
function de(t, e) {
  let r = Ti(),
    n = fc({
      issueData: e,
      data: t.data,
      path: t.path,
      errorMaps: [
        t.common.contextualErrorMap,
        t.schemaErrorMap,
        r,
        r === Yn ? void 0 : Yn,
      ].filter((s) => !!s),
    });
  t.common.issues.push(n);
}
var rr = class t {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      this.value === "valid" && (this.value = "dirty");
    }
    abort() {
      this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(e, r) {
      let n = [];
      for (let s of r) {
        if (s.status === "aborted") return $e;
        (s.status === "dirty" && e.dirty(), n.push(s.value));
      }
      return { status: e.value, value: n };
    }
    static async mergeObjectAsync(e, r) {
      let n = [];
      for (let s of r) {
        let a = await s.key,
          i = await s.value;
        n.push({ key: a, value: i });
      }
      return t.mergeObjectSync(e, n);
    }
    static mergeObjectSync(e, r) {
      let n = {};
      for (let s of r) {
        let { key: a, value: i } = s;
        if (a.status === "aborted" || i.status === "aborted") return $e;
        (a.status === "dirty" && e.dirty(),
          i.status === "dirty" && e.dirty(),
          a.value !== "__proto__" &&
            (typeof i.value < "u" || s.alwaysSet) &&
            (n[a.value] = i.value));
      }
      return { status: e.value, value: n };
    }
  },
  $e = Object.freeze({ status: "aborted" }),
  na = (t) => ({ status: "dirty", value: t }),
  cr = (t) => ({ status: "valid", value: t }),
  xu = (t) => t.status === "aborted",
  wu = (t) => t.status === "dirty",
  Cs = (t) => t.status === "valid",
  Ci = (t) => typeof Promise < "u" && t instanceof Promise;
var we;
(function (t) {
  ((t.errToObj = (e) => (typeof e == "string" ? { message: e } : e || {})),
    (t.toString = (e) => (typeof e == "string" ? e : e?.message)));
})(we || (we = {}));
var Jr = class {
    constructor(e, r, n, s) {
      ((this._cachedPath = []),
        (this.parent = e),
        (this.data = r),
        (this._path = n),
        (this._key = s));
    }
    get path() {
      return (
        this._cachedPath.length ||
          (Array.isArray(this._key)
            ? this._cachedPath.push(...this._path, ...this._key)
            : this._cachedPath.push(...this._path, this._key)),
        this._cachedPath
      );
    }
  },
  ME = (t, e) => {
    if (Cs(e)) return { success: !0, data: e.value };
    if (!t.common.issues.length)
      throw new Error("Validation failed but no issues detected.");
    return {
      success: !1,
      get error() {
        if (this._error) return this._error;
        let r = new xr(t.common.issues);
        return ((this._error = r), this._error);
      },
    };
  };
function Be(t) {
  if (!t) return {};
  let {
    errorMap: e,
    invalid_type_error: r,
    required_error: n,
    description: s,
  } = t;
  if (e && (r || n))
    throw new Error(
      `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`,
    );
  return e
    ? { errorMap: e, description: s }
    : {
        errorMap: (i, o) => {
          let { message: c } = t;
          return i.code === "invalid_enum_value"
            ? { message: c ?? o.defaultError }
            : typeof o.data > "u"
              ? { message: c ?? n ?? o.defaultError }
              : i.code !== "invalid_type"
                ? { message: o.defaultError }
                : { message: c ?? r ?? o.defaultError };
        },
        description: s,
      };
}
var He = class {
    get description() {
      return this._def.description;
    }
    _getType(e) {
      return Rn(e.data);
    }
    _getOrReturnCtx(e, r) {
      return (
        r || {
          common: e.parent.common,
          data: e.data,
          parsedType: Rn(e.data),
          schemaErrorMap: this._def.errorMap,
          path: e.path,
          parent: e.parent,
        }
      );
    }
    _processInputParams(e) {
      return {
        status: new rr(),
        ctx: {
          common: e.parent.common,
          data: e.data,
          parsedType: Rn(e.data),
          schemaErrorMap: this._def.errorMap,
          path: e.path,
          parent: e.parent,
        },
      };
    }
    _parseSync(e) {
      let r = this._parse(e);
      if (Ci(r)) throw new Error("Synchronous parse encountered promise.");
      return r;
    }
    _parseAsync(e) {
      let r = this._parse(e);
      return Promise.resolve(r);
    }
    parse(e, r) {
      let n = this.safeParse(e, r);
      if (n.success) return n.data;
      throw n.error;
    }
    safeParse(e, r) {
      let n = {
          common: {
            issues: [],
            async: r?.async ?? !1,
            contextualErrorMap: r?.errorMap,
          },
          path: r?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data: e,
          parsedType: Rn(e),
        },
        s = this._parseSync({ data: e, path: n.path, parent: n });
      return ME(n, s);
    }
    "~validate"(e) {
      let r = {
        common: { issues: [], async: !!this["~standard"].async },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: Rn(e),
      };
      if (!this["~standard"].async)
        try {
          let n = this._parseSync({ data: e, path: [], parent: r });
          return Cs(n) ? { value: n.value } : { issues: r.common.issues };
        } catch (n) {
          (n?.message?.toLowerCase()?.includes("encountered") &&
            (this["~standard"].async = !0),
            (r.common = { issues: [], async: !0 }));
        }
      return this._parseAsync({ data: e, path: [], parent: r }).then((n) =>
        Cs(n) ? { value: n.value } : { issues: r.common.issues },
      );
    }
    async parseAsync(e, r) {
      let n = await this.safeParseAsync(e, r);
      if (n.success) return n.data;
      throw n.error;
    }
    async safeParseAsync(e, r) {
      let n = {
          common: { issues: [], contextualErrorMap: r?.errorMap, async: !0 },
          path: r?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data: e,
          parsedType: Rn(e),
        },
        s = this._parse({ data: e, path: n.path, parent: n }),
        a = await (Ci(s) ? s : Promise.resolve(s));
      return ME(n, a);
    }
    refine(e, r) {
      let n = (s) =>
        typeof r == "string" || typeof r > "u"
          ? { message: r }
          : typeof r == "function"
            ? r(s)
            : r;
      return this._refinement((s, a) => {
        let i = e(s),
          o = () => a.addIssue({ code: re.custom, ...n(s) });
        return typeof Promise < "u" && i instanceof Promise
          ? i.then((c) => (c ? !0 : (o(), !1)))
          : i
            ? !0
            : (o(), !1);
      });
    }
    refinement(e, r) {
      return this._refinement((n, s) =>
        e(n) ? !0 : (s.addIssue(typeof r == "function" ? r(n, s) : r), !1),
      );
    }
    _refinement(e) {
      return new Xr({
        schema: this,
        typeName: se.ZodEffects,
        effect: { type: "refinement", refinement: e },
      });
    }
    superRefine(e) {
      return this._refinement(e);
    }
    constructor(e) {
      ((this.spa = this.safeParseAsync),
        (this._def = e),
        (this.parse = this.parse.bind(this)),
        (this.safeParse = this.safeParse.bind(this)),
        (this.parseAsync = this.parseAsync.bind(this)),
        (this.safeParseAsync = this.safeParseAsync.bind(this)),
        (this.spa = this.spa.bind(this)),
        (this.refine = this.refine.bind(this)),
        (this.refinement = this.refinement.bind(this)),
        (this.superRefine = this.superRefine.bind(this)),
        (this.optional = this.optional.bind(this)),
        (this.nullable = this.nullable.bind(this)),
        (this.nullish = this.nullish.bind(this)),
        (this.array = this.array.bind(this)),
        (this.promise = this.promise.bind(this)),
        (this.or = this.or.bind(this)),
        (this.and = this.and.bind(this)),
        (this.transform = this.transform.bind(this)),
        (this.brand = this.brand.bind(this)),
        (this.default = this.default.bind(this)),
        (this.catch = this.catch.bind(this)),
        (this.describe = this.describe.bind(this)),
        (this.pipe = this.pipe.bind(this)),
        (this.readonly = this.readonly.bind(this)),
        (this.isNullable = this.isNullable.bind(this)),
        (this.isOptional = this.isOptional.bind(this)),
        (this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: (r) => this["~validate"](r),
        }));
    }
    optional() {
      return wr.create(this, this._def);
    }
    nullable() {
      return In.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ts.create(this);
    }
    promise() {
      return Rs.create(this, this._def);
    }
    or(e) {
      return ua.create([this, e], this._def);
    }
    and(e) {
      return da.create(this, e, this._def);
    }
    transform(e) {
      return new Xr({
        ...Be(this._def),
        schema: this,
        typeName: se.ZodEffects,
        effect: { type: "transform", transform: e },
      });
    }
    default(e) {
      let r = typeof e == "function" ? e : () => e;
      return new ga({
        ...Be(this._def),
        innerType: this,
        defaultValue: r,
        typeName: se.ZodDefault,
      });
    }
    brand() {
      return new mc({ typeName: se.ZodBranded, type: this, ...Be(this._def) });
    }
    catch(e) {
      let r = typeof e == "function" ? e : () => e;
      return new va({
        ...Be(this._def),
        innerType: this,
        catchValue: r,
        typeName: se.ZodCatch,
      });
    }
    describe(e) {
      let r = this.constructor;
      return new r({ ...this._def, description: e });
    }
    pipe(e) {
      return hc.create(this, e);
    }
    readonly() {
      return ya.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  },
  X3 = /^c[^\s-]{8,}$/i,
  Y3 = /^[0-9a-z]+$/,
  Q3 = /^[0-9A-HJKMNP-TV-Z]{26}$/i,
  eZ =
    /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
  tZ = /^[a-z0-9_-]{21}$/i,
  rZ = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
  nZ =
    /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
  sZ =
    /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
  aZ = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
  yh,
  iZ =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  oZ =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  cZ =
    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,
  lZ =
    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  uZ = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  dZ = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  FE =
    "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
  pZ = new RegExp(`^${FE}$`);
function UE(t) {
  let e = "[0-5]\\d";
  t.precision
    ? (e = `${e}\\.\\d{${t.precision}}`)
    : t.precision == null && (e = `${e}(\\.\\d+)?`);
  let r = t.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${e})${r}`;
}
function fZ(t) {
  return new RegExp(`^${UE(t)}$`);
}
function qE(t) {
  let e = `${FE}T${UE(t)}`,
    r = [];
  return (
    r.push(t.local ? "Z?" : "Z"),
    t.offset && r.push("([+-]\\d{2}:?\\d{2})"),
    (e = `${e}(${r.join("|")})`),
    new RegExp(`^${e}$`)
  );
}
function mZ(t, e) {
  return !!(
    ((e === "v4" || !e) && iZ.test(t)) ||
    ((e === "v6" || !e) && cZ.test(t))
  );
}
function hZ(t, e) {
  if (!rZ.test(t)) return !1;
  try {
    let [r] = t.split(".");
    if (!r) return !1;
    let n = r
        .replace(/-/g, "+")
        .replace(/_/g, "/")
        .padEnd(r.length + ((4 - (r.length % 4)) % 4), "="),
      s = JSON.parse(atob(n));
    return !(
      typeof s != "object" ||
      s === null ||
      ("typ" in s && s?.typ !== "JWT") ||
      !s.alg ||
      (e && s.alg !== e)
    );
  } catch {
    return !1;
  }
}
function gZ(t, e) {
  return !!(
    ((e === "v4" || !e) && oZ.test(t)) ||
    ((e === "v6" || !e) && lZ.test(t))
  );
}
var Ps = class t extends He {
  _parse(e) {
    if (
      (this._def.coerce && (e.data = String(e.data)),
      this._getType(e) !== ve.string)
    ) {
      let a = this._getOrReturnCtx(e);
      return (
        de(a, {
          code: re.invalid_type,
          expected: ve.string,
          received: a.parsedType,
        }),
        $e
      );
    }
    let n = new rr(),
      s;
    for (let a of this._def.checks)
      if (a.kind === "min")
        e.data.length < a.value &&
          ((s = this._getOrReturnCtx(e, s)),
          de(s, {
            code: re.too_small,
            minimum: a.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "max")
        e.data.length > a.value &&
          ((s = this._getOrReturnCtx(e, s)),
          de(s, {
            code: re.too_big,
            maximum: a.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "length") {
        let i = e.data.length > a.value,
          o = e.data.length < a.value;
        (i || o) &&
          ((s = this._getOrReturnCtx(e, s)),
          i
            ? de(s, {
                code: re.too_big,
                maximum: a.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: a.message,
              })
            : o &&
              de(s, {
                code: re.too_small,
                minimum: a.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: a.message,
              }),
          n.dirty());
      } else if (a.kind === "email")
        sZ.test(e.data) ||
          ((s = this._getOrReturnCtx(e, s)),
          de(s, {
            validation: "email",
            code: re.invalid_string,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "emoji")
        (yh || (yh = new RegExp(aZ, "u")),
          yh.test(e.data) ||
            ((s = this._getOrReturnCtx(e, s)),
            de(s, {
              validation: "emoji",
              code: re.invalid_string,
              message: a.message,
            }),
            n.dirty()));
      else if (a.kind === "uuid")
        eZ.test(e.data) ||
          ((s = this._getOrReturnCtx(e, s)),
          de(s, {
            validation: "uuid",
            code: re.invalid_string,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "nanoid")
        tZ.test(e.data) ||
          ((s = this._getOrReturnCtx(e, s)),
          de(s, {
            validation: "nanoid",
            code: re.invalid_string,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "cuid")
        X3.test(e.data) ||
          ((s = this._getOrReturnCtx(e, s)),
          de(s, {
            validation: "cuid",
            code: re.invalid_string,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "cuid2")
        Y3.test(e.data) ||
          ((s = this._getOrReturnCtx(e, s)),
          de(s, {
            validation: "cuid2",
            code: re.invalid_string,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "ulid")
        Q3.test(e.data) ||
          ((s = this._getOrReturnCtx(e, s)),
          de(s, {
            validation: "ulid",
            code: re.invalid_string,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "url")
        try {
          new URL(e.data);
        } catch {
          ((s = this._getOrReturnCtx(e, s)),
            de(s, {
              validation: "url",
              code: re.invalid_string,
              message: a.message,
            }),
            n.dirty());
        }
      else
        a.kind === "regex"
          ? ((a.regex.lastIndex = 0),
            a.regex.test(e.data) ||
              ((s = this._getOrReturnCtx(e, s)),
              de(s, {
                validation: "regex",
                code: re.invalid_string,
                message: a.message,
              }),
              n.dirty()))
          : a.kind === "trim"
            ? (e.data = e.data.trim())
            : a.kind === "includes"
              ? e.data.includes(a.value, a.position) ||
                ((s = this._getOrReturnCtx(e, s)),
                de(s, {
                  code: re.invalid_string,
                  validation: { includes: a.value, position: a.position },
                  message: a.message,
                }),
                n.dirty())
              : a.kind === "toLowerCase"
                ? (e.data = e.data.toLowerCase())
                : a.kind === "toUpperCase"
                  ? (e.data = e.data.toUpperCase())
                  : a.kind === "startsWith"
                    ? e.data.startsWith(a.value) ||
                      ((s = this._getOrReturnCtx(e, s)),
                      de(s, {
                        code: re.invalid_string,
                        validation: { startsWith: a.value },
                        message: a.message,
                      }),
                      n.dirty())
                    : a.kind === "endsWith"
                      ? e.data.endsWith(a.value) ||
                        ((s = this._getOrReturnCtx(e, s)),
                        de(s, {
                          code: re.invalid_string,
                          validation: { endsWith: a.value },
                          message: a.message,
                        }),
                        n.dirty())
                      : a.kind === "datetime"
                        ? qE(a).test(e.data) ||
                          ((s = this._getOrReturnCtx(e, s)),
                          de(s, {
                            code: re.invalid_string,
                            validation: "datetime",
                            message: a.message,
                          }),
                          n.dirty())
                        : a.kind === "date"
                          ? pZ.test(e.data) ||
                            ((s = this._getOrReturnCtx(e, s)),
                            de(s, {
                              code: re.invalid_string,
                              validation: "date",
                              message: a.message,
                            }),
                            n.dirty())
                          : a.kind === "time"
                            ? fZ(a).test(e.data) ||
                              ((s = this._getOrReturnCtx(e, s)),
                              de(s, {
                                code: re.invalid_string,
                                validation: "time",
                                message: a.message,
                              }),
                              n.dirty())
                            : a.kind === "duration"
                              ? nZ.test(e.data) ||
                                ((s = this._getOrReturnCtx(e, s)),
                                de(s, {
                                  validation: "duration",
                                  code: re.invalid_string,
                                  message: a.message,
                                }),
                                n.dirty())
                              : a.kind === "ip"
                                ? mZ(e.data, a.version) ||
                                  ((s = this._getOrReturnCtx(e, s)),
                                  de(s, {
                                    validation: "ip",
                                    code: re.invalid_string,
                                    message: a.message,
                                  }),
                                  n.dirty())
                                : a.kind === "jwt"
                                  ? hZ(e.data, a.alg) ||
                                    ((s = this._getOrReturnCtx(e, s)),
                                    de(s, {
                                      validation: "jwt",
                                      code: re.invalid_string,
                                      message: a.message,
                                    }),
                                    n.dirty())
                                  : a.kind === "cidr"
                                    ? gZ(e.data, a.version) ||
                                      ((s = this._getOrReturnCtx(e, s)),
                                      de(s, {
                                        validation: "cidr",
                                        code: re.invalid_string,
                                        message: a.message,
                                      }),
                                      n.dirty())
                                    : a.kind === "base64"
                                      ? uZ.test(e.data) ||
                                        ((s = this._getOrReturnCtx(e, s)),
                                        de(s, {
                                          validation: "base64",
                                          code: re.invalid_string,
                                          message: a.message,
                                        }),
                                        n.dirty())
                                      : a.kind === "base64url"
                                        ? dZ.test(e.data) ||
                                          ((s = this._getOrReturnCtx(e, s)),
                                          de(s, {
                                            validation: "base64url",
                                            code: re.invalid_string,
                                            message: a.message,
                                          }),
                                          n.dirty())
                                        : We.assertNever(a);
    return { status: n.value, value: e.data };
  }
  _regex(e, r, n) {
    return this.refinement((s) => e.test(s), {
      validation: r,
      code: re.invalid_string,
      ...we.errToObj(n),
    });
  }
  _addCheck(e) {
    return new t({ ...this._def, checks: [...this._def.checks, e] });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...we.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...we.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...we.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...we.errToObj(e) });
  }
  nanoid(e) {
    return this._addCheck({ kind: "nanoid", ...we.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...we.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...we.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...we.errToObj(e) });
  }
  base64(e) {
    return this._addCheck({ kind: "base64", ...we.errToObj(e) });
  }
  base64url(e) {
    return this._addCheck({ kind: "base64url", ...we.errToObj(e) });
  }
  jwt(e) {
    return this._addCheck({ kind: "jwt", ...we.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...we.errToObj(e) });
  }
  cidr(e) {
    return this._addCheck({ kind: "cidr", ...we.errToObj(e) });
  }
  datetime(e) {
    return typeof e == "string"
      ? this._addCheck({
          kind: "datetime",
          precision: null,
          offset: !1,
          local: !1,
          message: e,
        })
      : this._addCheck({
          kind: "datetime",
          precision: typeof e?.precision > "u" ? null : e?.precision,
          offset: e?.offset ?? !1,
          local: e?.local ?? !1,
          ...we.errToObj(e?.message),
        });
  }
  date(e) {
    return this._addCheck({ kind: "date", message: e });
  }
  time(e) {
    return typeof e == "string"
      ? this._addCheck({ kind: "time", precision: null, message: e })
      : this._addCheck({
          kind: "time",
          precision: typeof e?.precision > "u" ? null : e?.precision,
          ...we.errToObj(e?.message),
        });
  }
  duration(e) {
    return this._addCheck({ kind: "duration", ...we.errToObj(e) });
  }
  regex(e, r) {
    return this._addCheck({ kind: "regex", regex: e, ...we.errToObj(r) });
  }
  includes(e, r) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: r?.position,
      ...we.errToObj(r?.message),
    });
  }
  startsWith(e, r) {
    return this._addCheck({ kind: "startsWith", value: e, ...we.errToObj(r) });
  }
  endsWith(e, r) {
    return this._addCheck({ kind: "endsWith", value: e, ...we.errToObj(r) });
  }
  min(e, r) {
    return this._addCheck({ kind: "min", value: e, ...we.errToObj(r) });
  }
  max(e, r) {
    return this._addCheck({ kind: "max", value: e, ...we.errToObj(r) });
  }
  length(e, r) {
    return this._addCheck({ kind: "length", value: e, ...we.errToObj(r) });
  }
  nonempty(e) {
    return this.min(1, we.errToObj(e));
  }
  trim() {
    return new t({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }],
    });
  }
  toLowerCase() {
    return new t({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }],
    });
  }
  toUpperCase() {
    return new t({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }],
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e) => e.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e) => e.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e) => e.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e) => e.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((e) => e.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((e) => e.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((e) => e.kind === "base64url");
  }
  get minLength() {
    let e = null;
    for (let r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (let r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
};
Ps.create = (t) =>
  new Ps({
    checks: [],
    typeName: se.ZodString,
    coerce: t?.coerce ?? !1,
    ...Be(t),
  });
function vZ(t, e) {
  let r = (t.toString().split(".")[1] || "").length,
    n = (e.toString().split(".")[1] || "").length,
    s = r > n ? r : n,
    a = Number.parseInt(t.toFixed(s).replace(".", "")),
    i = Number.parseInt(e.toFixed(s).replace(".", ""));
  return (a % i) / 10 ** s;
}
var sa = class t extends He {
  constructor() {
    (super(...arguments),
      (this.min = this.gte),
      (this.max = this.lte),
      (this.step = this.multipleOf));
  }
  _parse(e) {
    if (
      (this._def.coerce && (e.data = Number(e.data)),
      this._getType(e) !== ve.number)
    ) {
      let a = this._getOrReturnCtx(e);
      return (
        de(a, {
          code: re.invalid_type,
          expected: ve.number,
          received: a.parsedType,
        }),
        $e
      );
    }
    let n,
      s = new rr();
    for (let a of this._def.checks)
      a.kind === "int"
        ? We.isInteger(e.data) ||
          ((n = this._getOrReturnCtx(e, n)),
          de(n, {
            code: re.invalid_type,
            expected: "integer",
            received: "float",
            message: a.message,
          }),
          s.dirty())
        : a.kind === "min"
          ? (a.inclusive ? e.data < a.value : e.data <= a.value) &&
            ((n = this._getOrReturnCtx(e, n)),
            de(n, {
              code: re.too_small,
              minimum: a.value,
              type: "number",
              inclusive: a.inclusive,
              exact: !1,
              message: a.message,
            }),
            s.dirty())
          : a.kind === "max"
            ? (a.inclusive ? e.data > a.value : e.data >= a.value) &&
              ((n = this._getOrReturnCtx(e, n)),
              de(n, {
                code: re.too_big,
                maximum: a.value,
                type: "number",
                inclusive: a.inclusive,
                exact: !1,
                message: a.message,
              }),
              s.dirty())
            : a.kind === "multipleOf"
              ? vZ(e.data, a.value) !== 0 &&
                ((n = this._getOrReturnCtx(e, n)),
                de(n, {
                  code: re.not_multiple_of,
                  multipleOf: a.value,
                  message: a.message,
                }),
                s.dirty())
              : a.kind === "finite"
                ? Number.isFinite(e.data) ||
                  ((n = this._getOrReturnCtx(e, n)),
                  de(n, { code: re.not_finite, message: a.message }),
                  s.dirty())
                : We.assertNever(a);
    return { status: s.value, value: e.data };
  }
  gte(e, r) {
    return this.setLimit("min", e, !0, we.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, !1, we.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, !0, we.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, !1, we.toString(r));
  }
  setLimit(e, r, n, s) {
    return new t({
      ...this._def,
      checks: [
        ...this._def.checks,
        { kind: e, value: r, inclusive: n, message: we.toString(s) },
      ],
    });
  }
  _addCheck(e) {
    return new t({ ...this._def, checks: [...this._def.checks, e] });
  }
  int(e) {
    return this._addCheck({ kind: "int", message: we.toString(e) });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: we.toString(e),
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: we.toString(e),
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: we.toString(e),
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: we.toString(e),
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: we.toString(r),
    });
  }
  finite(e) {
    return this._addCheck({ kind: "finite", message: we.toString(e) });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: we.toString(e),
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: we.toString(e),
    });
  }
  get minValue() {
    let e = null;
    for (let r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (let r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find(
      (e) =>
        e.kind === "int" || (e.kind === "multipleOf" && We.isInteger(e.value)),
    );
  }
  get isFinite() {
    let e = null,
      r = null;
    for (let n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min"
        ? (r === null || n.value > r) && (r = n.value)
        : n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    }
    return Number.isFinite(r) && Number.isFinite(e);
  }
};
sa.create = (t) =>
  new sa({
    checks: [],
    typeName: se.ZodNumber,
    coerce: t?.coerce || !1,
    ...Be(t),
  });
var aa = class t extends He {
  constructor() {
    (super(...arguments), (this.min = this.gte), (this.max = this.lte));
  }
  _parse(e) {
    if (this._def.coerce)
      try {
        e.data = BigInt(e.data);
      } catch {
        return this._getInvalidInput(e);
      }
    if (this._getType(e) !== ve.bigint) return this._getInvalidInput(e);
    let n,
      s = new rr();
    for (let a of this._def.checks)
      a.kind === "min"
        ? (a.inclusive ? e.data < a.value : e.data <= a.value) &&
          ((n = this._getOrReturnCtx(e, n)),
          de(n, {
            code: re.too_small,
            type: "bigint",
            minimum: a.value,
            inclusive: a.inclusive,
            message: a.message,
          }),
          s.dirty())
        : a.kind === "max"
          ? (a.inclusive ? e.data > a.value : e.data >= a.value) &&
            ((n = this._getOrReturnCtx(e, n)),
            de(n, {
              code: re.too_big,
              type: "bigint",
              maximum: a.value,
              inclusive: a.inclusive,
              message: a.message,
            }),
            s.dirty())
          : a.kind === "multipleOf"
            ? e.data % a.value !== BigInt(0) &&
              ((n = this._getOrReturnCtx(e, n)),
              de(n, {
                code: re.not_multiple_of,
                multipleOf: a.value,
                message: a.message,
              }),
              s.dirty())
            : We.assertNever(a);
    return { status: s.value, value: e.data };
  }
  _getInvalidInput(e) {
    let r = this._getOrReturnCtx(e);
    return (
      de(r, {
        code: re.invalid_type,
        expected: ve.bigint,
        received: r.parsedType,
      }),
      $e
    );
  }
  gte(e, r) {
    return this.setLimit("min", e, !0, we.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, !1, we.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, !0, we.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, !1, we.toString(r));
  }
  setLimit(e, r, n, s) {
    return new t({
      ...this._def,
      checks: [
        ...this._def.checks,
        { kind: e, value: r, inclusive: n, message: we.toString(s) },
      ],
    });
  }
  _addCheck(e) {
    return new t({ ...this._def, checks: [...this._def.checks, e] });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: we.toString(e),
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: we.toString(e),
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: we.toString(e),
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: we.toString(e),
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: we.toString(r),
    });
  }
  get minValue() {
    let e = null;
    for (let r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (let r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
};
aa.create = (t) =>
  new aa({
    checks: [],
    typeName: se.ZodBigInt,
    coerce: t?.coerce ?? !1,
    ...Be(t),
  });
var ia = class extends He {
  _parse(e) {
    if (
      (this._def.coerce && (e.data = !!e.data), this._getType(e) !== ve.boolean)
    ) {
      let n = this._getOrReturnCtx(e);
      return (
        de(n, {
          code: re.invalid_type,
          expected: ve.boolean,
          received: n.parsedType,
        }),
        $e
      );
    }
    return cr(e.data);
  }
};
ia.create = (t) =>
  new ia({ typeName: se.ZodBoolean, coerce: t?.coerce || !1, ...Be(t) });
var oa = class t extends He {
  _parse(e) {
    if (
      (this._def.coerce && (e.data = new Date(e.data)),
      this._getType(e) !== ve.date)
    ) {
      let a = this._getOrReturnCtx(e);
      return (
        de(a, {
          code: re.invalid_type,
          expected: ve.date,
          received: a.parsedType,
        }),
        $e
      );
    }
    if (Number.isNaN(e.data.getTime())) {
      let a = this._getOrReturnCtx(e);
      return (de(a, { code: re.invalid_date }), $e);
    }
    let n = new rr(),
      s;
    for (let a of this._def.checks)
      a.kind === "min"
        ? e.data.getTime() < a.value &&
          ((s = this._getOrReturnCtx(e, s)),
          de(s, {
            code: re.too_small,
            message: a.message,
            inclusive: !0,
            exact: !1,
            minimum: a.value,
            type: "date",
          }),
          n.dirty())
        : a.kind === "max"
          ? e.data.getTime() > a.value &&
            ((s = this._getOrReturnCtx(e, s)),
            de(s, {
              code: re.too_big,
              message: a.message,
              inclusive: !0,
              exact: !1,
              maximum: a.value,
              type: "date",
            }),
            n.dirty())
          : We.assertNever(a);
    return { status: n.value, value: new Date(e.data.getTime()) };
  }
  _addCheck(e) {
    return new t({ ...this._def, checks: [...this._def.checks, e] });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: we.toString(r),
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: we.toString(r),
    });
  }
  get minDate() {
    let e = null;
    for (let r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (let r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
};
oa.create = (t) =>
  new oa({
    checks: [],
    coerce: t?.coerce || !1,
    typeName: se.ZodDate,
    ...Be(t),
  });
var ki = class extends He {
  _parse(e) {
    if (this._getType(e) !== ve.symbol) {
      let n = this._getOrReturnCtx(e);
      return (
        de(n, {
          code: re.invalid_type,
          expected: ve.symbol,
          received: n.parsedType,
        }),
        $e
      );
    }
    return cr(e.data);
  }
};
ki.create = (t) => new ki({ typeName: se.ZodSymbol, ...Be(t) });
var ca = class extends He {
  _parse(e) {
    if (this._getType(e) !== ve.undefined) {
      let n = this._getOrReturnCtx(e);
      return (
        de(n, {
          code: re.invalid_type,
          expected: ve.undefined,
          received: n.parsedType,
        }),
        $e
      );
    }
    return cr(e.data);
  }
};
ca.create = (t) => new ca({ typeName: se.ZodUndefined, ...Be(t) });
var la = class extends He {
  _parse(e) {
    if (this._getType(e) !== ve.null) {
      let n = this._getOrReturnCtx(e);
      return (
        de(n, {
          code: re.invalid_type,
          expected: ve.null,
          received: n.parsedType,
        }),
        $e
      );
    }
    return cr(e.data);
  }
};
la.create = (t) => new la({ typeName: se.ZodNull, ...Be(t) });
var ks = class extends He {
  constructor() {
    (super(...arguments), (this._any = !0));
  }
  _parse(e) {
    return cr(e.data);
  }
};
ks.create = (t) => new ks({ typeName: se.ZodAny, ...Be(t) });
var es = class extends He {
  constructor() {
    (super(...arguments), (this._unknown = !0));
  }
  _parse(e) {
    return cr(e.data);
  }
};
es.create = (t) => new es({ typeName: se.ZodUnknown, ...Be(t) });
var mn = class extends He {
  _parse(e) {
    let r = this._getOrReturnCtx(e);
    return (
      de(r, {
        code: re.invalid_type,
        expected: ve.never,
        received: r.parsedType,
      }),
      $e
    );
  }
};
mn.create = (t) => new mn({ typeName: se.ZodNever, ...Be(t) });
var Ri = class extends He {
  _parse(e) {
    if (this._getType(e) !== ve.undefined) {
      let n = this._getOrReturnCtx(e);
      return (
        de(n, {
          code: re.invalid_type,
          expected: ve.void,
          received: n.parsedType,
        }),
        $e
      );
    }
    return cr(e.data);
  }
};
Ri.create = (t) => new Ri({ typeName: se.ZodVoid, ...Be(t) });
var ts = class t extends He {
  _parse(e) {
    let { ctx: r, status: n } = this._processInputParams(e),
      s = this._def;
    if (r.parsedType !== ve.array)
      return (
        de(r, {
          code: re.invalid_type,
          expected: ve.array,
          received: r.parsedType,
        }),
        $e
      );
    if (s.exactLength !== null) {
      let i = r.data.length > s.exactLength.value,
        o = r.data.length < s.exactLength.value;
      (i || o) &&
        (de(r, {
          code: i ? re.too_big : re.too_small,
          minimum: o ? s.exactLength.value : void 0,
          maximum: i ? s.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: s.exactLength.message,
        }),
        n.dirty());
    }
    if (
      (s.minLength !== null &&
        r.data.length < s.minLength.value &&
        (de(r, {
          code: re.too_small,
          minimum: s.minLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: s.minLength.message,
        }),
        n.dirty()),
      s.maxLength !== null &&
        r.data.length > s.maxLength.value &&
        (de(r, {
          code: re.too_big,
          maximum: s.maxLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: s.maxLength.message,
        }),
        n.dirty()),
      r.common.async)
    )
      return Promise.all(
        [...r.data].map((i, o) => s.type._parseAsync(new Jr(r, i, r.path, o))),
      ).then((i) => rr.mergeArray(n, i));
    let a = [...r.data].map((i, o) =>
      s.type._parseSync(new Jr(r, i, r.path, o)),
    );
    return rr.mergeArray(n, a);
  }
  get element() {
    return this._def.type;
  }
  min(e, r) {
    return new t({
      ...this._def,
      minLength: { value: e, message: we.toString(r) },
    });
  }
  max(e, r) {
    return new t({
      ...this._def,
      maxLength: { value: e, message: we.toString(r) },
    });
  }
  length(e, r) {
    return new t({
      ...this._def,
      exactLength: { value: e, message: we.toString(r) },
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
};
ts.create = (t, e) =>
  new ts({
    type: t,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: se.ZodArray,
    ...Be(e),
  });
function Pi(t) {
  if (t instanceof Sr) {
    let e = {};
    for (let r in t.shape) {
      let n = t.shape[r];
      e[r] = wr.create(Pi(n));
    }
    return new Sr({ ...t._def, shape: () => e });
  } else
    return t instanceof ts
      ? new ts({ ...t._def, type: Pi(t.element) })
      : t instanceof wr
        ? wr.create(Pi(t.unwrap()))
        : t instanceof In
          ? In.create(Pi(t.unwrap()))
          : t instanceof On
            ? On.create(t.items.map((e) => Pi(e)))
            : t;
}
var Sr = class t extends He {
  constructor() {
    (super(...arguments),
      (this._cached = null),
      (this.nonstrict = this.passthrough),
      (this.augment = this.extend));
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    let e = this._def.shape(),
      r = We.objectKeys(e);
    return ((this._cached = { shape: e, keys: r }), this._cached);
  }
  _parse(e) {
    if (this._getType(e) !== ve.object) {
      let l = this._getOrReturnCtx(e);
      return (
        de(l, {
          code: re.invalid_type,
          expected: ve.object,
          received: l.parsedType,
        }),
        $e
      );
    }
    let { status: n, ctx: s } = this._processInputParams(e),
      { shape: a, keys: i } = this._getCached(),
      o = [];
    if (
      !(this._def.catchall instanceof mn && this._def.unknownKeys === "strip")
    )
      for (let l in s.data) i.includes(l) || o.push(l);
    let c = [];
    for (let l of i) {
      let u = a[l],
        d = s.data[l];
      c.push({
        key: { status: "valid", value: l },
        value: u._parse(new Jr(s, d, s.path, l)),
        alwaysSet: l in s.data,
      });
    }
    if (this._def.catchall instanceof mn) {
      let l = this._def.unknownKeys;
      if (l === "passthrough")
        for (let u of o)
          c.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: s.data[u] },
          });
      else if (l === "strict")
        o.length > 0 &&
          (de(s, { code: re.unrecognized_keys, keys: o }), n.dirty());
      else if (l !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      let l = this._def.catchall;
      for (let u of o) {
        let d = s.data[u];
        c.push({
          key: { status: "valid", value: u },
          value: l._parse(new Jr(s, d, s.path, u)),
          alwaysSet: u in s.data,
        });
      }
    }
    return s.common.async
      ? Promise.resolve()
          .then(async () => {
            let l = [];
            for (let u of c) {
              let d = await u.key,
                m = await u.value;
              l.push({ key: d, value: m, alwaysSet: u.alwaysSet });
            }
            return l;
          })
          .then((l) => rr.mergeObjectSync(n, l))
      : rr.mergeObjectSync(n, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return (
      we.errToObj,
      new t({
        ...this._def,
        unknownKeys: "strict",
        ...(e !== void 0
          ? {
              errorMap: (r, n) => {
                let s = this._def.errorMap?.(r, n).message ?? n.defaultError;
                return r.code === "unrecognized_keys"
                  ? { message: we.errToObj(e).message ?? s }
                  : { message: s };
              },
            }
          : {}),
      })
    );
  }
  strip() {
    return new t({ ...this._def, unknownKeys: "strip" });
  }
  passthrough() {
    return new t({ ...this._def, unknownKeys: "passthrough" });
  }
  extend(e) {
    return new t({
      ...this._def,
      shape: () => ({ ...this._def.shape(), ...e }),
    });
  }
  merge(e) {
    return new t({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({ ...this._def.shape(), ...e._def.shape() }),
      typeName: se.ZodObject,
    });
  }
  setKey(e, r) {
    return this.augment({ [e]: r });
  }
  catchall(e) {
    return new t({ ...this._def, catchall: e });
  }
  pick(e) {
    let r = {};
    for (let n of We.objectKeys(e))
      e[n] && this.shape[n] && (r[n] = this.shape[n]);
    return new t({ ...this._def, shape: () => r });
  }
  omit(e) {
    let r = {};
    for (let n of We.objectKeys(this.shape)) e[n] || (r[n] = this.shape[n]);
    return new t({ ...this._def, shape: () => r });
  }
  deepPartial() {
    return Pi(this);
  }
  partial(e) {
    let r = {};
    for (let n of We.objectKeys(this.shape)) {
      let s = this.shape[n];
      e && !e[n] ? (r[n] = s) : (r[n] = s.optional());
    }
    return new t({ ...this._def, shape: () => r });
  }
  required(e) {
    let r = {};
    for (let n of We.objectKeys(this.shape))
      if (e && !e[n]) r[n] = this.shape[n];
      else {
        let a = this.shape[n];
        for (; a instanceof wr; ) a = a._def.innerType;
        r[n] = a;
      }
    return new t({ ...this._def, shape: () => r });
  }
  keyof() {
    return zE(We.objectKeys(this.shape));
  }
};
Sr.create = (t, e) =>
  new Sr({
    shape: () => t,
    unknownKeys: "strip",
    catchall: mn.create(),
    typeName: se.ZodObject,
    ...Be(e),
  });
Sr.strictCreate = (t, e) =>
  new Sr({
    shape: () => t,
    unknownKeys: "strict",
    catchall: mn.create(),
    typeName: se.ZodObject,
    ...Be(e),
  });
Sr.lazycreate = (t, e) =>
  new Sr({
    shape: t,
    unknownKeys: "strip",
    catchall: mn.create(),
    typeName: se.ZodObject,
    ...Be(e),
  });
var ua = class extends He {
  _parse(e) {
    let { ctx: r } = this._processInputParams(e),
      n = this._def.options;
    function s(a) {
      for (let o of a) if (o.result.status === "valid") return o.result;
      for (let o of a)
        if (o.result.status === "dirty")
          return (r.common.issues.push(...o.ctx.common.issues), o.result);
      let i = a.map((o) => new xr(o.ctx.common.issues));
      return (de(r, { code: re.invalid_union, unionErrors: i }), $e);
    }
    if (r.common.async)
      return Promise.all(
        n.map(async (a) => {
          let i = { ...r, common: { ...r.common, issues: [] }, parent: null };
          return {
            result: await a._parseAsync({
              data: r.data,
              path: r.path,
              parent: i,
            }),
            ctx: i,
          };
        }),
      ).then(s);
    {
      let a,
        i = [];
      for (let c of n) {
        let l = { ...r, common: { ...r.common, issues: [] }, parent: null },
          u = c._parseSync({ data: r.data, path: r.path, parent: l });
        if (u.status === "valid") return u;
        (u.status === "dirty" && !a && (a = { result: u, ctx: l }),
          l.common.issues.length && i.push(l.common.issues));
      }
      if (a) return (r.common.issues.push(...a.ctx.common.issues), a.result);
      let o = i.map((c) => new xr(c));
      return (de(r, { code: re.invalid_union, unionErrors: o }), $e);
    }
  }
  get options() {
    return this._def.options;
  }
};
ua.create = (t, e) => new ua({ options: t, typeName: se.ZodUnion, ...Be(e) });
var Qn = (t) =>
    t instanceof pa
      ? Qn(t.schema)
      : t instanceof Xr
        ? Qn(t.innerType())
        : t instanceof fa
          ? [t.value]
          : t instanceof ma
            ? t.options
            : t instanceof ha
              ? We.objectValues(t.enum)
              : t instanceof ga
                ? Qn(t._def.innerType)
                : t instanceof ca
                  ? [void 0]
                  : t instanceof la
                    ? [null]
                    : t instanceof wr
                      ? [void 0, ...Qn(t.unwrap())]
                      : t instanceof In
                        ? [null, ...Qn(t.unwrap())]
                        : t instanceof mc || t instanceof ya
                          ? Qn(t.unwrap())
                          : t instanceof va
                            ? Qn(t._def.innerType)
                            : [],
  Su = class t extends He {
    _parse(e) {
      let { ctx: r } = this._processInputParams(e);
      if (r.parsedType !== ve.object)
        return (
          de(r, {
            code: re.invalid_type,
            expected: ve.object,
            received: r.parsedType,
          }),
          $e
        );
      let n = this.discriminator,
        s = r.data[n],
        a = this.optionsMap.get(s);
      return a
        ? r.common.async
          ? a._parseAsync({ data: r.data, path: r.path, parent: r })
          : a._parseSync({ data: r.data, path: r.path, parent: r })
        : (de(r, {
            code: re.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [n],
          }),
          $e);
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    static create(e, r, n) {
      let s = new Map();
      for (let a of r) {
        let i = Qn(a.shape[e]);
        if (!i.length)
          throw new Error(
            `A discriminator value for key \`${e}\` could not be extracted from all schema options`,
          );
        for (let o of i) {
          if (s.has(o))
            throw new Error(
              `Discriminator property ${String(e)} has duplicate value ${String(o)}`,
            );
          s.set(o, a);
        }
      }
      return new t({
        typeName: se.ZodDiscriminatedUnion,
        discriminator: e,
        options: r,
        optionsMap: s,
        ...Be(n),
      });
    }
  };
function bh(t, e) {
  let r = Rn(t),
    n = Rn(e);
  if (t === e) return { valid: !0, data: t };
  if (r === ve.object && n === ve.object) {
    let s = We.objectKeys(e),
      a = We.objectKeys(t).filter((o) => s.indexOf(o) !== -1),
      i = { ...t, ...e };
    for (let o of a) {
      let c = bh(t[o], e[o]);
      if (!c.valid) return { valid: !1 };
      i[o] = c.data;
    }
    return { valid: !0, data: i };
  } else if (r === ve.array && n === ve.array) {
    if (t.length !== e.length) return { valid: !1 };
    let s = [];
    for (let a = 0; a < t.length; a++) {
      let i = t[a],
        o = e[a],
        c = bh(i, o);
      if (!c.valid) return { valid: !1 };
      s.push(c.data);
    }
    return { valid: !0, data: s };
  } else
    return r === ve.date && n === ve.date && +t == +e
      ? { valid: !0, data: t }
      : { valid: !1 };
}
var da = class extends He {
  _parse(e) {
    let { status: r, ctx: n } = this._processInputParams(e),
      s = (a, i) => {
        if (xu(a) || xu(i)) return $e;
        let o = bh(a.value, i.value);
        return o.valid
          ? ((wu(a) || wu(i)) && r.dirty(), { status: r.value, value: o.data })
          : (de(n, { code: re.invalid_intersection_types }), $e);
      };
    return n.common.async
      ? Promise.all([
          this._def.left._parseAsync({ data: n.data, path: n.path, parent: n }),
          this._def.right._parseAsync({
            data: n.data,
            path: n.path,
            parent: n,
          }),
        ]).then(([a, i]) => s(a, i))
      : s(
          this._def.left._parseSync({ data: n.data, path: n.path, parent: n }),
          this._def.right._parseSync({ data: n.data, path: n.path, parent: n }),
        );
  }
};
da.create = (t, e, r) =>
  new da({ left: t, right: e, typeName: se.ZodIntersection, ...Be(r) });
var On = class t extends He {
  _parse(e) {
    let { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== ve.array)
      return (
        de(n, {
          code: re.invalid_type,
          expected: ve.array,
          received: n.parsedType,
        }),
        $e
      );
    if (n.data.length < this._def.items.length)
      return (
        de(n, {
          code: re.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array",
        }),
        $e
      );
    !this._def.rest &&
      n.data.length > this._def.items.length &&
      (de(n, {
        code: re.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array",
      }),
      r.dirty());
    let a = [...n.data]
      .map((i, o) => {
        let c = this._def.items[o] || this._def.rest;
        return c ? c._parse(new Jr(n, i, n.path, o)) : null;
      })
      .filter((i) => !!i);
    return n.common.async
      ? Promise.all(a).then((i) => rr.mergeArray(r, i))
      : rr.mergeArray(r, a);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new t({ ...this._def, rest: e });
  }
};
On.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new On({ items: t, typeName: se.ZodTuple, rest: null, ...Be(e) });
};
var Eu = class t extends He {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(e) {
      let { status: r, ctx: n } = this._processInputParams(e);
      if (n.parsedType !== ve.object)
        return (
          de(n, {
            code: re.invalid_type,
            expected: ve.object,
            received: n.parsedType,
          }),
          $e
        );
      let s = [],
        a = this._def.keyType,
        i = this._def.valueType;
      for (let o in n.data)
        s.push({
          key: a._parse(new Jr(n, o, n.path, o)),
          value: i._parse(new Jr(n, n.data[o], n.path, o)),
          alwaysSet: o in n.data,
        });
      return n.common.async
        ? rr.mergeObjectAsync(r, s)
        : rr.mergeObjectSync(r, s);
    }
    get element() {
      return this._def.valueType;
    }
    static create(e, r, n) {
      return r instanceof He
        ? new t({ keyType: e, valueType: r, typeName: se.ZodRecord, ...Be(n) })
        : new t({
            keyType: Ps.create(),
            valueType: e,
            typeName: se.ZodRecord,
            ...Be(r),
          });
    }
  },
  Oi = class extends He {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(e) {
      let { status: r, ctx: n } = this._processInputParams(e);
      if (n.parsedType !== ve.map)
        return (
          de(n, {
            code: re.invalid_type,
            expected: ve.map,
            received: n.parsedType,
          }),
          $e
        );
      let s = this._def.keyType,
        a = this._def.valueType,
        i = [...n.data.entries()].map(([o, c], l) => ({
          key: s._parse(new Jr(n, o, n.path, [l, "key"])),
          value: a._parse(new Jr(n, c, n.path, [l, "value"])),
        }));
      if (n.common.async) {
        let o = new Map();
        return Promise.resolve().then(async () => {
          for (let c of i) {
            let l = await c.key,
              u = await c.value;
            if (l.status === "aborted" || u.status === "aborted") return $e;
            ((l.status === "dirty" || u.status === "dirty") && r.dirty(),
              o.set(l.value, u.value));
          }
          return { status: r.value, value: o };
        });
      } else {
        let o = new Map();
        for (let c of i) {
          let l = c.key,
            u = c.value;
          if (l.status === "aborted" || u.status === "aborted") return $e;
          ((l.status === "dirty" || u.status === "dirty") && r.dirty(),
            o.set(l.value, u.value));
        }
        return { status: r.value, value: o };
      }
    }
  };
Oi.create = (t, e, r) =>
  new Oi({ valueType: e, keyType: t, typeName: se.ZodMap, ...Be(r) });
var Ii = class t extends He {
  _parse(e) {
    let { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== ve.set)
      return (
        de(n, {
          code: re.invalid_type,
          expected: ve.set,
          received: n.parsedType,
        }),
        $e
      );
    let s = this._def;
    (s.minSize !== null &&
      n.data.size < s.minSize.value &&
      (de(n, {
        code: re.too_small,
        minimum: s.minSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: s.minSize.message,
      }),
      r.dirty()),
      s.maxSize !== null &&
        n.data.size > s.maxSize.value &&
        (de(n, {
          code: re.too_big,
          maximum: s.maxSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: s.maxSize.message,
        }),
        r.dirty()));
    let a = this._def.valueType;
    function i(c) {
      let l = new Set();
      for (let u of c) {
        if (u.status === "aborted") return $e;
        (u.status === "dirty" && r.dirty(), l.add(u.value));
      }
      return { status: r.value, value: l };
    }
    let o = [...n.data.values()].map((c, l) =>
      a._parse(new Jr(n, c, n.path, l)),
    );
    return n.common.async ? Promise.all(o).then((c) => i(c)) : i(o);
  }
  min(e, r) {
    return new t({
      ...this._def,
      minSize: { value: e, message: we.toString(r) },
    });
  }
  max(e, r) {
    return new t({
      ...this._def,
      maxSize: { value: e, message: we.toString(r) },
    });
  }
  size(e, r) {
    return this.min(e, r).max(e, r);
  }
  nonempty(e) {
    return this.min(1, e);
  }
};
Ii.create = (t, e) =>
  new Ii({
    valueType: t,
    minSize: null,
    maxSize: null,
    typeName: se.ZodSet,
    ...Be(e),
  });
var Tu = class t extends He {
    constructor() {
      (super(...arguments), (this.validate = this.implement));
    }
    _parse(e) {
      let { ctx: r } = this._processInputParams(e);
      if (r.parsedType !== ve.function)
        return (
          de(r, {
            code: re.invalid_type,
            expected: ve.function,
            received: r.parsedType,
          }),
          $e
        );
      function n(o, c) {
        return fc({
          data: o,
          path: r.path,
          errorMaps: [
            r.common.contextualErrorMap,
            r.schemaErrorMap,
            Ti(),
            Yn,
          ].filter((l) => !!l),
          issueData: { code: re.invalid_arguments, argumentsError: c },
        });
      }
      function s(o, c) {
        return fc({
          data: o,
          path: r.path,
          errorMaps: [
            r.common.contextualErrorMap,
            r.schemaErrorMap,
            Ti(),
            Yn,
          ].filter((l) => !!l),
          issueData: { code: re.invalid_return_type, returnTypeError: c },
        });
      }
      let a = { errorMap: r.common.contextualErrorMap },
        i = r.data;
      if (this._def.returns instanceof Rs) {
        let o = this;
        return cr(async function (...c) {
          let l = new xr([]),
            u = await o._def.args.parseAsync(c, a).catch((p) => {
              throw (l.addIssue(n(c, p)), l);
            }),
            d = await Reflect.apply(i, this, u);
          return await o._def.returns._def.type.parseAsync(d, a).catch((p) => {
            throw (l.addIssue(s(d, p)), l);
          });
        });
      } else {
        let o = this;
        return cr(function (...c) {
          let l = o._def.args.safeParse(c, a);
          if (!l.success) throw new xr([n(c, l.error)]);
          let u = Reflect.apply(i, this, l.data),
            d = o._def.returns.safeParse(u, a);
          if (!d.success) throw new xr([s(u, d.error)]);
          return d.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...e) {
      return new t({ ...this._def, args: On.create(e).rest(es.create()) });
    }
    returns(e) {
      return new t({ ...this._def, returns: e });
    }
    implement(e) {
      return this.parse(e);
    }
    strictImplement(e) {
      return this.parse(e);
    }
    static create(e, r, n) {
      return new t({
        args: e || On.create([]).rest(es.create()),
        returns: r || es.create(),
        typeName: se.ZodFunction,
        ...Be(n),
      });
    }
  },
  pa = class extends He {
    get schema() {
      return this._def.getter();
    }
    _parse(e) {
      let { ctx: r } = this._processInputParams(e);
      return this._def
        .getter()
        ._parse({ data: r.data, path: r.path, parent: r });
    }
  };
pa.create = (t, e) => new pa({ getter: t, typeName: se.ZodLazy, ...Be(e) });
var fa = class extends He {
  _parse(e) {
    if (e.data !== this._def.value) {
      let r = this._getOrReturnCtx(e);
      return (
        de(r, {
          received: r.data,
          code: re.invalid_literal,
          expected: this._def.value,
        }),
        $e
      );
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
};
fa.create = (t, e) => new fa({ value: t, typeName: se.ZodLiteral, ...Be(e) });
function zE(t, e) {
  return new ma({ values: t, typeName: se.ZodEnum, ...Be(e) });
}
var ma = class t extends He {
  _parse(e) {
    if (typeof e.data != "string") {
      let r = this._getOrReturnCtx(e),
        n = this._def.values;
      return (
        de(r, {
          expected: We.joinValues(n),
          received: r.parsedType,
          code: re.invalid_type,
        }),
        $e
      );
    }
    if (
      (this._cache || (this._cache = new Set(this._def.values)),
      !this._cache.has(e.data))
    ) {
      let r = this._getOrReturnCtx(e),
        n = this._def.values;
      return (
        de(r, { received: r.data, code: re.invalid_enum_value, options: n }),
        $e
      );
    }
    return cr(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    let e = {};
    for (let r of this._def.values) e[r] = r;
    return e;
  }
  get Values() {
    let e = {};
    for (let r of this._def.values) e[r] = r;
    return e;
  }
  get Enum() {
    let e = {};
    for (let r of this._def.values) e[r] = r;
    return e;
  }
  extract(e, r = this._def) {
    return t.create(e, { ...this._def, ...r });
  }
  exclude(e, r = this._def) {
    return t.create(
      this.options.filter((n) => !e.includes(n)),
      { ...this._def, ...r },
    );
  }
};
ma.create = zE;
var ha = class extends He {
  _parse(e) {
    let r = We.getValidEnumValues(this._def.values),
      n = this._getOrReturnCtx(e);
    if (n.parsedType !== ve.string && n.parsedType !== ve.number) {
      let s = We.objectValues(r);
      return (
        de(n, {
          expected: We.joinValues(s),
          received: n.parsedType,
          code: re.invalid_type,
        }),
        $e
      );
    }
    if (
      (this._cache ||
        (this._cache = new Set(We.getValidEnumValues(this._def.values))),
      !this._cache.has(e.data))
    ) {
      let s = We.objectValues(r);
      return (
        de(n, { received: n.data, code: re.invalid_enum_value, options: s }),
        $e
      );
    }
    return cr(e.data);
  }
  get enum() {
    return this._def.values;
  }
};
ha.create = (t, e) =>
  new ha({ values: t, typeName: se.ZodNativeEnum, ...Be(e) });
var Rs = class extends He {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    let { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== ve.promise && r.common.async === !1)
      return (
        de(r, {
          code: re.invalid_type,
          expected: ve.promise,
          received: r.parsedType,
        }),
        $e
      );
    let n = r.parsedType === ve.promise ? r.data : Promise.resolve(r.data);
    return cr(
      n.then((s) =>
        this._def.type.parseAsync(s, {
          path: r.path,
          errorMap: r.common.contextualErrorMap,
        }),
      ),
    );
  }
};
Rs.create = (t, e) => new Rs({ type: t, typeName: se.ZodPromise, ...Be(e) });
var Xr = class extends He {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === se.ZodEffects
      ? this._def.schema.sourceType()
      : this._def.schema;
  }
  _parse(e) {
    let { status: r, ctx: n } = this._processInputParams(e),
      s = this._def.effect || null,
      a = {
        addIssue: (i) => {
          (de(n, i), i.fatal ? r.abort() : r.dirty());
        },
        get path() {
          return n.path;
        },
      };
    if (((a.addIssue = a.addIssue.bind(a)), s.type === "preprocess")) {
      let i = s.transform(n.data, a);
      if (n.common.async)
        return Promise.resolve(i).then(async (o) => {
          if (r.value === "aborted") return $e;
          let c = await this._def.schema._parseAsync({
            data: o,
            path: n.path,
            parent: n,
          });
          return c.status === "aborted"
            ? $e
            : c.status === "dirty"
              ? na(c.value)
              : r.value === "dirty"
                ? na(c.value)
                : c;
        });
      {
        if (r.value === "aborted") return $e;
        let o = this._def.schema._parseSync({
          data: i,
          path: n.path,
          parent: n,
        });
        return o.status === "aborted"
          ? $e
          : o.status === "dirty"
            ? na(o.value)
            : r.value === "dirty"
              ? na(o.value)
              : o;
      }
    }
    if (s.type === "refinement") {
      let i = (o) => {
        let c = s.refinement(o, a);
        if (n.common.async) return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error(
            "Async refinement encountered during synchronous parse operation. Use .parseAsync instead.",
          );
        return o;
      };
      if (n.common.async === !1) {
        let o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n,
        });
        return o.status === "aborted"
          ? $e
          : (o.status === "dirty" && r.dirty(),
            i(o.value),
            { status: r.value, value: o.value });
      } else
        return this._def.schema
          ._parseAsync({ data: n.data, path: n.path, parent: n })
          .then((o) =>
            o.status === "aborted"
              ? $e
              : (o.status === "dirty" && r.dirty(),
                i(o.value).then(() => ({ status: r.value, value: o.value }))),
          );
    }
    if (s.type === "transform")
      if (n.common.async === !1) {
        let i = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n,
        });
        if (!Cs(i)) return $e;
        let o = s.transform(i.value, a);
        if (o instanceof Promise)
          throw new Error(
            "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.",
          );
        return { status: r.value, value: o };
      } else
        return this._def.schema
          ._parseAsync({ data: n.data, path: n.path, parent: n })
          .then((i) =>
            Cs(i)
              ? Promise.resolve(s.transform(i.value, a)).then((o) => ({
                  status: r.value,
                  value: o,
                }))
              : $e,
          );
    We.assertNever(s);
  }
};
Xr.create = (t, e, r) =>
  new Xr({ schema: t, typeName: se.ZodEffects, effect: e, ...Be(r) });
Xr.createWithPreprocess = (t, e, r) =>
  new Xr({
    schema: e,
    effect: { type: "preprocess", transform: t },
    typeName: se.ZodEffects,
    ...Be(r),
  });
var wr = class extends He {
  _parse(e) {
    return this._getType(e) === ve.undefined
      ? cr(void 0)
      : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
wr.create = (t, e) =>
  new wr({ innerType: t, typeName: se.ZodOptional, ...Be(e) });
var In = class extends He {
  _parse(e) {
    return this._getType(e) === ve.null
      ? cr(null)
      : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
In.create = (t, e) =>
  new In({ innerType: t, typeName: se.ZodNullable, ...Be(e) });
var ga = class extends He {
  _parse(e) {
    let { ctx: r } = this._processInputParams(e),
      n = r.data;
    return (
      r.parsedType === ve.undefined && (n = this._def.defaultValue()),
      this._def.innerType._parse({ data: n, path: r.path, parent: r })
    );
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ga.create = (t, e) =>
  new ga({
    innerType: t,
    typeName: se.ZodDefault,
    defaultValue: typeof e.default == "function" ? e.default : () => e.default,
    ...Be(e),
  });
var va = class extends He {
  _parse(e) {
    let { ctx: r } = this._processInputParams(e),
      n = { ...r, common: { ...r.common, issues: [] } },
      s = this._def.innerType._parse({
        data: n.data,
        path: n.path,
        parent: { ...n },
      });
    return Ci(s)
      ? s.then((a) => ({
          status: "valid",
          value:
            a.status === "valid"
              ? a.value
              : this._def.catchValue({
                  get error() {
                    return new xr(n.common.issues);
                  },
                  input: n.data,
                }),
        }))
      : {
          status: "valid",
          value:
            s.status === "valid"
              ? s.value
              : this._def.catchValue({
                  get error() {
                    return new xr(n.common.issues);
                  },
                  input: n.data,
                }),
        };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
va.create = (t, e) =>
  new va({
    innerType: t,
    typeName: se.ZodCatch,
    catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
    ...Be(e),
  });
var $i = class extends He {
  _parse(e) {
    if (this._getType(e) !== ve.nan) {
      let n = this._getOrReturnCtx(e);
      return (
        de(n, {
          code: re.invalid_type,
          expected: ve.nan,
          received: n.parsedType,
        }),
        $e
      );
    }
    return { status: "valid", value: e.data };
  }
};
$i.create = (t) => new $i({ typeName: se.ZodNaN, ...Be(t) });
var yZ = Symbol("zod_brand"),
  mc = class extends He {
    _parse(e) {
      let { ctx: r } = this._processInputParams(e),
        n = r.data;
      return this._def.type._parse({ data: n, path: r.path, parent: r });
    }
    unwrap() {
      return this._def.type;
    }
  },
  hc = class t extends He {
    _parse(e) {
      let { status: r, ctx: n } = this._processInputParams(e);
      if (n.common.async)
        return (async () => {
          let a = await this._def.in._parseAsync({
            data: n.data,
            path: n.path,
            parent: n,
          });
          return a.status === "aborted"
            ? $e
            : a.status === "dirty"
              ? (r.dirty(), na(a.value))
              : this._def.out._parseAsync({
                  data: a.value,
                  path: n.path,
                  parent: n,
                });
        })();
      {
        let s = this._def.in._parseSync({
          data: n.data,
          path: n.path,
          parent: n,
        });
        return s.status === "aborted"
          ? $e
          : s.status === "dirty"
            ? (r.dirty(), { status: "dirty", value: s.value })
            : this._def.out._parseSync({
                data: s.value,
                path: n.path,
                parent: n,
              });
      }
    }
    static create(e, r) {
      return new t({ in: e, out: r, typeName: se.ZodPipeline });
    }
  },
  ya = class extends He {
    _parse(e) {
      let r = this._def.innerType._parse(e),
        n = (s) => (Cs(s) && (s.value = Object.freeze(s.value)), s);
      return Ci(r) ? r.then((s) => n(s)) : n(r);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
ya.create = (t, e) =>
  new ya({ innerType: t, typeName: se.ZodReadonly, ...Be(e) });
function jE(t, e) {
  let r =
    typeof t == "function" ? t(e) : typeof t == "string" ? { message: t } : t;
  return typeof r == "string" ? { message: r } : r;
}
function BE(t, e = {}, r) {
  return t
    ? ks.create().superRefine((n, s) => {
        let a = t(n);
        if (a instanceof Promise)
          return a.then((i) => {
            if (!i) {
              let o = jE(e, n),
                c = o.fatal ?? r ?? !0;
              s.addIssue({ code: "custom", ...o, fatal: c });
            }
          });
        if (!a) {
          let i = jE(e, n),
            o = i.fatal ?? r ?? !0;
          s.addIssue({ code: "custom", ...i, fatal: o });
        }
      })
    : ks.create();
}
var bZ = { object: Sr.lazycreate },
  se;
(function (t) {
  ((t.ZodString = "ZodString"),
    (t.ZodNumber = "ZodNumber"),
    (t.ZodNaN = "ZodNaN"),
    (t.ZodBigInt = "ZodBigInt"),
    (t.ZodBoolean = "ZodBoolean"),
    (t.ZodDate = "ZodDate"),
    (t.ZodSymbol = "ZodSymbol"),
    (t.ZodUndefined = "ZodUndefined"),
    (t.ZodNull = "ZodNull"),
    (t.ZodAny = "ZodAny"),
    (t.ZodUnknown = "ZodUnknown"),
    (t.ZodNever = "ZodNever"),
    (t.ZodVoid = "ZodVoid"),
    (t.ZodArray = "ZodArray"),
    (t.ZodObject = "ZodObject"),
    (t.ZodUnion = "ZodUnion"),
    (t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
    (t.ZodIntersection = "ZodIntersection"),
    (t.ZodTuple = "ZodTuple"),
    (t.ZodRecord = "ZodRecord"),
    (t.ZodMap = "ZodMap"),
    (t.ZodSet = "ZodSet"),
    (t.ZodFunction = "ZodFunction"),
    (t.ZodLazy = "ZodLazy"),
    (t.ZodLiteral = "ZodLiteral"),
    (t.ZodEnum = "ZodEnum"),
    (t.ZodEffects = "ZodEffects"),
    (t.ZodNativeEnum = "ZodNativeEnum"),
    (t.ZodOptional = "ZodOptional"),
    (t.ZodNullable = "ZodNullable"),
    (t.ZodDefault = "ZodDefault"),
    (t.ZodCatch = "ZodCatch"),
    (t.ZodPromise = "ZodPromise"),
    (t.ZodBranded = "ZodBranded"),
    (t.ZodPipeline = "ZodPipeline"),
    (t.ZodReadonly = "ZodReadonly"));
})(se || (se = {}));
var _Z = (t, e = { message: `Input not instance of ${t.name}` }) =>
    BE((r) => r instanceof t, e),
  HE = Ps.create,
  VE = sa.create,
  xZ = $i.create,
  wZ = aa.create,
  ZE = ia.create,
  SZ = oa.create,
  EZ = ki.create,
  TZ = ca.create,
  CZ = la.create,
  PZ = ks.create,
  kZ = es.create,
  RZ = mn.create,
  OZ = Ri.create,
  IZ = ts.create,
  $Z = Sr.create,
  AZ = Sr.strictCreate,
  NZ = ua.create,
  DZ = Su.create,
  LZ = da.create,
  MZ = On.create,
  jZ = Eu.create,
  FZ = Oi.create,
  UZ = Ii.create,
  qZ = Tu.create,
  zZ = pa.create,
  BZ = fa.create,
  HZ = ma.create,
  VZ = ha.create,
  ZZ = Rs.create,
  GZ = Xr.create,
  WZ = wr.create,
  KZ = In.create,
  JZ = Xr.createWithPreprocess,
  XZ = hc.create,
  YZ = () => HE().optional(),
  QZ = () => VE().optional(),
  eG = () => ZE().optional(),
  tG = {
    string: (t) => Ps.create({ ...t, coerce: !0 }),
    number: (t) => sa.create({ ...t, coerce: !0 }),
    boolean: (t) => ia.create({ ...t, coerce: !0 }),
    bigint: (t) => aa.create({ ...t, coerce: !0 }),
    date: (t) => oa.create({ ...t, coerce: !0 }),
  };
var rG = $e;
var ba = E;
var nG = ba.object({
  method: ba.literal("experiment_gates"),
  params: ba.object({ gates: ba.record(ba.string(), ba.boolean()) }),
});
function GE(t) {
  let e = $E({ name: "claude-vscode", version: "2.0.75", tools: [] });
  return (
    e.instance.server.setNotificationHandler(nG, async (r) => {
      let { gates: n } = r.params;
      t(n);
    }),
    e
  );
}
function WE(t, e, r) {
  t.instance.server.notification({
    method: "log_event",
    params: { eventName: e, eventData: r },
  });
}
var Cu = class {
  constructor(e, r, n, s, a, i, o) {
    this.cwd = e;
    this.logger = r;
    this.settings = n;
    this.openNewInTab = s;
    this.showTerminalBanner = a;
    this.experimentGates = i;
    this.authManager = o;
    this.readFromClient();
    try {
      Bn.load(this.cwd, this.logger);
    } catch (c) {
      this.logger.error(`Failed to load sessions at startup: ${c}`);
    }
  }
  channels = new Map();
  fromClientStream = new ei();
  abortControllers = new Map();
  config;
  showReviewUpsellBanner;
  showYearEndPromo;
  yearEndPromoViewCount = 0;
  outstandingRequests = new Map();
  async fromClient(e) {
    this.fromClientStream.enqueue(e);
  }
  async readFromClient() {
    for await (let e of this.fromClientStream)
      switch (e.type) {
        case "launch_claude":
          await this.launchClaude(
            e.channelId,
            e.resume,
            e.cwd,
            e.model,
            e.permissionMode,
            e.thinkingLevel,
          );
          break;
        case "close_channel":
          this.closeChannel(e.channelId, !1);
          break;
        case "interrupt_claude":
          this.interruptClaude(e.channelId);
          break;
        case "start_speech_to_text":
          await this.handleStartSpeechToText(e.channelId);
          break;
        case "stop_speech_to_text":
          this.handleStopSpeechToText(e.channelId);
          break;
        case "io_message":
          this.transportMessage(e.channelId, e.message, e.done);
          break;
        case "request":
          this.handleRequest(e);
          break;
        case "response":
          {
            let r = e.requestId,
              n = this.outstandingRequests.get(r);
            n
              ? e.response.type === "error"
                ? n.reject(new Error(e.response.error))
                : n.resolve(e.response)
              : this.logger.warn(
                  `No handler for response with requestId: ${r}`,
                );
          }
          break;
        case "cancel_request":
          this.handleCancellation(e.targetRequestId);
          break;
        default:
          this.logger.error(`Unknown message: ${e}`);
      }
  }
  async launchClaude(e, r, n, s, a, i) {
    if (
      (this.logger.log(`Launching Claude on channel: ${e}`),
      this.channels.has(e))
    )
      throw new Error(`Channel already exists: ${e}`);
    this.generateAndPushProactiveSuggestions(e);
    try {
      let o = new ei(),
        c = GE((y) => {
          this.onExperimentGatesUpdated(y);
        }),
        l = { "claude-vscode": c },
        u = new Set(await jl(process.pid)),
        d = this.spawnClaude(
          o,
          r,
          async (y, h, g) =>
            this.requestToolPermission(e, y, h, g.suggestions || []),
          s || null,
          n,
          a,
          this.settings.getAllowDangerouslySkipPermissions(),
          this.getMaxThinkingTokensForModel(i),
          l,
        ),
        p = (await jl(process.pid)).filter((y) => !u.has(y)),
        f;
      for (let y of p) {
        let h = await Jf(y);
        if (h.includes("cli.js") || h.includes("/claude")) {
          f = parseInt(y, 10);
          break;
        }
      }
      (f === void 0 && p.length > 0 && (f = parseInt(p[0], 10)),
        this.channels.set(e, {
          in: o,
          query: d,
          pid: f,
          vscodeMcpServer: c,
          mcpServers: {},
          chromeMcpState: { status: "disconnected" },
        }),
        this.logger.log(
          `Claude spawned on channel ${e} with PID: ${f ?? "unknown"}`,
        ),
        this.claudeLaunched(e),
        (async () => {
          try {
            for await (let y of d)
              (this.send({
                type: "io_message",
                channelId: e,
                message: y,
                done: !1,
              }),
                Hw(y));
            this.closeChannel(e, !0);
          } catch (y) {
            (this.closeChannel(e, !0, String(y)),
              this.logger.error(`Error from Claude (on channel ${e}): ${y}`));
          }
        })());
    } catch (o) {
      (this.closeChannel(e, !0, String(o)),
        this.logger.error(`Error spawning Claude (on channel ${e}): ${o}`));
    }
  }
  claudeLaunched(e) {}
  async requestToolPermission(e, r, n, s) {
    let a = this.channels.get(e),
      i = await this.sendRequest(e, {
        type: "tool_permission_request",
        toolName: r,
        inputs: n,
        suggestions: s,
      });
    return (Bw(r, i), i.result);
  }
  sendRequest(e, r) {
    let n = vs();
    return new Promise((s, a) => {
      (this.outstandingRequests.set(n, {
        resolve: (i) => {
          s(i);
        },
        reject: a,
      }),
        this.send({ type: "request", channelId: e, requestId: n, request: r }));
    }).finally(() => {
      this.outstandingRequests.delete(n);
    });
  }
  async interruptClaude(e) {
    let r = this.channels.get(e);
    if (!r) {
      this.logger.warn(`Channel not found: ${e}`);
      return;
    }
    try {
      (await r.query.interrupt(),
        this.logger.log(`Interrupted Claude for requestId: ${e}`));
    } catch (n) {
      this.logger.error(`Failed to interrupt Claude: ${n}`);
    }
  }
  logEvent(e, r, n) {
    let s = this.channels.get(e);
    if (!s) {
      this.logger.warn(`Channel not found for logEvent: ${e}`);
      return;
    }
    WE(s.vscodeMcpServer, r, n);
  }
  async handleStartSpeechToText(e) {
    throw new Error("Speech-to-text is not supported in this environment");
  }
  async handleStopSpeechToText(e) {
    throw new Error("Speech-to-text is not supported in this environment");
  }
  async closeChannel(e, r, n) {
    (this.logger.log(`Closing Claude on channel: ${e}`),
      r && this.send({ type: "close_channel", channelId: e, error: n }));
    let s = this.channels.get(e);
    if (s) {
      s.in.done();
      try {
        await s.query.return();
      } catch (a) {
        this.logger.warn(`Error cleaning up channel ${e}: ${a}`);
      }
      this.channels.delete(e);
    }
  }
  transportMessage(e, r, n) {
    let s = this.channels.get(e);
    if (!s) throw new Error(`Channel not found: ${e}`);
    (r.type === "user" && s.in.enqueue(r), n && s.in.done());
  }
  async shutdown() {
    (await this.closeAllChannels(), this.fromClientStream.done());
  }
  async closeAllChannels() {
    let e = Array.from(this.channels.keys()).map((r) =>
      this.closeChannel(r, !1),
    );
    (await Promise.all(e), this.channels.clear());
  }
  async closeAllChannelsWithCredentialChange() {
    let e = Array.from(this.channels.keys()).map((r) =>
      this.closeChannel(r, !0),
    );
    (await Promise.all(e), this.channels.clear());
  }
  loadConfig() {
    if (this.config) return this.config;
    this.logger.log("Loading config cache by launching Claude...");
    let e = (async () => {
      let r = new ei(),
        n = this.spawnClaude(
          r,
          void 0,
          async () => ({ behavior: "deny", message: "Config loading only" }),
          "default",
          this.cwd,
          "default",
          !1,
          0,
          void 0,
        );
      r.done();
      let s = {
        slashCommands: await n.supportedCommands(),
        models: await n.supportedModels(),
        accountInfo: await n.accountInfo(),
      };
      return (n.return(), s);
    })().catch((r) => {
      throw (
        this.logger.error(`Failed to load config cache: ${r}`),
        (this.config = void 0),
        r
      );
    });
    return ((this.config = e), e);
  }
  async getMcpServers(e) {
    let r = e ? this.channels.get(e) : void 0;
    if (!r) throw new Error(`Channel not found: ${e}`);
    try {
      return {
        type: "get_mcp_servers_response",
        mcpServers: (await r.query.mcpServerStatus()).filter(
          (s) => s.name !== "claude-vscode",
        ),
      };
    } catch (n) {
      return (
        this.logger.error(`Error fetching MCP servers: ${n}`),
        { type: "get_mcp_servers_response", mcpServers: [] }
      );
    }
  }
  async ensureChromeMcpEnabled(e) {
    throw new Error("Not supported");
  }
  async disableChromeMcp(e) {
    throw new Error("Not supported");
  }
  async createNewBrowserTab() {
    throw new Error("createNewBrowserTab must be implemented by subclass");
  }
  getChromeMcpServerConfig() {
    throw new Error("getChromeMcpServerConfig must be implemented by subclass");
  }
  async handleRequest(e) {
    let r = new AbortController();
    try {
      this.abortControllers.set(e.requestId, r);
      let n = await this.processRequest(e, r.signal);
      this.send({ type: "response", requestId: e.requestId, response: n });
    } catch (n) {
      (this.logger.error(`Error processing client request: ${n}`),
        this.send({
          type: "response",
          requestId: e.requestId,
          response: {
            type: "error",
            error: n instanceof Error ? n.message : String(n),
          },
        }));
    } finally {
      this.abortControllers.delete(e.requestId);
    }
  }
  async processRequest(e, r) {
    switch (e.request.type) {
      case "init": {
        let n = this.authManager?.getAuthStatus(),
          s = e.channelId ? this.channels.get(e.channelId) : void 0;
        return {
          type: "init_response",
          state: {
            defaultCwd: this.cwd,
            openNewInTab: this.openNewInTab,
            showTerminalBanner: this.showTerminalBanner,
            showReviewUpsellBanner: this.showReviewUpsellBanner || !1,
            showYearEndPromo: this.showYearEndPromo || !1,
            yearEndPromoViewCount: this.yearEndPromoViewCount,
            authStatus: n,
            modelSetting: this.settings.getModel(),
            thinkingLevel: this.settings.getThinkingLevel(),
            initialPermissionMode: this.settings.getInitialPermissionMode(),
            allowDangerouslySkipPermissions:
              this.settings.getAllowDangerouslySkipPermissions(),
            platform: this.getPlatform(),
            speechToTextEnabled: this.isSpeechToTextEnabled(),
            marketplaceType: this.getMarketplaceType(),
            useCtrlEnterToSend: this.settings.getUseCtrlEnterToSend(),
            chromeMcpState: s?.chromeMcpState ?? { status: "disconnected" },
            browserIntegrationSupported: this.isBrowserIntegrationSupported(),
          },
        };
      }
      case "get_claude_state":
        return {
          type: "get_claude_state_response",
          config: await this.loadConfig(),
        };
      case "get_mcp_servers":
        return await this.getMcpServers(e.channelId);
      case "ensure_chrome_mcp_enabled": {
        if (!e.channelId)
          throw new Error(
            "channelId is required for ensure_chrome_mcp_enabled",
          );
        return await this.ensureChromeMcpEnabled(e.channelId);
      }
      case "disable_chrome_mcp": {
        if (!e.channelId)
          throw new Error("channelId is required for disable_chrome_mcp");
        return await this.disableChromeMcp(e.channelId);
      }
      case "create_new_browser_tab":
        return await this.createNewBrowserTab();
      case "list_sessions_request":
        return this.listSessions();
      case "open_file":
        return (
          this.openFile(e.request.filePath, e.request.location),
          { type: "open_file_response" }
        );
      case "get_session_request":
        return this.getSession(e.request.sessionId);
      case "exec":
        return this.execCommand(e.request.command, e.request.params);
      case "list_files_request":
        return {
          type: "list_files_response",
          files: await this.findFiles(e.request.pattern),
        };
      case "get_terminal_contents":
        return {
          type: "get_terminal_contents_response",
          content: await this.getTerminalContents(e.request.terminalName),
        };
      case "open_diff":
        return this.openDiff(
          e.request.originalFilePath,
          e.request.newFilePath,
          e.request.edits,
          e.request.supportMultiEdits || !1,
          r,
        );
      case "open_content":
        return this.openContent(
          e.request.content,
          e.request.fileName,
          e.request.editable,
          r,
        );
      case "get_asset_uris":
        return { type: "asset_uris_response", assetUris: this.getAssetUris() };
      case "open_url":
        return (
          await this.openURL(e.request.url),
          { type: "open_url_response" }
        );
      case "set_permission_mode":
        return this.setPermissionMode(e.channelId, e.request.mode);
      case "set_model":
        return this.setModel(e.channelId, e.request.model);
      case "set_thinking_level":
        return this.setThinkingLevel(e.channelId, e.request.thinkingLevel);
      case "get_auth_status":
        return {
          type: "get_auth_status_response",
          status: this.authManager?.getAuthStatus(),
        };
      case "login": {
        if (!this.authManager)
          throw new Error(
            "Authentication is not supported in this environment",
          );
        let { method: n } = e.request,
          s = await this.authManager.login(n, async (a) => {
            this.send({
              type: "request",
              channelId: "",
              requestId: vs(),
              request: {
                type: "auth_url",
                url: a.manualRedirectUrl,
                method: n,
              },
            });
            try {
              await this.openURL(a.automaticRedirectUrl);
            } catch (i) {
              this.logger.warn(`Failed to open browser: ${i}`);
            }
          });
        return (
          await this.closeAllChannelsWithCredentialChange(),
          { type: "login_response", auth: s }
        );
      }
      case "submit_oauth_code": {
        if (!this.authManager)
          throw new Error(
            "Authentication is not supported in this environment",
          );
        let { code: n } = e.request;
        return (
          this.authManager.handleManualAuthCode(n),
          { type: "submit_oauth_code_response" }
        );
      }
      case "open_config_file":
        return (
          this.openConfigFile(e.request.configType),
          { type: "open_config_file_response" }
        );
      case "open_claude_in_terminal":
        return (
          await this.openClaudeInTerminal(
            e.request.prompt,
            e.request.args,
            e.request.location,
          ),
          { type: "open_claude_in_terminal_response" }
        );
      case "open_terminal":
        return (
          await this.openTerminal(
            e.request.executable,
            e.request.args,
            e.request.cwd,
            e.request.location,
            e.channelId,
          ),
          { type: "open_terminal_response" }
        );
      case "show_claude_terminal_setting":
        return (
          await this.showClaudeTerminalSetting(),
          { type: "show_claude_terminal_setting_response" }
        );
      case "dismiss_terminal_banner":
        return (
          await this.dismissTerminalBanner(),
          { type: "dismiss_terminal_banner_response" }
        );
      case "dismiss_review_upsell_banner":
        return (
          await this.dismissReviewUpsellBanner(e.request.metadata),
          { type: "dismiss_review_upsell_banner_response" }
        );
      case "dismiss_year_end_promo":
        return (
          await this.dismissYearEndPromo(),
          { type: "dismiss_year_end_promo_response" }
        );
      case "log_event": {
        let n = e.channelId || "";
        return (
          this.logEvent(n, e.request.eventName, e.request.eventData),
          { type: "log_event_response" }
        );
      }
      case "open_config":
        return (
          await this.openConfig(e.request.searchString),
          { type: "open_config_response" }
        );
      case "open_help":
        return (await this.openHelp(), { type: "open_help_response" });
      case "open_output_panel":
        return (
          await this.openOutputPanel(),
          { type: "open_output_panel_response" }
        );
      case "fork_conversation":
        return {
          type: "fork_conversation_response",
          sessionId: await (
            await Bn.load(this.cwd, this.logger)
          ).forkSession(e.request.forkedFromSession, e.request.resumeSessionAt),
        };
      case "rewind_code": {
        let n = e.channelId ? this.channels.get(e.channelId) : void 0;
        if (!n) throw new Error(`Channel not found: ${e.channelId}`);
        return (
          await n.query.rewindFiles(e.request.userMessageId),
          { type: "rewind_code_response" }
        );
      }
      default:
    }
    throw new Error("Unknown request type.");
  }
  async loadSessionsFromPath(e, r, n) {
    try {
      return (await (await Bn.load(e, this.logger)).fetchSessions())
        .filter((i) => !i.isSidechain)
        .map((i) => ({
          id: i.id,
          lastModified: i.lastModified,
          messageCount: i.messageCount,
          summary: i.summary,
          worktree: r,
          isCurrentWorkspace: n,
        }));
    } catch (s) {
      return (this.logger.warn(`Failed to load sessions from ${e}: ${s}`), []);
    }
  }
  async listSessions() {
    let e = [],
      r = await this.loadSessionsFromPath(this.cwd, void 0, !0);
    return (
      e.push(...r),
      zw(e),
      { type: "list_sessions_response", sessions: e }
    );
  }
  async getSession(e) {
    return {
      type: "get_session_response",
      messages: await (
        await Bn.load(this.cwd, this.logger)
      ).getSessionMessages(e),
    };
  }
  handleCancellation(e) {
    let r = this.abortControllers.get(e);
    r && r.abort();
  }
  async execCommand(e, r) {
    let n = "",
      s = "",
      a = (0, KE.spawn)(e, r, { cwd: this.cwd, shell: !1 });
    (a.stdout.on("data", (o) => {
      n += o.toString();
    }),
      a.stderr.on("data", (o) => {
        s += o.toString();
      }));
    let i = await new Promise((o) => {
      (a.on("close", (c) => {
        o(c ?? 0);
      }),
        a.on("error", (c) => {
          ((s += c.message), o(1));
        }));
    });
    return { type: "exec_response", stdout: n, stderr: s, exitCode: i };
  }
  async createSpeechToTextStream() {
    throw new Error("Speech-to-text is not supported in this environment");
  }
  isSpeechToTextEnabled() {
    return !1;
  }
  getAssetUris() {
    return Dw();
  }
  async setPermissionMode(e, r) {
    let n = e ? this.channels.get(e) : void 0;
    if (!n) throw new Error(`Channel not found: ${e}`);
    try {
      return (
        await n.query.setPermissionMode(r),
        { type: "set_permission_mode_response", success: !0 }
      );
    } catch (s) {
      return (
        this.logger.error(`Failed to set permission mode: ${s}`),
        { type: "set_permission_mode_response", success: !1 }
      );
    }
  }
  async setModel(e, r) {
    let n = e ? this.channels.get(e) : void 0;
    if (!n) throw new Error(`Channel not found: ${e}`);
    try {
      return (
        await n.query.setModel(r.value),
        await this.settings.setModel(r.value),
        { type: "set_model_response", success: !0 }
      );
    } catch (s) {
      return (
        this.logger.error(`Failed to set model: ${s}`),
        { type: "set_model_response", success: !1 }
      );
    }
  }
  async setThinkingLevel(e, r) {
    let n = e ? this.channels.get(e) : void 0;
    if (!n) throw new Error(`Channel not found: ${e}`);
    let s = this.getMaxThinkingTokensForModel(r);
    return (
      await n.query.setMaxThinkingTokens(s),
      await this.settings.setThinkingLevel(r),
      { type: "set_thinking_level_response" }
    );
  }
  getPlatform() {
    switch (process.platform) {
      case "win32":
        return "windows";
      case "darwin":
        return "macos";
      default:
        return "linux";
    }
  }
  isBrowserIntegrationSupported() {
    return !1;
  }
  async pushStateUpdate() {
    this.config = void 0;
    let e = await this.loadConfig(),
      r = {
        type: "request",
        channelId: "",
        requestId: vs(),
        request: {
          type: "update_state",
          state: this.getCurrentState(),
          config: e,
        },
      };
    this.send(r);
  }
  getCurrentState() {
    let e = this.authManager?.getAuthStatus();
    return {
      defaultCwd: this.cwd,
      openNewInTab: this.openNewInTab,
      showTerminalBanner: this.showTerminalBanner,
      showReviewUpsellBanner: this.showReviewUpsellBanner ?? !1,
      showYearEndPromo: this.showYearEndPromo ?? !1,
      yearEndPromoViewCount: this.yearEndPromoViewCount,
      authStatus: e,
      modelSetting: this.settings.getModel(),
      thinkingLevel: this.settings.getThinkingLevel(),
      allowDangerouslySkipPermissions:
        this.settings.getAllowDangerouslySkipPermissions(),
      initialPermissionMode: this.settings.getInitialPermissionMode(),
      platform: this.getPlatform(),
      speechToTextEnabled: this.isSpeechToTextEnabled(),
      marketplaceType: this.getMarketplaceType(),
      useCtrlEnterToSend: this.settings.getUseCtrlEnterToSend(),
      chromeMcpState: { status: "disconnected" },
      browserIntegrationSupported: this.isBrowserIntegrationSupported(),
    };
  }
  async pushChannelStateUpdate(e) {
    let r = this.channels.get(e);
    if (!r) return;
    let n = await this.loadConfig(),
      s = this.getCurrentState();
    s.chromeMcpState = r.chromeMcpState;
    let a = {
      type: "request",
      channelId: e,
      requestId: vs(),
      request: { type: "update_state", state: s, config: n },
    };
    this.send(a);
  }
  async generateAndPushProactiveSuggestions(e) {
    if (process.env.CLAUDE_PROACTIVE_SUGGESTIONS === "true")
      try {
        let {
            pathToClaudeCodeExecutable: r,
            executableArgs: n,
            env: s,
          } = this.getClaudeBinary(),
          a = await DE({
            cwd: this.cwd,
            logger: this.logger,
            pathToClaudeCodeExecutable: r,
            executableArgs: n,
            env: s,
          });
        if (a.suggestions.length > 0) {
          let i = {
            type: "request",
            channelId: e,
            requestId: vs(),
            request: {
              type: "proactive_suggestions_update",
              suggestions: a.suggestions,
            },
          };
          this.send(i);
        }
      } catch (r) {
        this.logger.warn(`Failed to generate proactive suggestions: ${r}`);
      }
  }
  getClaudeBinary() {
    return { pathToClaudeCodeExecutable: "", executableArgs: [], env: {} };
  }
  getMaxThinkingTokensForModel(e) {
    return e === "off" ? 0 : 31999;
  }
};
var he = le(require("vscode"), 1);
var Mr = le(require("vscode"), 1),
  ji = require("fs"),
  kT = require("os"),
  Sh = require("path"),
  RT = require("child_process");
var aG =
    typeof global == "object" && global && global.Object === Object && global,
  JE = aG;
var iG = typeof self == "object" && self && self.Object === Object && self,
  oG = JE || iG || Function("return this")(),
  Ai = oG;
var cG = Ai.Symbol,
  Ni = cG;
var XE = Object.prototype,
  lG = XE.hasOwnProperty,
  uG = XE.toString,
  gc = Ni ? Ni.toStringTag : void 0;
function dG(t) {
  var e = lG.call(t, gc),
    r = t[gc];
  try {
    t[gc] = void 0;
    var n = !0;
  } catch {}
  var s = uG.call(t);
  return (n && (e ? (t[gc] = r) : delete t[gc]), s);
}
var YE = dG;
var pG = Object.prototype,
  fG = pG.toString;
function mG(t) {
  return fG.call(t);
}
var QE = mG;
var hG = "[object Null]",
  gG = "[object Undefined]",
  eT = Ni ? Ni.toStringTag : void 0;
function vG(t) {
  return t == null
    ? t === void 0
      ? gG
      : hG
    : eT && eT in Object(t)
      ? YE(t)
      : QE(t);
}
var tT = vG;
function yG(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var Pu = yG;
var bG = "[object AsyncFunction]",
  _G = "[object Function]",
  xG = "[object GeneratorFunction]",
  wG = "[object Proxy]";
function SG(t) {
  if (!Pu(t)) return !1;
  var e = tT(t);
  return e == _G || e == xG || e == bG || e == wG;
}
var rT = SG;
var EG = Ai["__core-js_shared__"],
  ku = EG;
var nT = (function () {
  var t = /[^.]+$/.exec((ku && ku.keys && ku.keys.IE_PROTO) || "");
  return t ? "Symbol(src)_1." + t : "";
})();
function TG(t) {
  return !!nT && nT in t;
}
var sT = TG;
var CG = Function.prototype,
  PG = CG.toString;
function kG(t) {
  if (t != null) {
    try {
      return PG.call(t);
    } catch {}
    try {
      return t + "";
    } catch {}
  }
  return "";
}
var aT = kG;
var RG = /[\\^$.*+?()[\]{}|]/g,
  OG = /^\[object .+?Constructor\]$/,
  IG = Function.prototype,
  $G = Object.prototype,
  AG = IG.toString,
  NG = $G.hasOwnProperty,
  DG = RegExp(
    "^" +
      AG.call(NG)
        .replace(RG, "\\$&")
        .replace(
          /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
          "$1.*?",
        ) +
      "$",
  );
function LG(t) {
  if (!Pu(t) || sT(t)) return !1;
  var e = rT(t) ? DG : OG;
  return e.test(aT(t));
}
var iT = LG;
function MG(t, e) {
  return t?.[e];
}
var oT = MG;
function jG(t, e) {
  var r = oT(t, e);
  return iT(r) ? r : void 0;
}
var Ru = jG;
function FG(t, e) {
  return t === e || (t !== t && e !== e);
}
var cT = FG;
var UG = Ru(Object, "create"),
  rs = UG;
function qG() {
  ((this.__data__ = rs ? rs(null) : {}), (this.size = 0));
}
var lT = qG;
function zG(t) {
  var e = this.has(t) && delete this.__data__[t];
  return ((this.size -= e ? 1 : 0), e);
}
var uT = zG;
var BG = "__lodash_hash_undefined__",
  HG = Object.prototype,
  VG = HG.hasOwnProperty;
function ZG(t) {
  var e = this.__data__;
  if (rs) {
    var r = e[t];
    return r === BG ? void 0 : r;
  }
  return VG.call(e, t) ? e[t] : void 0;
}
var dT = ZG;
var GG = Object.prototype,
  WG = GG.hasOwnProperty;
function KG(t) {
  var e = this.__data__;
  return rs ? e[t] !== void 0 : WG.call(e, t);
}
var pT = KG;
var JG = "__lodash_hash_undefined__";
function XG(t, e) {
  var r = this.__data__;
  return (
    (this.size += this.has(t) ? 0 : 1),
    (r[t] = rs && e === void 0 ? JG : e),
    this
  );
}
var fT = XG;
function Di(t) {
  var e = -1,
    r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
Di.prototype.clear = lT;
Di.prototype.delete = uT;
Di.prototype.get = dT;
Di.prototype.has = pT;
Di.prototype.set = fT;
var _h = Di;
function YG() {
  ((this.__data__ = []), (this.size = 0));
}
var mT = YG;
function QG(t, e) {
  for (var r = t.length; r--; ) if (cT(t[r][0], e)) return r;
  return -1;
}
var Os = QG;
var e6 = Array.prototype,
  t6 = e6.splice;
function r6(t) {
  var e = this.__data__,
    r = Os(e, t);
  if (r < 0) return !1;
  var n = e.length - 1;
  return (r == n ? e.pop() : t6.call(e, r, 1), --this.size, !0);
}
var hT = r6;
function n6(t) {
  var e = this.__data__,
    r = Os(e, t);
  return r < 0 ? void 0 : e[r][1];
}
var gT = n6;
function s6(t) {
  return Os(this.__data__, t) > -1;
}
var vT = s6;
function a6(t, e) {
  var r = this.__data__,
    n = Os(r, t);
  return (n < 0 ? (++this.size, r.push([t, e])) : (r[n][1] = e), this);
}
var yT = a6;
function Li(t) {
  var e = -1,
    r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
Li.prototype.clear = mT;
Li.prototype.delete = hT;
Li.prototype.get = gT;
Li.prototype.has = vT;
Li.prototype.set = yT;
var bT = Li;
var i6 = Ru(Ai, "Map"),
  _T = i6;
function o6() {
  ((this.size = 0),
    (this.__data__ = {
      hash: new _h(),
      map: new (_T || bT)(),
      string: new _h(),
    }));
}
var xT = o6;
function c6(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean"
    ? t !== "__proto__"
    : t === null;
}
var wT = c6;
function l6(t, e) {
  var r = t.__data__;
  return wT(e) ? r[typeof e == "string" ? "string" : "hash"] : r.map;
}
var Is = l6;
function u6(t) {
  var e = Is(this, t).delete(t);
  return ((this.size -= e ? 1 : 0), e);
}
var ST = u6;
function d6(t) {
  return Is(this, t).get(t);
}
var ET = d6;
function p6(t) {
  return Is(this, t).has(t);
}
var TT = p6;
function f6(t, e) {
  var r = Is(this, t),
    n = r.size;
  return (r.set(t, e), (this.size += r.size == n ? 0 : 1), this);
}
var CT = f6;
function Mi(t) {
  var e = -1,
    r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
Mi.prototype.clear = xT;
Mi.prototype.delete = ST;
Mi.prototype.get = ET;
Mi.prototype.has = TT;
Mi.prototype.set = CT;
var xh = Mi;
var m6 = "Expected a function";
function wh(t, e) {
  if (typeof t != "function" || (e != null && typeof e != "function"))
    throw new TypeError(m6);
  var r = function () {
    var n = arguments,
      s = e ? e.apply(this, n) : n[0],
      a = r.cache;
    if (a.has(s)) return a.get(s);
    var i = t.apply(this, n);
    return ((r.cache = a.set(s, i) || a), i);
  };
  return ((r.cache = new (wh.Cache || xh)()), r);
}
wh.Cache = xh;
var Yr = wh;
var hn = le(require("vscode"), 1),
  Ou = class {
    constructor(e) {
      this.context = e;
    }
    getModel() {
      let e = mr("selectedModel");
      return e || "default";
    }
    async setModel(e) {
      await hn.workspace
        .getConfiguration("claudeCode")
        .update("selectedModel", e, hn.ConfigurationTarget.Global);
    }
    getThinkingLevel() {
      let e = this.context.globalState.get("thinkingLevel");
      return e || "off";
    }
    async setThinkingLevel(e) {
      this.context.globalState.update("thinkingLevel", e);
    }
    getInitialPermissionMode() {
      let r = mr("initialPermissionMode") || "default";
      return r === "bypassPermissions" &&
        !this.getAllowDangerouslySkipPermissions()
        ? "default"
        : r;
    }
    getAllowDangerouslySkipPermissions() {
      return mr("allowDangerouslySkipPermissions") || !1;
    }
    getUseCtrlEnterToSend() {
      return mr("useCtrlEnterToSend") || !1;
    }
    getPreferredLocation() {
      return mr("preferredLocation") === "sidebar" ? "sidebar" : "panel";
    }
    async setPreferredLocation(e) {
      await hn.workspace
        .getConfiguration("claudeCode")
        .update("preferredLocation", e, hn.ConfigurationTarget.Global);
    }
    migrateAllSettings() {
      (this.migrateOldConfigSettings(), this.migrateLastClaudeLocation());
    }
    migrateOldConfigSettings() {
      if (this.context.globalState.get("settingsMigrated20251024")) return;
      let e = hn.workspace.getConfiguration("claude-code"),
        r = hn.workspace.getConfiguration("claudeCode"),
        n = [
          "selectedModel",
          "environmentVariables",
          "useTerminal",
          "allowDangerouslySkipPermissions",
          "claudeProcessWrapper",
          "respectGitIgnore",
        ];
      for (let s of n) {
        let a = e.get(s);
        a !== void 0 &&
          (r.update(s, a, hn.ConfigurationTarget.Global),
          e.update(s, void 0, hn.ConfigurationTarget.Global));
      }
      this.context.globalState.update("settingsMigrated20251024", !0);
    }
    migrateLastClaudeLocation() {
      if (this.context.globalState.get("lastClaudeLocationMigrated")) return;
      let e = this.context.globalState.get("lastClaudeLocation");
      if (e !== void 0) {
        let r = e === 0 ? "sidebar" : "panel";
        this.setPreferredLocation(r);
      }
      this.context.globalState.update("lastClaudeLocationMigrated", !0);
    }
  };
function mr(t) {
  return hn.workspace.getConfiguration("claudeCode").get(t);
}
function h6(t) {
  let e = t.trim();
  return e
    ? /[*?{}[\]]/.test(e)
      ? e
      : `**/*${e
          .split("")
          .map((n) => {
            if (/[a-zA-Z]/.test(n)) {
              let s = n.toLowerCase(),
                a = n.toUpperCase();
              return `[${s}${a}]`;
            }
            return n;
          })
          .join("")}*`
    : "**/*";
}
var OT = `{${["**/node_modules/**", "**/.git/**", "**/dist/**", "**/build/**", "**/.next/**", "**/.nuxt/**", "**/.DS_Store", "**/Thumbs.db", "**/*.log", "**/.env", "**/.env.*", "**/yarn-error.log", "**/npm-debug.log*"].join(",")}}`;
async function Eh(t) {
  let e = [],
    r = t ? h6(t) : "**/*",
    n = await IT(),
    s = 100,
    a;
  try {
    a = await Mr.workspace.findFiles(r, n, s);
  } catch {
    a = await Mr.workspace.findFiles(r, OT, s);
  }
  try {
    for (let i of a) {
      let o = Mr.workspace.asRelativePath(i),
        c = i.path.split("/").pop() || "";
      e.push({ path: o, name: c, type: "file" });
    }
    e.sort((i, o) => i.path.localeCompare(o.path));
  } catch {}
  return e;
}
async function IT() {
  let t = [];
  try {
    let n = Mr.workspace.getConfiguration("search"),
      s = Mr.workspace.getConfiguration("files"),
      a = n.get("exclude") || {},
      i = s.get("exclude") || {};
    for (let [l, u] of Object.entries(a))
      u && typeof l == "string" && t.push(l);
    for (let [l, u] of Object.entries(i))
      u && typeof l == "string" && t.push(l);
    let o = n.get("useIgnoreFiles", !0),
      c = mr("respectGitIgnore") ?? !0;
    if (o && c) {
      let l = Mr.workspace.workspaceFolders;
      if (l)
        for (let u of l) {
          let d = g6(u.uri.fsPath);
          t.push(...d);
        }
    }
  } catch {}
  let e = t.filter((n) => typeof n == "string" && n.length > 0);
  return e.length === 0 ? OT : e.length === 1 ? e[0] : `{${e.join(",")}}`;
}
function g6(t) {
  let e = [];
  try {
    let r = (0, Sh.join)(t, ".gitignore");
    if ((0, ji.existsSync)(r)) {
      let s = (0, ji.readFileSync)(r, "utf8");
      e.push(...PT(s));
    }
    let n = (0, Sh.join)((0, kT.homedir)(), ".config", "git", "ignore");
    if ((0, ji.existsSync)(n)) {
      let s = (0, ji.readFileSync)(n, "utf8");
      e.push(...PT(s));
    }
  } catch {}
  return e;
}
function PT(t) {
  let e = [];
  for (let r of t.split(`
`)) {
    let n = r.trim();
    if (!n || n.startsWith("#") || n.startsWith("!")) continue;
    let s = n;
    (s.endsWith("/") && (s = s.slice(0, -1) + "/**"),
      s.startsWith("/") ? (s = s.slice(1)) : (s = "**/" + s),
      e.includes(s) || e.push(s));
  }
  return e;
}
async function v6(t) {
  if (t.scheme === "comment" || t.scheme === "output") return !0;
  try {
    let e = Mr.workspace.getWorkspaceFolder(t);
    if (!e) return !1;
    let r = Mr.workspace.asRelativePath(t, !1),
      n = await IT();
    if (
      (await Mr.workspace.findFiles(new Mr.RelativePattern(e, r), n, 1))
        .length === 0
    )
      return !0;
    let a = mr("respectGitIgnore") ?? !0;
    return !!(
      Mr.workspace.getConfiguration("search").get("useIgnoreFiles", !0) &&
      a &&
      (await new Promise((l) => {
        (0, RT.execFile)(
          "git",
          ["check-ignore", t.fsPath],
          { cwd: e.uri.fsPath },
          (u, d) => {
            l(!u && !!d);
          },
        );
      }))
    );
  } catch {
    return !1;
  }
}
var Iu = Yr(v6, (t) => t.fsPath);
var qh = le(require("vscode"), 1),
  Bt = le(require("path"), 1);
function ns(t) {
  return Array.isArray ? Array.isArray(t) : FT(t) === "[object Array]";
}
var y6 = 1 / 0;
function b6(t) {
  if (typeof t == "string") return t;
  let e = t + "";
  return e == "0" && 1 / t == -y6 ? "-0" : e;
}
function _6(t) {
  return t == null ? "" : b6(t);
}
function $n(t) {
  return typeof t == "string";
}
function MT(t) {
  return typeof t == "number";
}
function x6(t) {
  return t === !0 || t === !1 || (w6(t) && FT(t) == "[object Boolean]");
}
function jT(t) {
  return typeof t == "object";
}
function w6(t) {
  return jT(t) && t !== null;
}
function jr(t) {
  return t != null;
}
function Th(t) {
  return !t.trim().length;
}
function FT(t) {
  return t == null
    ? t === void 0
      ? "[object Undefined]"
      : "[object Null]"
    : Object.prototype.toString.call(t);
}
var S6 = "Incorrect 'index' type",
  E6 = (t) => `Invalid value for key ${t}`,
  T6 = (t) => `Pattern length exceeds max of ${t}.`,
  C6 = (t) => `Missing ${t} property in key`,
  P6 = (t) => `Property 'weight' in key '${t}' must be a positive integer`,
  $T = Object.prototype.hasOwnProperty,
  Ch = class {
    constructor(e) {
      ((this._keys = []), (this._keyMap = {}));
      let r = 0;
      (e.forEach((n) => {
        let s = UT(n);
        (this._keys.push(s), (this._keyMap[s.id] = s), (r += s.weight));
      }),
        this._keys.forEach((n) => {
          n.weight /= r;
        }));
    }
    get(e) {
      return this._keyMap[e];
    }
    keys() {
      return this._keys;
    }
    toJSON() {
      return JSON.stringify(this._keys);
    }
  };
function UT(t) {
  let e = null,
    r = null,
    n = null,
    s = 1,
    a = null;
  if ($n(t) || ns(t)) ((n = t), (e = AT(t)), (r = Ph(t)));
  else {
    if (!$T.call(t, "name")) throw new Error(C6("name"));
    let i = t.name;
    if (((n = i), $T.call(t, "weight") && ((s = t.weight), s <= 0)))
      throw new Error(P6(i));
    ((e = AT(i)), (r = Ph(i)), (a = t.getFn));
  }
  return { path: e, id: r, weight: s, src: n, getFn: a };
}
function AT(t) {
  return ns(t) ? t : t.split(".");
}
function Ph(t) {
  return ns(t) ? t.join(".") : t;
}
function k6(t, e) {
  let r = [],
    n = !1,
    s = (a, i, o) => {
      if (jr(a))
        if (!i[o]) r.push(a);
        else {
          let c = i[o],
            l = a[c];
          if (!jr(l)) return;
          if (o === i.length - 1 && ($n(l) || MT(l) || x6(l))) r.push(_6(l));
          else if (ns(l)) {
            n = !0;
            for (let u = 0, d = l.length; u < d; u += 1) s(l[u], i, o + 1);
          } else i.length && s(l, i, o + 1);
        }
    };
  return (s(t, $n(e) ? e.split(".") : e, 0), n ? r : r[0]);
}
var R6 = { includeMatches: !1, findAllMatches: !1, minMatchCharLength: 1 },
  O6 = {
    isCaseSensitive: !1,
    includeScore: !1,
    keys: [],
    shouldSort: !0,
    sortFn: (t, e) =>
      t.score === e.score
        ? t.idx < e.idx
          ? -1
          : 1
        : t.score < e.score
          ? -1
          : 1,
  },
  I6 = { location: 0, threshold: 0.6, distance: 100 },
  $6 = {
    useExtendedSearch: !1,
    getFn: k6,
    ignoreLocation: !1,
    ignoreFieldNorm: !1,
    fieldNormWeight: 1,
  },
  Ue = { ...O6, ...R6, ...I6, ...$6 },
  A6 = /[^ ]+/g;
function N6(t = 1, e = 3) {
  let r = new Map(),
    n = Math.pow(10, e);
  return {
    get(s) {
      let a = s.match(A6).length;
      if (r.has(a)) return r.get(a);
      let i = 1 / Math.pow(a, 0.5 * t),
        o = parseFloat(Math.round(i * n) / n);
      return (r.set(a, o), o);
    },
    clear() {
      r.clear();
    },
  };
}
var vc = class {
  constructor({
    getFn: e = Ue.getFn,
    fieldNormWeight: r = Ue.fieldNormWeight,
  } = {}) {
    ((this.norm = N6(r, 3)),
      (this.getFn = e),
      (this.isCreated = !1),
      this.setIndexRecords());
  }
  setSources(e = []) {
    this.docs = e;
  }
  setIndexRecords(e = []) {
    this.records = e;
  }
  setKeys(e = []) {
    ((this.keys = e),
      (this._keysMap = {}),
      e.forEach((r, n) => {
        this._keysMap[r.id] = n;
      }));
  }
  create() {
    this.isCreated ||
      !this.docs.length ||
      ((this.isCreated = !0),
      $n(this.docs[0])
        ? this.docs.forEach((e, r) => {
            this._addString(e, r);
          })
        : this.docs.forEach((e, r) => {
            this._addObject(e, r);
          }),
      this.norm.clear());
  }
  add(e) {
    let r = this.size();
    $n(e) ? this._addString(e, r) : this._addObject(e, r);
  }
  removeAt(e) {
    this.records.splice(e, 1);
    for (let r = e, n = this.size(); r < n; r += 1) this.records[r].i -= 1;
  }
  getValueForItemAtKeyId(e, r) {
    return e[this._keysMap[r]];
  }
  size() {
    return this.records.length;
  }
  _addString(e, r) {
    if (!jr(e) || Th(e)) return;
    let n = { v: e, i: r, n: this.norm.get(e) };
    this.records.push(n);
  }
  _addObject(e, r) {
    let n = { i: r, $: {} };
    (this.keys.forEach((s, a) => {
      let i = s.getFn ? s.getFn(e) : this.getFn(e, s.path);
      if (jr(i)) {
        if (ns(i)) {
          let o = [],
            c = [{ nestedArrIndex: -1, value: i }];
          for (; c.length; ) {
            let { nestedArrIndex: l, value: u } = c.pop();
            if (jr(u))
              if ($n(u) && !Th(u)) {
                let d = { v: u, i: l, n: this.norm.get(u) };
                o.push(d);
              } else
                ns(u) &&
                  u.forEach((d, m) => {
                    c.push({ nestedArrIndex: m, value: d });
                  });
          }
          n.$[a] = o;
        } else if ($n(i) && !Th(i)) {
          let o = { v: i, n: this.norm.get(i) };
          n.$[a] = o;
        }
      }
    }),
      this.records.push(n));
  }
  toJSON() {
    return { keys: this.keys, records: this.records };
  }
};
function qT(
  t,
  e,
  { getFn: r = Ue.getFn, fieldNormWeight: n = Ue.fieldNormWeight } = {},
) {
  let s = new vc({ getFn: r, fieldNormWeight: n });
  return (s.setKeys(t.map(UT)), s.setSources(e), s.create(), s);
}
function D6(
  t,
  { getFn: e = Ue.getFn, fieldNormWeight: r = Ue.fieldNormWeight } = {},
) {
  let { keys: n, records: s } = t,
    a = new vc({ getFn: e, fieldNormWeight: r });
  return (a.setKeys(n), a.setIndexRecords(s), a);
}
function $u(
  t,
  {
    errors: e = 0,
    currentLocation: r = 0,
    expectedLocation: n = 0,
    distance: s = Ue.distance,
    ignoreLocation: a = Ue.ignoreLocation,
  } = {},
) {
  let i = e / t.length;
  if (a) return i;
  let o = Math.abs(n - r);
  return s ? i + o / s : o ? 1 : i;
}
function L6(t = [], e = Ue.minMatchCharLength) {
  let r = [],
    n = -1,
    s = -1,
    a = 0;
  for (let i = t.length; a < i; a += 1) {
    let o = t[a];
    o && n === -1
      ? (n = a)
      : !o &&
        n !== -1 &&
        ((s = a - 1), s - n + 1 >= e && r.push([n, s]), (n = -1));
  }
  return (t[a - 1] && a - n >= e && r.push([n, a - 1]), r);
}
var _a = 32;
function M6(
  t,
  e,
  r,
  {
    location: n = Ue.location,
    distance: s = Ue.distance,
    threshold: a = Ue.threshold,
    findAllMatches: i = Ue.findAllMatches,
    minMatchCharLength: o = Ue.minMatchCharLength,
    includeMatches: c = Ue.includeMatches,
    ignoreLocation: l = Ue.ignoreLocation,
  } = {},
) {
  if (e.length > _a) throw new Error(T6(_a));
  let u = e.length,
    d = t.length,
    m = Math.max(0, Math.min(n, d)),
    p = a,
    f = m,
    y = o > 1 || c,
    h = y ? Array(d) : [],
    g;
  for (; (g = t.indexOf(e, f)) > -1; ) {
    let S = $u(e, {
      currentLocation: g,
      expectedLocation: m,
      distance: s,
      ignoreLocation: l,
    });
    if (((p = Math.min(S, p)), (f = g + u), y)) {
      let C = 0;
      for (; C < u; ) ((h[g + C] = 1), (C += 1));
    }
  }
  f = -1;
  let _ = [],
    v = 1,
    b = u + d,
    x = 1 << (u - 1);
  for (let S = 0; S < u; S += 1) {
    let C = 0,
      P = b;
    for (; C < P; )
      ($u(e, {
        errors: S,
        currentLocation: m + P,
        expectedLocation: m,
        distance: s,
        ignoreLocation: l,
      }) <= p
        ? (C = P)
        : (b = P),
        (P = Math.floor((b - C) / 2 + C)));
    b = P;
    let A = Math.max(1, m - P + 1),
      R = i ? d : Math.min(m + P, d) + u,
      D = Array(R + 2);
    D[R + 1] = (1 << S) - 1;
    for (let I = R; I >= A; I -= 1) {
      let K = I - 1,
        ee = r[t.charAt(K)];
      if (
        (y && (h[K] = +!!ee),
        (D[I] = ((D[I + 1] << 1) | 1) & ee),
        S && (D[I] |= ((_[I + 1] | _[I]) << 1) | 1 | _[I + 1]),
        D[I] & x &&
          ((v = $u(e, {
            errors: S,
            currentLocation: K,
            expectedLocation: m,
            distance: s,
            ignoreLocation: l,
          })),
          v <= p))
      ) {
        if (((p = v), (f = K), f <= m)) break;
        A = Math.max(1, 2 * m - f);
      }
    }
    if (
      $u(e, {
        errors: S + 1,
        currentLocation: m,
        expectedLocation: m,
        distance: s,
        ignoreLocation: l,
      }) > p
    )
      break;
    _ = D;
  }
  let w = { isMatch: f >= 0, score: Math.max(0.001, v) };
  if (y) {
    let S = L6(h, o);
    S.length ? c && (w.indices = S) : (w.isMatch = !1);
  }
  return w;
}
function j6(t) {
  let e = {};
  for (let r = 0, n = t.length; r < n; r += 1) {
    let s = t.charAt(r);
    e[s] = (e[s] || 0) | (1 << (n - r - 1));
  }
  return e;
}
var Au = class {
    constructor(
      e,
      {
        location: r = Ue.location,
        threshold: n = Ue.threshold,
        distance: s = Ue.distance,
        includeMatches: a = Ue.includeMatches,
        findAllMatches: i = Ue.findAllMatches,
        minMatchCharLength: o = Ue.minMatchCharLength,
        isCaseSensitive: c = Ue.isCaseSensitive,
        ignoreLocation: l = Ue.ignoreLocation,
      } = {},
    ) {
      if (
        ((this.options = {
          location: r,
          threshold: n,
          distance: s,
          includeMatches: a,
          findAllMatches: i,
          minMatchCharLength: o,
          isCaseSensitive: c,
          ignoreLocation: l,
        }),
        (this.pattern = c ? e : e.toLowerCase()),
        (this.chunks = []),
        !this.pattern.length)
      )
        return;
      let u = (m, p) => {
          this.chunks.push({ pattern: m, alphabet: j6(m), startIndex: p });
        },
        d = this.pattern.length;
      if (d > _a) {
        let m = 0,
          p = d % _a,
          f = d - p;
        for (; m < f; ) (u(this.pattern.substr(m, _a), m), (m += _a));
        if (p) {
          let y = d - _a;
          u(this.pattern.substr(y), y);
        }
      } else u(this.pattern, 0);
    }
    searchIn(e) {
      let { isCaseSensitive: r, includeMatches: n } = this.options;
      if ((r || (e = e.toLowerCase()), this.pattern === e)) {
        let f = { isMatch: !0, score: 0 };
        return (n && (f.indices = [[0, e.length - 1]]), f);
      }
      let {
          location: s,
          distance: a,
          threshold: i,
          findAllMatches: o,
          minMatchCharLength: c,
          ignoreLocation: l,
        } = this.options,
        u = [],
        d = 0,
        m = !1;
      this.chunks.forEach(({ pattern: f, alphabet: y, startIndex: h }) => {
        let {
          isMatch: g,
          score: _,
          indices: v,
        } = M6(e, f, y, {
          location: s + h,
          distance: a,
          threshold: i,
          findAllMatches: o,
          minMatchCharLength: c,
          includeMatches: n,
          ignoreLocation: l,
        });
        (g && (m = !0), (d += _), g && v && (u = [...u, ...v]));
      });
      let p = { isMatch: m, score: m ? d / this.chunks.length : 1 };
      return (m && n && (p.indices = u), p);
    }
  },
  An = class {
    constructor(e) {
      this.pattern = e;
    }
    static isMultiMatch(e) {
      return NT(e, this.multiRegex);
    }
    static isSingleMatch(e) {
      return NT(e, this.singleRegex);
    }
    search() {}
  };
function NT(t, e) {
  let r = t.match(e);
  return r ? r[1] : null;
}
var kh = class extends An {
    constructor(e) {
      super(e);
    }
    static get type() {
      return "exact";
    }
    static get multiRegex() {
      return /^="(.*)"$/;
    }
    static get singleRegex() {
      return /^=(.*)$/;
    }
    search(e) {
      let r = e === this.pattern;
      return {
        isMatch: r,
        score: r ? 0 : 1,
        indices: [0, this.pattern.length - 1],
      };
    }
  },
  Rh = class extends An {
    constructor(e) {
      super(e);
    }
    static get type() {
      return "inverse-exact";
    }
    static get multiRegex() {
      return /^!"(.*)"$/;
    }
    static get singleRegex() {
      return /^!(.*)$/;
    }
    search(e) {
      let n = e.indexOf(this.pattern) === -1;
      return { isMatch: n, score: n ? 0 : 1, indices: [0, e.length - 1] };
    }
  },
  Oh = class extends An {
    constructor(e) {
      super(e);
    }
    static get type() {
      return "prefix-exact";
    }
    static get multiRegex() {
      return /^\^"(.*)"$/;
    }
    static get singleRegex() {
      return /^\^(.*)$/;
    }
    search(e) {
      let r = e.startsWith(this.pattern);
      return {
        isMatch: r,
        score: r ? 0 : 1,
        indices: [0, this.pattern.length - 1],
      };
    }
  },
  Ih = class extends An {
    constructor(e) {
      super(e);
    }
    static get type() {
      return "inverse-prefix-exact";
    }
    static get multiRegex() {
      return /^!\^"(.*)"$/;
    }
    static get singleRegex() {
      return /^!\^(.*)$/;
    }
    search(e) {
      let r = !e.startsWith(this.pattern);
      return { isMatch: r, score: r ? 0 : 1, indices: [0, e.length - 1] };
    }
  },
  $h = class extends An {
    constructor(e) {
      super(e);
    }
    static get type() {
      return "suffix-exact";
    }
    static get multiRegex() {
      return /^"(.*)"\$$/;
    }
    static get singleRegex() {
      return /^(.*)\$$/;
    }
    search(e) {
      let r = e.endsWith(this.pattern);
      return {
        isMatch: r,
        score: r ? 0 : 1,
        indices: [e.length - this.pattern.length, e.length - 1],
      };
    }
  },
  Ah = class extends An {
    constructor(e) {
      super(e);
    }
    static get type() {
      return "inverse-suffix-exact";
    }
    static get multiRegex() {
      return /^!"(.*)"\$$/;
    }
    static get singleRegex() {
      return /^!(.*)\$$/;
    }
    search(e) {
      let r = !e.endsWith(this.pattern);
      return { isMatch: r, score: r ? 0 : 1, indices: [0, e.length - 1] };
    }
  },
  Nu = class extends An {
    constructor(
      e,
      {
        location: r = Ue.location,
        threshold: n = Ue.threshold,
        distance: s = Ue.distance,
        includeMatches: a = Ue.includeMatches,
        findAllMatches: i = Ue.findAllMatches,
        minMatchCharLength: o = Ue.minMatchCharLength,
        isCaseSensitive: c = Ue.isCaseSensitive,
        ignoreLocation: l = Ue.ignoreLocation,
      } = {},
    ) {
      (super(e),
        (this._bitapSearch = new Au(e, {
          location: r,
          threshold: n,
          distance: s,
          includeMatches: a,
          findAllMatches: i,
          minMatchCharLength: o,
          isCaseSensitive: c,
          ignoreLocation: l,
        })));
    }
    static get type() {
      return "fuzzy";
    }
    static get multiRegex() {
      return /^"(.*)"$/;
    }
    static get singleRegex() {
      return /^(.*)$/;
    }
    search(e) {
      return this._bitapSearch.searchIn(e);
    }
  },
  Du = class extends An {
    constructor(e) {
      super(e);
    }
    static get type() {
      return "include";
    }
    static get multiRegex() {
      return /^'"(.*)"$/;
    }
    static get singleRegex() {
      return /^'(.*)$/;
    }
    search(e) {
      let r = 0,
        n,
        s = [],
        a = this.pattern.length;
      for (; (n = e.indexOf(this.pattern, r)) > -1; )
        ((r = n + a), s.push([n, r - 1]));
      let i = !!s.length;
      return { isMatch: i, score: i ? 0 : 1, indices: s };
    }
  },
  Nh = [kh, Du, Oh, Ih, Ah, $h, Rh, Nu],
  DT = Nh.length,
  F6 = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,
  U6 = "|";
function q6(t, e = {}) {
  return t.split(U6).map((r) => {
    let n = r
        .trim()
        .split(F6)
        .filter((a) => a && !!a.trim()),
      s = [];
    for (let a = 0, i = n.length; a < i; a += 1) {
      let o = n[a],
        c = !1,
        l = -1;
      for (; !c && ++l < DT; ) {
        let u = Nh[l],
          d = u.isMultiMatch(o);
        d && (s.push(new u(d, e)), (c = !0));
      }
      if (!c)
        for (l = -1; ++l < DT; ) {
          let u = Nh[l],
            d = u.isSingleMatch(o);
          if (d) {
            s.push(new u(d, e));
            break;
          }
        }
    }
    return s;
  });
}
var z6 = new Set([Nu.type, Du.type]),
  Dh = class {
    constructor(
      e,
      {
        isCaseSensitive: r = Ue.isCaseSensitive,
        includeMatches: n = Ue.includeMatches,
        minMatchCharLength: s = Ue.minMatchCharLength,
        ignoreLocation: a = Ue.ignoreLocation,
        findAllMatches: i = Ue.findAllMatches,
        location: o = Ue.location,
        threshold: c = Ue.threshold,
        distance: l = Ue.distance,
      } = {},
    ) {
      ((this.query = null),
        (this.options = {
          isCaseSensitive: r,
          includeMatches: n,
          minMatchCharLength: s,
          findAllMatches: i,
          ignoreLocation: a,
          location: o,
          threshold: c,
          distance: l,
        }),
        (this.pattern = r ? e : e.toLowerCase()),
        (this.query = q6(this.pattern, this.options)));
    }
    static condition(e, r) {
      return r.useExtendedSearch;
    }
    searchIn(e) {
      let r = this.query;
      if (!r) return { isMatch: !1, score: 1 };
      let { includeMatches: n, isCaseSensitive: s } = this.options;
      e = s ? e : e.toLowerCase();
      let a = 0,
        i = [],
        o = 0;
      for (let c = 0, l = r.length; c < l; c += 1) {
        let u = r[c];
        ((i.length = 0), (a = 0));
        for (let d = 0, m = u.length; d < m; d += 1) {
          let p = u[d],
            { isMatch: f, indices: y, score: h } = p.search(e);
          if (f) {
            if (((a += 1), (o += h), n)) {
              let g = p.constructor.type;
              z6.has(g) ? (i = [...i, ...y]) : i.push(y);
            }
          } else {
            ((o = 0), (a = 0), (i.length = 0));
            break;
          }
        }
        if (a) {
          let d = { isMatch: !0, score: o / a };
          return (n && (d.indices = i), d);
        }
      }
      return { isMatch: !1, score: 1 };
    }
  },
  Lh = [];
function B6(...t) {
  Lh.push(...t);
}
function Mh(t, e) {
  for (let r = 0, n = Lh.length; r < n; r += 1) {
    let s = Lh[r];
    if (s.condition(t, e)) return new s(t, e);
  }
  return new Au(t, e);
}
var Lu = { AND: "$and", OR: "$or" },
  jh = { PATH: "$path", PATTERN: "$val" },
  Fh = (t) => !!(t[Lu.AND] || t[Lu.OR]),
  H6 = (t) => !!t[jh.PATH],
  V6 = (t) => !ns(t) && jT(t) && !Fh(t),
  LT = (t) => ({ [Lu.AND]: Object.keys(t).map((e) => ({ [e]: t[e] })) });
function zT(t, e, { auto: r = !0 } = {}) {
  let n = (s) => {
    let a = Object.keys(s),
      i = H6(s);
    if (!i && a.length > 1 && !Fh(s)) return n(LT(s));
    if (V6(s)) {
      let c = i ? s[jh.PATH] : a[0],
        l = i ? s[jh.PATTERN] : s[c];
      if (!$n(l)) throw new Error(E6(c));
      let u = { keyId: Ph(c), pattern: l };
      return (r && (u.searcher = Mh(l, e)), u);
    }
    let o = { children: [], operator: a[0] };
    return (
      a.forEach((c) => {
        let l = s[c];
        ns(l) &&
          l.forEach((u) => {
            o.children.push(n(u));
          });
      }),
      o
    );
  };
  return (Fh(t) || (t = LT(t)), n(t));
}
function Z6(t, { ignoreFieldNorm: e = Ue.ignoreFieldNorm }) {
  t.forEach((r) => {
    let n = 1;
    (r.matches.forEach(({ key: s, norm: a, score: i }) => {
      let o = s ? s.weight : null;
      n *= Math.pow(i === 0 && o ? Number.EPSILON : i, (o || 1) * (e ? 1 : a));
    }),
      (r.score = n));
  });
}
function G6(t, e) {
  let r = t.matches;
  ((e.matches = []),
    jr(r) &&
      r.forEach((n) => {
        if (!jr(n.indices) || !n.indices.length) return;
        let { indices: s, value: a } = n,
          i = { indices: s, value: a };
        (n.key && (i.key = n.key.src),
          n.idx > -1 && (i.refIndex = n.idx),
          e.matches.push(i));
      }));
}
function W6(t, e) {
  e.score = t.score;
}
function K6(
  t,
  e,
  {
    includeMatches: r = Ue.includeMatches,
    includeScore: n = Ue.includeScore,
  } = {},
) {
  let s = [];
  return (
    r && s.push(G6),
    n && s.push(W6),
    t.map((a) => {
      let { idx: i } = a,
        o = { item: e[i], refIndex: i };
      return (
        s.length &&
          s.forEach((c) => {
            c(a, o);
          }),
        o
      );
    })
  );
}
var ss = class {
  constructor(e, r = {}, n) {
    ((this.options = { ...Ue, ...r }),
      this.options.useExtendedSearch,
      (this._keyStore = new Ch(this.options.keys)),
      this.setCollection(e, n));
  }
  setCollection(e, r) {
    if (((this._docs = e), r && !(r instanceof vc))) throw new Error(S6);
    this._myIndex =
      r ||
      qT(this.options.keys, this._docs, {
        getFn: this.options.getFn,
        fieldNormWeight: this.options.fieldNormWeight,
      });
  }
  add(e) {
    jr(e) && (this._docs.push(e), this._myIndex.add(e));
  }
  remove(e = () => !1) {
    let r = [];
    for (let n = 0, s = this._docs.length; n < s; n += 1) {
      let a = this._docs[n];
      e(a, n) && (this.removeAt(n), (n -= 1), (s -= 1), r.push(a));
    }
    return r;
  }
  removeAt(e) {
    (this._docs.splice(e, 1), this._myIndex.removeAt(e));
  }
  getIndex() {
    return this._myIndex;
  }
  search(e, { limit: r = -1 } = {}) {
    let {
        includeMatches: n,
        includeScore: s,
        shouldSort: a,
        sortFn: i,
        ignoreFieldNorm: o,
      } = this.options,
      c = $n(e)
        ? $n(this._docs[0])
          ? this._searchStringList(e)
          : this._searchObjectList(e)
        : this._searchLogical(e);
    return (
      Z6(c, { ignoreFieldNorm: o }),
      a && c.sort(i),
      MT(r) && r > -1 && (c = c.slice(0, r)),
      K6(c, this._docs, { includeMatches: n, includeScore: s })
    );
  }
  _searchStringList(e) {
    let r = Mh(e, this.options),
      { records: n } = this._myIndex,
      s = [];
    return (
      n.forEach(({ v: a, i, n: o }) => {
        if (!jr(a)) return;
        let { isMatch: c, score: l, indices: u } = r.searchIn(a);
        c &&
          s.push({
            item: a,
            idx: i,
            matches: [{ score: l, value: a, norm: o, indices: u }],
          });
      }),
      s
    );
  }
  _searchLogical(e) {
    let r = zT(e, this.options),
      n = (o, c, l) => {
        if (!o.children) {
          let { keyId: d, searcher: m } = o,
            p = this._findMatches({
              key: this._keyStore.get(d),
              value: this._myIndex.getValueForItemAtKeyId(c, d),
              searcher: m,
            });
          return p && p.length ? [{ idx: l, item: c, matches: p }] : [];
        }
        let u = [];
        for (let d = 0, m = o.children.length; d < m; d += 1) {
          let p = o.children[d],
            f = n(p, c, l);
          if (f.length) u.push(...f);
          else if (o.operator === Lu.AND) return [];
        }
        return u;
      },
      s = this._myIndex.records,
      a = {},
      i = [];
    return (
      s.forEach(({ $: o, i: c }) => {
        if (jr(o)) {
          let l = n(r, o, c);
          l.length &&
            (a[c] || ((a[c] = { idx: c, item: o, matches: [] }), i.push(a[c])),
            l.forEach(({ matches: u }) => {
              a[c].matches.push(...u);
            }));
        }
      }),
      i
    );
  }
  _searchObjectList(e) {
    let r = Mh(e, this.options),
      { keys: n, records: s } = this._myIndex,
      a = [];
    return (
      s.forEach(({ $: i, i: o }) => {
        if (!jr(i)) return;
        let c = [];
        (n.forEach((l, u) => {
          c.push(...this._findMatches({ key: l, value: i[u], searcher: r }));
        }),
          c.length && a.push({ idx: o, item: i, matches: c }));
      }),
      a
    );
  }
  _findMatches({ key: e, value: r, searcher: n }) {
    if (!jr(r)) return [];
    let s = [];
    if (ns(r))
      r.forEach(({ v: a, i, n: o }) => {
        if (!jr(a)) return;
        let { isMatch: c, score: l, indices: u } = n.searchIn(a);
        c &&
          s.push({ score: l, key: e, value: a, idx: i, norm: o, indices: u });
      });
    else {
      let { v: a, n: i } = r,
        { isMatch: o, score: c, indices: l } = n.searchIn(a);
      o && s.push({ score: c, key: e, value: a, norm: i, indices: l });
    }
    return s;
  }
};
ss.version = "7.0.0";
ss.createIndex = qT;
ss.parseIndex = D6;
ss.config = Ue;
ss.parseQuery = zT;
B6(Dh);
var Mu = require("child_process");
var Uh = 100,
  J6 = 2e7,
  X6 = 1e4,
  Y6 = Yr(() => {
    if (
      !process.env.USE_BUILTIN_RIPGREP ||
      process.env.USE_BUILTIN_RIPGREP === "0" ||
      process.env.USE_BUILTIN_RIPGREP === "false"
    ) {
      let s = process.platform === "win32" ? "rg.exe" : "rg";
      try {
        return (
          (0, Mu.execFileSync)(s, ["--version"], { stdio: "ignore" }),
          { mode: "system", command: s, args: [] }
        );
      } catch {}
    }
    let e = Bt.resolve(__dirname, "..", "..", "..", ".."),
      r = Bt.resolve(e, "vendor", "ripgrep");
    return {
      mode: "builtin",
      command:
        process.platform === "win32"
          ? Bt.resolve(r, "x64-win32", "rg.exe")
          : Bt.resolve(r, `${process.arch}-${process.platform}`, "rg"),
      args: [],
    };
  });
function Q6() {
  let t = Y6();
  return { rgPath: t.command, rgArgs: t.args };
}
async function eW(t, e) {
  return new Promise((r, n) => {
    let { rgPath: s, rgArgs: a } = Q6();
    (0, Mu.execFile)(
      s,
      [...a, ...t],
      { cwd: e, maxBuffer: J6, timeout: X6 },
      (i, o) => {
        if (!i) {
          r(
            o
              .trim()
              .split(
                `
`,
              )
              .filter(Boolean),
          );
          return;
        }
        if ("code" in i && i.code === 1) {
          r([]);
          return;
        }
        let c = o && o.trim().length > 0,
          l =
            ("signal" in i && i.signal === "SIGTERM") ||
            ("code" in i && i.code === "ABORT_ERR"),
          u = "code" in i && i.code === "ERR_CHILD_PROCESS_STDIO_MAXBUFFER";
        if ((l || u) && c) {
          let d = o
            .trim()
            .split(
              `
`,
            )
            .filter(Boolean);
          r(d.length > 0 ? d.slice(0, -1) : []);
          return;
        }
        n(i);
      },
    );
  });
}
function tW(t, e) {
  if (!e) {
    let i = new Set();
    for (let o of t) {
      let c = o.split(Bt.sep)[0];
      if (c && (i.add(c), i.size >= Uh)) break;
    }
    return [...i].sort().map((o) => {
      let c = t.some((l) => l.startsWith(o + Bt.sep));
      return {
        path: c ? o + Bt.sep : o,
        filename: Bt.basename(o),
        isDirectory: c,
      };
    });
  }
  let r = t.map((i) => ({
      path: i,
      filename: Bt.basename(i),
      testPenalty: i.includes("test") ? 1 : 0,
    })),
    n = e.lastIndexOf(Bt.sep);
  n > 2 &&
    (r = r.filter((i) => i.path.substring(0, n).startsWith(e.substring(0, n))));
  let a = new ss(r, {
    includeScore: !0,
    threshold: 0.5,
    keys: [
      { name: "path", weight: 1 },
      { name: "filename", weight: 2 },
    ],
  }).search(e, { limit: Uh });
  return (
    (a = a.sort((i, o) =>
      i.score === void 0 || o.score === void 0
        ? 0
        : Math.abs(i.score - o.score) > 0.05
          ? i.score - o.score
          : i.item.testPenalty - o.item.testPenalty,
    )),
    a
      .map((i) => ({
        path: i.item.path,
        filename: i.item.filename,
        isDirectory: i.item.path.endsWith(Bt.sep),
      }))
      .slice(0, Uh)
  );
}
async function BT(t, e, r) {
  try {
    let n = ["--files", "--follow", "--hidden"];
    (mr("respectGitIgnore") ?? !0) || n.push("--no-ignore-vcs");
    try {
      let l = qh.workspace.getConfiguration("search"),
        u = qh.workspace.getConfiguration("files"),
        d = l.get("exclude") || {},
        m = u.get("exclude") || {};
      for (let [p, f] of Object.entries(d)) f && n.push("--glob", `!${p}`);
      for (let [p, f] of Object.entries(m))
        f && !d[p] && n.push("--glob", `!${p}`);
    } catch (l) {
      r.warn("Failed to get VSCode exclude patterns", l);
    }
    let a = await eW(n, e),
      o = [...rW(a), ...a];
    return tW(o, t).map((l) => ({
      path: l.path,
      name: l.filename,
      type: l.isDirectory ? "directory" : "file",
    }));
  } catch (n) {
    throw (r.error("Ripgrep search failed", n), n);
  }
}
function rW(t) {
  let e = new Set();
  return (
    t.forEach((r) => {
      let s = Bt.dirname(r);
      for (; s !== "." && s !== Bt.parse(s).root; )
        (e.add(s), (s = Bt.dirname(s)));
    }),
    [...e].map((r) => r + Bt.sep)
  );
}
var kr = require("path"),
  ay = le(Vh(), 1),
  J$ = require("os");
var As = le(require("vscode"), 1);
var $s = le(require("vscode"), 1);
function Fi() {
  return $s.window.tabGroups.all.flatMap((t) => t.tabs);
}
function Ui(t, e) {
  return new Promise((r, n) => {
    let s,
      a = setInterval(() => {
        let i = t();
        i && (clearInterval(a), s && clearTimeout(s), r(i));
      }, 100);
    e &&
      (s = setTimeout(() => {
        (clearInterval(a), n(new Error(`Timeout waiting after ${e}ms`)));
      }, e));
  });
}
async function wa(t, e) {
  if (!t) return;
  let r = t.input;
  if (r instanceof $s.TabInputTextDiff)
    try {
      let n = await $s.workspace.openTextDocument(r.modified);
      if (n.isDirty) {
        let s = new Promise((a) => {
          let i = $s.workspace.onDidSaveTextDocument((o) => {
            o.uri.toString() === n.uri.toString() && (i.dispose(), a());
          });
          setTimeout(() => {
            (i.dispose(), a());
          }, 2e3);
        });
        (await n.save(), await s);
      }
    } catch (n) {
      e.error("Error saving modified file:", n);
    }
  try {
    await $s.window.tabGroups.close(t);
  } catch {}
}
async function QT(t, e, r, n, s, a, i) {
  let o = [],
    l = `${s || "Claude Code"} (${Math.random().toString(36).substring(2, 8)})`,
    u = [],
    d;
  if (a) {
    let f = `/temp/${l}`,
      h = r.createFile(f, n).uri;
    ((d = await As.workspace.openTextDocument(h)),
      t.info("Editable uri: ", h.toString()));
    let g = new Promise((v) => {
      o.push(
        As.workspace.onWillSaveTextDocument((b) => {
          if (b.document.uri.toString() === h.toString()) {
            let x = b.document.getText();
            v(x);
          }
        }),
      );
    });
    As.workspace.getConfiguration("files").get("autoSave") === "off"
      ? (t.info("files.autoSave is off, waiting for file save"), u.push(g))
      : t.info("files.autoSave is on, cannot save to exit");
    let _ = { preview: !1, preserveFocus: !0 };
    await As.window.showTextDocument(d, _);
  } else {
    let f = `/temp/readonly/${l}`,
      y = e.createFile(f, n);
    ((d = await As.workspace.openTextDocument(y)),
      await As.window.showTextDocument(d, { preview: !0 }));
  }
  let m = await Ui(() => Fi().find((f) => f.label === l), 1e3);
  i?.addEventListener("abort", () => {
    wa(m, t);
  });
  let p = Ui(() => !Fi().some((f) => f.label === l)).then(() => {
    if ((t.info("Tab closed", l), a)) return d.getText();
  });
  return (
    u.push(p),
    await Promise.race(u)
      .finally(() => {
        o.forEach((f) => f.dispose());
      })
      .then((f) => (t.info("File save operation completed", f), f))
      .finally(() => {
        wa(m, t);
      })
  );
}
var At = le(require("vscode"), 1),
  fC = le(require("fs"), 1);
function gn() {}
gn.prototype = {
  diff: function (e, r) {
    var n,
      s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
      a = s.callback;
    typeof s == "function" && ((a = s), (s = {}));
    var i = this;
    function o(b) {
      return (
        (b = i.postProcess(b, s)),
        a
          ? (setTimeout(function () {
              a(b);
            }, 0),
            !0)
          : b
      );
    }
    ((e = this.castInput(e, s)),
      (r = this.castInput(r, s)),
      (e = this.removeEmpty(this.tokenize(e, s))),
      (r = this.removeEmpty(this.tokenize(r, s))));
    var c = r.length,
      l = e.length,
      u = 1,
      d = c + l;
    s.maxEditLength != null && (d = Math.min(d, s.maxEditLength));
    var m = (n = s.timeout) !== null && n !== void 0 ? n : 1 / 0,
      p = Date.now() + m,
      f = [{ oldPos: -1, lastComponent: void 0 }],
      y = this.extractCommon(f[0], r, e, 0, s);
    if (f[0].oldPos + 1 >= l && y + 1 >= c)
      return o(eC(i, f[0].lastComponent, r, e, i.useLongestToken));
    var h = -1 / 0,
      g = 1 / 0;
    function _() {
      for (var b = Math.max(h, -u); b <= Math.min(g, u); b += 2) {
        var x = void 0,
          w = f[b - 1],
          S = f[b + 1];
        w && (f[b - 1] = void 0);
        var C = !1;
        if (S) {
          var P = S.oldPos - b;
          C = S && 0 <= P && P < c;
        }
        var A = w && w.oldPos + 1 < l;
        if (!C && !A) {
          f[b] = void 0;
          continue;
        }
        if (
          (!A || (C && w.oldPos < S.oldPos)
            ? (x = i.addToPath(S, !0, !1, 0, s))
            : (x = i.addToPath(w, !1, !0, 1, s)),
          (y = i.extractCommon(x, r, e, b, s)),
          x.oldPos + 1 >= l && y + 1 >= c)
        )
          return o(eC(i, x.lastComponent, r, e, i.useLongestToken));
        ((f[b] = x),
          x.oldPos + 1 >= l && (g = Math.min(g, b - 1)),
          y + 1 >= c && (h = Math.max(h, b + 1)));
      }
      u++;
    }
    if (a)
      (function b() {
        setTimeout(function () {
          if (u > d || Date.now() > p) return a();
          _() || b();
        }, 0);
      })();
    else
      for (; u <= d && Date.now() <= p; ) {
        var v = _();
        if (v) return v;
      }
  },
  addToPath: function (e, r, n, s, a) {
    var i = e.lastComponent;
    return i && !a.oneChangePerToken && i.added === r && i.removed === n
      ? {
          oldPos: e.oldPos + s,
          lastComponent: {
            count: i.count + 1,
            added: r,
            removed: n,
            previousComponent: i.previousComponent,
          },
        }
      : {
          oldPos: e.oldPos + s,
          lastComponent: {
            count: 1,
            added: r,
            removed: n,
            previousComponent: i,
          },
        };
  },
  extractCommon: function (e, r, n, s, a) {
    for (
      var i = r.length, o = n.length, c = e.oldPos, l = c - s, u = 0;
      l + 1 < i && c + 1 < o && this.equals(n[c + 1], r[l + 1], a);
    )
      (l++,
        c++,
        u++,
        a.oneChangePerToken &&
          (e.lastComponent = {
            count: 1,
            previousComponent: e.lastComponent,
            added: !1,
            removed: !1,
          }));
    return (
      u &&
        !a.oneChangePerToken &&
        (e.lastComponent = {
          count: u,
          previousComponent: e.lastComponent,
          added: !1,
          removed: !1,
        }),
      (e.oldPos = c),
      l
    );
  },
  equals: function (e, r, n) {
    return n.comparator
      ? n.comparator(e, r)
      : e === r || (n.ignoreCase && e.toLowerCase() === r.toLowerCase());
  },
  removeEmpty: function (e) {
    for (var r = [], n = 0; n < e.length; n++) e[n] && r.push(e[n]);
    return r;
  },
  castInput: function (e) {
    return e;
  },
  tokenize: function (e) {
    return Array.from(e);
  },
  join: function (e) {
    return e.join("");
  },
  postProcess: function (e) {
    return e;
  },
};
function eC(t, e, r, n, s) {
  for (var a = [], i; e; )
    (a.push(e), (i = e.previousComponent), delete e.previousComponent, (e = i));
  a.reverse();
  for (var o = 0, c = a.length, l = 0, u = 0; o < c; o++) {
    var d = a[o];
    if (d.removed)
      ((d.value = t.join(n.slice(u, u + d.count))), (u += d.count));
    else {
      if (!d.added && s) {
        var m = r.slice(l, l + d.count);
        ((m = m.map(function (p, f) {
          var y = n[u + f];
          return y.length > p.length ? y : p;
        })),
          (d.value = t.join(m)));
      } else d.value = t.join(r.slice(l, l + d.count));
      ((l += d.count), d.added || (u += d.count));
    }
  }
  return a;
}
var qie = new gn();
function tC(t, e) {
  var r;
  for (r = 0; r < t.length && r < e.length; r++)
    if (t[r] != e[r]) return t.slice(0, r);
  return t.slice(0, r);
}
function rC(t, e) {
  var r;
  if (!t || !e || t[t.length - 1] != e[e.length - 1]) return "";
  for (r = 0; r < t.length && r < e.length; r++)
    if (t[t.length - (r + 1)] != e[e.length - (r + 1)]) return t.slice(-r);
  return t.slice(-r);
}
function Gh(t, e, r) {
  if (t.slice(0, e.length) != e)
    throw Error(
      "string "
        .concat(JSON.stringify(t), " doesn't start with prefix ")
        .concat(JSON.stringify(e), "; this is a bug"),
    );
  return r + t.slice(e.length);
}
function Wh(t, e, r) {
  if (!e) return t + r;
  if (t.slice(-e.length) != e)
    throw Error(
      "string "
        .concat(JSON.stringify(t), " doesn't end with suffix ")
        .concat(JSON.stringify(e), "; this is a bug"),
    );
  return t.slice(0, -e.length) + r;
}
function yc(t, e) {
  return Gh(t, e, "");
}
function ju(t, e) {
  return Wh(t, e, "");
}
function nC(t, e) {
  return e.slice(0, dW(t, e));
}
function dW(t, e) {
  var r = 0;
  t.length > e.length && (r = t.length - e.length);
  var n = e.length;
  t.length < e.length && (n = t.length);
  var s = Array(n),
    a = 0;
  s[0] = 0;
  for (var i = 1; i < n; i++) {
    for (e[i] == e[a] ? (s[i] = s[a]) : (s[i] = a); a > 0 && e[i] != e[a]; )
      a = s[a];
    e[i] == e[a] && a++;
  }
  a = 0;
  for (var o = r; o < t.length; o++) {
    for (; a > 0 && t[o] != e[a]; ) a = s[a];
    t[o] == e[a] && a++;
  }
  return a;
}
var Fu =
    "a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}",
  pW = new RegExp("[".concat(Fu, "]+|\\s+|[^").concat(Fu, "]"), "ug"),
  Uu = new gn();
Uu.equals = function (t, e, r) {
  return (
    r.ignoreCase && ((t = t.toLowerCase()), (e = e.toLowerCase())),
    t.trim() === e.trim()
  );
};
Uu.tokenize = function (t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    r;
  if (e.intlSegmenter) {
    if (e.intlSegmenter.resolvedOptions().granularity != "word")
      throw new Error('The segmenter passed must have a granularity of "word"');
    r = Array.from(e.intlSegmenter.segment(t), function (a) {
      return a.segment;
    });
  } else r = t.match(pW) || [];
  var n = [],
    s = null;
  return (
    r.forEach(function (a) {
      (/\s/.test(a)
        ? s == null
          ? n.push(a)
          : n.push(n.pop() + a)
        : /\s/.test(s)
          ? n[n.length - 1] == s
            ? n.push(n.pop() + a)
            : n.push(s + a)
          : n.push(a),
        (s = a));
    }),
    n
  );
};
Uu.join = function (t) {
  return t
    .map(function (e, r) {
      return r == 0 ? e : e.replace(/^\s+/, "");
    })
    .join("");
};
Uu.postProcess = function (t, e) {
  if (!t || e.oneChangePerToken) return t;
  var r = null,
    n = null,
    s = null;
  return (
    t.forEach(function (a) {
      a.added
        ? (n = a)
        : a.removed
          ? (s = a)
          : ((n || s) && sC(r, s, n, a), (r = a), (n = null), (s = null));
    }),
    (n || s) && sC(r, s, n, null),
    t
  );
};
function sC(t, e, r, n) {
  if (e && r) {
    var s = e.value.match(/^\s*/)[0],
      a = e.value.match(/\s*$/)[0],
      i = r.value.match(/^\s*/)[0],
      o = r.value.match(/\s*$/)[0];
    if (t) {
      var c = tC(s, i);
      ((t.value = Wh(t.value, i, c)),
        (e.value = yc(e.value, c)),
        (r.value = yc(r.value, c)));
    }
    if (n) {
      var l = rC(a, o);
      ((n.value = Gh(n.value, o, l)),
        (e.value = ju(e.value, l)),
        (r.value = ju(r.value, l)));
    }
  } else if (r)
    (t && (r.value = r.value.replace(/^\s*/, "")),
      n && (n.value = n.value.replace(/^\s*/, "")));
  else if (t && n) {
    var u = n.value.match(/^\s*/)[0],
      d = e.value.match(/^\s*/)[0],
      m = e.value.match(/\s*$/)[0],
      p = tC(u, d);
    e.value = yc(e.value, p);
    var f = rC(yc(u, p), m);
    ((e.value = ju(e.value, f)),
      (n.value = Gh(n.value, u, f)),
      (t.value = Wh(t.value, u, u.slice(0, u.length - f.length))));
  } else if (n) {
    var y = n.value.match(/^\s*/)[0],
      h = e.value.match(/\s*$/)[0],
      g = nC(h, y);
    e.value = ju(e.value, g);
  } else if (t) {
    var _ = t.value.match(/\s*$/)[0],
      v = e.value.match(/^\s*/)[0],
      b = nC(_, v);
    e.value = yc(e.value, b);
  }
}
var fW = new gn();
fW.tokenize = function (t) {
  var e = new RegExp(
    "(\\r?\\n)|[".concat(Fu, "]+|[^\\S\\n\\r]+|[^").concat(Fu, "]"),
    "ug",
  );
  return t.match(e) || [];
};
var qu = new gn();
qu.tokenize = function (t, e) {
  e.stripTrailingCr &&
    (t = t.replace(
      /\r\n/g,
      `
`,
    ));
  var r = [],
    n = t.split(/(\n|\r\n)/);
  n[n.length - 1] || n.pop();
  for (var s = 0; s < n.length; s++) {
    var a = n[s];
    s % 2 && !e.newlineIsToken ? (r[r.length - 1] += a) : r.push(a);
  }
  return r;
};
qu.equals = function (t, e, r) {
  return (
    r.ignoreWhitespace
      ? ((!r.newlineIsToken ||
          !t.includes(`
`)) &&
          (t = t.trim()),
        (!r.newlineIsToken ||
          !e.includes(`
`)) &&
          (e = e.trim()))
      : r.ignoreNewlineAtEof &&
        !r.newlineIsToken &&
        (t.endsWith(`
`) && (t = t.slice(0, -1)),
        e.endsWith(`
`) && (e = e.slice(0, -1))),
    gn.prototype.equals.call(this, t, e, r)
  );
};
function aC(t, e, r) {
  return qu.diff(t, e, r);
}
var mW = new gn();
mW.tokenize = function (t) {
  return t.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var hW = new gn();
hW.tokenize = function (t) {
  return t.split(/([{}:;,]|\s+)/);
};
function iC(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    (e &&
      (n = n.filter(function (s) {
        return Object.getOwnPropertyDescriptor(t, s).enumerable;
      })),
      r.push.apply(r, n));
  }
  return r;
}
function oC(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? iC(Object(r), !0).forEach(function (n) {
          yW(t, n, r[n]);
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r))
        : iC(Object(r)).forEach(function (n) {
            Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
          });
  }
  return t;
}
function gW(t, e) {
  if (typeof t != "object" || !t) return t;
  var r = t[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t, e || "default");
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function vW(t) {
  var e = gW(t, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Kh(t) {
  "@babel/helpers - typeof";
  return (
    (Kh =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    Kh(t)
  );
}
function yW(t, e, r) {
  return (
    (e = vW(e)),
    e in t
      ? Object.defineProperty(t, e, {
          value: r,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (t[e] = r),
    t
  );
}
function Zh(t) {
  return bW(t) || _W(t) || xW(t) || wW();
}
function bW(t) {
  if (Array.isArray(t)) return Jh(t);
}
function _W(t) {
  if (
    (typeof Symbol < "u" && t[Symbol.iterator] != null) ||
    t["@@iterator"] != null
  )
    return Array.from(t);
}
function xW(t, e) {
  if (t) {
    if (typeof t == "string") return Jh(t, e);
    var r = Object.prototype.toString.call(t).slice(8, -1);
    if (
      (r === "Object" && t.constructor && (r = t.constructor.name),
      r === "Map" || r === "Set")
    )
      return Array.from(t);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))
      return Jh(t, e);
  }
}
function Jh(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
  return n;
}
function wW() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var bc = new gn();
bc.useLongestToken = !0;
bc.tokenize = qu.tokenize;
bc.castInput = function (t, e) {
  var r = e.undefinedReplacement,
    n = e.stringifyReplacer,
    s =
      n === void 0
        ? function (a, i) {
            return typeof i > "u" ? r : i;
          }
        : n;
  return typeof t == "string"
    ? t
    : JSON.stringify(Xh(t, null, null, s), s, "  ");
};
bc.equals = function (t, e, r) {
  return gn.prototype.equals.call(
    bc,
    t.replace(/,([\r\n])/g, "$1"),
    e.replace(/,([\r\n])/g, "$1"),
    r,
  );
};
function Xh(t, e, r, n, s) {
  ((e = e || []), (r = r || []), n && (t = n(s, t)));
  var a;
  for (a = 0; a < e.length; a += 1) if (e[a] === t) return r[a];
  var i;
  if (Object.prototype.toString.call(t) === "[object Array]") {
    for (
      e.push(t), i = new Array(t.length), r.push(i), a = 0;
      a < t.length;
      a += 1
    )
      i[a] = Xh(t[a], e, r, n, s);
    return (e.pop(), r.pop(), i);
  }
  if ((t && t.toJSON && (t = t.toJSON()), Kh(t) === "object" && t !== null)) {
    (e.push(t), (i = {}), r.push(i));
    var o = [],
      c;
    for (c in t) Object.prototype.hasOwnProperty.call(t, c) && o.push(c);
    for (o.sort(), a = 0; a < o.length; a += 1)
      ((c = o[a]), (i[c] = Xh(t[c], e, r, n, c)));
    (e.pop(), r.pop());
  } else i = t;
  return i;
}
var Yh = new gn();
Yh.tokenize = function (t) {
  return t.slice();
};
Yh.join = Yh.removeEmpty = function (t) {
  return t;
};
function cC(t, e, r, n, s, a, i) {
  if (
    (i || (i = {}),
    typeof i == "function" && (i = { callback: i }),
    typeof i.context > "u" && (i.context = 4),
    i.newlineIsToken)
  )
    throw new Error(
      "newlineIsToken may not be used with patch-generation functions, only with diffing functions",
    );
  if (i.callback) {
    var o = i,
      c = o.callback;
    aC(
      r,
      n,
      oC(
        oC({}, i),
        {},
        {
          callback: function (d) {
            var m = l(d);
            c(m);
          },
        },
      ),
    );
  } else return l(aC(r, n, i));
  function l(u) {
    if (!u) return;
    u.push({ value: "", lines: [] });
    function d(C) {
      return C.map(function (P) {
        return " " + P;
      });
    }
    for (
      var m = [],
        p = 0,
        f = 0,
        y = [],
        h = 1,
        g = 1,
        _ = function () {
          var P = u[v],
            A = P.lines || SW(P.value);
          if (((P.lines = A), P.added || P.removed)) {
            var R;
            if (!p) {
              var D = u[v - 1];
              ((p = h),
                (f = g),
                D &&
                  ((y = i.context > 0 ? d(D.lines.slice(-i.context)) : []),
                  (p -= y.length),
                  (f -= y.length)));
            }
            ((R = y).push.apply(
              R,
              Zh(
                A.map(function (Y) {
                  return (P.added ? "+" : "-") + Y;
                }),
              ),
            ),
              P.added ? (g += A.length) : (h += A.length));
          } else {
            if (p)
              if (A.length <= i.context * 2 && v < u.length - 2) {
                var F;
                (F = y).push.apply(F, Zh(d(A)));
              } else {
                var I,
                  K = Math.min(A.length, i.context);
                (I = y).push.apply(I, Zh(d(A.slice(0, K))));
                var ee = {
                  oldStart: p,
                  oldLines: h - p + K,
                  newStart: f,
                  newLines: g - f + K,
                  lines: y,
                };
                (m.push(ee), (p = 0), (f = 0), (y = []));
              }
            ((h += A.length), (g += A.length));
          }
        },
        v = 0;
      v < u.length;
      v++
    )
      _();
    for (var b = 0, x = m; b < x.length; b++)
      for (var w = x[b], S = 0; S < w.lines.length; S++)
        w.lines[S].endsWith(`
`)
          ? (w.lines[S] = w.lines[S].slice(0, -1))
          : (w.lines.splice(S + 1, 0, "\\ No newline at end of file"), S++);
    return {
      oldFileName: t,
      newFileName: e,
      oldHeader: s,
      newHeader: a,
      hunks: m,
    };
  }
}
function SW(t) {
  var e = t.endsWith(`
`),
    r = t
      .split(
        `
`,
      )
      .map(function (n) {
        return (
          n +
          `
`
        );
      });
  return (e ? r.pop() : r.push(r.pop().slice(0, -1)), r);
}
function uC(t, e) {
  let r = t,
    n = [];
  if (
    !t &&
    e.length === 1 &&
    e[0] &&
    e[0].oldString === "" &&
    e[0].newString === ""
  )
    return "";
  for (let s of e) {
    let a = s.oldString.replace(/\n+$/, "");
    for (let o of n)
      if (a !== "" && o.includes(a))
        throw new Error(
          "Cannot edit file: old_string is a substring of a new_string from a previous edit.",
        );
    let i = r;
    if (
      (s.oldString === ""
        ? (r = s.newString)
        : (r = EW(r, s.oldString, s.newString, s.replaceAll)),
      r === i)
    )
      throw new Error("String not found in file. Failed to apply edit.");
    n.push(s.newString);
  }
  if (r === t)
    throw new Error(
      "Original and edited file match exactly. Failed to apply edit.",
    );
  return r;
}
function EW(t, e, r, n = !1) {
  let s = n
    ? (i, o, c) => i.replaceAll(o, () => c)
    : (i, o, c) => i.replace(o, () => c);
  return r !== ""
    ? s(t, e, r)
    : !e.endsWith(`
`) &&
        t.includes(
          e +
            `
`,
        )
      ? s(
          t,
          e +
            `
`,
          r,
        )
      : s(t, e, r);
}
function Qh(t, e, r, n) {
  let a = kW({
    filePath: t,
    oldContent: e,
    newContent: r,
    singleHunk: n === "single",
  });
  return a.length === 0 ? [] : TW(a);
}
function TW(t) {
  return t.map((e) => {
    let r = [],
      n = [],
      s = [];
    for (let a of e.lines)
      a.startsWith(" ")
        ? (r.push(a.slice(1)), n.push(a.slice(1)), s.push(a.slice(1)))
        : a.startsWith("-")
          ? n.push(a.slice(1))
          : a.startsWith("+") && s.push(a.slice(1));
    return {
      oldString: n.join(`
`),
      newString: s.join(`
`),
      replaceAll: !1,
    };
  });
}
var dC = "<<:AMPERSAND_TOKEN:>>",
  pC = "<<:DOLLAR_TOKEN:>>";
function lC(t) {
  return t.replaceAll("&", dC).replaceAll("$", pC);
}
function CW(t) {
  return t.replaceAll(dC, "&").replaceAll(pC, "$");
}
var PW = 3;
function kW({
  filePath: t,
  oldContent: e,
  newContent: r,
  ignoreWhitespace: n = !1,
  singleHunk: s = !1,
}) {
  return cC(t, t, lC(e), lC(r), void 0, void 0, {
    ignoreWhitespace: n,
    context: s ? 1e5 : PW,
  }).hunks.map((a) => ({ ...a, lines: a.lines.map(CW) }));
}
async function mC(t, e, r, n, s, a, i, o, c) {
  let l = n.split("/").pop() || n,
    u = s.split("/").pop() || s,
    m = `\u273B [Claude Code] ${l === u ? l : `${l} \u2192 ${u}`}`;
  (t.info("diff from", n, "to", s, "as", m), hC.push(m));
  let p = At.Uri.file(n),
    f = "";
  try {
    let ee = await At.workspace.openTextDocument(p);
    ee.isDirty
      ? ((f = fC.readFileSync(n, "utf8")), (p = e.createFile(n, f).uri))
      : (f = ee.getText());
  } catch {
    (t.info("leftTempFileProvider.createFile", n),
      (p = e.createFile(n, "").uri));
  }
  let y = uC(f, a),
    g = r.createFile(s, y).uri,
    _ = await At.workspace.openTextDocument(g);
  (await RW(t)) > 0 && (await new Promise((ee) => setTimeout(ee, 200)));
  let b = y,
    x = y,
    w;
  At.workspace.onDidChangeTextDocument((ee) => {
    ee.document.uri.toString() === g.toString() &&
      ((b = x),
      (x = ee.document.getText()),
      ee.contentChanges.length > 3 &&
        ee.reason !== At.TextDocumentChangeReason.Undo &&
        ee.reason !== At.TextDocumentChangeReason.Redo &&
        (w = { time: Date.now(), contents: b }));
  });
  let S = [],
    C = new Promise((ee) => {
      S.push(
        At.workspace.onWillSaveTextDocument((Y) => {
          if (Y.document.uri.toString() === g.toString()) {
            let Q = Y.document.getText();
            (w && Date.now() - w.time < 500 && (Q = w.contents), ee(Q));
          }
        }),
      );
    }),
    P = new Promise((ee) => {
      S.push(
        o((Y) => {
          Y.activeTab && Y.activeTab.label === m && ee(Y);
        }),
      );
    }).then((ee) => {
      if (ee.accepted)
        return (
          t.info("diff_accepted", m),
          Qh(s, f, _.getText(), i ? "multiple" : "single")
        );
    }),
    A = { preview: !1, preserveFocus: !0 },
    R = await At.commands.executeCommand("vscode.diff", p, g, m, A);
  t.info("diff result", R, m, p, g, A);
  let D = await Ui(() => Fi().find((ee) => ee.label === m), 1e3);
  c?.addEventListener("abort", () => {
    wa(D, t);
  });
  let F = Ui(() => !Fi().some((ee) => ee.label === m)).then(() => {
      t.info("tab_closed", m);
    }),
    I = C.then(async (ee) => Qh(s, f, ee, i ? "multiple" : "single")),
    K = [F, P];
  return (
    At.workspace.getConfiguration("files").get("autoSave") === "off"
      ? (t.info("files.autoSave is off, waiting for file save"), K.push(I))
      : t.info("files.autoSave is on, need explicit accept"),
    await Promise.race(K)
      .finally(() => {
        S.forEach((ee) => ee.dispose());
      })
      .then((ee) => (t.info("diff operation completed", ee), ee))
      .finally(() => {
        wa(D, t);
      })
  );
}
var hC = [];
async function RW(t) {
  let e = 0;
  t.info("Closing all diff tabs in the editor...");
  for (let r of At.window.tabGroups.all)
    for (let n of r.tabs)
      n.input instanceof At.TabInputTextDiff &&
        hC.includes(n.label) &&
        (await wa(n, t), e++);
  return (t.info(`Closed ${e} diff tabs.`), e);
}
function gC(t) {
  let e = new At.EventEmitter();
  return (
    t.push(
      At.commands.registerCommand(
        "claude-vscode.acceptProposedDiff",
        async () => {
          let r = At.window.tabGroups.activeTabGroup.activeTab;
          e.fire({ accepted: !0, activeTab: r });
        },
      ),
    ),
    t.push(
      At.commands.registerCommand(
        "claude-vscode.rejectProposedDiff",
        async () => {
          let r = At.window.tabGroups.activeTabGroup.activeTab;
          e.fire({ accepted: !1, activeTab: r });
        },
      ),
    ),
    e.event
  );
}
var Ns = le(require("vscode"), 1);
var zu = le(require("vscode"), 1);
var vC = require("node:child_process");
function yC(t) {
  let e = t;
  if (
    (t.startsWith("file://") && (e = t.substring(7)),
    !e.startsWith("/") || /^\/[a-zA-Z]:/.test(e))
  )
    return t;
  try {
    return (0, vC.execFileSync)("wsl.exe", ["-e", "wslpath", "-w", e], {
      encoding: "utf8",
      stdio: ["pipe", "pipe", "ignore"],
    }).trim();
  } catch {
    return t;
  }
}
function Bu(t) {
  if (process.platform === "win32") {
    let e = yC(t);
    return e.startsWith("file://") ? zu.Uri.parse(e) : zu.Uri.file(e);
  } else return zu.Uri.parse(t);
}
function OW(t) {
  return t.map((e) => ({
    message: e.message,
    severity: Ns.DiagnosticSeverity[e.severity],
    range: {
      start: { line: e.range.start.line, character: e.range.start.character },
      end: { line: e.range.end.line, character: e.range.end.character },
    },
    source: e.source,
    code: e.code?.toString(),
  }));
}
function _c(t) {
  return (
    t
      ? (() => {
          let r = Bu(t);
          return [[r, Ns.languages.getDiagnostics(r)]];
        })()
      : Ns.languages.getDiagnostics()
  ).map(([r, n]) => ({
    uri: r.toString(!0),
    linesInFile: IW(r),
    diagnostics: OW(n),
  }));
}
function IW(t) {
  try {
    return Ns.workspace.textDocuments.find(
      (r) => r.uri.toString() === t.toString(),
    )?.lineCount;
  } catch {
    return;
  }
}
var Hu = class t {
  static instance;
  listener;
  clients;
  clientCounter;
  output;
  constructor(e) {
    ((this.clients = new Map()), (this.clientCounter = 0), (this.output = e));
  }
  static getInstance(e) {
    return (t.instance || (t.instance = new t(e)), t.instance);
  }
  registerClient(e) {
    let r = `client_${this.clientCounter++}`;
    return (this.clients.set(r, e), this.startStreaming(), r);
  }
  unregisterClient(e) {
    this.clients.delete(e) &&
      (this.output.info(
        `[DiagnosticStreamManager] Unregistered client ${e}. Total clients: ${this.clients.size}`,
      ),
      this.clients.size === 0 && this.stopStreaming());
  }
  startStreaming() {
    this.listener ||
      ((this.listener = Ns.languages.onDidChangeDiagnostics((e) => {
        this.notifyDiagnosticsChanged(e.uris);
      })),
      this.output.info(
        "[DiagnosticStreamManager] Started streaming diagnostics",
      ));
  }
  stopStreaming() {
    this.listener &&
      (this.listener.dispose(),
      (this.listener = void 0),
      this.output.info(
        "[DiagnosticStreamManager] Stopped streaming diagnostics",
      ));
  }
  notifyDiagnosticsChanged(e) {
    if (this.clients.size === 0) return;
    let r = e.map((n) => n.toString());
    (this.output.info(
      `[DiagnosticStreamManager] Notifying ${this.clients.size} clients about diagnostics change for ${e.length} files`,
    ),
      this.clients.forEach((n, s) => {
        try {
          n(r);
        } catch (a) {
          this.output.error(
            `[DiagnosticStreamManager] Error notifying client ${s}: ${a}`,
          );
        }
      }));
  }
  dispose() {
    (this.clients.clear(), this.stopStreaming());
  }
};
var Zu = le(require("vscode"), 1),
  Vu = class {
    constructor(e) {
      this.logger = e;
    }
    baselineDiagnostics = new Map();
    async captureBaseline(e) {
      try {
        if (e.hook_event_name !== "PreToolUse") return { continue: !0 };
        let r = this.extractFilePath(e);
        if (r && typeof r == "string") {
          let n = _c(r);
          (this.baselineDiagnostics.set(r, n),
            this.logger.log(
              `[DiagnosticTracking] Captured baseline diagnostics for ${r}: ${n.length} files`,
            ));
        }
      } catch (r) {
        this.logger.error(
          `[DiagnosticTracking] Error capturing baseline diagnostics: ${r}`,
        );
      }
      return { continue: !0 };
    }
    async findDiagnosticsProblems(e) {
      try {
        if (e.hook_event_name !== "PostToolUse") return { continue: !0 };
        let r = this.extractFilePath(e);
        if (r && typeof r == "string") {
          let n = Zu.Uri.file(r),
            s = Zu.window.visibleTextEditors.some(
              (o) => o.document.uri.toString() === n.toString(),
            ),
            a = this.baselineDiagnostics.get(r) || [],
            i = s ? [750, 750] : [1e3];
          for (let o = 0; o < i.length; o++) {
            await new Promise((u) => setTimeout(u, i[o]));
            let c = _c(r),
              l = this.findNewDiagnostics(a, c);
            if (l.length > 0) {
              this.logger.log(
                `[DiagnosticTracking] Found ${l.length} new diagnostics for ${r} at ${o + 1}s`,
              );
              let u = this.formatDiagnosticsSummary(l);
              return (
                this.baselineDiagnostics.delete(r),
                {
                  continue: !0,
                  hookSpecificOutput: {
                    hookEventName: "PostToolUse",
                    additionalContext: `<ide_diagnostics>${u}</ide_diagnostics>`,
                  },
                }
              );
            }
          }
          (this.logger.log(
            `[DiagnosticTracking] No new diagnostics found for ${r}`,
          ),
            this.baselineDiagnostics.delete(r));
        }
      } catch (r) {
        this.logger.error(
          `[DiagnosticTracking] Error tracking post-tool diagnostics: ${r}`,
        );
      }
      return { continue: !0 };
    }
    extractFilePath(e) {
      if (
        (e.hook_event_name === "PreToolUse" ||
          e.hook_event_name === "PostToolUse") &&
        (e.tool_name === "Edit" ||
          e.tool_name === "MultiEdit" ||
          e.tool_name === "Write")
      )
        return e.tool_input?.file_path;
    }
    findNewDiagnostics(e, r) {
      let n = [];
      for (let s of r) {
        let a = e.find((i) => i.uri === s.uri);
        if (!a) n.push(s);
        else {
          let i =
              a.linesInFile !== void 0 && s.linesInFile !== void 0
                ? Math.abs(a.linesInFile - s.linesInFile)
                : 0,
            o = s.diagnostics.filter(
              (c) =>
                !a.diagnostics.some((l) => this.areDiagnosticsEqual(c, l, i)),
            );
          o.length > 0 &&
            n.push({ uri: s.uri, linesInFile: s.linesInFile, diagnostics: o });
        }
      }
      return n;
    }
    areDiagnosticsEqual(e, r, n) {
      let s = Math.abs(
          (e.range?.start?.line ?? 0) - (r.range?.start?.line ?? 0),
        ),
        a = Math.abs((e.range?.end?.line ?? 0) - (r.range?.end?.line ?? 0));
      return (
        e.message === r.message &&
        e.severity === r.severity &&
        e.source === r.source &&
        e.code === r.code &&
        s <= n &&
        a <= n &&
        e.range?.start?.character === r.range?.start?.character &&
        e.range?.end?.character === r.range?.end?.character
      );
    }
    formatDiagnosticsSummary(e) {
      let r = e.flatMap((n) =>
        n.diagnostics.map((s) => ({
          filePath: this.normalizeFileUri(n.uri),
          line: s.range?.start?.line !== void 0 ? s.range.start.line + 1 : 0,
          column:
            s.range?.start?.character !== void 0
              ? s.range.start.character + 1
              : 0,
          message: s.message,
          code: s.code || "",
          severity: s.severity || "",
        })),
      );
      return JSON.stringify(r, null, 2);
    }
    normalizeFileUri(e) {
      let r = ["file://", "_claude_fs_right:", "_claude_fs_left:"];
      for (let n of r) if (e.startsWith(n)) return e.slice(n.length);
      return e;
    }
  };
var Cd = le(require("path"), 1),
  Cr = le(require("fs"), 1);
var Fc = le(require("crypto"), 1),
  YR = le(require("http"), 1);
function xc(t, e) {
  return function () {
    return t.apply(e, arguments);
  };
}
var { toString: $W } = Object.prototype,
  { getPrototypeOf: tg } = Object,
  Wu = ((t) => (e) => {
    let r = $W.call(e);
    return t[r] || (t[r] = r.slice(8, -1).toLowerCase());
  })(Object.create(null)),
  vn = (t) => ((t = t.toLowerCase()), (e) => Wu(e) === t),
  Ku = (t) => (e) => typeof e === t,
  { isArray: qi } = Array,
  wc = Ku("undefined");
function AW(t) {
  return (
    t !== null &&
    !wc(t) &&
    t.constructor !== null &&
    !wc(t.constructor) &&
    Fr(t.constructor.isBuffer) &&
    t.constructor.isBuffer(t)
  );
}
var _C = vn("ArrayBuffer");
function NW(t) {
  let e;
  return (
    typeof ArrayBuffer < "u" && ArrayBuffer.isView
      ? (e = ArrayBuffer.isView(t))
      : (e = t && t.buffer && _C(t.buffer)),
    e
  );
}
var DW = Ku("string"),
  Fr = Ku("function"),
  xC = Ku("number"),
  Ju = (t) => t !== null && typeof t == "object",
  LW = (t) => t === !0 || t === !1,
  Gu = (t) => {
    if (Wu(t) !== "object") return !1;
    let e = tg(t);
    return (
      (e === null ||
        e === Object.prototype ||
        Object.getPrototypeOf(e) === null) &&
      !(Symbol.toStringTag in t) &&
      !(Symbol.iterator in t)
    );
  },
  MW = vn("Date"),
  jW = vn("File"),
  FW = vn("Blob"),
  UW = vn("FileList"),
  qW = (t) => Ju(t) && Fr(t.pipe),
  zW = (t) => {
    let e;
    return (
      t &&
      ((typeof FormData == "function" && t instanceof FormData) ||
        (Fr(t.append) &&
          ((e = Wu(t)) === "formdata" ||
            (e === "object" &&
              Fr(t.toString) &&
              t.toString() === "[object FormData]"))))
    );
  },
  BW = vn("URLSearchParams"),
  [HW, VW, ZW, GW] = ["ReadableStream", "Request", "Response", "Headers"].map(
    vn,
  ),
  WW = (t) =>
    t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Sc(t, e, { allOwnKeys: r = !1 } = {}) {
  if (t === null || typeof t > "u") return;
  let n, s;
  if ((typeof t != "object" && (t = [t]), qi(t)))
    for (n = 0, s = t.length; n < s; n++) e.call(null, t[n], n, t);
  else {
    let a = r ? Object.getOwnPropertyNames(t) : Object.keys(t),
      i = a.length,
      o;
    for (n = 0; n < i; n++) ((o = a[n]), e.call(null, t[o], o, t));
  }
}
function wC(t, e) {
  e = e.toLowerCase();
  let r = Object.keys(t),
    n = r.length,
    s;
  for (; n-- > 0; ) if (((s = r[n]), e === s.toLowerCase())) return s;
  return null;
}
var Sa =
    typeof globalThis < "u"
      ? globalThis
      : typeof self < "u"
        ? self
        : typeof window < "u"
          ? window
          : global,
  SC = (t) => !wc(t) && t !== Sa;
function eg() {
  let { caseless: t } = (SC(this) && this) || {},
    e = {},
    r = (n, s) => {
      let a = (t && wC(e, s)) || s;
      Gu(e[a]) && Gu(n)
        ? (e[a] = eg(e[a], n))
        : Gu(n)
          ? (e[a] = eg({}, n))
          : qi(n)
            ? (e[a] = n.slice())
            : (e[a] = n);
    };
  for (let n = 0, s = arguments.length; n < s; n++)
    arguments[n] && Sc(arguments[n], r);
  return e;
}
var KW = (t, e, r, { allOwnKeys: n } = {}) => (
    Sc(
      e,
      (s, a) => {
        r && Fr(s) ? (t[a] = xc(s, r)) : (t[a] = s);
      },
      { allOwnKeys: n },
    ),
    t
  ),
  JW = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t),
  XW = (t, e, r, n) => {
    ((t.prototype = Object.create(e.prototype, n)),
      (t.prototype.constructor = t),
      Object.defineProperty(t, "super", { value: e.prototype }),
      r && Object.assign(t.prototype, r));
  },
  YW = (t, e, r, n) => {
    let s,
      a,
      i,
      o = {};
    if (((e = e || {}), t == null)) return e;
    do {
      for (s = Object.getOwnPropertyNames(t), a = s.length; a-- > 0; )
        ((i = s[a]),
          (!n || n(i, t, e)) && !o[i] && ((e[i] = t[i]), (o[i] = !0)));
      t = r !== !1 && tg(t);
    } while (t && (!r || r(t, e)) && t !== Object.prototype);
    return e;
  },
  QW = (t, e, r) => {
    ((t = String(t)),
      (r === void 0 || r > t.length) && (r = t.length),
      (r -= e.length));
    let n = t.indexOf(e, r);
    return n !== -1 && n === r;
  },
  e5 = (t) => {
    if (!t) return null;
    if (qi(t)) return t;
    let e = t.length;
    if (!xC(e)) return null;
    let r = new Array(e);
    for (; e-- > 0; ) r[e] = t[e];
    return r;
  },
  t5 = (
    (t) => (e) =>
      t && e instanceof t
  )(typeof Uint8Array < "u" && tg(Uint8Array)),
  r5 = (t, e) => {
    let n = (t && t[Symbol.iterator]).call(t),
      s;
    for (; (s = n.next()) && !s.done; ) {
      let a = s.value;
      e.call(t, a[0], a[1]);
    }
  },
  n5 = (t, e) => {
    let r,
      n = [];
    for (; (r = t.exec(e)) !== null; ) n.push(r);
    return n;
  },
  s5 = vn("HTMLFormElement"),
  a5 = (t) =>
    t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (r, n, s) {
      return n.toUpperCase() + s;
    }),
  bC = (
    ({ hasOwnProperty: t }) =>
    (e, r) =>
      t.call(e, r)
  )(Object.prototype),
  i5 = vn("RegExp"),
  EC = (t, e) => {
    let r = Object.getOwnPropertyDescriptors(t),
      n = {};
    (Sc(r, (s, a) => {
      let i;
      (i = e(s, a, t)) !== !1 && (n[a] = i || s);
    }),
      Object.defineProperties(t, n));
  },
  o5 = (t) => {
    EC(t, (e, r) => {
      if (Fr(t) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
        return !1;
      let n = t[r];
      if (Fr(n)) {
        if (((e.enumerable = !1), "writable" in e)) {
          e.writable = !1;
          return;
        }
        e.set ||
          (e.set = () => {
            throw Error("Can not rewrite read-only method '" + r + "'");
          });
      }
    });
  },
  c5 = (t, e) => {
    let r = {},
      n = (s) => {
        s.forEach((a) => {
          r[a] = !0;
        });
      };
    return (qi(t) ? n(t) : n(String(t).split(e)), r);
  },
  l5 = () => {},
  u5 = (t, e) => (t != null && Number.isFinite((t = +t)) ? t : e);
function d5(t) {
  return !!(
    t &&
    Fr(t.append) &&
    t[Symbol.toStringTag] === "FormData" &&
    t[Symbol.iterator]
  );
}
var p5 = (t) => {
    let e = new Array(10),
      r = (n, s) => {
        if (Ju(n)) {
          if (e.indexOf(n) >= 0) return;
          if (!("toJSON" in n)) {
            e[s] = n;
            let a = qi(n) ? [] : {};
            return (
              Sc(n, (i, o) => {
                let c = r(i, s + 1);
                !wc(c) && (a[o] = c);
              }),
              (e[s] = void 0),
              a
            );
          }
        }
        return n;
      };
    return r(t, 0);
  },
  f5 = vn("AsyncFunction"),
  m5 = (t) => t && (Ju(t) || Fr(t)) && Fr(t.then) && Fr(t.catch),
  TC = ((t, e) =>
    t
      ? setImmediate
      : e
        ? ((r, n) => (
            Sa.addEventListener(
              "message",
              ({ source: s, data: a }) => {
                s === Sa && a === r && n.length && n.shift()();
              },
              !1,
            ),
            (s) => {
              (n.push(s), Sa.postMessage(r, "*"));
            }
          ))(`axios@${Math.random()}`, [])
        : (r) => setTimeout(r))(
    typeof setImmediate == "function",
    Fr(Sa.postMessage),
  ),
  h5 =
    typeof queueMicrotask < "u"
      ? queueMicrotask.bind(Sa)
      : (typeof process < "u" && process.nextTick) || TC,
  L = {
    isArray: qi,
    isArrayBuffer: _C,
    isBuffer: AW,
    isFormData: zW,
    isArrayBufferView: NW,
    isString: DW,
    isNumber: xC,
    isBoolean: LW,
    isObject: Ju,
    isPlainObject: Gu,
    isReadableStream: HW,
    isRequest: VW,
    isResponse: ZW,
    isHeaders: GW,
    isUndefined: wc,
    isDate: MW,
    isFile: jW,
    isBlob: FW,
    isRegExp: i5,
    isFunction: Fr,
    isStream: qW,
    isURLSearchParams: BW,
    isTypedArray: t5,
    isFileList: UW,
    forEach: Sc,
    merge: eg,
    extend: KW,
    trim: WW,
    stripBOM: JW,
    inherits: XW,
    toFlatObject: YW,
    kindOf: Wu,
    kindOfTest: vn,
    endsWith: QW,
    toArray: e5,
    forEachEntry: r5,
    matchAll: n5,
    isHTMLForm: s5,
    hasOwnProperty: bC,
    hasOwnProp: bC,
    reduceDescriptors: EC,
    freezeMethods: o5,
    toObjectSet: c5,
    toCamelCase: a5,
    noop: l5,
    toFiniteNumber: u5,
    findKey: wC,
    global: Sa,
    isContextDefined: SC,
    isSpecCompliantForm: d5,
    toJSONObject: p5,
    isAsyncFn: f5,
    isThenable: m5,
    setImmediate: TC,
    asap: h5,
  };
function zi(t, e, r, n, s) {
  (Error.call(this),
    Error.captureStackTrace
      ? Error.captureStackTrace(this, this.constructor)
      : (this.stack = new Error().stack),
    (this.message = t),
    (this.name = "AxiosError"),
    e && (this.code = e),
    r && (this.config = r),
    n && (this.request = n),
    s && ((this.response = s), (this.status = s.status ? s.status : null)));
}
L.inherits(zi, Error, {
  toJSON: function () {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: L.toJSONObject(this.config),
      code: this.code,
      status: this.status,
    };
  },
});
var CC = zi.prototype,
  PC = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL",
].forEach((t) => {
  PC[t] = { value: t };
});
Object.defineProperties(zi, PC);
Object.defineProperty(CC, "isAxiosError", { value: !0 });
zi.from = (t, e, r, n, s, a) => {
  let i = Object.create(CC);
  return (
    L.toFlatObject(
      t,
      i,
      function (c) {
        return c !== Error.prototype;
      },
      (o) => o !== "isAxiosError",
    ),
    zi.call(i, t.message, e, r, n, s),
    (i.cause = t),
    (i.name = t.name),
    a && Object.assign(i, a),
    i
  );
};
var pe = zi;
var Ik = le(Ok(), 1),
  id = Ik.default;
function wg(t) {
  return L.isPlainObject(t) || L.isArray(t);
}
function Ak(t) {
  return L.endsWith(t, "[]") ? t.slice(0, -2) : t;
}
function $k(t, e, r) {
  return t
    ? t
        .concat(e)
        .map(function (s, a) {
          return ((s = Ak(s)), !r && a ? "[" + s + "]" : s);
        })
        .join(r ? "." : "")
    : e;
}
function Q8(t) {
  return L.isArray(t) && !t.some(wg);
}
var eK = L.toFlatObject(L, {}, null, function (e) {
  return /^is[A-Z]/.test(e);
});
function tK(t, e, r) {
  if (!L.isObject(t)) throw new TypeError("target must be an object");
  ((e = e || new (id || FormData)()),
    (r = L.toFlatObject(
      r,
      { metaTokens: !0, dots: !1, indexes: !1 },
      !1,
      function (y, h) {
        return !L.isUndefined(h[y]);
      },
    )));
  let n = r.metaTokens,
    s = r.visitor || u,
    a = r.dots,
    i = r.indexes,
    c = (r.Blob || (typeof Blob < "u" && Blob)) && L.isSpecCompliantForm(e);
  if (!L.isFunction(s)) throw new TypeError("visitor must be a function");
  function l(f) {
    if (f === null) return "";
    if (L.isDate(f)) return f.toISOString();
    if (!c && L.isBlob(f))
      throw new pe("Blob is not supported. Use a Buffer instead.");
    return L.isArrayBuffer(f) || L.isTypedArray(f)
      ? c && typeof Blob == "function"
        ? new Blob([f])
        : Buffer.from(f)
      : f;
  }
  function u(f, y, h) {
    let g = f;
    if (f && !h && typeof f == "object") {
      if (L.endsWith(y, "{}"))
        ((y = n ? y : y.slice(0, -2)), (f = JSON.stringify(f)));
      else if (
        (L.isArray(f) && Q8(f)) ||
        ((L.isFileList(f) || L.endsWith(y, "[]")) && (g = L.toArray(f)))
      )
        return (
          (y = Ak(y)),
          g.forEach(function (v, b) {
            !(L.isUndefined(v) || v === null) &&
              e.append(
                i === !0 ? $k([y], b, a) : i === null ? y : y + "[]",
                l(v),
              );
          }),
          !1
        );
    }
    return wg(f) ? !0 : (e.append($k(h, y, a), l(f)), !1);
  }
  let d = [],
    m = Object.assign(eK, {
      defaultVisitor: u,
      convertValue: l,
      isVisitable: wg,
    });
  function p(f, y) {
    if (!L.isUndefined(f)) {
      if (d.indexOf(f) !== -1)
        throw Error("Circular reference detected in " + y.join("."));
      (d.push(f),
        L.forEach(f, function (g, _) {
          (!(L.isUndefined(g) || g === null) &&
            s.call(e, g, L.isString(_) ? _.trim() : _, y, m)) === !0 &&
            p(g, y ? y.concat(_) : [_]);
        }),
        d.pop());
    }
  }
  if (!L.isObject(t)) throw new TypeError("data must be an object");
  return (p(t), e);
}
var Ds = tK;
function Nk(t) {
  let e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0",
  };
  return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function (n) {
    return e[n];
  });
}
function Dk(t, e) {
  ((this._pairs = []), t && Ds(t, this, e));
}
var Lk = Dk.prototype;
Lk.append = function (e, r) {
  this._pairs.push([e, r]);
};
Lk.toString = function (e) {
  let r = e
    ? function (n) {
        return e.call(this, n, Nk);
      }
    : Nk;
  return this._pairs
    .map(function (s) {
      return r(s[0]) + "=" + r(s[1]);
    }, "")
    .join("&");
};
var Mk = Dk;
function rK(t) {
  return encodeURIComponent(t)
    .replace(/%3A/gi, ":")
    .replace(/%24/g, "$")
    .replace(/%2C/gi, ",")
    .replace(/%20/g, "+")
    .replace(/%5B/gi, "[")
    .replace(/%5D/gi, "]");
}
function Ta(t, e, r) {
  if (!e) return t;
  let n = (r && r.encode) || rK;
  L.isFunction(r) && (r = { serialize: r });
  let s = r && r.serialize,
    a;
  if (
    (s
      ? (a = s(e, r))
      : (a = L.isURLSearchParams(e) ? e.toString() : new Mk(e, r).toString(n)),
    a)
  ) {
    let i = t.indexOf("#");
    (i !== -1 && (t = t.slice(0, i)),
      (t += (t.indexOf("?") === -1 ? "?" : "&") + a));
  }
  return t;
}
var Sg = class {
    constructor() {
      this.handlers = [];
    }
    use(e, r, n) {
      return (
        this.handlers.push({
          fulfilled: e,
          rejected: r,
          synchronous: n ? n.synchronous : !1,
          runWhen: n ? n.runWhen : null,
        }),
        this.handlers.length - 1
      );
    }
    eject(e) {
      this.handlers[e] && (this.handlers[e] = null);
    }
    clear() {
      this.handlers && (this.handlers = []);
    }
    forEach(e) {
      L.forEach(this.handlers, function (n) {
        n !== null && e(n);
      });
    }
  },
  Eg = Sg;
var Gi = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1,
};
var qk = le(require("crypto"), 1);
var jk = le(require("url"), 1),
  Fk = jk.default.URLSearchParams;
var Tg = "abcdefghijklmnopqrstuvwxyz",
  Uk = "0123456789",
  zk = { DIGIT: Uk, ALPHA: Tg, ALPHA_DIGIT: Tg + Tg.toUpperCase() + Uk },
  nK = (t = 16, e = zk.ALPHA_DIGIT) => {
    let r = "",
      { length: n } = e,
      s = new Uint32Array(t);
    qk.default.randomFillSync(s);
    for (let a = 0; a < t; a++) r += e[s[a] % n];
    return r;
  },
  Bk = {
    isNode: !0,
    classes: {
      URLSearchParams: Fk,
      FormData: id,
      Blob: (typeof Blob < "u" && Blob) || null,
    },
    ALPHABET: zk,
    generateString: nK,
    protocols: ["http", "https", "file", "data"],
  };
var kg = {};
Hp(kg, {
  hasBrowserEnv: () => Pg,
  hasStandardBrowserEnv: () => sK,
  hasStandardBrowserWebWorkerEnv: () => aK,
  navigator: () => Cg,
  origin: () => iK,
});
var Pg = typeof window < "u" && typeof document < "u",
  Cg = (typeof navigator == "object" && navigator) || void 0,
  sK =
    Pg &&
    (!Cg || ["ReactNative", "NativeScript", "NS"].indexOf(Cg.product) < 0),
  aK =
    typeof WorkerGlobalScope < "u" &&
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts == "function",
  iK = (Pg && window.location.href) || "http://localhost";
var at = { ...kg, ...Bk };
function Rg(t, e) {
  return Ds(
    t,
    new at.classes.URLSearchParams(),
    Object.assign(
      {
        visitor: function (r, n, s, a) {
          return at.isNode && L.isBuffer(r)
            ? (this.append(n, r.toString("base64")), !1)
            : a.defaultVisitor.apply(this, arguments);
        },
      },
      e,
    ),
  );
}
function oK(t) {
  return L.matchAll(/\w+|\[(\w*)]/g, t).map((e) =>
    e[0] === "[]" ? "" : e[1] || e[0],
  );
}
function cK(t) {
  let e = {},
    r = Object.keys(t),
    n,
    s = r.length,
    a;
  for (n = 0; n < s; n++) ((a = r[n]), (e[a] = t[a]));
  return e;
}
function lK(t) {
  function e(r, n, s, a) {
    let i = r[a++];
    if (i === "__proto__") return !0;
    let o = Number.isFinite(+i),
      c = a >= r.length;
    return (
      (i = !i && L.isArray(s) ? s.length : i),
      c
        ? (L.hasOwnProp(s, i) ? (s[i] = [s[i], n]) : (s[i] = n), !o)
        : ((!s[i] || !L.isObject(s[i])) && (s[i] = []),
          e(r, n, s[i], a) && L.isArray(s[i]) && (s[i] = cK(s[i])),
          !o)
    );
  }
  if (L.isFormData(t) && L.isFunction(t.entries)) {
    let r = {};
    return (
      L.forEachEntry(t, (n, s) => {
        e(oK(n), s, r, 0);
      }),
      r
    );
  }
  return null;
}
var od = lK;
function uK(t, e, r) {
  if (L.isString(t))
    try {
      return ((e || JSON.parse)(t), L.trim(t));
    } catch (n) {
      if (n.name !== "SyntaxError") throw n;
    }
  return (r || JSON.stringify)(t);
}
var Og = {
  transitional: Gi,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [
    function (e, r) {
      let n = r.getContentType() || "",
        s = n.indexOf("application/json") > -1,
        a = L.isObject(e);
      if ((a && L.isHTMLForm(e) && (e = new FormData(e)), L.isFormData(e)))
        return s ? JSON.stringify(od(e)) : e;
      if (
        L.isArrayBuffer(e) ||
        L.isBuffer(e) ||
        L.isStream(e) ||
        L.isFile(e) ||
        L.isBlob(e) ||
        L.isReadableStream(e)
      )
        return e;
      if (L.isArrayBufferView(e)) return e.buffer;
      if (L.isURLSearchParams(e))
        return (
          r.setContentType(
            "application/x-www-form-urlencoded;charset=utf-8",
            !1,
          ),
          e.toString()
        );
      let o;
      if (a) {
        if (n.indexOf("application/x-www-form-urlencoded") > -1)
          return Rg(e, this.formSerializer).toString();
        if ((o = L.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
          let c = this.env && this.env.FormData;
          return Ds(
            o ? { "files[]": e } : e,
            c && new c(),
            this.formSerializer,
          );
        }
      }
      return a || s ? (r.setContentType("application/json", !1), uK(e)) : e;
    },
  ],
  transformResponse: [
    function (e) {
      let r = this.transitional || Og.transitional,
        n = r && r.forcedJSONParsing,
        s = this.responseType === "json";
      if (L.isResponse(e) || L.isReadableStream(e)) return e;
      if (e && L.isString(e) && ((n && !this.responseType) || s)) {
        let i = !(r && r.silentJSONParsing) && s;
        try {
          return JSON.parse(e);
        } catch (o) {
          if (i)
            throw o.name === "SyntaxError"
              ? pe.from(o, pe.ERR_BAD_RESPONSE, this, null, this.response)
              : o;
        }
      }
      return e;
    },
  ],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: { FormData: at.classes.FormData, Blob: at.classes.Blob },
  validateStatus: function (e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0,
    },
  },
};
L.forEach(["delete", "get", "head", "post", "put", "patch"], (t) => {
  Og.headers[t] = {};
});
var Wi = Og;
var dK = L.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent",
  ]),
  Hk = (t) => {
    let e = {},
      r,
      n,
      s;
    return (
      t &&
        t
          .split(
            `
`,
          )
          .forEach(function (i) {
            ((s = i.indexOf(":")),
              (r = i.substring(0, s).trim().toLowerCase()),
              (n = i.substring(s + 1).trim()),
              !(!r || (e[r] && dK[r])) &&
                (r === "set-cookie"
                  ? e[r]
                    ? e[r].push(n)
                    : (e[r] = [n])
                  : (e[r] = e[r] ? e[r] + ", " + n : n)));
          }),
      e
    );
  };
var Vk = Symbol("internals");
function kc(t) {
  return t && String(t).trim().toLowerCase();
}
function cd(t) {
  return t === !1 || t == null ? t : L.isArray(t) ? t.map(cd) : String(t);
}
function pK(t) {
  let e = Object.create(null),
    r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g,
    n;
  for (; (n = r.exec(t)); ) e[n[1]] = n[2];
  return e;
}
var fK = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());
function Ig(t, e, r, n, s) {
  if (L.isFunction(n)) return n.call(this, e, r);
  if ((s && (e = r), !!L.isString(e))) {
    if (L.isString(n)) return e.indexOf(n) !== -1;
    if (L.isRegExp(n)) return n.test(e);
  }
}
function mK(t) {
  return t
    .trim()
    .toLowerCase()
    .replace(/([a-z\d])(\w*)/g, (e, r, n) => r.toUpperCase() + n);
}
function hK(t, e) {
  let r = L.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(t, n + r, {
      value: function (s, a, i) {
        return this[n].call(this, e, s, a, i);
      },
      configurable: !0,
    });
  });
}
var Ki = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, r, n) {
    let s = this;
    function a(o, c, l) {
      let u = kc(c);
      if (!u) throw new Error("header name must be a non-empty string");
      let d = L.findKey(s, u);
      (!d || s[d] === void 0 || l === !0 || (l === void 0 && s[d] !== !1)) &&
        (s[d || c] = cd(o));
    }
    let i = (o, c) => L.forEach(o, (l, u) => a(l, u, c));
    if (L.isPlainObject(e) || e instanceof this.constructor) i(e, r);
    else if (L.isString(e) && (e = e.trim()) && !fK(e)) i(Hk(e), r);
    else if (L.isHeaders(e)) for (let [o, c] of e.entries()) a(c, o, n);
    else e != null && a(r, e, n);
    return this;
  }
  get(e, r) {
    if (((e = kc(e)), e)) {
      let n = L.findKey(this, e);
      if (n) {
        let s = this[n];
        if (!r) return s;
        if (r === !0) return pK(s);
        if (L.isFunction(r)) return r.call(this, s, n);
        if (L.isRegExp(r)) return r.exec(s);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, r) {
    if (((e = kc(e)), e)) {
      let n = L.findKey(this, e);
      return !!(n && this[n] !== void 0 && (!r || Ig(this, this[n], n, r)));
    }
    return !1;
  }
  delete(e, r) {
    let n = this,
      s = !1;
    function a(i) {
      if (((i = kc(i)), i)) {
        let o = L.findKey(n, i);
        o && (!r || Ig(n, n[o], o, r)) && (delete n[o], (s = !0));
      }
    }
    return (L.isArray(e) ? e.forEach(a) : a(e), s);
  }
  clear(e) {
    let r = Object.keys(this),
      n = r.length,
      s = !1;
    for (; n--; ) {
      let a = r[n];
      (!e || Ig(this, this[a], a, e, !0)) && (delete this[a], (s = !0));
    }
    return s;
  }
  normalize(e) {
    let r = this,
      n = {};
    return (
      L.forEach(this, (s, a) => {
        let i = L.findKey(n, a);
        if (i) {
          ((r[i] = cd(s)), delete r[a]);
          return;
        }
        let o = e ? mK(a) : String(a).trim();
        (o !== a && delete r[a], (r[o] = cd(s)), (n[o] = !0));
      }),
      this
    );
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    let r = Object.create(null);
    return (
      L.forEach(this, (n, s) => {
        n != null && n !== !1 && (r[s] = e && L.isArray(n) ? n.join(", ") : n);
      }),
      r
    );
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, r]) => e + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...r) {
    let n = new this(e);
    return (r.forEach((s) => n.set(s)), n);
  }
  static accessor(e) {
    let n = (this[Vk] = this[Vk] = { accessors: {} }).accessors,
      s = this.prototype;
    function a(i) {
      let o = kc(i);
      n[o] || (hK(s, i), (n[o] = !0));
    }
    return (L.isArray(e) ? e.forEach(a) : a(e), this);
  }
};
Ki.accessor([
  "Content-Type",
  "Content-Length",
  "Accept",
  "Accept-Encoding",
  "User-Agent",
  "Authorization",
]);
L.reduceDescriptors(Ki.prototype, ({ value: t }, e) => {
  let r = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => t,
    set(n) {
      this[r] = n;
    },
  };
});
L.freezeMethods(Ki);
var Nt = Ki;
function Rc(t, e) {
  let r = this || Wi,
    n = e || r,
    s = Nt.from(n.headers),
    a = n.data;
  return (
    L.forEach(t, function (o) {
      a = o.call(r, a, s.normalize(), e ? e.status : void 0);
    }),
    s.normalize(),
    a
  );
}
function Oc(t) {
  return !!(t && t.__CANCEL__);
}
function Zk(t, e, r) {
  (pe.call(this, t ?? "canceled", pe.ERR_CANCELED, e, r),
    (this.name = "CanceledError"));
}
L.inherits(Zk, pe, { __CANCEL__: !0 });
var Ur = Zk;
function Nn(t, e, r) {
  let n = r.config.validateStatus;
  !r.status || !n || n(r.status)
    ? t(r)
    : e(
        new pe(
          "Request failed with status code " + r.status,
          [pe.ERR_BAD_REQUEST, pe.ERR_BAD_RESPONSE][
            Math.floor(r.status / 100) - 4
          ],
          r.config,
          r.request,
          r,
        ),
      );
}
function $g(t) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
}
function Ag(t, e) {
  return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t;
}
function Ca(t, e, r) {
  let n = !$g(e);
  return t && (n || r == !1) ? Ag(t, e) : e;
}
var RR = le(Wk(), 1),
  OR = le(require("http"), 1),
  IR = le(require("https"), 1),
  $R = le(require("util"), 1),
  AR = le(fR(), 1),
  is = le(require("zlib"), 1);
var Oa = "1.8.4";
function Dc(t) {
  let e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
  return (e && e[1]) || "";
}
var rJ = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function Kg(t, e, r) {
  let n = (r && r.Blob) || at.classes.Blob,
    s = Dc(t);
  if ((e === void 0 && n && (e = !0), s === "data")) {
    t = s.length ? t.slice(s.length + 1) : t;
    let a = rJ.exec(t);
    if (!a) throw new pe("Invalid URL", pe.ERR_INVALID_URL);
    let i = a[1],
      o = a[2],
      c = a[3],
      l = Buffer.from(decodeURIComponent(c), o ? "base64" : "utf8");
    if (e) {
      if (!n) throw new pe("Blob is not supported", pe.ERR_NOT_SUPPORT);
      return new n([l], { type: i });
    }
    return l;
  }
  throw new pe("Unsupported protocol " + s, pe.ERR_NOT_SUPPORT);
}
var Ia = le(require("stream"), 1);
var mR = le(require("stream"), 1);
var Jg = Symbol("internals"),
  Xg = class extends mR.default.Transform {
    constructor(e) {
      ((e = L.toFlatObject(
        e,
        {
          maxRate: 0,
          chunkSize: 64 * 1024,
          minChunkSize: 100,
          timeWindow: 500,
          ticksRate: 2,
          samplesCount: 15,
        },
        null,
        (n, s) => !L.isUndefined(s[n]),
      )),
        super({ readableHighWaterMark: e.chunkSize }));
      let r = (this[Jg] = {
        timeWindow: e.timeWindow,
        chunkSize: e.chunkSize,
        maxRate: e.maxRate,
        minChunkSize: e.minChunkSize,
        bytesSeen: 0,
        isCaptured: !1,
        notifiedBytesLoaded: 0,
        ts: Date.now(),
        bytes: 0,
        onReadCallback: null,
      });
      this.on("newListener", (n) => {
        n === "progress" && (r.isCaptured || (r.isCaptured = !0));
      });
    }
    _read(e) {
      let r = this[Jg];
      return (r.onReadCallback && r.onReadCallback(), super._read(e));
    }
    _transform(e, r, n) {
      let s = this[Jg],
        a = s.maxRate,
        i = this.readableHighWaterMark,
        o = s.timeWindow,
        c = 1e3 / o,
        l = a / c,
        u = s.minChunkSize !== !1 ? Math.max(s.minChunkSize, l * 0.01) : 0,
        d = (p, f) => {
          let y = Buffer.byteLength(p);
          ((s.bytesSeen += y),
            (s.bytes += y),
            s.isCaptured && this.emit("progress", s.bytesSeen),
            this.push(p)
              ? process.nextTick(f)
              : (s.onReadCallback = () => {
                  ((s.onReadCallback = null), process.nextTick(f));
                }));
        },
        m = (p, f) => {
          let y = Buffer.byteLength(p),
            h = null,
            g = i,
            _,
            v = 0;
          if (a) {
            let b = Date.now();
            ((!s.ts || (v = b - s.ts) >= o) &&
              ((s.ts = b),
              (_ = l - s.bytes),
              (s.bytes = _ < 0 ? -_ : 0),
              (v = 0)),
              (_ = l - s.bytes));
          }
          if (a) {
            if (_ <= 0)
              return setTimeout(() => {
                f(null, p);
              }, o - v);
            _ < g && (g = _);
          }
          (g &&
            y > g &&
            y - g > u &&
            ((h = p.subarray(g)), (p = p.subarray(0, g))),
            d(
              p,
              h
                ? () => {
                    process.nextTick(f, null, h);
                  }
                : f,
            ));
        };
      m(e, function p(f, y) {
        if (f) return n(f);
        y ? m(y, p) : n(null);
      });
    }
  },
  Yg = Xg;
var NR = require("events");
var gR = le(require("util"), 1),
  vR = require("stream");
var { asyncIterator: hR } = Symbol,
  nJ = async function* (t) {
    t.stream
      ? yield* t.stream()
      : t.arrayBuffer
        ? yield await t.arrayBuffer()
        : t[hR]
          ? yield* t[hR]()
          : yield t;
  },
  md = nJ;
var sJ = at.ALPHABET.ALPHA_DIGIT + "-_",
  Lc =
    typeof TextEncoder == "function"
      ? new TextEncoder()
      : new gR.default.TextEncoder(),
  Ls = `\r
`,
  aJ = Lc.encode(Ls),
  iJ = 2,
  Qg = class {
    constructor(e, r) {
      let { escapeName: n } = this.constructor,
        s = L.isString(r),
        a = `Content-Disposition: form-data; name="${n(e)}"${!s && r.name ? `; filename="${n(r.name)}"` : ""}${Ls}`;
      (s
        ? (r = Lc.encode(String(r).replace(/\r?\n|\r\n?/g, Ls)))
        : (a += `Content-Type: ${r.type || "application/octet-stream"}${Ls}`),
        (this.headers = Lc.encode(a + Ls)),
        (this.contentLength = s ? r.byteLength : r.size),
        (this.size = this.headers.byteLength + this.contentLength + iJ),
        (this.name = e),
        (this.value = r));
    }
    async *encode() {
      yield this.headers;
      let { value: e } = this;
      (L.isTypedArray(e) ? yield e : yield* md(e), yield aJ);
    }
    static escapeName(e) {
      return String(e).replace(
        /[\r\n"]/g,
        (r) => ({ "\r": "%0D", "\n": "%0A", '"': "%22" })[r],
      );
    }
  },
  oJ = (t, e, r) => {
    let {
      tag: n = "form-data-boundary",
      size: s = 25,
      boundary: a = n + "-" + at.generateString(s, sJ),
    } = r || {};
    if (!L.isFormData(t)) throw TypeError("FormData instance required");
    if (a.length < 1 || a.length > 70)
      throw Error("boundary must be 10-70 characters long");
    let i = Lc.encode("--" + a + Ls),
      o = Lc.encode("--" + a + "--" + Ls + Ls),
      c = o.byteLength,
      l = Array.from(t.entries()).map(([d, m]) => {
        let p = new Qg(d, m);
        return ((c += p.size), p);
      });
    ((c += i.byteLength * l.length), (c = L.toFiniteNumber(c)));
    let u = { "Content-Type": `multipart/form-data; boundary=${a}` };
    return (
      Number.isFinite(c) && (u["Content-Length"] = c),
      e && e(u),
      vR.Readable.from(
        (async function* () {
          for (let d of l) (yield i, yield* d.encode());
          yield o;
        })(),
      )
    );
  },
  yR = oJ;
var bR = le(require("stream"), 1),
  ev = class extends bR.default.Transform {
    __transform(e, r, n) {
      (this.push(e), n());
    }
    _transform(e, r, n) {
      if (
        e.length !== 0 &&
        ((this._transform = this.__transform), e[0] !== 120)
      ) {
        let s = Buffer.alloc(2);
        ((s[0] = 120), (s[1] = 156), this.push(s, r));
      }
      this.__transform(e, r, n);
    }
  },
  _R = ev;
var cJ = (t, e) =>
    L.isAsyncFn(t)
      ? function (...r) {
          let n = r.pop();
          t.apply(this, r).then((s) => {
            try {
              e ? n(null, ...e(s)) : n(null, s);
            } catch (a) {
              n(a);
            }
          }, n);
        }
      : t,
  xR = cJ;
function lJ(t, e) {
  t = t || 10;
  let r = new Array(t),
    n = new Array(t),
    s = 0,
    a = 0,
    i;
  return (
    (e = e !== void 0 ? e : 1e3),
    function (c) {
      let l = Date.now(),
        u = n[a];
      (i || (i = l), (r[s] = c), (n[s] = l));
      let d = a,
        m = 0;
      for (; d !== s; ) ((m += r[d++]), (d = d % t));
      if (((s = (s + 1) % t), s === a && (a = (a + 1) % t), l - i < e)) return;
      let p = u && l - u;
      return p ? Math.round((m * 1e3) / p) : void 0;
    }
  );
}
var wR = lJ;
function uJ(t, e) {
  let r = 0,
    n = 1e3 / e,
    s,
    a,
    i = (l, u = Date.now()) => {
      ((r = u),
        (s = null),
        a && (clearTimeout(a), (a = null)),
        t.apply(null, l));
    };
  return [
    (...l) => {
      let u = Date.now(),
        d = u - r;
      d >= n
        ? i(l, u)
        : ((s = l),
          a ||
            (a = setTimeout(() => {
              ((a = null), i(s));
            }, n - d)));
    },
    () => s && i(s),
  ];
}
var SR = uJ;
var as = (t, e, r = 3) => {
    let n = 0,
      s = wR(50, 250);
    return SR((a) => {
      let i = a.loaded,
        o = a.lengthComputable ? a.total : void 0,
        c = i - n,
        l = s(c),
        u = i <= o;
      n = i;
      let d = {
        loaded: i,
        total: o,
        progress: o ? i / o : void 0,
        bytes: c,
        rate: l || void 0,
        estimated: l && o && u ? (o - i) / l : void 0,
        event: a,
        lengthComputable: o != null,
        [e ? "download" : "upload"]: !0,
      };
      t(d);
    }, r);
  },
  eo = (t, e) => {
    let r = t != null;
    return [(n) => e[0]({ lengthComputable: r, total: t, loaded: n }), e[1]];
  },
  to =
    (t) =>
    (...e) =>
      L.asap(() => t(...e));
var ER = {
    flush: is.default.constants.Z_SYNC_FLUSH,
    finishFlush: is.default.constants.Z_SYNC_FLUSH,
  },
  dJ = {
    flush: is.default.constants.BROTLI_OPERATION_FLUSH,
    finishFlush: is.default.constants.BROTLI_OPERATION_FLUSH,
  },
  TR = L.isFunction(is.default.createBrotliDecompress),
  { http: pJ, https: fJ } = AR.default,
  mJ = /https:?/,
  CR = at.protocols.map((t) => t + ":"),
  PR = (t, [e, r]) => (t.on("end", r).on("error", r), e);
function hJ(t, e) {
  (t.beforeRedirects.proxy && t.beforeRedirects.proxy(t),
    t.beforeRedirects.config && t.beforeRedirects.config(t, e));
}
function DR(t, e, r) {
  let n = e;
  if (!n && n !== !1) {
    let s = RR.default.getProxyForUrl(r);
    s && (n = new URL(s));
  }
  if (n) {
    if (
      (n.username && (n.auth = (n.username || "") + ":" + (n.password || "")),
      n.auth)
    ) {
      (n.auth.username || n.auth.password) &&
        (n.auth = (n.auth.username || "") + ":" + (n.auth.password || ""));
      let a = Buffer.from(n.auth, "utf8").toString("base64");
      t.headers["Proxy-Authorization"] = "Basic " + a;
    }
    t.headers.host = t.hostname + (t.port ? ":" + t.port : "");
    let s = n.hostname || n.host;
    ((t.hostname = s),
      (t.host = s),
      (t.port = n.port),
      (t.path = r),
      n.protocol &&
        (t.protocol = n.protocol.includes(":")
          ? n.protocol
          : `${n.protocol}:`));
  }
  t.beforeRedirects.proxy = function (a) {
    DR(a, e, a.href);
  };
}
var gJ = typeof process < "u" && L.kindOf(process) === "process",
  vJ = (t) =>
    new Promise((e, r) => {
      let n,
        s,
        a = (c, l) => {
          s || ((s = !0), n && n(c, l));
        },
        i = (c) => {
          (a(c), e(c));
        },
        o = (c) => {
          (a(c, !0), r(c));
        };
      t(i, o, (c) => (n = c)).catch(o);
    }),
  yJ = ({ address: t, family: e }) => {
    if (!L.isString(t)) throw TypeError("address must be a string");
    return { address: t, family: e || (t.indexOf(".") < 0 ? 6 : 4) };
  },
  kR = (t, e) => yJ(L.isObject(t) ? t : { address: t, family: e }),
  LR =
    gJ &&
    function (e) {
      return vJ(async function (n, s, a) {
        let { data: i, lookup: o, family: c } = e,
          { responseType: l, responseEncoding: u } = e,
          d = e.method.toUpperCase(),
          m,
          p = !1,
          f;
        if (o) {
          let Y = xR(o, (Q) => (L.isArray(Q) ? Q : [Q]));
          o = (Q, ae, B) => {
            Y(Q, ae, ($, G, U) => {
              if ($) return B($);
              let T = L.isArray(G) ? G.map((O) => kR(O)) : [kR(G, U)];
              ae.all ? B($, T) : B($, T[0].address, T[0].family);
            });
          };
        }
        let y = new NR.EventEmitter(),
          h = () => {
            (e.cancelToken && e.cancelToken.unsubscribe(g),
              e.signal && e.signal.removeEventListener("abort", g),
              y.removeAllListeners());
          };
        a((Y, Q) => {
          ((m = !0), Q && ((p = !0), h()));
        });
        function g(Y) {
          y.emit("abort", !Y || Y.type ? new Ur(null, e, f) : Y);
        }
        (y.once("abort", s),
          (e.cancelToken || e.signal) &&
            (e.cancelToken && e.cancelToken.subscribe(g),
            e.signal &&
              (e.signal.aborted
                ? g()
                : e.signal.addEventListener("abort", g))));
        let _ = Ca(e.baseURL, e.url, e.allowAbsoluteUrls),
          v = new URL(_, at.hasBrowserEnv ? at.origin : void 0),
          b = v.protocol || CR[0];
        if (b === "data:") {
          let Y;
          if (d !== "GET")
            return Nn(n, s, {
              status: 405,
              statusText: "method not allowed",
              headers: {},
              config: e,
            });
          try {
            Y = Kg(e.url, l === "blob", { Blob: e.env && e.env.Blob });
          } catch (Q) {
            throw pe.from(Q, pe.ERR_BAD_REQUEST, e);
          }
          return (
            l === "text"
              ? ((Y = Y.toString(u)),
                (!u || u === "utf8") && (Y = L.stripBOM(Y)))
              : l === "stream" && (Y = Ia.default.Readable.from(Y)),
            Nn(n, s, {
              data: Y,
              status: 200,
              statusText: "OK",
              headers: new Nt(),
              config: e,
            })
          );
        }
        if (CR.indexOf(b) === -1)
          return s(new pe("Unsupported protocol " + b, pe.ERR_BAD_REQUEST, e));
        let x = Nt.from(e.headers).normalize();
        x.set("User-Agent", "axios/" + Oa, !1);
        let { onUploadProgress: w, onDownloadProgress: S } = e,
          C = e.maxRate,
          P,
          A;
        if (L.isSpecCompliantForm(i)) {
          let Y = x.getContentType(/boundary=([-_\w\d]{10,70})/i);
          i = yR(
            i,
            (Q) => {
              x.set(Q);
            },
            { tag: `axios-${Oa}-boundary`, boundary: (Y && Y[1]) || void 0 },
          );
        } else if (L.isFormData(i) && L.isFunction(i.getHeaders)) {
          if ((x.set(i.getHeaders()), !x.hasContentLength()))
            try {
              let Y = await $R.default.promisify(i.getLength).call(i);
              Number.isFinite(Y) && Y >= 0 && x.setContentLength(Y);
            } catch {}
        } else if (L.isBlob(i) || L.isFile(i))
          (i.size && x.setContentType(i.type || "application/octet-stream"),
            x.setContentLength(i.size || 0),
            (i = Ia.default.Readable.from(md(i))));
        else if (i && !L.isStream(i)) {
          if (!Buffer.isBuffer(i))
            if (L.isArrayBuffer(i)) i = Buffer.from(new Uint8Array(i));
            else if (L.isString(i)) i = Buffer.from(i, "utf-8");
            else
              return s(
                new pe(
                  "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
                  pe.ERR_BAD_REQUEST,
                  e,
                ),
              );
          if (
            (x.setContentLength(i.length, !1),
            e.maxBodyLength > -1 && i.length > e.maxBodyLength)
          )
            return s(
              new pe(
                "Request body larger than maxBodyLength limit",
                pe.ERR_BAD_REQUEST,
                e,
              ),
            );
        }
        let R = L.toFiniteNumber(x.getContentLength());
        (L.isArray(C) ? ((P = C[0]), (A = C[1])) : (P = A = C),
          i &&
            (w || P) &&
            (L.isStream(i) ||
              (i = Ia.default.Readable.from(i, { objectMode: !1 })),
            (i = Ia.default.pipeline(
              [i, new Yg({ maxRate: L.toFiniteNumber(P) })],
              L.noop,
            )),
            w && i.on("progress", PR(i, eo(R, as(to(w), !1, 3))))));
        let D;
        if (e.auth) {
          let Y = e.auth.username || "",
            Q = e.auth.password || "";
          D = Y + ":" + Q;
        }
        if (!D && v.username) {
          let Y = v.username,
            Q = v.password;
          D = Y + ":" + Q;
        }
        D && x.delete("authorization");
        let F;
        try {
          F = Ta(v.pathname + v.search, e.params, e.paramsSerializer).replace(
            /^\?/,
            "",
          );
        } catch (Y) {
          let Q = new Error(Y.message);
          return ((Q.config = e), (Q.url = e.url), (Q.exists = !0), s(Q));
        }
        x.set(
          "Accept-Encoding",
          "gzip, compress, deflate" + (TR ? ", br" : ""),
          !1,
        );
        let I = {
          path: F,
          method: d,
          headers: x.toJSON(),
          agents: { http: e.httpAgent, https: e.httpsAgent },
          auth: D,
          protocol: b,
          family: c,
          beforeRedirect: hJ,
          beforeRedirects: {},
        };
        (!L.isUndefined(o) && (I.lookup = o),
          e.socketPath
            ? (I.socketPath = e.socketPath)
            : ((I.hostname = v.hostname.startsWith("[")
                ? v.hostname.slice(1, -1)
                : v.hostname),
              (I.port = v.port),
              DR(
                I,
                e.proxy,
                b + "//" + v.hostname + (v.port ? ":" + v.port : "") + I.path,
              )));
        let K,
          ee = mJ.test(I.protocol);
        if (
          ((I.agent = ee ? e.httpsAgent : e.httpAgent),
          e.transport
            ? (K = e.transport)
            : e.maxRedirects === 0
              ? (K = ee ? IR.default : OR.default)
              : (e.maxRedirects && (I.maxRedirects = e.maxRedirects),
                e.beforeRedirect &&
                  (I.beforeRedirects.config = e.beforeRedirect),
                (K = ee ? fJ : pJ)),
          e.maxBodyLength > -1
            ? (I.maxBodyLength = e.maxBodyLength)
            : (I.maxBodyLength = 1 / 0),
          e.insecureHTTPParser && (I.insecureHTTPParser = e.insecureHTTPParser),
          (f = K.request(I, function (Q) {
            if (f.destroyed) return;
            let ae = [Q],
              B = +Q.headers["content-length"];
            if (S || A) {
              let O = new Yg({ maxRate: L.toFiniteNumber(A) });
              (S && O.on("progress", PR(O, eo(B, as(to(S), !0, 3)))),
                ae.push(O));
            }
            let $ = Q,
              G = Q.req || f;
            if (e.decompress !== !1 && Q.headers["content-encoding"])
              switch (
                ((d === "HEAD" || Q.statusCode === 204) &&
                  delete Q.headers["content-encoding"],
                (Q.headers["content-encoding"] || "").toLowerCase())
              ) {
                case "gzip":
                case "x-gzip":
                case "compress":
                case "x-compress":
                  (ae.push(is.default.createUnzip(ER)),
                    delete Q.headers["content-encoding"]);
                  break;
                case "deflate":
                  (ae.push(new _R()),
                    ae.push(is.default.createUnzip(ER)),
                    delete Q.headers["content-encoding"]);
                  break;
                case "br":
                  TR &&
                    (ae.push(is.default.createBrotliDecompress(dJ)),
                    delete Q.headers["content-encoding"]);
              }
            $ = ae.length > 1 ? Ia.default.pipeline(ae, L.noop) : ae[0];
            let U = Ia.default.finished($, () => {
                (U(), h());
              }),
              T = {
                status: Q.statusCode,
                statusText: Q.statusMessage,
                headers: new Nt(Q.headers),
                config: e,
                request: G,
              };
            if (l === "stream") ((T.data = $), Nn(n, s, T));
            else {
              let O = [],
                H = 0;
              ($.on("data", function (oe) {
                (O.push(oe),
                  (H += oe.length),
                  e.maxContentLength > -1 &&
                    H > e.maxContentLength &&
                    ((p = !0),
                    $.destroy(),
                    s(
                      new pe(
                        "maxContentLength size of " +
                          e.maxContentLength +
                          " exceeded",
                        pe.ERR_BAD_RESPONSE,
                        e,
                        G,
                      ),
                    )));
              }),
                $.on("aborted", function () {
                  if (p) return;
                  let oe = new pe(
                    "stream has been aborted",
                    pe.ERR_BAD_RESPONSE,
                    e,
                    G,
                  );
                  ($.destroy(oe), s(oe));
                }),
                $.on("error", function (oe) {
                  f.destroyed || s(pe.from(oe, null, e, G));
                }),
                $.on("end", function () {
                  try {
                    let oe = O.length === 1 ? O[0] : Buffer.concat(O);
                    (l !== "arraybuffer" &&
                      ((oe = oe.toString(u)),
                      (!u || u === "utf8") && (oe = L.stripBOM(oe))),
                      (T.data = oe));
                  } catch (oe) {
                    return s(pe.from(oe, null, e, T.request, T));
                  }
                  Nn(n, s, T);
                }));
            }
            y.once("abort", (O) => {
              $.destroyed || ($.emit("error", O), $.destroy());
            });
          })),
          y.once("abort", (Y) => {
            (s(Y), f.destroy(Y));
          }),
          f.on("error", function (Q) {
            s(pe.from(Q, null, e, f));
          }),
          f.on("socket", function (Q) {
            Q.setKeepAlive(!0, 1e3 * 60);
          }),
          e.timeout)
        ) {
          let Y = parseInt(e.timeout, 10);
          if (Number.isNaN(Y)) {
            s(
              new pe(
                "error trying to parse `config.timeout` to int",
                pe.ERR_BAD_OPTION_VALUE,
                e,
                f,
              ),
            );
            return;
          }
          f.setTimeout(Y, function () {
            if (m) return;
            let ae = e.timeout
                ? "timeout of " + e.timeout + "ms exceeded"
                : "timeout exceeded",
              B = e.transitional || Gi;
            (e.timeoutErrorMessage && (ae = e.timeoutErrorMessage),
              s(
                new pe(
                  ae,
                  B.clarifyTimeoutError ? pe.ETIMEDOUT : pe.ECONNABORTED,
                  e,
                  f,
                ),
              ),
              g());
          });
        }
        if (L.isStream(i)) {
          let Y = !1,
            Q = !1;
          (i.on("end", () => {
            Y = !0;
          }),
            i.once("error", (ae) => {
              ((Q = !0), f.destroy(ae));
            }),
            i.on("close", () => {
              !Y && !Q && g(new Ur("Request stream has been aborted", e, f));
            }),
            i.pipe(f));
        } else f.end(i);
      });
    };
var MR = at.hasStandardBrowserEnv
  ? ((t, e) => (r) => (
      (r = new URL(r, at.origin)),
      t.protocol === r.protocol && t.host === r.host && (e || t.port === r.port)
    ))(
      new URL(at.origin),
      at.navigator && /(msie|trident)/i.test(at.navigator.userAgent),
    )
  : () => !0;
var jR = at.hasStandardBrowserEnv
  ? {
      write(t, e, r, n, s, a) {
        let i = [t + "=" + encodeURIComponent(e)];
        (L.isNumber(r) && i.push("expires=" + new Date(r).toGMTString()),
          L.isString(n) && i.push("path=" + n),
          L.isString(s) && i.push("domain=" + s),
          a === !0 && i.push("secure"),
          (document.cookie = i.join("; ")));
      },
      read(t) {
        let e = document.cookie.match(
          new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"),
        );
        return e ? decodeURIComponent(e[3]) : null;
      },
      remove(t) {
        this.write(t, "", Date.now() - 864e5);
      },
    }
  : {
      write() {},
      read() {
        return null;
      },
      remove() {},
    };
var FR = (t) => (t instanceof Nt ? { ...t } : t);
function bn(t, e) {
  e = e || {};
  let r = {};
  function n(l, u, d, m) {
    return L.isPlainObject(l) && L.isPlainObject(u)
      ? L.merge.call({ caseless: m }, l, u)
      : L.isPlainObject(u)
        ? L.merge({}, u)
        : L.isArray(u)
          ? u.slice()
          : u;
  }
  function s(l, u, d, m) {
    if (L.isUndefined(u)) {
      if (!L.isUndefined(l)) return n(void 0, l, d, m);
    } else return n(l, u, d, m);
  }
  function a(l, u) {
    if (!L.isUndefined(u)) return n(void 0, u);
  }
  function i(l, u) {
    if (L.isUndefined(u)) {
      if (!L.isUndefined(l)) return n(void 0, l);
    } else return n(void 0, u);
  }
  function o(l, u, d) {
    if (d in e) return n(l, u);
    if (d in t) return n(void 0, l);
  }
  let c = {
    url: a,
    method: a,
    data: a,
    baseURL: i,
    transformRequest: i,
    transformResponse: i,
    paramsSerializer: i,
    timeout: i,
    timeoutMessage: i,
    withCredentials: i,
    withXSRFToken: i,
    adapter: i,
    responseType: i,
    xsrfCookieName: i,
    xsrfHeaderName: i,
    onUploadProgress: i,
    onDownloadProgress: i,
    decompress: i,
    maxContentLength: i,
    maxBodyLength: i,
    beforeRedirect: i,
    transport: i,
    httpAgent: i,
    httpsAgent: i,
    cancelToken: i,
    socketPath: i,
    responseEncoding: i,
    validateStatus: o,
    headers: (l, u, d) => s(FR(l), FR(u), d, !0),
  };
  return (
    L.forEach(Object.keys(Object.assign({}, t, e)), function (u) {
      let d = c[u] || s,
        m = d(t[u], e[u], u);
      (L.isUndefined(m) && d !== o) || (r[u] = m);
    }),
    r
  );
}
var hd = (t) => {
  let e = bn({}, t),
    {
      data: r,
      withXSRFToken: n,
      xsrfHeaderName: s,
      xsrfCookieName: a,
      headers: i,
      auth: o,
    } = e;
  ((e.headers = i = Nt.from(i)),
    (e.url = Ta(
      Ca(e.baseURL, e.url, e.allowAbsoluteUrls),
      t.params,
      t.paramsSerializer,
    )),
    o &&
      i.set(
        "Authorization",
        "Basic " +
          btoa(
            (o.username || "") +
              ":" +
              (o.password ? unescape(encodeURIComponent(o.password)) : ""),
          ),
      ));
  let c;
  if (L.isFormData(r)) {
    if (at.hasStandardBrowserEnv || at.hasStandardBrowserWebWorkerEnv)
      i.setContentType(void 0);
    else if ((c = i.getContentType()) !== !1) {
      let [l, ...u] = c
        ? c
            .split(";")
            .map((d) => d.trim())
            .filter(Boolean)
        : [];
      i.setContentType([l || "multipart/form-data", ...u].join("; "));
    }
  }
  if (
    at.hasStandardBrowserEnv &&
    (n && L.isFunction(n) && (n = n(e)), n || (n !== !1 && MR(e.url)))
  ) {
    let l = s && a && jR.read(a);
    l && i.set(s, l);
  }
  return e;
};
var bJ = typeof XMLHttpRequest < "u",
  UR =
    bJ &&
    function (t) {
      return new Promise(function (r, n) {
        let s = hd(t),
          a = s.data,
          i = Nt.from(s.headers).normalize(),
          { responseType: o, onUploadProgress: c, onDownloadProgress: l } = s,
          u,
          d,
          m,
          p,
          f;
        function y() {
          (p && p(),
            f && f(),
            s.cancelToken && s.cancelToken.unsubscribe(u),
            s.signal && s.signal.removeEventListener("abort", u));
        }
        let h = new XMLHttpRequest();
        (h.open(s.method.toUpperCase(), s.url, !0), (h.timeout = s.timeout));
        function g() {
          if (!h) return;
          let v = Nt.from(
              "getAllResponseHeaders" in h && h.getAllResponseHeaders(),
            ),
            x = {
              data:
                !o || o === "text" || o === "json"
                  ? h.responseText
                  : h.response,
              status: h.status,
              statusText: h.statusText,
              headers: v,
              config: t,
              request: h,
            };
          (Nn(
            function (S) {
              (r(S), y());
            },
            function (S) {
              (n(S), y());
            },
            x,
          ),
            (h = null));
        }
        ("onloadend" in h
          ? (h.onloadend = g)
          : (h.onreadystatechange = function () {
              !h ||
                h.readyState !== 4 ||
                (h.status === 0 &&
                  !(h.responseURL && h.responseURL.indexOf("file:") === 0)) ||
                setTimeout(g);
            }),
          (h.onabort = function () {
            h &&
              (n(new pe("Request aborted", pe.ECONNABORTED, t, h)), (h = null));
          }),
          (h.onerror = function () {
            (n(new pe("Network Error", pe.ERR_NETWORK, t, h)), (h = null));
          }),
          (h.ontimeout = function () {
            let b = s.timeout
                ? "timeout of " + s.timeout + "ms exceeded"
                : "timeout exceeded",
              x = s.transitional || Gi;
            (s.timeoutErrorMessage && (b = s.timeoutErrorMessage),
              n(
                new pe(
                  b,
                  x.clarifyTimeoutError ? pe.ETIMEDOUT : pe.ECONNABORTED,
                  t,
                  h,
                ),
              ),
              (h = null));
          }),
          a === void 0 && i.setContentType(null),
          "setRequestHeader" in h &&
            L.forEach(i.toJSON(), function (b, x) {
              h.setRequestHeader(x, b);
            }),
          L.isUndefined(s.withCredentials) ||
            (h.withCredentials = !!s.withCredentials),
          o && o !== "json" && (h.responseType = s.responseType),
          l && (([m, f] = as(l, !0)), h.addEventListener("progress", m)),
          c &&
            h.upload &&
            (([d, p] = as(c)),
            h.upload.addEventListener("progress", d),
            h.upload.addEventListener("loadend", p)),
          (s.cancelToken || s.signal) &&
            ((u = (v) => {
              h &&
                (n(!v || v.type ? new Ur(null, t, h) : v),
                h.abort(),
                (h = null));
            }),
            s.cancelToken && s.cancelToken.subscribe(u),
            s.signal &&
              (s.signal.aborted
                ? u()
                : s.signal.addEventListener("abort", u))));
        let _ = Dc(s.url);
        if (_ && at.protocols.indexOf(_) === -1) {
          n(new pe("Unsupported protocol " + _ + ":", pe.ERR_BAD_REQUEST, t));
          return;
        }
        h.send(a || null);
      });
    };
var _J = (t, e) => {
    let { length: r } = (t = t ? t.filter(Boolean) : []);
    if (e || r) {
      let n = new AbortController(),
        s,
        a = function (l) {
          if (!s) {
            ((s = !0), o());
            let u = l instanceof Error ? l : this.reason;
            n.abort(
              u instanceof pe ? u : new Ur(u instanceof Error ? u.message : u),
            );
          }
        },
        i =
          e &&
          setTimeout(() => {
            ((i = null),
              a(new pe(`timeout ${e} of ms exceeded`, pe.ETIMEDOUT)));
          }, e),
        o = () => {
          t &&
            (i && clearTimeout(i),
            (i = null),
            t.forEach((l) => {
              l.unsubscribe
                ? l.unsubscribe(a)
                : l.removeEventListener("abort", a);
            }),
            (t = null));
        };
      t.forEach((l) => l.addEventListener("abort", a));
      let { signal: c } = n;
      return ((c.unsubscribe = () => L.asap(o)), c);
    }
  },
  qR = _J;
var xJ = function* (t, e) {
    let r = t.byteLength;
    if (!e || r < e) {
      yield t;
      return;
    }
    let n = 0,
      s;
    for (; n < r; ) ((s = n + e), yield t.slice(n, s), (n = s));
  },
  wJ = async function* (t, e) {
    for await (let r of SJ(t)) yield* xJ(r, e);
  },
  SJ = async function* (t) {
    if (t[Symbol.asyncIterator]) {
      yield* t;
      return;
    }
    let e = t.getReader();
    try {
      for (;;) {
        let { done: r, value: n } = await e.read();
        if (r) break;
        yield n;
      }
    } finally {
      await e.cancel();
    }
  },
  tv = (t, e, r, n) => {
    let s = wJ(t, e),
      a = 0,
      i,
      o = (c) => {
        i || ((i = !0), n && n(c));
      };
    return new ReadableStream(
      {
        async pull(c) {
          try {
            let { done: l, value: u } = await s.next();
            if (l) {
              (o(), c.close());
              return;
            }
            let d = u.byteLength;
            if (r) {
              let m = (a += d);
              r(m);
            }
            c.enqueue(new Uint8Array(u));
          } catch (l) {
            throw (o(l), l);
          }
        },
        cancel(c) {
          return (o(c), s.return());
        },
      },
      { highWaterMark: 2 },
    );
  };
var vd =
    typeof fetch == "function" &&
    typeof Request == "function" &&
    typeof Response == "function",
  BR = vd && typeof ReadableStream == "function",
  EJ =
    vd &&
    (typeof TextEncoder == "function"
      ? (
          (t) => (e) =>
            t.encode(e)
        )(new TextEncoder())
      : async (t) => new Uint8Array(await new Response(t).arrayBuffer())),
  HR = (t, ...e) => {
    try {
      return !!t(...e);
    } catch {
      return !1;
    }
  },
  TJ =
    BR &&
    HR(() => {
      let t = !1,
        e = new Request(at.origin, {
          body: new ReadableStream(),
          method: "POST",
          get duplex() {
            return ((t = !0), "half");
          },
        }).headers.has("Content-Type");
      return t && !e;
    }),
  zR = 64 * 1024,
  rv = BR && HR(() => L.isReadableStream(new Response("").body)),
  gd = { stream: rv && ((t) => t.body) };
vd &&
  ((t) => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
      !gd[e] &&
        (gd[e] = L.isFunction(t[e])
          ? (r) => r[e]()
          : (r, n) => {
              throw new pe(
                `Response type '${e}' is not supported`,
                pe.ERR_NOT_SUPPORT,
                n,
              );
            });
    });
  })(new Response());
var CJ = async (t) => {
    if (t == null) return 0;
    if (L.isBlob(t)) return t.size;
    if (L.isSpecCompliantForm(t))
      return (
        await new Request(at.origin, { method: "POST", body: t }).arrayBuffer()
      ).byteLength;
    if (L.isArrayBufferView(t) || L.isArrayBuffer(t)) return t.byteLength;
    if ((L.isURLSearchParams(t) && (t = t + ""), L.isString(t)))
      return (await EJ(t)).byteLength;
  },
  PJ = async (t, e) => {
    let r = L.toFiniteNumber(t.getContentLength());
    return r ?? CJ(e);
  },
  VR =
    vd &&
    (async (t) => {
      let {
        url: e,
        method: r,
        data: n,
        signal: s,
        cancelToken: a,
        timeout: i,
        onDownloadProgress: o,
        onUploadProgress: c,
        responseType: l,
        headers: u,
        withCredentials: d = "same-origin",
        fetchOptions: m,
      } = hd(t);
      l = l ? (l + "").toLowerCase() : "text";
      let p = qR([s, a && a.toAbortSignal()], i),
        f,
        y =
          p &&
          p.unsubscribe &&
          (() => {
            p.unsubscribe();
          }),
        h;
      try {
        if (
          c &&
          TJ &&
          r !== "get" &&
          r !== "head" &&
          (h = await PJ(u, n)) !== 0
        ) {
          let x = new Request(e, { method: "POST", body: n, duplex: "half" }),
            w;
          if (
            (L.isFormData(n) &&
              (w = x.headers.get("content-type")) &&
              u.setContentType(w),
            x.body)
          ) {
            let [S, C] = eo(h, as(to(c)));
            n = tv(x.body, zR, S, C);
          }
        }
        L.isString(d) || (d = d ? "include" : "omit");
        let g = "credentials" in Request.prototype;
        f = new Request(e, {
          ...m,
          signal: p,
          method: r.toUpperCase(),
          headers: u.normalize().toJSON(),
          body: n,
          duplex: "half",
          credentials: g ? d : void 0,
        });
        let _ = await fetch(f),
          v = rv && (l === "stream" || l === "response");
        if (rv && (o || (v && y))) {
          let x = {};
          ["status", "statusText", "headers"].forEach((P) => {
            x[P] = _[P];
          });
          let w = L.toFiniteNumber(_.headers.get("content-length")),
            [S, C] = (o && eo(w, as(to(o), !0))) || [];
          _ = new Response(
            tv(_.body, zR, S, () => {
              (C && C(), y && y());
            }),
            x,
          );
        }
        l = l || "text";
        let b = await gd[L.findKey(gd, l) || "text"](_, t);
        return (
          !v && y && y(),
          await new Promise((x, w) => {
            Nn(x, w, {
              data: b,
              headers: Nt.from(_.headers),
              status: _.status,
              statusText: _.statusText,
              config: t,
              request: f,
            });
          })
        );
      } catch (g) {
        throw (
          y && y(),
          g && g.name === "TypeError" && /fetch/i.test(g.message)
            ? Object.assign(new pe("Network Error", pe.ERR_NETWORK, t, f), {
                cause: g.cause || g,
              })
            : pe.from(g, g && g.code, t, f)
        );
      }
    });
var nv = { http: LR, xhr: UR, fetch: VR };
L.forEach(nv, (t, e) => {
  if (t) {
    try {
      Object.defineProperty(t, "name", { value: e });
    } catch {}
    Object.defineProperty(t, "adapterName", { value: e });
  }
});
var ZR = (t) => `- ${t}`,
  kJ = (t) => L.isFunction(t) || t === null || t === !1,
  yd = {
    getAdapter: (t) => {
      t = L.isArray(t) ? t : [t];
      let { length: e } = t,
        r,
        n,
        s = {};
      for (let a = 0; a < e; a++) {
        r = t[a];
        let i;
        if (
          ((n = r),
          !kJ(r) && ((n = nv[(i = String(r)).toLowerCase()]), n === void 0))
        )
          throw new pe(`Unknown adapter '${i}'`);
        if (n) break;
        s[i || "#" + a] = n;
      }
      if (!n) {
        let a = Object.entries(s).map(
            ([o, c]) =>
              `adapter ${o} ` +
              (c === !1
                ? "is not supported by the environment"
                : "is not available in the build"),
          ),
          i = e
            ? a.length > 1
              ? `since :
` +
                a.map(ZR).join(`
`)
              : " " + ZR(a[0])
            : "as no adapter specified";
        throw new pe(
          "There is no suitable adapter to dispatch the request " + i,
          "ERR_NOT_SUPPORT",
        );
      }
      return n;
    },
    adapters: nv,
  };
function sv(t) {
  if (
    (t.cancelToken && t.cancelToken.throwIfRequested(),
    t.signal && t.signal.aborted)
  )
    throw new Ur(null, t);
}
function bd(t) {
  return (
    sv(t),
    (t.headers = Nt.from(t.headers)),
    (t.data = Rc.call(t, t.transformRequest)),
    ["post", "put", "patch"].indexOf(t.method) !== -1 &&
      t.headers.setContentType("application/x-www-form-urlencoded", !1),
    yd
      .getAdapter(t.adapter || Wi.adapter)(t)
      .then(
        function (n) {
          return (
            sv(t),
            (n.data = Rc.call(t, t.transformResponse, n)),
            (n.headers = Nt.from(n.headers)),
            n
          );
        },
        function (n) {
          return (
            Oc(n) ||
              (sv(t),
              n &&
                n.response &&
                ((n.response.data = Rc.call(
                  t,
                  t.transformResponse,
                  n.response,
                )),
                (n.response.headers = Nt.from(n.response.headers)))),
            Promise.reject(n)
          );
        },
      )
  );
}
var _d = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(
  (t, e) => {
    _d[t] = function (n) {
      return typeof n === t || "a" + (e < 1 ? "n " : " ") + t;
    };
  },
);
var GR = {};
_d.transitional = function (e, r, n) {
  function s(a, i) {
    return (
      "[Axios v" +
      Oa +
      "] Transitional option '" +
      a +
      "'" +
      i +
      (n ? ". " + n : "")
    );
  }
  return (a, i, o) => {
    if (e === !1)
      throw new pe(
        s(i, " has been removed" + (r ? " in " + r : "")),
        pe.ERR_DEPRECATED,
      );
    return (
      r &&
        !GR[i] &&
        ((GR[i] = !0),
        console.warn(
          s(
            i,
            " has been deprecated since v" +
              r +
              " and will be removed in the near future",
          ),
        )),
      e ? e(a, i, o) : !0
    );
  };
};
_d.spelling = function (e) {
  return (r, n) => (console.warn(`${n} is likely a misspelling of ${e}`), !0);
};
function RJ(t, e, r) {
  if (typeof t != "object")
    throw new pe("options must be an object", pe.ERR_BAD_OPTION_VALUE);
  let n = Object.keys(t),
    s = n.length;
  for (; s-- > 0; ) {
    let a = n[s],
      i = e[a];
    if (i) {
      let o = t[a],
        c = o === void 0 || i(o, a, t);
      if (c !== !0)
        throw new pe("option " + a + " must be " + c, pe.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== !0) throw new pe("Unknown option " + a, pe.ERR_BAD_OPTION);
  }
}
var Mc = { assertOptions: RJ, validators: _d };
var Dn = Mc.validators,
  ro = class {
    constructor(e) {
      ((this.defaults = e),
        (this.interceptors = { request: new Eg(), response: new Eg() }));
    }
    async request(e, r) {
      try {
        return await this._request(e, r);
      } catch (n) {
        if (n instanceof Error) {
          let s = {};
          Error.captureStackTrace
            ? Error.captureStackTrace(s)
            : (s = new Error());
          let a = s.stack ? s.stack.replace(/^.+\n/, "") : "";
          try {
            n.stack
              ? a &&
                !String(n.stack).endsWith(a.replace(/^.+\n.+\n/, "")) &&
                (n.stack +=
                  `
` + a)
              : (n.stack = a);
          } catch {}
        }
        throw n;
      }
    }
    _request(e, r) {
      (typeof e == "string" ? ((r = r || {}), (r.url = e)) : (r = e || {}),
        (r = bn(this.defaults, r)));
      let { transitional: n, paramsSerializer: s, headers: a } = r;
      (n !== void 0 &&
        Mc.assertOptions(
          n,
          {
            silentJSONParsing: Dn.transitional(Dn.boolean),
            forcedJSONParsing: Dn.transitional(Dn.boolean),
            clarifyTimeoutError: Dn.transitional(Dn.boolean),
          },
          !1,
        ),
        s != null &&
          (L.isFunction(s)
            ? (r.paramsSerializer = { serialize: s })
            : Mc.assertOptions(
                s,
                { encode: Dn.function, serialize: Dn.function },
                !0,
              )),
        r.allowAbsoluteUrls !== void 0 ||
          (this.defaults.allowAbsoluteUrls !== void 0
            ? (r.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls)
            : (r.allowAbsoluteUrls = !0)),
        Mc.assertOptions(
          r,
          {
            baseUrl: Dn.spelling("baseURL"),
            withXsrfToken: Dn.spelling("withXSRFToken"),
          },
          !0,
        ),
        (r.method = (r.method || this.defaults.method || "get").toLowerCase()));
      let i = a && L.merge(a.common, a[r.method]);
      (a &&
        L.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (f) => {
            delete a[f];
          },
        ),
        (r.headers = Nt.concat(i, a)));
      let o = [],
        c = !0;
      this.interceptors.request.forEach(function (y) {
        (typeof y.runWhen == "function" && y.runWhen(r) === !1) ||
          ((c = c && y.synchronous), o.unshift(y.fulfilled, y.rejected));
      });
      let l = [];
      this.interceptors.response.forEach(function (y) {
        l.push(y.fulfilled, y.rejected);
      });
      let u,
        d = 0,
        m;
      if (!c) {
        let f = [bd.bind(this), void 0];
        for (
          f.unshift.apply(f, o),
            f.push.apply(f, l),
            m = f.length,
            u = Promise.resolve(r);
          d < m;
        )
          u = u.then(f[d++], f[d++]);
        return u;
      }
      m = o.length;
      let p = r;
      for (d = 0; d < m; ) {
        let f = o[d++],
          y = o[d++];
        try {
          p = f(p);
        } catch (h) {
          y.call(this, h);
          break;
        }
      }
      try {
        u = bd.call(this, p);
      } catch (f) {
        return Promise.reject(f);
      }
      for (d = 0, m = l.length; d < m; ) u = u.then(l[d++], l[d++]);
      return u;
    }
    getUri(e) {
      e = bn(this.defaults, e);
      let r = Ca(e.baseURL, e.url, e.allowAbsoluteUrls);
      return Ta(r, e.params, e.paramsSerializer);
    }
  };
L.forEach(["delete", "get", "head", "options"], function (e) {
  ro.prototype[e] = function (r, n) {
    return this.request(
      bn(n || {}, { method: e, url: r, data: (n || {}).data }),
    );
  };
});
L.forEach(["post", "put", "patch"], function (e) {
  function r(n) {
    return function (a, i, o) {
      return this.request(
        bn(o || {}, {
          method: e,
          headers: n ? { "Content-Type": "multipart/form-data" } : {},
          url: a,
          data: i,
        }),
      );
    };
  }
  ((ro.prototype[e] = r()), (ro.prototype[e + "Form"] = r(!0)));
});
var jc = ro;
var av = class t {
    constructor(e) {
      if (typeof e != "function")
        throw new TypeError("executor must be a function.");
      let r;
      this.promise = new Promise(function (a) {
        r = a;
      });
      let n = this;
      (this.promise.then((s) => {
        if (!n._listeners) return;
        let a = n._listeners.length;
        for (; a-- > 0; ) n._listeners[a](s);
        n._listeners = null;
      }),
        (this.promise.then = (s) => {
          let a,
            i = new Promise((o) => {
              (n.subscribe(o), (a = o));
            }).then(s);
          return (
            (i.cancel = function () {
              n.unsubscribe(a);
            }),
            i
          );
        }),
        e(function (a, i, o) {
          n.reason || ((n.reason = new Ur(a, i, o)), r(n.reason));
        }));
    }
    throwIfRequested() {
      if (this.reason) throw this.reason;
    }
    subscribe(e) {
      if (this.reason) {
        e(this.reason);
        return;
      }
      this._listeners ? this._listeners.push(e) : (this._listeners = [e]);
    }
    unsubscribe(e) {
      if (!this._listeners) return;
      let r = this._listeners.indexOf(e);
      r !== -1 && this._listeners.splice(r, 1);
    }
    toAbortSignal() {
      let e = new AbortController(),
        r = (n) => {
          e.abort(n);
        };
      return (
        this.subscribe(r),
        (e.signal.unsubscribe = () => this.unsubscribe(r)),
        e.signal
      );
    }
    static source() {
      let e;
      return {
        token: new t(function (s) {
          e = s;
        }),
        cancel: e,
      };
    }
  },
  WR = av;
function iv(t) {
  return function (r) {
    return t.apply(null, r);
  };
}
function ov(t) {
  return L.isObject(t) && t.isAxiosError === !0;
}
var cv = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};
Object.entries(cv).forEach(([t, e]) => {
  cv[e] = t;
});
var KR = cv;
function JR(t) {
  let e = new jc(t),
    r = xc(jc.prototype.request, e);
  return (
    L.extend(r, jc.prototype, e, { allOwnKeys: !0 }),
    L.extend(r, e, null, { allOwnKeys: !0 }),
    (r.create = function (s) {
      return JR(bn(t, s));
    }),
    r
  );
}
var Ht = JR(Wi);
Ht.Axios = jc;
Ht.CanceledError = Ur;
Ht.CancelToken = WR;
Ht.isCancel = Oc;
Ht.VERSION = Oa;
Ht.toFormData = Ds;
Ht.AxiosError = pe;
Ht.Cancel = Ht.CanceledError;
Ht.all = function (e) {
  return Promise.all(e);
};
Ht.spread = iv;
Ht.isAxiosError = ov;
Ht.mergeConfig = bn;
Ht.AxiosHeaders = Nt;
Ht.formToJSON = (t) => od(L.isHTMLForm(t) ? new FormData(t) : t);
Ht.getAdapter = yd.getAdapter;
Ht.HttpStatusCode = KR;
Ht.default = Ht;
var no = Ht;
var {
  Axios: Mde,
  AxiosError: jde,
  CanceledError: Fde,
  isCancel: Ude,
  CancelToken: qde,
  VERSION: zde,
  all: Bde,
  Cancel: Hde,
  isAxiosError: Vde,
  spread: Zde,
  toFormData: Gde,
  AxiosHeaders: Wde,
  HttpStatusCode: Kde,
  formToJSON: Jde,
  getAdapter: Xde,
  mergeConfig: Yde,
} = no;
function OJ() {
  return "prod";
}
var IJ = "user:inference",
  $J = "org:create_api_key";
var lv = [$J, "user:profile"],
  uv = ["user:profile", IJ, "user:sessions:claude_code"],
  rpe = Array.from(new Set([...lv, ...uv])),
  XR = {
    BASE_API_URL: "https://api.anthropic.com",
    CONSOLE_AUTHORIZE_URL: "https://console.anthropic.com/oauth/authorize",
    CLAUDE_AI_AUTHORIZE_URL: "https://claude.ai/oauth/authorize",
    TOKEN_URL: "https://console.anthropic.com/v1/oauth/token",
    API_KEY_URL:
      "https://api.anthropic.com/api/oauth/claude_cli/create_api_key",
    ROLES_URL: "https://api.anthropic.com/api/oauth/claude_cli/roles",
    CONSOLE_SUCCESS_URL:
      "https://console.anthropic.com/buy_credits?returnUrl=/oauth/code/success%3Fapp%3Dclaude-code",
    CLAUDEAI_SUCCESS_URL:
      "https://console.anthropic.com/oauth/code/success?app=claude-code",
    MANUAL_REDIRECT_URL: "https://console.anthropic.com/oauth/code/callback",
    CLIENT_ID: "9d1c250a-e61b-44d9-88ed-5944d1962f5e",
    OAUTH_FILE_SUFFIX: "",
    MCP_PROXY_URL: void 0,
    MCP_PROXY_PATH: void 0,
  },
  AJ = void 0,
  NJ = {
    BASE_API_URL: "http://localhost:3000",
    CONSOLE_AUTHORIZE_URL: "http://localhost:3000/oauth/authorize",
    CLAUDE_AI_AUTHORIZE_URL: "http://localhost:4000/oauth/authorize",
    TOKEN_URL: "http://localhost:3000/v1/oauth/token",
    API_KEY_URL: "http://localhost:3000/api/oauth/claude_cli/create_api_key",
    ROLES_URL: "http://localhost:3000/api/oauth/claude_cli/roles",
    CONSOLE_SUCCESS_URL:
      "http://localhost:3000/buy_credits?returnUrl=/oauth/code/success%3Fapp%3Dclaude-code",
    CLAUDEAI_SUCCESS_URL:
      "http://localhost:3000/oauth/code/success?app=claude-code",
    MANUAL_REDIRECT_URL: "https://console.staging.ant.dev/oauth/code/callback",
    CLIENT_ID: "22422756-60c9-4084-8eb7-27705fd5cf9a",
    OAUTH_FILE_SUFFIX: "-local-oauth",
    MCP_PROXY_URL: "http://localhost:8205",
    MCP_PROXY_PATH: "/v1/toolbox/shttp/mcp/{server_id}",
  };
function os() {
  switch (OJ()) {
    case "local":
      return NJ;
    case "staging":
      return AJ ?? XR;
    case "prod":
      return XR;
  }
}
var xd = class {
  constructor(e) {
    this.logger = e;
    this.codeVerifier = this.generateCodeVerifier();
  }
  codeVerifier;
  server = null;
  manualAuthCodeResolver = null;
  async startOAuthFlow(e, r) {
    let n = await this.startCallbackServer(),
      s = this.generateCodeChallenge(this.codeVerifier),
      a = this.generateState(),
      i = this.buildAuthUrls({
        codeChallenge: s,
        state: a,
        port: n,
        loginWithClaudeAi: e,
      });
    await r(i);
    let { code: o, isManualFlow: c } = await this.waitForAuthorizationCode(
      a,
      n,
      e,
    );
    return await this.exchangeCodeForTokens(
      o,
      a,
      this.codeVerifier,
      c ? void 0 : n,
    );
  }
  buildAuthUrls(e) {
    let r = os(),
      n = e.loginWithClaudeAi
        ? r.CLAUDE_AI_AUTHORIZE_URL
        : r.CONSOLE_AUTHORIZE_URL,
      s = new URL(n);
    (s.searchParams.set("code", "true"),
      s.searchParams.set("client_id", r.CLIENT_ID),
      s.searchParams.set("response_type", "code"));
    let a = e.loginWithClaudeAi ? uv : lv;
    (s.searchParams.set("scope", a.join(" ")),
      s.searchParams.set("code_challenge", e.codeChallenge),
      s.searchParams.set("code_challenge_method", "S256"),
      s.searchParams.set("state", e.state),
      s.searchParams.set(
        "redirect_uri",
        `http://localhost:${e.port}/callback`,
      ));
    let i = s.toString();
    s.searchParams.set("redirect_uri", r.MANUAL_REDIRECT_URL);
    let o = s.toString();
    return { automaticRedirectUrl: i, manualRedirectUrl: o };
  }
  async startCallbackServer() {
    return new Promise((e, r) => {
      ((this.server = YR.createServer()),
        this.server.listen(0, "127.0.0.1", () => {
          let n = this.server.address();
          if (!n || typeof n == "string") {
            r(new Error("Failed to get server address"));
            return;
          }
          e(n.port);
        }),
        this.server.on("error", r));
    });
  }
  async waitForAuthorizationCode(e, r, n) {
    return new Promise((s, a) => {
      if (!this.server) {
        a(new Error("Server not started"));
        return;
      }
      ((this.manualAuthCodeResolver = (i) => {
        let o = i.trim().split("#");
        if (o[1] !== e) throw new Error("Invalid state parameter");
        s({ code: o[0], isManualFlow: !0 });
      }),
        this.server.on("request", (i, o) => {
          let c = new URL(i.url, `http://localhost:${r}`);
          if (c.pathname === "/callback") {
            let l = c.searchParams.get("code");
            if (c.searchParams.get("state") !== e) {
              (o.writeHead(400),
                o.end("Invalid state parameter"),
                a(new Error("Invalid state parameter")));
              return;
            }
            if (!l) {
              (o.writeHead(400),
                o.end("Missing authorization code"),
                a(new Error("Missing authorization code")));
              return;
            }
            let d = n ? os().CLAUDEAI_SUCCESS_URL : os().CONSOLE_SUCCESS_URL;
            (o.writeHead(302, { Location: d }),
              o.end(),
              (this.manualAuthCodeResolver = null),
              s({ code: l, isManualFlow: !1 }));
          }
        }));
    });
  }
  async exchangeCodeForTokens(e, r, n, s) {
    let a = os(),
      i = {
        grant_type: "authorization_code",
        code: e,
        redirect_uri: s
          ? `http://localhost:${s}/callback`
          : a.MANUAL_REDIRECT_URL,
        client_id: a.CLIENT_ID,
        code_verifier: n,
        state: r,
      };
    try {
      let o = await no.post(a.TOKEN_URL, i, {
        headers: { "Content-Type": "application/json" },
      });
      if (o.status !== 200)
        throw new Error(`Token exchange failed: ${o.statusText}`);
      let c = o.data,
        l = {
          accessToken: c.access_token,
          refreshToken: c.refresh_token || null,
          expiresAt: c.expires_in ? Date.now() + c.expires_in * 1e3 : null,
          scopes: c.scope ? c.scope.split(" ") : [],
          subscriptionType: null,
          rateLimitTier: null,
        };
      if (l.scopes.includes("user:profile")) {
        let u = await this.fetchProfileInfo(l.accessToken);
        ((l.subscriptionType = u.subscriptionType),
          (l.rateLimitTier = u.rateLimitTier));
      }
      return l;
    } catch (o) {
      let c = o;
      throw new Error(
        `Token exchange failed: ${c.response?.data?.error || c.response?.data?.message || c.message || "Unknown error"}`,
      );
    }
  }
  handleManualAuthCodeInput(e) {
    this.manualAuthCodeResolver &&
      e &&
      (this.manualAuthCodeResolver(e),
      (this.manualAuthCodeResolver = null),
      this.cleanup());
  }
  async createApiKey(e) {
    let r = os();
    try {
      return (
        (
          await no.post(r.API_KEY_URL, null, {
            headers: { Authorization: `Bearer ${e}` },
          })
        ).data?.raw_key || null
      );
    } catch {
      return null;
    }
  }
  cleanup() {
    this.server && (this.server.close(), (this.server = null));
  }
  generateCodeVerifier() {
    return Fc.randomBytes(32).toString("base64url");
  }
  generateCodeChallenge(e) {
    return Fc.createHash("sha256").update(e).digest("base64url");
  }
  generateState() {
    return Fc.randomBytes(32).toString("base64url");
  }
  async fetchProfileInfo(e) {
    try {
      let r = `${os().BASE_API_URL}/api/claude_cli_profile`,
        n = await no.get(r, {
          headers: {
            Authorization: `Bearer ${e}`,
            "Content-Type": "application/json",
          },
        }),
        s = n.data?.organization?.organization_type,
        a = null;
      switch (s) {
        case "claude_max":
          a = "max";
          break;
        case "claude_pro":
          a = "pro";
          break;
        case "claude_enterprise":
          a = "enterprise";
          break;
        case "claude_team":
          a = "team";
          break;
        default:
          a = null;
          break;
      }
      return {
        subscriptionType: a,
        rateLimitTier: n.data?.organization?.rate_limit_tier ?? null,
      };
    } catch (r) {
      return (
        this.logger.error(`Failed to fetch subscription: ${r}`),
        { subscriptionType: null, rateLimitTier: null }
      );
    }
  }
};
var TO = require("fs");
var tO = require("process"),
  rO = require("fs"),
  nO = require("crypto");
var QR = {
    name: "BASH_MAX_OUTPUT_LENGTH",
    default: 3e4,
    validate: (t) => {
      if (!t) return { effective: 3e4, status: "valid" };
      let n = parseInt(t, 10);
      return isNaN(n) || n <= 0
        ? {
            effective: 3e4,
            status: "invalid",
            message: `Invalid value "${t}" (using default: 30000)`,
          }
        : n > 15e4
          ? {
              effective: 15e4,
              status: "capped",
              message: `Capped from ${n} to 150000`,
            }
          : { effective: n, status: "valid" };
    },
  },
  eO = {
    name: "CLAUDE_CODE_MAX_OUTPUT_TOKENS",
    default: 32e3,
    validate: (t) => {
      if (!t) return { effective: 32e3, status: "valid" };
      let n = parseInt(t, 10);
      return isNaN(n) || n <= 0
        ? {
            effective: 32e3,
            status: "invalid",
            message: `Invalid value "${t}" (using default: 32000)`,
          }
        : n > 64e3
          ? {
              effective: 64e3,
              status: "capped",
              message: `Capped from ${n} to 64000`,
            }
          : { effective: n, status: "valid" };
    },
  };
function DJ() {
  let t = "";
  return (
    typeof process < "u" &&
      typeof process.cwd == "function" &&
      (t = (0, rO.realpathSync)((0, tO.cwd)())),
    {
      originalCwd: t,
      totalCostUSD: 0,
      totalAPIDuration: 0,
      totalAPIDurationWithoutRetries: 0,
      totalToolDuration: 0,
      startTime: Date.now(),
      lastInteractionTime: Date.now(),
      totalLinesAdded: 0,
      totalLinesRemoved: 0,
      hasUnknownModelCost: !1,
      cwd: t,
      modelUsage: {},
      mainLoopModelOverride: void 0,
      initialMainLoopModel: null,
      modelStrings: null,
      isInteractive: !1,
      clientType: "cli",
      sessionIngressToken: void 0,
      oauthTokenFromFd: void 0,
      apiKeyFromFd: void 0,
      flagSettingsPath: void 0,
      allowedSettingSources: [
        "userSettings",
        "projectSettings",
        "localSettings",
        "flagSettings",
        "policySettings",
      ],
      meter: null,
      sessionCounter: null,
      locCounter: null,
      prCounter: null,
      commitCounter: null,
      costCounter: null,
      tokenCounter: null,
      codeEditToolDecisionCounter: null,
      activeTimeCounter: null,
      sessionId: (0, nO.randomUUID)(),
      loggerProvider: null,
      eventLogger: null,
      meterProvider: null,
      tracerProvider: null,
      agentColorMap: new Map(),
      agentColorIndex: 0,
      envVarValidators: [QR, eO],
      lastAPIRequest: null,
      inMemoryErrorLog: [],
      inlinePlugins: [],
      sessionBypassPermissionsMode: !1,
      sessionPersistenceDisabled: !1,
      hasExitedPlanMode: !1,
      needsPlanModeExitAttachment: !1,
      hasExitedDelegateMode: !1,
      needsDelegateModeExitAttachment: !1,
      lspRecommendationShownThisSession: !1,
      initJsonSchema: null,
      registeredHooks: null,
      planSlugCache: new Map(),
      teleportedSessionInfo: null,
      invokedSkills: new Map(),
    }
  );
}
var dv = DJ();
function sO() {
  return dv.sessionId;
}
function aO() {
  return dv.originalCwd;
}
function iO() {
  return dv.cwd;
}
function LJ() {
  return iO();
}
function oO() {
  try {
    return LJ();
  } catch {
    return aO();
  }
}
function cO(t) {
  for (let e = 0; e < t.length; e += 2e3)
    process.stderr.write(t.substring(e, e + 2e3));
}
var lO = Yr((t) => {
  if (!t || t.trim() === "") return null;
  let e = t
    .split(",")
    .map((a) => a.trim())
    .filter(Boolean);
  if (e.length === 0) return null;
  let r = e.some((a) => a.startsWith("!")),
    n = e.some((a) => !a.startsWith("!"));
  if (r && n) return null;
  let s = e.map((a) => a.replace(/^!/, "").toLowerCase());
  return { include: r ? [] : s, exclude: r ? s : [], isExclusive: r };
});
function MJ(t) {
  let e = [],
    r = t.match(/^MCP server ["']([^"']+)["']/);
  if (r && r[1]) (e.push("mcp"), e.push(r[1].toLowerCase()));
  else {
    let a = t.match(/^([^:[]+):/);
    a && a[1] && e.push(a[1].trim().toLowerCase());
  }
  let n = t.match(/^\[([^\]]+)]/);
  (n && n[1] && e.push(n[1].trim().toLowerCase()),
    t.toLowerCase().includes("statsig event:") && e.push("statsig"));
  let s = t.match(/:\s*([^:]+?)(?:\s+(?:type|mode|status|event))?:/);
  if (s && s[1]) {
    let a = s[1].trim().toLowerCase();
    a.length < 30 && !a.includes(" ") && e.push(a);
  }
  return Array.from(new Set(e));
}
function jJ(t, e) {
  return e
    ? t.length === 0
      ? !1
      : e.isExclusive
        ? !t.some((r) => e.exclude.includes(r))
        : t.some((r) => e.include.includes(r))
    : !0;
}
function uO(t, e) {
  if (!e) return !0;
  let r = MJ(t);
  return jJ(r, e);
}
var Oe = le(require("fs"), 1),
  pv = require("fs/promises");
var FJ = 5;
function Ft(t, e) {
  let r = performance.now();
  try {
    return e();
  } finally {
    let n = performance.now() - r;
    n > FJ && Uc(`[SLOW OPERATION DETECTED] fs.${t} (${n.toFixed(1)}ms)`);
  }
}
var UJ = {
    cwd() {
      return process.cwd();
    },
    existsSync(t) {
      return Ft("existsSync", () => Oe.existsSync(t));
    },
    async stat(t) {
      return (0, pv.stat)(t);
    },
    statSync(t) {
      return Ft("statSync", () => Oe.statSync(t));
    },
    lstatSync(t) {
      return Ft("lstatSync", () => Oe.lstatSync(t));
    },
    readFileSync(t, e) {
      return Ft("readFileSync", () =>
        Oe.readFileSync(t, { encoding: e.encoding }),
      );
    },
    readFileBytesSync(t) {
      return Ft("readFileBytesSync", () => Oe.readFileSync(t));
    },
    readSync(t, e) {
      return Ft("readSync", () => {
        let r;
        try {
          r = Oe.openSync(t, "r");
          let n = Buffer.alloc(e.length),
            s = Oe.readSync(r, n, 0, e.length, 0);
          return { buffer: n, bytesRead: s };
        } finally {
          r && Oe.closeSync(r);
        }
      });
    },
    writeFileSync(t, e, r) {
      return Ft("writeFileSync", () => {
        let n = Oe.existsSync(t);
        if (!r.flush) {
          let a = { encoding: r.encoding };
          (n
            ? r.mode !== void 0 && (a.mode = r.mode)
            : (a.mode = r.mode ?? 384),
            Oe.writeFileSync(t, e, a));
          return;
        }
        let s;
        try {
          let a = n ? r.mode : (r.mode ?? 384);
          ((s = Oe.openSync(t, "w", a)),
            Oe.writeFileSync(s, e, { encoding: r.encoding }),
            Oe.fsyncSync(s));
        } finally {
          s && Oe.closeSync(s);
        }
      });
    },
    appendFileSync(t, e, r) {
      return Ft("appendFileSync", () => {
        if (Oe.existsSync(t)) Oe.appendFileSync(t, e);
        else {
          let n = r?.mode ?? 384,
            s = Oe.openSync(t, "a", n);
          try {
            Oe.appendFileSync(s, e);
          } finally {
            Oe.closeSync(s);
          }
        }
      });
    },
    copyFileSync(t, e) {
      return Ft("copyFileSync", () => Oe.copyFileSync(t, e));
    },
    unlinkSync(t) {
      return Ft("unlinkSync", () => Oe.unlinkSync(t));
    },
    renameSync(t, e) {
      return Ft("renameSync", () => Oe.renameSync(t, e));
    },
    linkSync(t, e) {
      return Ft("linkSync", () => Oe.linkSync(t, e));
    },
    symlinkSync(t, e) {
      return Ft("symlinkSync", () => Oe.symlinkSync(t, e));
    },
    readlinkSync(t) {
      return Ft("readlinkSync", () => Oe.readlinkSync(t));
    },
    realpathSync(t) {
      return Ft("realpathSync", () => Oe.realpathSync(t));
    },
    mkdirSync(t) {
      return Ft("mkdirSync", () => {
        Oe.existsSync(t) || Oe.mkdirSync(t, { recursive: !0, mode: 448 });
      });
    },
    readdirSync(t) {
      return Ft("readdirSync", () => Oe.readdirSync(t, { withFileTypes: !0 }));
    },
    readdirStringSync(t) {
      return Ft("readdirStringSync", () => Oe.readdirSync(t));
    },
    isDirEmptySync(t) {
      return Ft("isDirEmptySync", () => this.readdirSync(t).length === 0);
    },
    rmdirSync(t) {
      return Ft("rmdirSync", () => Oe.rmdirSync(t));
    },
    rmSync(t, e) {
      return Ft("rmSync", () => Oe.rmSync(t, e));
    },
    createWriteStream(t) {
      return Oe.createWriteStream(t);
    },
  },
  qJ = UJ;
function nr() {
  return qJ;
}
var $a = require("path");
function dO({
  writeFn: t,
  flushIntervalMs: e = 1e3,
  maxBufferSize: r = 100,
  immediateMode: n = !1,
}) {
  let s = [],
    a = null;
  function i() {
    a && (clearTimeout(a), (a = null));
  }
  function o() {
    s.length !== 0 && (t(s.join("")), (s = []), i());
  }
  function c() {
    a || (a = setTimeout(o, e));
  }
  return {
    write(l) {
      if (n) {
        t(l);
        return;
      }
      (s.push(l), c(), s.length >= r && o());
    },
    flush: o,
    dispose() {
      o();
    },
  };
}
var pO = new Set();
function fO(t) {
  return (pO.add(t), () => pO.delete(t));
}
var zJ = Yr(
    () =>
      Vf(process.env.DEBUG) ||
      Vf(process.env.DEBUG_SDK) ||
      process.argv.includes("--debug") ||
      process.argv.includes("-d") ||
      fv() ||
      process.argv.some((t) => t.startsWith("--debug=")),
  ),
  BJ = Yr(() => {
    let t = process.argv.find((r) => r.startsWith("--debug="));
    if (!t) return null;
    let e = t.substring(8);
    return lO(e);
  }),
  fv = Yr(
    () =>
      process.argv.includes("--debug-to-stderr") ||
      process.argv.includes("-d2e"),
  );
function HJ(t) {
  if (
    (process.env.NODE_ENV === "test" && !fv()) ||
    typeof process > "u" ||
    typeof process.versions > "u" ||
    typeof process.versions.node > "u"
  )
    return !1;
  let e = BJ();
  return uO(t, e);
}
var VJ = !1;
var wd = null;
function ZJ() {
  return (
    wd ||
      ((wd = dO({
        writeFn: (t) => {
          let e = mO();
          (nr().existsSync((0, $a.dirname)(e)) ||
            nr().mkdirSync((0, $a.dirname)(e)),
            nr().appendFileSync(e, t),
            GJ());
        },
        flushIntervalMs: 1e3,
        maxBufferSize: 100,
        immediateMode: zJ(),
      })),
      fO(async () => wd?.dispose())),
    wd
  );
}
function Uc(t, { level: e } = { level: "debug" }) {
  if (!HJ(t)) return;
  VJ &&
    t.includes(`
`) &&
    (t = JSON.stringify(t));
  let n = `${new Date().toISOString()} [${e.toUpperCase()}] ${t.trim()}
`;
  if (fv()) {
    cO(n);
    return;
  }
  ZJ().write(n);
}
function mO() {
  return (
    process.env.CLAUDE_CODE_DEBUG_LOGS_DIR ??
    (0, $a.join)(sn(), "debug", `${sO()}.txt`)
  );
}
var GJ = Yr(() => {
  if (process.argv[2] !== "--ripgrep")
    try {
      let t = mO(),
        e = (0, $a.dirname)(t),
        r = (0, $a.join)(e, "latest");
      if ((nr().existsSync(e) || nr().mkdirSync(e), nr().existsSync(r)))
        try {
          nr().unlinkSync(r);
        } catch {}
      nr().symlinkSync(t, r);
    } catch {}
});
var hO = 5,
  gO = 1e3,
  vO = 60;
function Sd(t, e, r = 10 * vO * gO) {
  let n;
  e === void 0
    ? (n = {})
    : e instanceof AbortSignal
      ? (n = { abortSignal: e, timeout: r })
      : (n = e);
  let {
    abortSignal: s,
    timeout: a = 10 * vO * gO,
    input: i,
    stdio: o = ["ignore", "pipe", "pipe"],
  } = n;
  s?.throwIfAborted();
  let c = performance.now();
  try {
    let l = Ar(t, {
        env: process.env,
        maxBuffer: 1e6,
        timeout: a,
        cwd: oO(),
        stdio: o,
        shell: !0,
        reject: !1,
        input: i,
      }),
      u = performance.now() - c;
    return (
      u > hO &&
        Uc(
          `[SLOW OPERATION DETECTED] execSyncWithDefaults_DEPRECATED (${u.toFixed(1)}ms): ${t.slice(0, 100)}`,
        ),
      (l.stdout && l.stdout.trim()) || null
    );
  } catch {
    let l = performance.now() - c;
    return (
      l > hO &&
        Uc(
          `[SLOW OPERATION DETECTED] execSyncWithDefaults_DEPRECATED (${l.toFixed(1)}ms): ${t.slice(0, 100)}`,
        ),
      null
    );
  }
}
var yO = require("crypto");
var bO = require("os");
function Ms(t = "") {
  let e = sn(),
    n = !process.env.CLAUDE_CONFIG_DIR
      ? ""
      : `-${(0, yO.createHash)("sha256").update(e).digest("hex").substring(0, 8)}`;
  return `Claude Code${os().OAUTH_FILE_SUFFIX}${t}${n}`;
}
function Aa() {
  try {
    return process.env.USER || (0, bO.userInfo)().username;
  } catch {
    return "claude-code-user";
  }
}
var _O = {
  name: "keychain",
  read() {
    try {
      let t = Ms("-credentials"),
        e = Aa(),
        r = Sd(`security find-generic-password -a "${e}" -w -s "${t}"`);
      if (r) return JSON.parse(r);
    } catch {
      return null;
    }
    return null;
  },
  update(t) {
    try {
      let e = Ms("-credentials"),
        r = Aa(),
        n = JSON.stringify(t),
        s = Buffer.from(n, "utf-8").toString("hex"),
        a = `add-generic-password -U -a "${r}" -s "${e}" -X "${s}"
`;
      return Ar("security", ["-i"], {
        input: a,
        stdio: ["pipe", "pipe", "pipe"],
        reject: !1,
      }).exitCode !== 0
        ? { success: !1 }
        : { success: !0 };
    } catch {
      return { success: !1 };
    }
  },
  delete() {
    try {
      let t = Ms("-credentials"),
        e = Aa();
      return (Sd(`security delete-generic-password -a "${e}" -s "${t}"`), !0);
    } catch {
      return !1;
    }
  },
};
function xO(t, e) {
  return {
    name: `${t.name}-with-${e.name}-fallback`,
    read() {
      let r = t.read();
      return r ?? (e.read() || {});
    },
    update(r) {
      let n = t.read(),
        s = t.update(r);
      if (s.success) return (n === null && e.delete(), s);
      let a = e.update(r);
      return a.success ? { success: !0, warning: a.warning } : { success: !1 };
    },
    delete() {
      let r = t.delete(),
        n = e.delete();
      return r || n;
    },
  };
}
var wO = require("path");
var SO = require("fs");
function mv() {
  let t = sn();
  return { storageDir: t, storagePath: (0, wO.join)(t, ".credentials.json") };
}
var hv = {
  name: "plaintext",
  read() {
    let { storagePath: t } = mv();
    if (nr().existsSync(t))
      try {
        let e = nr().readFileSync(t, { encoding: "utf8" });
        return JSON.parse(e);
      } catch {
        return null;
      }
    return null;
  },
  update(t) {
    try {
      let { storageDir: e, storagePath: r } = mv();
      return (
        nr().existsSync(e) || nr().mkdirSync(e),
        nr().writeFileSync(r, JSON.stringify(t), {
          encoding: "utf8",
          flush: !1,
        }),
        (0, SO.chmodSync)(r, 384),
        { success: !0, warning: "Warning: Storing credentials in plaintext." }
      );
    } catch {
      return { success: !1 };
    }
  },
  delete() {
    let { storagePath: t } = mv();
    if (nr().existsSync(t))
      try {
        return (nr().unlinkSync(t), !0);
      } catch {
        return !1;
      }
    return !0;
  },
};
function Ed() {
  return process.platform === "darwin" ? xO(_O, hv) : hv;
}
function EO(t) {
  return t.slice(-20);
}
var so = class {
  constructor(e, r, n = !1) {
    this.logger = e;
    this.env = r;
    this.disableAuthLogin = n;
    this.logger.log("AuthManager initialized");
  }
  currentOAuthService = null;
  getAuthStatus() {
    if (
      (this.logger.log("Getting authentication status"),
      Td(this.env.CLAUDE_CODE_USE_BEDROCK) ||
        Td(this.env.CLAUDE_CODE_USE_VERTEX) ||
        Td(this.env.CLAUDE_CODE_USE_FOUNDRY) ||
        this.env.ANTHROPIC_API_KEY ||
        this.env.ANTHROPIC_AUTH_TOKEN ||
        Td(this.env.CLAUDE_CODE_SKIP_AUTH_LOGIN) ||
        this.disableAuthLogin)
    )
      return { authMethod: "3p", email: null, subscriptionType: null };
    let e = this.getApiKey(),
      r = this.getOAuthTokens();
    if (!e && !r) {
      this.logger.log("No authentication found");
      return;
    }
    let n;
    r
      ? (n = r.scopes.includes("user:inference") ? "claudeai" : "console")
      : (n = "api-key");
    let s = {
      authMethod: n,
      email: null,
      subscriptionType: r?.subscriptionType || null,
    };
    return (this.logger.log(`Auth status: method=${s.authMethod}`), s);
  }
  getOAuthTokens() {
    let n = (Ed().read() || {})?.claudeAiOauth;
    return n
      ? (this.logger.log("OAuth tokens found in secure storage"),
        {
          accessToken: n.accessToken,
          refreshToken: n.refreshToken || null,
          expiresAt: n.expiresAt || null,
          scopes: n.scopes,
          subscriptionType: n.subscriptionType,
          rateLimitTier: n.rateLimitTier,
        })
      : null;
  }
  getApiKey() {
    if (process.platform === "darwin")
      try {
        let n = Ar("security", [
          "find-generic-password",
          "-a",
          Aa(),
          "-w",
          "-s",
          Ms(),
        ]);
        if (n.stdout)
          return (
            this.logger.log("API key found in macOS keychain"),
            n.stdout.trim()
          );
      } catch {
        this.logger.log("Keychain read failed, trying file fallback");
      }
    let e = this.getConfigPath(),
      r = Cd.join(e, "config.json");
    if (Cr.existsSync(r))
      try {
        let n = JSON.parse(Cr.readFileSync(r, "utf8"));
        if (n.primaryApiKey)
          return (
            this.logger.log("API key found in config file"),
            n.primaryApiKey
          );
      } catch {
        this.logger.warn("Failed to read config file");
      }
    return null;
  }
  saveOAuthTokens(e) {
    this.logger.log("Saving OAuth tokens to secure storage");
    let r = Ed(),
      n = r.read() || {};
    ((n.claudeAiOauth = {
      accessToken: e.accessToken,
      refreshToken: e.refreshToken || "",
      expiresAt: e.expiresAt || Date.now() + 1 * 60 * 60 * 1e3,
      scopes: e.scopes,
      subscriptionType: e.subscriptionType,
      rateLimitTier: e.rateLimitTier,
    }),
      r.update(n));
  }
  async saveApiKey(e) {
    this.logger.log("Saving API key");
    let r = this.getConfigPath();
    Cr.existsSync(r) || Cr.mkdirSync(r, { recursive: !0 });
    let n = Cd.join(r, "config.json"),
      s = {};
    if (Cr.existsSync(n))
      try {
        s = JSON.parse(Cr.readFileSync(n, "utf8"));
      } catch {}
    if (process.platform === "darwin")
      try {
        let i = Ms(),
          o = Aa(),
          c = Buffer.from(e, "utf-8").toString("hex"),
          l = `add-generic-password -U -a "${o}" -s "${i}" -X "${c}"
`,
          u = Ar("security", ["-i"], {
            input: l,
            stdio: ["pipe", "pipe", "pipe"],
            reject: !1,
          });
        if (u.exitCode !== 0)
          throw new Error(
            `security command failed with exit code ${u.exitCode}`,
          );
        this.logger.log("API key saved to macOS keychain named ");
      } catch (i) {
        throw (
          this.logger.error(`Failed to save API key to keychain: ${i}`),
          new Error(
            "Unable to save API key to macOS Keychain. Please ensure VS Code has keychain access permissions.",
          )
        );
      }
    else s.primaryApiKey = e;
    (s.customApiKeyResponses || (s.customApiKeyResponses = {}),
      s.customApiKeyResponses.approved ||
        (s.customApiKeyResponses.approved = []));
    let a = EO(e);
    s.customApiKeyResponses.approved.includes(a) ||
      s.customApiKeyResponses.approved.push(a);
    try {
      (Cr.writeFileSync(n, JSON.stringify(s, null, 2), "utf8"),
        (0, TO.chmodSync)(n, 384),
        this.logger.log("API key saved to config file"));
    } catch (i) {
      throw (
        this.logger.error(`Failed to save API key: ${i}`),
        new Error(`Failed to save API key ${i}`)
      );
    }
  }
  async logout() {
    this.logger.log("Logging out - clearing stored credentials");
    let e = !0;
    (process.platform === "darwin" && this.maybeRemoveApiKeyFromMacOSKeychain(),
      Ed().delete());
    let n = this.getConfigPath(),
      s = Cd.join(n, "config.json");
    if (Cr.existsSync(s))
      try {
        let a = JSON.parse(Cr.readFileSync(s, "utf8"));
        (delete a.primaryApiKey,
          Cr.writeFileSync(s, JSON.stringify(a, null, 2), "utf8"));
      } catch {
        e = !1;
      }
    return (this.logger.log(`Logout ${e ? "successful" : "failed"}`), e);
  }
  getConfigPath() {
    return sn();
  }
  handleManualAuthCode(e) {
    this.currentOAuthService
      ? (this.logger.log("Handling manual auth code input"),
        this.currentOAuthService.handleManualAuthCodeInput(e))
      : this.logger.warn("No active OAuth service to handle manual auth code");
  }
  async login(e, r) {
    (this.logger.log(`Starting OAuth login flow: method=${e}`),
      (this.currentOAuthService = new xd(this.logger)));
    try {
      let n = await this.currentOAuthService.startOAuthFlow(
        e === "claudeai",
        r,
      );
      if (e === "claudeai") this.saveOAuthTokens(n);
      else if (e === "console") {
        this.logger.log("Creating API key for Console user");
        let a = await this.currentOAuthService.createApiKey(n.accessToken);
        if (!a)
          throw (
            this.logger.error("Failed to create API key"),
            new Error("Failed to create API key")
          );
        await this.saveApiKey(a);
      }
      this.logger.log("Login successful");
      let s = this.getAuthStatus();
      if (!s) throw new Error("Failed to retrieve auth status after login");
      return s;
    } finally {
      this.currentOAuthService &&
        (this.currentOAuthService.cleanup(), (this.currentOAuthService = null));
    }
  }
  maybeRemoveApiKeyFromMacOSKeychain() {
    if (process.platform === "darwin")
      try {
        let e = Ms();
        Ar("security", ["delete-generic-password", "-a", Aa(), "-s", e]);
      } catch (e) {
        this.logger.error(`Failed to remove API key from keychain: ${e}`);
      }
  }
};
function Td(t) {
  if (!t) return !1;
  if (typeof t == "boolean") return t;
  let e = t.toLowerCase().trim();
  return ["1", "true", "yes", "on"].includes(e);
}
function CO(t) {
  return t !== void 0 && Date.now() - t < 864e5;
}
function PO() {
  let t = qw();
  return !(
    t.totalSessions <= 12 ||
    t.recentSessions <= 4 ||
    (t.editsAccepted < 4 && t.editsAutoAccepted < 10) ||
    t.editsDeclined > 1
  );
}
var qc = "2025-06-18";
var Pd = [qc, "2025-03-26", "2024-11-05", "2024-10-07"],
  kd = "2.0",
  kO = E.union([E.string(), E.number().int()]),
  RO = E.string(),
  WJ = E.object({ progressToken: E.optional(kO) }).passthrough(),
  en = E.object({ _meta: E.optional(WJ) }).passthrough(),
  Pr = E.object({ method: E.string(), params: E.optional(en) }),
  zc = E.object({
    _meta: E.optional(E.object({}).passthrough()),
  }).passthrough(),
  Ln = E.object({ method: E.string(), params: E.optional(zc) }),
  tn = E.object({
    _meta: E.optional(E.object({}).passthrough()),
  }).passthrough(),
  Rd = E.union([E.string(), E.number().int()]),
  OO = E.object({ jsonrpc: E.literal(kd), id: Rd })
    .merge(Pr)
    .strict(),
  IO = (t) => OO.safeParse(t).success,
  $O = E.object({ jsonrpc: E.literal(kd) })
    .merge(Ln)
    .strict(),
  AO = (t) => $O.safeParse(t).success,
  NO = E.object({ jsonrpc: E.literal(kd), id: Rd, result: tn }).strict(),
  gv = (t) => NO.safeParse(t).success,
  lt;
(function (t) {
  ((t[(t.ConnectionClosed = -32e3)] = "ConnectionClosed"),
    (t[(t.RequestTimeout = -32001)] = "RequestTimeout"),
    (t[(t.ParseError = -32700)] = "ParseError"),
    (t[(t.InvalidRequest = -32600)] = "InvalidRequest"),
    (t[(t.MethodNotFound = -32601)] = "MethodNotFound"),
    (t[(t.InvalidParams = -32602)] = "InvalidParams"),
    (t[(t.InternalError = -32603)] = "InternalError"));
})(lt || (lt = {}));
var DO = E.object({
    jsonrpc: E.literal(kd),
    id: Rd,
    error: E.object({
      code: E.number().int(),
      message: E.string(),
      data: E.optional(E.unknown()),
    }),
  }).strict(),
  LO = (t) => DO.safeParse(t).success,
  Od = E.union([OO, $O, NO, DO]),
  cs = tn.strict(),
  Id = Ln.extend({
    method: E.literal("notifications/cancelled"),
    params: zc.extend({ requestId: Rd, reason: E.string().optional() }),
  }),
  Bc = E.object({
    name: E.string(),
    title: E.optional(E.string()),
  }).passthrough(),
  MO = Bc.extend({ version: E.string() }),
  KJ = E.object({
    experimental: E.optional(E.object({}).passthrough()),
    sampling: E.optional(E.object({}).passthrough()),
    elicitation: E.optional(E.object({}).passthrough()),
    roots: E.optional(
      E.object({ listChanged: E.optional(E.boolean()) }).passthrough(),
    ),
  }).passthrough(),
  vv = Pr.extend({
    method: E.literal("initialize"),
    params: en.extend({
      protocolVersion: E.string(),
      capabilities: KJ,
      clientInfo: MO,
    }),
  });
var JJ = E.object({
    experimental: E.optional(E.object({}).passthrough()),
    logging: E.optional(E.object({}).passthrough()),
    completions: E.optional(E.object({}).passthrough()),
    prompts: E.optional(
      E.object({ listChanged: E.optional(E.boolean()) }).passthrough(),
    ),
    resources: E.optional(
      E.object({
        subscribe: E.optional(E.boolean()),
        listChanged: E.optional(E.boolean()),
      }).passthrough(),
    ),
    tools: E.optional(
      E.object({ listChanged: E.optional(E.boolean()) }).passthrough(),
    ),
  }).passthrough(),
  yv = tn.extend({
    protocolVersion: E.string(),
    capabilities: JJ,
    serverInfo: MO,
    instructions: E.optional(E.string()),
  }),
  bv = Ln.extend({ method: E.literal("notifications/initialized") });
var $d = Pr.extend({ method: E.literal("ping") }),
  XJ = E.object({
    progress: E.number(),
    total: E.optional(E.number()),
    message: E.optional(E.string()),
  }).passthrough(),
  Ad = Ln.extend({
    method: E.literal("notifications/progress"),
    params: zc.merge(XJ).extend({ progressToken: kO }),
  }),
  Nd = Pr.extend({ params: en.extend({ cursor: E.optional(RO) }).optional() }),
  Dd = tn.extend({ nextCursor: E.optional(RO) }),
  jO = E.object({
    uri: E.string(),
    mimeType: E.optional(E.string()),
    _meta: E.optional(E.object({}).passthrough()),
  }).passthrough(),
  FO = jO.extend({ text: E.string() }),
  _v = E.string().refine(
    (t) => {
      try {
        return (atob(t), !0);
      } catch {
        return !1;
      }
    },
    { message: "Invalid Base64 string" },
  ),
  UO = jO.extend({ blob: _v }),
  qO = Bc.extend({
    uri: E.string(),
    description: E.optional(E.string()),
    mimeType: E.optional(E.string()),
    _meta: E.optional(E.object({}).passthrough()),
  }),
  YJ = Bc.extend({
    uriTemplate: E.string(),
    description: E.optional(E.string()),
    mimeType: E.optional(E.string()),
    _meta: E.optional(E.object({}).passthrough()),
  }),
  Ld = Nd.extend({ method: E.literal("resources/list") }),
  xv = Dd.extend({ resources: E.array(qO) }),
  Md = Nd.extend({ method: E.literal("resources/templates/list") }),
  wv = Dd.extend({ resourceTemplates: E.array(YJ) }),
  jd = Pr.extend({
    method: E.literal("resources/read"),
    params: en.extend({ uri: E.string() }),
  }),
  Sv = tn.extend({ contents: E.array(E.union([FO, UO])) }),
  QJ = Ln.extend({ method: E.literal("notifications/resources/list_changed") }),
  e7 = Pr.extend({
    method: E.literal("resources/subscribe"),
    params: en.extend({ uri: E.string() }),
  }),
  t7 = Pr.extend({
    method: E.literal("resources/unsubscribe"),
    params: en.extend({ uri: E.string() }),
  }),
  r7 = Ln.extend({
    method: E.literal("notifications/resources/updated"),
    params: zc.extend({ uri: E.string() }),
  }),
  n7 = E.object({
    name: E.string(),
    description: E.optional(E.string()),
    required: E.optional(E.boolean()),
  }).passthrough(),
  s7 = Bc.extend({
    description: E.optional(E.string()),
    arguments: E.optional(E.array(n7)),
    _meta: E.optional(E.object({}).passthrough()),
  }),
  Fd = Nd.extend({ method: E.literal("prompts/list") }),
  Ev = Dd.extend({ prompts: E.array(s7) }),
  Ud = Pr.extend({
    method: E.literal("prompts/get"),
    params: en.extend({
      name: E.string(),
      arguments: E.optional(E.record(E.string())),
    }),
  }),
  Tv = E.object({
    type: E.literal("text"),
    text: E.string(),
    _meta: E.optional(E.object({}).passthrough()),
  }).passthrough(),
  Cv = E.object({
    type: E.literal("image"),
    data: _v,
    mimeType: E.string(),
    _meta: E.optional(E.object({}).passthrough()),
  }).passthrough(),
  Pv = E.object({
    type: E.literal("audio"),
    data: _v,
    mimeType: E.string(),
    _meta: E.optional(E.object({}).passthrough()),
  }).passthrough(),
  a7 = E.object({
    type: E.literal("resource"),
    resource: E.union([FO, UO]),
    _meta: E.optional(E.object({}).passthrough()),
  }).passthrough(),
  i7 = qO.extend({ type: E.literal("resource_link") }),
  zO = E.union([Tv, Cv, Pv, i7, a7]),
  o7 = E.object({
    role: E.enum(["user", "assistant"]),
    content: zO,
  }).passthrough(),
  kv = tn.extend({
    description: E.optional(E.string()),
    messages: E.array(o7),
  }),
  c7 = Ln.extend({ method: E.literal("notifications/prompts/list_changed") }),
  l7 = E.object({
    title: E.optional(E.string()),
    readOnlyHint: E.optional(E.boolean()),
    destructiveHint: E.optional(E.boolean()),
    idempotentHint: E.optional(E.boolean()),
    openWorldHint: E.optional(E.boolean()),
  }).passthrough(),
  u7 = Bc.extend({
    description: E.optional(E.string()),
    inputSchema: E.object({
      type: E.literal("object"),
      properties: E.optional(E.object({}).passthrough()),
      required: E.optional(E.array(E.string())),
    }).passthrough(),
    outputSchema: E.optional(
      E.object({
        type: E.literal("object"),
        properties: E.optional(E.object({}).passthrough()),
        required: E.optional(E.array(E.string())),
      }).passthrough(),
    ),
    annotations: E.optional(l7),
    _meta: E.optional(E.object({}).passthrough()),
  }),
  qd = Nd.extend({ method: E.literal("tools/list") }),
  Rv = Dd.extend({ tools: E.array(u7) }),
  Na = tn.extend({
    content: E.array(zO).default([]),
    structuredContent: E.object({}).passthrough().optional(),
    isError: E.optional(E.boolean()),
  }),
  ofe = Na.or(tn.extend({ toolResult: E.unknown() })),
  zd = Pr.extend({
    method: E.literal("tools/call"),
    params: en.extend({
      name: E.string(),
      arguments: E.optional(E.record(E.unknown())),
    }),
  }),
  d7 = Ln.extend({ method: E.literal("notifications/tools/list_changed") }),
  BO = E.enum([
    "debug",
    "info",
    "notice",
    "warning",
    "error",
    "critical",
    "alert",
    "emergency",
  ]),
  p7 = Pr.extend({
    method: E.literal("logging/setLevel"),
    params: en.extend({ level: BO }),
  }),
  f7 = Ln.extend({
    method: E.literal("notifications/message"),
    params: zc.extend({
      level: BO,
      logger: E.optional(E.string()),
      data: E.unknown(),
    }),
  }),
  m7 = E.object({ name: E.string().optional() }).passthrough(),
  h7 = E.object({
    hints: E.optional(E.array(m7)),
    costPriority: E.optional(E.number().min(0).max(1)),
    speedPriority: E.optional(E.number().min(0).max(1)),
    intelligencePriority: E.optional(E.number().min(0).max(1)),
  }).passthrough(),
  g7 = E.object({
    role: E.enum(["user", "assistant"]),
    content: E.union([Tv, Cv, Pv]),
  }).passthrough(),
  v7 = Pr.extend({
    method: E.literal("sampling/createMessage"),
    params: en.extend({
      messages: E.array(g7),
      systemPrompt: E.optional(E.string()),
      includeContext: E.optional(E.enum(["none", "thisServer", "allServers"])),
      temperature: E.optional(E.number()),
      maxTokens: E.number().int(),
      stopSequences: E.optional(E.array(E.string())),
      metadata: E.optional(E.object({}).passthrough()),
      modelPreferences: E.optional(h7),
    }),
  }),
  Ov = tn.extend({
    model: E.string(),
    stopReason: E.optional(
      E.enum(["endTurn", "stopSequence", "maxTokens"]).or(E.string()),
    ),
    role: E.enum(["user", "assistant"]),
    content: E.discriminatedUnion("type", [Tv, Cv, Pv]),
  }),
  y7 = E.object({
    type: E.literal("boolean"),
    title: E.optional(E.string()),
    description: E.optional(E.string()),
    default: E.optional(E.boolean()),
  }).passthrough(),
  b7 = E.object({
    type: E.literal("string"),
    title: E.optional(E.string()),
    description: E.optional(E.string()),
    minLength: E.optional(E.number()),
    maxLength: E.optional(E.number()),
    format: E.optional(E.enum(["email", "uri", "date", "date-time"])),
  }).passthrough(),
  _7 = E.object({
    type: E.enum(["number", "integer"]),
    title: E.optional(E.string()),
    description: E.optional(E.string()),
    minimum: E.optional(E.number()),
    maximum: E.optional(E.number()),
  }).passthrough(),
  x7 = E.object({
    type: E.literal("string"),
    title: E.optional(E.string()),
    description: E.optional(E.string()),
    enum: E.array(E.string()),
    enumNames: E.optional(E.array(E.string())),
  }).passthrough(),
  w7 = E.union([y7, b7, _7, x7]),
  S7 = Pr.extend({
    method: E.literal("elicitation/create"),
    params: en.extend({
      message: E.string(),
      requestedSchema: E.object({
        type: E.literal("object"),
        properties: E.record(E.string(), w7),
        required: E.optional(E.array(E.string())),
      }).passthrough(),
    }),
  }),
  Iv = tn.extend({
    action: E.enum(["accept", "decline", "cancel"]),
    content: E.optional(E.record(E.string(), E.unknown())),
  }),
  E7 = E.object({
    type: E.literal("ref/resource"),
    uri: E.string(),
  }).passthrough();
var T7 = E.object({
    type: E.literal("ref/prompt"),
    name: E.string(),
  }).passthrough(),
  Bd = Pr.extend({
    method: E.literal("completion/complete"),
    params: en.extend({
      ref: E.union([T7, E7]),
      argument: E.object({ name: E.string(), value: E.string() }).passthrough(),
      context: E.optional(
        E.object({ arguments: E.optional(E.record(E.string(), E.string())) }),
      ),
    }),
  }),
  $v = tn.extend({
    completion: E.object({
      values: E.array(E.string()).max(100),
      total: E.optional(E.number().int()),
      hasMore: E.optional(E.boolean()),
    }).passthrough(),
  }),
  C7 = E.object({
    uri: E.string().startsWith("file://"),
    name: E.optional(E.string()),
    _meta: E.optional(E.object({}).passthrough()),
  }).passthrough(),
  P7 = Pr.extend({ method: E.literal("roots/list") }),
  Av = tn.extend({ roots: E.array(C7) }),
  k7 = Ln.extend({ method: E.literal("notifications/roots/list_changed") }),
  cfe = E.union([$d, vv, Bd, p7, Ud, Fd, Ld, Md, jd, e7, t7, zd, qd]),
  lfe = E.union([Id, Ad, bv, k7]),
  ufe = E.union([cs, Ov, Iv, Av]),
  dfe = E.union([$d, v7, S7, P7]),
  pfe = E.union([Id, Ad, f7, r7, QJ, d7, c7]),
  ffe = E.union([cs, yv, $v, kv, Ev, xv, wv, Sv, Na, Rv]),
  ot = class extends Error {
    constructor(e, r, n) {
      (super(`MCP error ${e}: ${r}`),
        (this.code = e),
        (this.data = n),
        (this.name = "McpError"));
    }
  };
var R7 = 6e4,
  ao = class {
    constructor(e) {
      ((this._options = e),
        (this._requestMessageId = 0),
        (this._requestHandlers = new Map()),
        (this._requestHandlerAbortControllers = new Map()),
        (this._notificationHandlers = new Map()),
        (this._responseHandlers = new Map()),
        (this._progressHandlers = new Map()),
        (this._timeoutInfo = new Map()),
        (this._pendingDebouncedNotifications = new Set()),
        this.setNotificationHandler(Id, (r) => {
          let n = this._requestHandlerAbortControllers.get(r.params.requestId);
          n?.abort(r.params.reason);
        }),
        this.setNotificationHandler(Ad, (r) => {
          this._onprogress(r);
        }),
        this.setRequestHandler($d, (r) => ({})));
    }
    _setupTimeout(e, r, n, s, a = !1) {
      this._timeoutInfo.set(e, {
        timeoutId: setTimeout(s, r),
        startTime: Date.now(),
        timeout: r,
        maxTotalTimeout: n,
        resetTimeoutOnProgress: a,
        onTimeout: s,
      });
    }
    _resetTimeout(e) {
      let r = this._timeoutInfo.get(e);
      if (!r) return !1;
      let n = Date.now() - r.startTime;
      if (r.maxTotalTimeout && n >= r.maxTotalTimeout)
        throw (
          this._timeoutInfo.delete(e),
          new ot(lt.RequestTimeout, "Maximum total timeout exceeded", {
            maxTotalTimeout: r.maxTotalTimeout,
            totalElapsed: n,
          })
        );
      return (
        clearTimeout(r.timeoutId),
        (r.timeoutId = setTimeout(r.onTimeout, r.timeout)),
        !0
      );
    }
    _cleanupTimeout(e) {
      let r = this._timeoutInfo.get(e);
      r && (clearTimeout(r.timeoutId), this._timeoutInfo.delete(e));
    }
    async connect(e) {
      var r, n, s;
      this._transport = e;
      let a =
        (r = this.transport) === null || r === void 0 ? void 0 : r.onclose;
      this._transport.onclose = () => {
        (a?.(), this._onclose());
      };
      let i =
        (n = this.transport) === null || n === void 0 ? void 0 : n.onerror;
      this._transport.onerror = (c) => {
        (i?.(c), this._onerror(c));
      };
      let o =
        (s = this._transport) === null || s === void 0 ? void 0 : s.onmessage;
      ((this._transport.onmessage = (c, l) => {
        (o?.(c, l),
          gv(c) || LO(c)
            ? this._onresponse(c)
            : IO(c)
              ? this._onrequest(c, l)
              : AO(c)
                ? this._onnotification(c)
                : this._onerror(
                    new Error(`Unknown message type: ${JSON.stringify(c)}`),
                  ));
      }),
        await this._transport.start());
    }
    _onclose() {
      var e;
      let r = this._responseHandlers;
      ((this._responseHandlers = new Map()),
        this._progressHandlers.clear(),
        this._pendingDebouncedNotifications.clear(),
        (this._transport = void 0),
        (e = this.onclose) === null || e === void 0 || e.call(this));
      let n = new ot(lt.ConnectionClosed, "Connection closed");
      for (let s of r.values()) s(n);
    }
    _onerror(e) {
      var r;
      (r = this.onerror) === null || r === void 0 || r.call(this, e);
    }
    _onnotification(e) {
      var r;
      let n =
        (r = this._notificationHandlers.get(e.method)) !== null && r !== void 0
          ? r
          : this.fallbackNotificationHandler;
      n !== void 0 &&
        Promise.resolve()
          .then(() => n(e))
          .catch((s) =>
            this._onerror(
              new Error(`Uncaught error in notification handler: ${s}`),
            ),
          );
    }
    _onrequest(e, r) {
      var n, s;
      let a =
          (n = this._requestHandlers.get(e.method)) !== null && n !== void 0
            ? n
            : this.fallbackRequestHandler,
        i = this._transport;
      if (a === void 0) {
        i?.send({
          jsonrpc: "2.0",
          id: e.id,
          error: { code: lt.MethodNotFound, message: "Method not found" },
        }).catch((l) =>
          this._onerror(new Error(`Failed to send an error response: ${l}`)),
        );
        return;
      }
      let o = new AbortController();
      this._requestHandlerAbortControllers.set(e.id, o);
      let c = {
        signal: o.signal,
        sessionId: i?.sessionId,
        _meta: (s = e.params) === null || s === void 0 ? void 0 : s._meta,
        sendNotification: (l) =>
          this.notification(l, { relatedRequestId: e.id }),
        sendRequest: (l, u, d) =>
          this.request(l, u, { ...d, relatedRequestId: e.id }),
        authInfo: r?.authInfo,
        requestId: e.id,
        requestInfo: r?.requestInfo,
      };
      Promise.resolve()
        .then(() => a(e, c))
        .then(
          (l) => {
            if (!o.signal.aborted)
              return i?.send({ result: l, jsonrpc: "2.0", id: e.id });
          },
          (l) => {
            var u;
            if (!o.signal.aborted)
              return i?.send({
                jsonrpc: "2.0",
                id: e.id,
                error: {
                  code: Number.isSafeInteger(l.code)
                    ? l.code
                    : lt.InternalError,
                  message:
                    (u = l.message) !== null && u !== void 0
                      ? u
                      : "Internal error",
                },
              });
          },
        )
        .catch((l) => this._onerror(new Error(`Failed to send response: ${l}`)))
        .finally(() => {
          this._requestHandlerAbortControllers.delete(e.id);
        });
    }
    _onprogress(e) {
      let { progressToken: r, ...n } = e.params,
        s = Number(r),
        a = this._progressHandlers.get(s);
      if (!a) {
        this._onerror(
          new Error(
            `Received a progress notification for an unknown token: ${JSON.stringify(e)}`,
          ),
        );
        return;
      }
      let i = this._responseHandlers.get(s),
        o = this._timeoutInfo.get(s);
      if (o && i && o.resetTimeoutOnProgress)
        try {
          this._resetTimeout(s);
        } catch (c) {
          i(c);
          return;
        }
      a(n);
    }
    _onresponse(e) {
      let r = Number(e.id),
        n = this._responseHandlers.get(r);
      if (n === void 0) {
        this._onerror(
          new Error(
            `Received a response for an unknown message ID: ${JSON.stringify(e)}`,
          ),
        );
        return;
      }
      if (
        (this._responseHandlers.delete(r),
        this._progressHandlers.delete(r),
        this._cleanupTimeout(r),
        gv(e))
      )
        n(e);
      else {
        let s = new ot(e.error.code, e.error.message, e.error.data);
        n(s);
      }
    }
    get transport() {
      return this._transport;
    }
    async close() {
      var e;
      await ((e = this._transport) === null || e === void 0
        ? void 0
        : e.close());
    }
    request(e, r, n) {
      let {
        relatedRequestId: s,
        resumptionToken: a,
        onresumptiontoken: i,
      } = n ?? {};
      return new Promise((o, c) => {
        var l, u, d, m, p, f;
        if (!this._transport) {
          c(new Error("Not connected"));
          return;
        }
        (((l = this._options) === null || l === void 0
          ? void 0
          : l.enforceStrictCapabilities) === !0 &&
          this.assertCapabilityForMethod(e.method),
          (u = n?.signal) === null || u === void 0 || u.throwIfAborted());
        let y = this._requestMessageId++,
          h = { ...e, jsonrpc: "2.0", id: y };
        n?.onprogress &&
          (this._progressHandlers.set(y, n.onprogress),
          (h.params = {
            ...e.params,
            _meta: {
              ...(((d = e.params) === null || d === void 0
                ? void 0
                : d._meta) || {}),
              progressToken: y,
            },
          }));
        let g = (b) => {
          var x;
          (this._responseHandlers.delete(y),
            this._progressHandlers.delete(y),
            this._cleanupTimeout(y),
            (x = this._transport) === null ||
              x === void 0 ||
              x
                .send(
                  {
                    jsonrpc: "2.0",
                    method: "notifications/cancelled",
                    params: { requestId: y, reason: String(b) },
                  },
                  {
                    relatedRequestId: s,
                    resumptionToken: a,
                    onresumptiontoken: i,
                  },
                )
                .catch((w) =>
                  this._onerror(new Error(`Failed to send cancellation: ${w}`)),
                ),
            c(b));
        };
        (this._responseHandlers.set(y, (b) => {
          var x;
          if (!(!((x = n?.signal) === null || x === void 0) && x.aborted)) {
            if (b instanceof Error) return c(b);
            try {
              let w = r.parse(b.result);
              o(w);
            } catch (w) {
              c(w);
            }
          }
        }),
          (m = n?.signal) === null ||
            m === void 0 ||
            m.addEventListener("abort", () => {
              var b;
              g((b = n?.signal) === null || b === void 0 ? void 0 : b.reason);
            }));
        let _ = (p = n?.timeout) !== null && p !== void 0 ? p : R7,
          v = () =>
            g(new ot(lt.RequestTimeout, "Request timed out", { timeout: _ }));
        (this._setupTimeout(
          y,
          _,
          n?.maxTotalTimeout,
          v,
          (f = n?.resetTimeoutOnProgress) !== null && f !== void 0 ? f : !1,
        ),
          this._transport
            .send(h, {
              relatedRequestId: s,
              resumptionToken: a,
              onresumptiontoken: i,
            })
            .catch((b) => {
              (this._cleanupTimeout(y), c(b));
            }));
      });
    }
    async notification(e, r) {
      var n, s;
      if (!this._transport) throw new Error("Not connected");
      if (
        (this.assertNotificationCapability(e.method),
        ((s =
          (n = this._options) === null || n === void 0
            ? void 0
            : n.debouncedNotificationMethods) !== null && s !== void 0
          ? s
          : []
        ).includes(e.method) &&
          !e.params &&
          !r?.relatedRequestId)
      ) {
        if (this._pendingDebouncedNotifications.has(e.method)) return;
        (this._pendingDebouncedNotifications.add(e.method),
          Promise.resolve().then(() => {
            var c;
            if (
              (this._pendingDebouncedNotifications.delete(e.method),
              !this._transport)
            )
              return;
            let l = { ...e, jsonrpc: "2.0" };
            (c = this._transport) === null ||
              c === void 0 ||
              c.send(l, r).catch((u) => this._onerror(u));
          }));
        return;
      }
      let o = { ...e, jsonrpc: "2.0" };
      await this._transport.send(o, r);
    }
    setRequestHandler(e, r) {
      let n = e.shape.method.value;
      (this.assertRequestHandlerCapability(n),
        this._requestHandlers.set(n, (s, a) =>
          Promise.resolve(r(e.parse(s), a)),
        ));
    }
    removeRequestHandler(e) {
      this._requestHandlers.delete(e);
    }
    assertCanSetRequestHandler(e) {
      if (this._requestHandlers.has(e))
        throw new Error(
          `A request handler for ${e} already exists, which would be overridden`,
        );
    }
    setNotificationHandler(e, r) {
      this._notificationHandlers.set(e.shape.method.value, (n) =>
        Promise.resolve(r(e.parse(n))),
      );
    }
    removeNotificationHandler(e) {
      this._notificationHandlers.delete(e);
    }
  };
function Hd(t, e) {
  return Object.entries(e).reduce(
    (r, [n, s]) => (
      s && typeof s == "object"
        ? (r[n] = r[n] ? { ...r[n], ...s } : s)
        : (r[n] = s),
      r
    ),
    { ...t },
  );
}
var H$ = le(sy(), 1),
  lp = class extends ao {
    constructor(e, r) {
      var n;
      (super(r),
        (this._clientInfo = e),
        (this._cachedToolOutputValidators = new Map()),
        (this._capabilities =
          (n = r?.capabilities) !== null && n !== void 0 ? n : {}),
        (this._ajv = new H$.default()));
    }
    registerCapabilities(e) {
      if (this.transport)
        throw new Error(
          "Cannot register capabilities after connecting to transport",
        );
      this._capabilities = Hd(this._capabilities, e);
    }
    assertCapability(e, r) {
      var n;
      if (!(!((n = this._serverCapabilities) === null || n === void 0) && n[e]))
        throw new Error(`Server does not support ${e} (required for ${r})`);
    }
    async connect(e, r) {
      if ((await super.connect(e), e.sessionId === void 0))
        try {
          let n = await this.request(
            {
              method: "initialize",
              params: {
                protocolVersion: qc,
                capabilities: this._capabilities,
                clientInfo: this._clientInfo,
              },
            },
            yv,
            r,
          );
          if (n === void 0)
            throw new Error(`Server sent invalid initialize result: ${n}`);
          if (!Pd.includes(n.protocolVersion))
            throw new Error(
              `Server's protocol version is not supported: ${n.protocolVersion}`,
            );
          ((this._serverCapabilities = n.capabilities),
            (this._serverVersion = n.serverInfo),
            e.setProtocolVersion && e.setProtocolVersion(n.protocolVersion),
            (this._instructions = n.instructions),
            await this.notification({ method: "notifications/initialized" }));
        } catch (n) {
          throw (this.close(), n);
        }
    }
    getServerCapabilities() {
      return this._serverCapabilities;
    }
    getServerVersion() {
      return this._serverVersion;
    }
    getInstructions() {
      return this._instructions;
    }
    assertCapabilityForMethod(e) {
      var r, n, s, a, i;
      switch (e) {
        case "logging/setLevel":
          if (
            !(
              !((r = this._serverCapabilities) === null || r === void 0) &&
              r.logging
            )
          )
            throw new Error(
              `Server does not support logging (required for ${e})`,
            );
          break;
        case "prompts/get":
        case "prompts/list":
          if (
            !(
              !((n = this._serverCapabilities) === null || n === void 0) &&
              n.prompts
            )
          )
            throw new Error(
              `Server does not support prompts (required for ${e})`,
            );
          break;
        case "resources/list":
        case "resources/templates/list":
        case "resources/read":
        case "resources/subscribe":
        case "resources/unsubscribe":
          if (
            !(
              !((s = this._serverCapabilities) === null || s === void 0) &&
              s.resources
            )
          )
            throw new Error(
              `Server does not support resources (required for ${e})`,
            );
          if (
            e === "resources/subscribe" &&
            !this._serverCapabilities.resources.subscribe
          )
            throw new Error(
              `Server does not support resource subscriptions (required for ${e})`,
            );
          break;
        case "tools/call":
        case "tools/list":
          if (
            !(
              !((a = this._serverCapabilities) === null || a === void 0) &&
              a.tools
            )
          )
            throw new Error(
              `Server does not support tools (required for ${e})`,
            );
          break;
        case "completion/complete":
          if (
            !(
              !((i = this._serverCapabilities) === null || i === void 0) &&
              i.completions
            )
          )
            throw new Error(
              `Server does not support completions (required for ${e})`,
            );
          break;
        case "initialize":
          break;
        case "ping":
          break;
      }
    }
    assertNotificationCapability(e) {
      var r;
      switch (e) {
        case "notifications/roots/list_changed":
          if (
            !(
              !((r = this._capabilities.roots) === null || r === void 0) &&
              r.listChanged
            )
          )
            throw new Error(
              `Client does not support roots list changed notifications (required for ${e})`,
            );
          break;
        case "notifications/initialized":
          break;
        case "notifications/cancelled":
          break;
        case "notifications/progress":
          break;
      }
    }
    assertRequestHandlerCapability(e) {
      switch (e) {
        case "sampling/createMessage":
          if (!this._capabilities.sampling)
            throw new Error(
              `Client does not support sampling capability (required for ${e})`,
            );
          break;
        case "elicitation/create":
          if (!this._capabilities.elicitation)
            throw new Error(
              `Client does not support elicitation capability (required for ${e})`,
            );
          break;
        case "roots/list":
          if (!this._capabilities.roots)
            throw new Error(
              `Client does not support roots capability (required for ${e})`,
            );
          break;
        case "ping":
          break;
      }
    }
    async ping(e) {
      return this.request({ method: "ping" }, cs, e);
    }
    async complete(e, r) {
      return this.request({ method: "completion/complete", params: e }, $v, r);
    }
    async setLoggingLevel(e, r) {
      return this.request(
        { method: "logging/setLevel", params: { level: e } },
        cs,
        r,
      );
    }
    async getPrompt(e, r) {
      return this.request({ method: "prompts/get", params: e }, kv, r);
    }
    async listPrompts(e, r) {
      return this.request({ method: "prompts/list", params: e }, Ev, r);
    }
    async listResources(e, r) {
      return this.request({ method: "resources/list", params: e }, xv, r);
    }
    async listResourceTemplates(e, r) {
      return this.request(
        { method: "resources/templates/list", params: e },
        wv,
        r,
      );
    }
    async readResource(e, r) {
      return this.request({ method: "resources/read", params: e }, Sv, r);
    }
    async subscribeResource(e, r) {
      return this.request({ method: "resources/subscribe", params: e }, cs, r);
    }
    async unsubscribeResource(e, r) {
      return this.request(
        { method: "resources/unsubscribe", params: e },
        cs,
        r,
      );
    }
    async callTool(e, r = Na, n) {
      let s = await this.request({ method: "tools/call", params: e }, r, n),
        a = this.getToolOutputValidator(e.name);
      if (a) {
        if (!s.structuredContent && !s.isError)
          throw new ot(
            lt.InvalidRequest,
            `Tool ${e.name} has an output schema but did not return structured content`,
          );
        if (s.structuredContent)
          try {
            if (!a(s.structuredContent))
              throw new ot(
                lt.InvalidParams,
                `Structured content does not match the tool's output schema: ${this._ajv.errorsText(a.errors)}`,
              );
          } catch (i) {
            throw i instanceof ot
              ? i
              : new ot(
                  lt.InvalidParams,
                  `Failed to validate structured content: ${i instanceof Error ? i.message : String(i)}`,
                );
          }
      }
      return s;
    }
    cacheToolOutputSchemas(e) {
      this._cachedToolOutputValidators.clear();
      for (let r of e)
        if (r.outputSchema)
          try {
            let n = this._ajv.compile(r.outputSchema);
            this._cachedToolOutputValidators.set(r.name, n);
          } catch {}
    }
    getToolOutputValidator(e) {
      return this._cachedToolOutputValidators.get(e);
    }
    async listTools(e, r) {
      let n = await this.request({ method: "tools/list", params: e }, Rv, r);
      return (this.cacheToolOutputSchemas(n.tools), n);
    }
    async sendRootsListChanged() {
      return this.notification({ method: "notifications/roots/list_changed" });
    }
  };
var Z$ = le(ef(), 1),
  Vc = le(require("node:process"), 1),
  G$ = require("node:stream");
var up = class {
  append(e) {
    this._buffer = this._buffer ? Buffer.concat([this._buffer, e]) : e;
  }
  readMessage() {
    if (!this._buffer) return null;
    let e = this._buffer.indexOf(`
`);
    if (e === -1) return null;
    let r = this._buffer.toString("utf8", 0, e).replace(/\r$/, "");
    return ((this._buffer = this._buffer.subarray(e + 1)), cY(r));
  }
  clear() {
    this._buffer = void 0;
  }
};
function cY(t) {
  return Od.parse(JSON.parse(t));
}
function V$(t) {
  return (
    JSON.stringify(t) +
    `
`
  );
}
var lY =
  Vc.default.platform === "win32"
    ? [
        "APPDATA",
        "HOMEDRIVE",
        "HOMEPATH",
        "LOCALAPPDATA",
        "PATH",
        "PROCESSOR_ARCHITECTURE",
        "SYSTEMDRIVE",
        "SYSTEMROOT",
        "TEMP",
        "USERNAME",
        "USERPROFILE",
        "PROGRAMFILES",
      ]
    : ["HOME", "LOGNAME", "PATH", "SHELL", "TERM", "USER"];
function uY() {
  let t = {};
  for (let e of lY) {
    let r = Vc.default.env[e];
    r !== void 0 && (r.startsWith("()") || (t[e] = r));
  }
  return t;
}
var dp = class {
  constructor(e) {
    ((this._abortController = new AbortController()),
      (this._readBuffer = new up()),
      (this._stderrStream = null),
      (this._serverParams = e),
      (e.stderr === "pipe" || e.stderr === "overlapped") &&
        (this._stderrStream = new G$.PassThrough()));
  }
  async start() {
    if (this._process)
      throw new Error(
        "StdioClientTransport already started! If using Client class, note that connect() calls start() automatically.",
      );
    return new Promise((e, r) => {
      var n, s, a, i, o;
      ((this._process = (0, Z$.default)(
        this._serverParams.command,
        (n = this._serverParams.args) !== null && n !== void 0 ? n : [],
        {
          env: { ...uY(), ...this._serverParams.env },
          stdio: [
            "pipe",
            "pipe",
            (s = this._serverParams.stderr) !== null && s !== void 0
              ? s
              : "inherit",
          ],
          shell: !1,
          signal: this._abortController.signal,
          windowsHide: Vc.default.platform === "win32" && dY(),
          cwd: this._serverParams.cwd,
        },
      )),
        this._process.on("error", (c) => {
          var l, u;
          if (c.name === "AbortError") {
            (l = this.onclose) === null || l === void 0 || l.call(this);
            return;
          }
          (r(c),
            (u = this.onerror) === null || u === void 0 || u.call(this, c));
        }),
        this._process.on("spawn", () => {
          e();
        }),
        this._process.on("close", (c) => {
          var l;
          ((this._process = void 0),
            (l = this.onclose) === null || l === void 0 || l.call(this));
        }),
        (a = this._process.stdin) === null ||
          a === void 0 ||
          a.on("error", (c) => {
            var l;
            (l = this.onerror) === null || l === void 0 || l.call(this, c);
          }),
        (i = this._process.stdout) === null ||
          i === void 0 ||
          i.on("data", (c) => {
            (this._readBuffer.append(c), this.processReadBuffer());
          }),
        (o = this._process.stdout) === null ||
          o === void 0 ||
          o.on("error", (c) => {
            var l;
            (l = this.onerror) === null || l === void 0 || l.call(this, c);
          }),
        this._stderrStream &&
          this._process.stderr &&
          this._process.stderr.pipe(this._stderrStream));
    });
  }
  get stderr() {
    var e, r;
    return this._stderrStream
      ? this._stderrStream
      : (r =
            (e = this._process) === null || e === void 0
              ? void 0
              : e.stderr) !== null && r !== void 0
        ? r
        : null;
  }
  get pid() {
    var e, r;
    return (r =
      (e = this._process) === null || e === void 0 ? void 0 : e.pid) !== null &&
      r !== void 0
      ? r
      : null;
  }
  processReadBuffer() {
    for (var e, r; ; )
      try {
        let n = this._readBuffer.readMessage();
        if (n === null) break;
        (e = this.onmessage) === null || e === void 0 || e.call(this, n);
      } catch (n) {
        (r = this.onerror) === null || r === void 0 || r.call(this, n);
      }
  }
  async close() {
    (this._abortController.abort(),
      (this._process = void 0),
      this._readBuffer.clear());
  }
  send(e) {
    return new Promise((r) => {
      var n;
      if (!(!((n = this._process) === null || n === void 0) && n.stdin))
        throw new Error("Not connected");
      let s = V$(e);
      this._process.stdin.write(s) ? r() : this._process.stdin.once("drain", r);
    });
  }
};
function dY() {
  return "type" in Vc.default;
}
var Zc = class {
  constructor(e, r) {
    this.output = e;
    this.getClaudeBinary = r;
  }
  client = null;
  transport = null;
  async connect() {
    return !1;
  }
  async disconnect() {}
  async createNewBrowserTab() {
    if (!(await this.connect()) || !this.client)
      throw new Error("Failed to connect to Chrome MCP server");
    try {
      let r = await this.client.callTool(
        { name: "tabs_context_mcp", arguments: { createIfEmpty: !0 } },
        Na,
      );
      if (r.isError) {
        let s = W$(r.content);
        throw new Error(`Failed to create new tab: ${s}`);
      }
      let n = r.content;
      if (Array.isArray(n) && n.length > 0) {
        let s = n.find((a) => a.type === "text");
        if (s && "text" in s) {
          let a = JSON.parse(s.text);
          return { tabGroupId: String(a.tabGroupId), tabId: a.tabId };
        }
      }
      throw new Error("Unexpected response format from tabs_create");
    } catch (r) {
      throw (
        this.output.error(`Chrome MCP: Error calling tabs_create: ${r}`),
        await this.disconnect(),
        r
      );
    }
  }
  async getBrowserTabs() {
    if (!(await this.connect()) || !this.client) return [];
    try {
      let r = await this.client.callTool(
          { name: "tabs_context_mcp", arguments: { createIfEmpty: !1 } },
          Na,
        ),
        n = { tabGroupId: "", tabId: 0, title: "new tab", url: "" };
      if (r.isError)
        return W$(r.content).includes("No tab available")
          ? [n]
          : (this.output.warn(
              `Chrome MCP: tabs_context returned error: ${JSON.stringify(r.content)}`,
            ),
            []);
      let s = r.content;
      if (Array.isArray(s) && s.length > 0) {
        let a = s.find((i) => i.type === "text");
        if (a && "text" in a)
          try {
            let i = JSON.parse(a.text),
              o = String(i.tabGroupId),
              c = (i.availableTabs || []).map((l) => ({ ...l, tabGroupId: o }));
            return (c.push(n), c);
          } catch (i) {
            if (a.text.includes("No MCP tab groups found.")) return [n];
            (this.output.warn(
              `Chrome MCP: Failed to parse tabs_context response: ${i}`,
            ),
              this.output.warn(`Response text: ${a.text}`));
          }
      }
      return [];
    } catch (r) {
      return (
        this.output.error(`Chrome MCP: Error calling tabs_context: ${r}`),
        await this.disconnect(),
        []
      );
    }
  }
};
function W$(t) {
  return typeof t == "string"
    ? t
    : Array.isArray(t)
      ? t
          .map((e) => {
            if (
              e &&
              typeof e == "object" &&
              "text" in e &&
              typeof e.text == "string"
            )
              return e.text;
          })
          .join("")
      : "";
}
var pY = `
# VSCode Extension Context

You are running inside a VSCode native extension environment.

## Code References in Text
IMPORTANT: When referencing files or code locations, use markdown link syntax to make them clickable:
- For files: [filename.ts](src/filename.ts)
- For specific lines: [filename.ts:42](src/filename.ts#L42)
- For a range of lines: [filename.ts:42-51](src/filename.ts#L42-L51)
- For folders: [src/utils/](src/utils/)
Unless explicitly asked for by the user, DO NOT USE backtickets \` or HTML tags like code for file references - always use markdown [text](link) format.
The URL links should be relative paths from the root of  the user's workspace.

## User Selection Context
The user's IDE selection (if any) is included in the conversation context and marked with ide_selection tags. This represents code or text the user has highlighted in their editor and may or may not be relevant to their request.`,
  Gc = class extends Cu {
    constructor(r, n, s, a, i, o, c, l, u, d, m, p, f, y, h) {
      let g = r.globalState.get("experimentGates") || {},
        _ = r.globalState.get("showTerminalBanner");
      super(
        n,
        io(i),
        s,
        !!h,
        _ === void 0 ? !0 : _,
        g,
        new so(io(i), pp(), mr("disableLoginPrompt")),
      );
      this.context = r;
      this.cwd = n;
      this.settings = s;
      this.webview = a;
      this.output = i;
      this.leftTempFileProvider = l;
      this.rightTempFileProvider = u;
      this.readOnlyTempFileProvider = d;
      this.acceptOrRejectDiffs = m;
      this.getCurrentSelection = p;
      this.isVisible = f;
      this.makeVisible = y;
      this.panelTab = h;
      (this.checkAndUpdateReviewUpsellBanner(),
        this.checkAndUpdateYearEndPromo(),
        o((v) => {
          (this.send({
            type: "request",
            channelId: "",
            requestId: "",
            request: { type: "insert_at_mention", text: v },
          }),
            this.panelTab && this.panelTab.reveal());
        }),
        c((v) => {
          this.send({
            type: "request",
            channelId: "",
            requestId: "",
            request: { type: "selection_changed", selection: v },
          });
        }),
        setTimeout(() => {
          this.notifyVisibilityChange(this.isVisible());
        }, 100));
    }
    sendQueue = Promise.resolve();
    speechToTextChannels = new Map();
    chromeMcpClient;
    notifyVisibilityChange(r) {
      (this.send({
        type: "request",
        channelId: "",
        requestId: "",
        request: { type: "visibility_changed", isVisible: r },
      }),
        r &&
          (this.checkAndUpdateReviewUpsellBanner(),
          this.checkAndUpdateYearEndPromo()));
    }
    notifyFontConfigurationChange(r) {
      this.send({
        type: "request",
        channelId: "",
        requestId: "",
        request: { type: "font_configuration_changed", fontConfig: r },
      });
    }
    notifyCreateNewConversation() {
      this.send({
        type: "request",
        channelId: "",
        requestId: "",
        request: { type: "create_new_conversation" },
      });
    }
    send(r) {
      ((this.sendQueue = this.sendQueue.then(() =>
        this.webview
          .postMessage({ type: "from-extension", message: r })
          .then(() => {}),
      )),
        this.checkAndUpdateReviewUpsellBanner());
    }
    async processRequest(r, n) {
      if (r.request.type === "get_current_selection")
        return {
          type: "get_current_selection_response",
          selection: this.getCurrentSelection(),
        };
      if (r.request.type === "new_conversation_tab")
        return (
          await he.commands.executeCommand(
            "claude-vscode.editor.open",
            r.request.sessionId,
            r.request.initialPrompt,
          ),
          { type: "new_conversation_tab_response" }
        );
      if (r.request.type === "rename_tab") {
        if (this.panelTab) {
          this.panelTab.title = r.request.title;
          let s;
          (r.request.hasPendingPermissions
            ? (s = "claude-logo-pending.svg")
            : r.request.hasUnseenCompletion
              ? (s = "claude-logo-done.svg")
              : (s = "claude-logo.svg"),
            (this.panelTab.iconPath = he.Uri.file(
              (0, kr.join)(this.context.extensionPath, "resources", s),
            )));
        }
        return { type: "rename_tab_response" };
      } else if (r.request.type === "show_notification") {
        let {
          message: s,
          severity: a,
          buttons: i,
          onlyIfNotVisible: o,
        } = r.request;
        if (o && this.isVisible())
          return { type: "show_notification_response" };
        let c;
        switch (a) {
          case "error":
            c = await he.window.showErrorMessage(s, ...(i || []));
            break;
          case "warning":
            c = await he.window.showWarningMessage(s, ...(i || []));
            break;
          case "info":
          default:
            c = await he.window.showInformationMessage(s, ...(i || []));
            break;
        }
        return (
          c && this.makeVisible(),
          { type: "show_notification_response", buttonValue: c }
        );
      }
      return super.processRequest(r, n);
    }
    spawnClaude(r, n, s, a, i, o, c, l, u) {
      hY();
      let d = new Vu(io(this.output)),
        m = {
          cwd: i || this.cwd,
          resume: n,
          canUseTool: s,
          permissionMode: o,
          allowDangerouslySkipPermissions: c,
          model: a === null ? "default" : a,
          stderr: (g) => {
            (g.includes("An update to our Consumer Terms and Privacy Policy") &&
              he.window
                .showErrorMessage(
                  "An update to our Consumer Terms and Privacy Policy has taken effect on October 8, 2025. You must run claude in the terminal to review the updated terms.",
                  "Resolve in Terminal",
                )
                .then((_) => {
                  _ === "Resolve in Terminal" && this.openClaudeInTerminal();
                }),
              this.output.info(`From claude: ${g}`));
          },
          systemPrompt: { type: "preset", preset: "claude_code", append: pY },
          enableFileCheckpointing: !0,
          maxThinkingTokens: l,
          includePartialMessages: !0,
          hooks: {
            PreToolUse: [
              {
                matcher: "Edit|Write|MultiEdit",
                hooks: [(g) => d.captureBaseline(g)],
              },
              {
                matcher: "Edit|Write|Read",
                hooks: [(g) => this.saveFileIfNeeded(g)],
              },
            ],
            PostToolUse: [
              {
                matcher: "Edit|Write|MultiEdit",
                hooks: [(g) => d.findDiagnosticsProblems(g)],
              },
            ],
          },
          settingSources: ["user", "project", "local"],
          extraArgs: {
            debug: null,
            "debug-to-stderr": null,
            "enable-auth-status": null,
          },
          mcpServers: u,
        },
        {
          pathToClaudeCodeExecutable: p,
          executableArgs: f,
          env: y,
        } = this.getClaudeBinary();
      return (
        (m.pathToClaudeCodeExecutable = p),
        (m.executableArgs = f),
        (m.env = y),
        this.output.info(
          `Spawning Claude with SDK query function - cwd: ${m.cwd}, permission mode: ${o}, version: 2.0.75, ${m.pathToClaudeCodeExecutable}, resume: ${n}`,
        ),
        _u({ prompt: r, options: m })
      );
    }
    getClaudeBinary() {
      let r,
        n = [];
      {
        let i = mY(this.context);
        i && (r = i);
      }
      let s = !1;
      if (!r) {
        let i = this.context.asAbsolutePath(
          (0, kr.join)("resources", "claude-code", "cli.js"),
        );
        if (!Rr.existsSync(i))
          throw new Error(
            `Unsupported platform: ${process.platform}-${process.arch}. No compatible Claude Code binary found.`,
          );
        (gY(), (s = !0), (r = i));
      }
      let a = mr("claudeProcessWrapper");
      return (
        a && ((n = [r]), s && n.unshift("node"), (r = a)),
        { pathToClaudeCodeExecutable: r, executableArgs: n, env: pp() }
      );
    }
    getChromeMcpServerConfig() {
      throw new Error("Not supported");
    }
    async onExperimentGatesUpdated(r) {
      ((this.experimentGates = r),
        this.context.globalState.update("experimentGates", r),
        await this.checkAndUpdateReviewUpsellBanner());
    }
    claudeLaunched(r) {
      let n = { appName: he.env.appName, version: he.version };
      this.logEvent(r, "claude_launched", { ide: n });
    }
    async openFile(r, n) {
      let s = (0, kr.isAbsolute)(r) ? r : (0, kr.join)(this.cwd, r);
      if (!Rr.existsSync(s) && !(0, kr.isAbsolute)(r)) {
        let i = await Eh(r);
        i.length > 0 && (s = (0, kr.join)(this.cwd, i[0].path));
      }
      let a = he.Uri.file(s);
      if (Rr.existsSync(s) && Rr.statSync(s).isDirectory()) {
        he.commands.executeCommand("revealInExplorer", a);
        return;
      }
      he.window.showTextDocument(a).then((i) => {
        if (n?.searchText) {
          let o = i.document,
            l = o.getText().indexOf(n.searchText);
          if (l !== -1) {
            let u = o.positionAt(l),
              d = o.positionAt(l + n.searchText.length),
              m = new he.Range(u, d);
            (i.revealRange(m, he.TextEditorRevealType.InCenter),
              (i.selection = new he.Selection(u, d)));
          }
        } else if (n) {
          let o = new he.Range(
            new he.Position((n.startLine || 1) - 1, 0),
            new he.Position((n.endLine || n.startLine || 1) - 1, 0),
          );
          (i.revealRange(o, he.TextEditorRevealType.InCenter),
            (i.selection = new he.Selection(o.start, o.end)));
        }
      });
    }
    openConfigFile(r) {
      let n,
        s = `{
  "mcpServers": {}
}
`,
        a = (0, kr.join)(
          process.env.CLAUDE_CONFIG_DIR || (0, J$.homedir)(),
          ".claude.json",
        );
      switch (r) {
        case "mcp-local":
        case "mcp-user":
          n = a;
          break;
        case "mcp-project":
          n = (0, kr.join)(this.cwd, ".mcp.json");
          break;
        default:
          n = a;
          break;
      }
      Rr.existsSync(n) || Rr.writeFileSync(n, s, "utf-8");
      let i = he.Uri.file(n);
      he.workspace.openTextDocument(i).then(
        (o) => {
          he.window.showTextDocument(o, { preview: !1 });
        },
        (o) => {
          this.output.error(`Failed to open config file ${n}: ${o}`);
        },
      );
    }
    async openContent(r, n, s, a) {
      return {
        type: "open_content_response",
        updatedContent: await QT(
          this.output,
          this.readOnlyTempFileProvider,
          this.rightTempFileProvider,
          r,
          n,
          s,
          a,
        ),
      };
    }
    async openDiff(r, n, s, a, i) {
      return {
        type: "open_diff_response",
        newEdits: await mC(
          this.output,
          this.leftTempFileProvider,
          this.rightTempFileProvider,
          r,
          n,
          s,
          a,
          this.acceptOrRejectDiffs,
          i,
        ),
      };
    }
    async openURL(r) {
      await he.env.openExternal(he.Uri.parse(r));
    }
    async openClaudeInTerminal(r, n, s) {
      await he.commands.executeCommand("claude-vscode.terminal.open", r, n, s);
    }
    async openTerminal(r, n = [], s, a, i) {
      let o = { ...process.env },
        c = "Claude Code",
        l =
          a === "beside" || a === void 0
            ? { viewColumn: he.ViewColumn.Beside }
            : a === "window"
              ? { viewColumn: he.ViewColumn.One }
              : void 0,
        u = he.window.createTerminal({
          name: c,
          iconPath: he.Uri.file(
            (0, kr.join)(
              this.context.extensionPath,
              "resources",
              "claude-logo.svg",
            ),
          ),
          cwd: s || this.cwd,
          location: l,
          isTransient: !0,
          env: o,
          strictEnv: !0,
        }),
        d = [r, ...n];
      u.show();
      let m, p;
      (await new Promise((f) => {
        let y = !1;
        ((m = he.window.onDidChangeTerminalShellIntegration((h) => {
          h.terminal === u &&
            !y &&
            ((y = !0),
            (p = he.window.onDidStartTerminalShellExecution((g) => {
              g.terminal === u && f();
            })),
            h.shellIntegration.executeCommand((0, ay.quote)(d)));
        })),
          setTimeout(() => {
            !u.shellIntegration &&
              !y &&
              ((y = !0), u.sendText((0, ay.quote)(d)), f());
          }, 3e3));
      }).finally(() => {
        (m?.dispose(), p?.dispose());
      }),
        a === "window" &&
          (await he.commands.executeCommand(
            "workbench.action.moveEditorToNewWindow",
          )));
    }
    async showClaudeTerminalSetting() {
      (await he.commands.executeCommand(
        "workbench.action.focusFirstEditorGroup",
      ),
        await he.commands.executeCommand(
          "workbench.action.openSettings",
          "claudeCode.useTerminal",
        ));
    }
    async dismissTerminalBanner() {
      ((this.showTerminalBanner = !1),
        await this.context.globalState.update("showTerminalBanner", !1));
    }
    async dismissReviewUpsellBanner(r) {
      (this.context.globalState.update("reviewUpsellDismissedMetadata", r),
        (this.showReviewUpsellBanner = !1),
        await this.pushStateUpdate());
    }
    async dismissYearEndPromo() {
      (this.context.globalState.update("yearEndPromoDismissed", !0),
        (this.showYearEndPromo = !1),
        await this.pushStateUpdate());
    }
    async checkAndUpdateYearEndPromo() {
      try {
        if (
          this.showYearEndPromo !== void 0 ||
          !this.experimentGates.tengu_year_end_2025_campaign_promo
        )
          return;
        if (this.context.globalState.get("yearEndPromoDismissed")) {
          ((this.showYearEndPromo = !1), await this.pushStateUpdate());
          return;
        }
        let n = this.context.globalState.get("yearEndPromoViewCount") ?? 0;
        ((this.yearEndPromoViewCount = n + 1),
          await this.context.globalState.update(
            "yearEndPromoViewCount",
            this.yearEndPromoViewCount,
          ),
          (this.showYearEndPromo = !0),
          await this.pushStateUpdate());
      } catch (r) {
        this.output.warn(`Failed to check year-end promo: ${r}`);
      }
    }
    async checkAndUpdateReviewUpsellBanner() {
      try {
        if (
          this.showReviewUpsellBanner !== void 0 ||
          !this.experimentGates.tengu_vscode_review_upsell
        )
          return;
        if (
          this.context.globalState.get("reviewUpsellDismissedMetadata") !==
          void 0
        ) {
          ((this.showReviewUpsellBanner = !1), await this.pushStateUpdate());
          return;
        }
        let n = this.context.globalState.get("reviewUpsellLastShownTimestamp");
        if (CO(n)) {
          ((this.showReviewUpsellBanner = !1), await this.pushStateUpdate());
          return;
        }
        let s = PO();
        s &&
          this.showReviewUpsellBanner !== !0 &&
          ((this.showReviewUpsellBanner = s),
          s &&
            this.context.globalState.update(
              "reviewUpsellLastShownTimestamp",
              Date.now(),
            ),
          await this.pushStateUpdate());
      } catch (r) {
        this.output.warn(`Failed to check review upsell banner: ${r}`);
      }
    }
    async openConfig(r) {
      (await he.commands.executeCommand(
        "workbench.action.focusFirstEditorGroup",
      ),
        await he.commands.executeCommand(
          "workbench.action.openSettings",
          r || "claudeCode",
        ));
    }
    async openHelp() {
      let r = he.Uri.parse("https://code.claude.com/docs/en/vs-code");
      await he.env.openExternal(r);
    }
    async openOutputPanel() {
      this.output.show();
    }
    isSpeechToTextEnabled() {
      return process.env.CLAUDE_SPEECH_TO_TEXT !== "true"
        ? !1
        : he.extensions.getExtension("ms-vscode.vscode-speech") !== void 0;
    }
    async handleStartSpeechToText(r) {
      if (
        (this.output.info(`Starting speech-to-text on channel: ${r}`),
        this.speechToTextChannels.has(r))
      )
        throw new Error(`Speech-to-text channel already exists: ${r}`);
      try {
        let { iterator: n, abort: s } = await this.createSpeechToTextStream();
        (this.speechToTextChannels.set(r, { abort: s }),
          (async () => {
            try {
              for await (let a of n)
                this.send({
                  type: "speech_to_text_message",
                  channelId: r,
                  text: a,
                  done: !1,
                });
              this.closeSpeechToTextChannel(r, !0);
            } catch (a) {
              (this.closeSpeechToTextChannel(r, !0, String(a)),
                this.output.error(
                  `Error from speech-to-text (on channel ${r}): ${a}`,
                ));
            }
          })());
      } catch (n) {
        (this.closeSpeechToTextChannel(r, !0, String(n)),
          this.output.error(
            `Error starting speech-to-text (on channel ${r}): ${n}`,
          ));
      }
    }
    async handleStopSpeechToText(r) {
      let n = this.speechToTextChannels.get(r);
      if (!n) {
        this.output.warn(`Speech-to-text channel not found: ${r}`);
        return;
      }
      try {
        (n.abort(),
          this.output.info(`Stopped speech-to-text for channel: ${r}`));
      } catch (s) {
        this.output.error(`Failed to stop speech-to-text: ${s}`);
      }
    }
    closeSpeechToTextChannel(r, n, s) {
      (this.output.info(`Closing speech-to-text on channel: ${r}`),
        n && this.send({ type: "close_channel", channelId: r, error: s }),
        this.speechToTextChannels.delete(r));
    }
    async createSpeechToTextStream() {
      let r = he.extensions.getExtension("ms-vscode.vscode-speech");
      if (!r)
        throw new Error(
          "Speech extension not found. Please install ms-vscode.vscode-speech",
        );
      r.isActive || (await r.activate());
      let n = await he.workspace.openTextDocument({
        content: "",
        language: "plaintext",
      });
      await he.window.showTextDocument(n, { preview: !0, preserveFocus: !1 });
      let s = !1,
        a = "",
        i = [],
        o = null,
        c = he.workspace.onDidChangeTextDocument((d) => {
          if (d.document === n && d.contentChanges.length > 0) {
            let m = n.getText();
            (this.output.info(
              `Speech document changed. Current text length: ${m.length}, Last text length: ${a.length}`,
            ),
              m !== a &&
                ((a = m),
                i.push(m),
                this.output.info(`Enqueued speech text: "${m}"`),
                o && (o(), (o = null))));
          }
        }),
        l = () => {
          ((s = !0),
            he.commands.executeCommand("workbench.action.editorDictation.stop"),
            c.dispose(),
            he.commands.executeCommand(
              "workbench.action.revertAndCloseActiveEditor",
            ),
            o && (o(), (o = null)));
        };
      (await he.commands.executeCommand(
        "workbench.action.editorDictation.start",
      ),
        this.panelTab
          ? this.panelTab.reveal()
          : await he.commands.executeCommand("claudeVSCodeSidebar.focus"));
      async function* u() {
        try {
          for (; !s; )
            i.length > 0
              ? yield i.shift()
              : await new Promise((d) => {
                  ((o = d),
                    setTimeout(() => {
                      o === d && ((o = null), d());
                    }, 100));
                });
        } finally {
          (c.dispose(),
            he.commands.executeCommand(
              "workbench.action.revertAndCloseActiveEditor",
            ));
        }
      }
      return { iterator: u(), abort: l };
    }
    getAssetUris() {
      let r = Lw(),
        n = (s) =>
          this.webview
            .asWebviewUri(he.Uri.file(this.context.asAbsolutePath(s)))
            .toString();
      for (let s of Object.keys(r))
        r[s] = { light: n(r[s].light), dark: n(r[s].dark) };
      return r;
    }
    async findFiles(r) {
      let n = r?.toLowerCase() ?? "";
      if (
        process.env.AT_MENTION_TERMINAL === "true" &&
        n.startsWith("terminal:")
      )
        return this.getMatchingTerminals(r);
      let s = "browser:",
        a = "terminal:",
        i = n && s.startsWith(n),
        o = n && a.startsWith(n),
        c = [];
      process.env.AT_MENTION_TERMINAL === "true" &&
        (c = this.getMatchingTerminals(r));
      let l = [],
        u = he.workspace.workspaceFolders;
      if (!u || u.length === 0) return [...c, ...l];
      let d;
      try {
        d = await BT(r, this.cwd, io(this.output));
      } catch (m) {
        (this.output.warn(
          `Ripgrep search failed, falling back to VSCode findFiles: ${m}`,
        ),
          (d = await Eh(r)));
      }
      return i
        ? [...l, ...c, ...d]
        : o
          ? [...c, ...l, ...d]
          : [...d, ...c, ...l];
    }
    getMatchingTerminals(r) {
      let n = r?.toLowerCase() ?? "";
      return he.window.terminals
        .filter((s) => {
          let a = s.name.replace(/ /g, "_");
          return !r || `terminal:${a}`.toLowerCase().includes(n);
        })
        .map((s) => {
          let a = s.name.replace(/ /g, "_");
          return {
            path: `terminal:${a}`,
            name: `terminal:${a}`,
            type: "terminal",
          };
        });
    }
    async getMatchingBrowserTabs(r) {
      return [];
    }
    async disableChromeMcp(r) {
      return (
        this.chromeMcpClient && (await this.chromeMcpClient.disconnect()),
        super.disableChromeMcp(r)
      );
    }
    async createNewBrowserTab() {
      throw new Error("Browser integration is not enabled");
    }
    getMarketplaceType() {
      let r = he.env.appName.toLowerCase();
      return r.includes("vscodium") ||
        r.includes("gitpod") ||
        r.includes("code - oss") ||
        r.includes("cursor")
        ? "openvsx"
        : "vscode";
    }
    isBrowserIntegrationSupported() {
      return !1;
    }
    async getTerminalContents(r) {
      let n = he.window.terminals.find((a) => a.name.replace(/ /g, "_") === r);
      if (!n) return null;
      let s = await he.env.clipboard.readText();
      try {
        (n.show(),
          await he.commands.executeCommand(
            "workbench.action.terminal.selectAll",
          ),
          await he.commands.executeCommand(
            "workbench.action.terminal.copySelection",
          ),
          await he.commands.executeCommand(
            "workbench.action.terminal.clearSelection",
          ));
        let a = await he.env.clipboard.readText(),
          i = 100,
          o = a.split(`
`);
        return (
          o.length > i &&
            (a = o.slice(-i).join(`
`)),
          await he.env.clipboard.writeText(s),
          a
        );
      } catch (a) {
        return (
          await he.env.clipboard.writeText(s),
          this.output.error(`Failed to get terminal contents: ${a}`),
          null
        );
      }
    }
    async saveFileIfNeeded(r) {
      if (!mr("autosave")) return { continue: !0 };
      if (r.hook_event_name !== "PreToolUse") return { continue: !0 };
      if (
        r.tool_name !== "Edit" &&
        r.tool_name !== "Write" &&
        r.tool_name !== "Read"
      )
        return { continue: !0 };
      let n = r.tool_input?.file_path,
        s = Bu(n);
      try {
        let a = await he.workspace.openTextDocument(s);
        a.isDirty && (await a.save());
      } catch {}
      return { continue: !0 };
    }
    async shutdown() {
      await super.shutdown();
    }
  };
function io(t) {
  return {
    log: (e, ...r) => t.info(e, ...r),
    warn: (e, ...r) => t.warn(e, ...r),
    error: (e, ...r) => t.error(e, ...r),
  };
}
function fY() {
  if (process.platform !== "linux") return !1;
  try {
    if (
      Rr.existsSync("/lib/libc.musl-x86_64.so.1") ||
      Rr.existsSync("/lib/libc.musl-aarch64.so.1")
    )
      return !0;
    let t = Ar("ldd /bin/ls 2>/dev/null", {
      env: process.env,
      maxBuffer: 1e6,
      timeout: 2e4,
      stdio: ["ignore", "pipe", "pipe"],
      shell: !0,
      reject: !1,
    });
    return t.stdout && t.stdout.includes("musl");
  } catch {
    return !1;
  }
}
function mY(t) {
  let e = process.platform === "win32" ? "claude.exe" : "claude",
    r = fY() ? `${process.arch}-musl` : process.arch,
    n = t.asAbsolutePath(
      (0, kr.join)(
        "resources",
        "native-binaries",
        `${process.platform}-${r}`,
        e,
      ),
    );
  if (Rr.existsSync(n)) return n;
  if (process.platform === "win32" && process.arch === "arm64") {
    let a = t.asAbsolutePath(
      (0, kr.join)("resources", "native-binaries", "win32-x64", e),
    );
    if (Rr.existsSync(a)) return a;
  }
  let s = t.asAbsolutePath((0, kr.join)("resources", "native-binary", e));
  if (Rr.existsSync(s)) return s;
}
function hY() {
  if (process.platform === "win32")
    try {
      Ar("where.exe", ["git"], { stdio: "pipe", encoding: "utf8" });
    } catch {
      throw new Error(
        "Claude Code on Windows requires git-bash (https://git-scm.com/downloads/win). If installed but not in PATH, set environment variable pointing to your bash.exe, similar to: CLAUDE_CODE_GIT_BASH_PATH=C:\\Program Files\\Git\\bin\\bash.exe",
      );
    }
}
function gY() {
  try {
    let t = process.platform === "win32" ? "node.exe" : "node",
      r = Ar(t, ["--version"], {
        stdio: "pipe",
        encoding: "utf8",
      }).stdout.trim();
    if (!K$.default.gte(r, "18.0.0"))
      throw new Error(
        `Claude Code requires Node.js version 18 or higher. Found version ${r}.`,
      );
  } catch (t) {
    throw t instanceof Error && t.message.includes("requires Node.js")
      ? t
      : new Error(
          "Claude Code requires Node.js version 18 or higher to be installed.",
        );
  }
}
function pp() {
  let t = mr("environmentVariables") || [],
    e = { ...process.env };
  for (let r of t) r.name && (e[r.name] = r.value || "");
  return ((e.CLAUDE_CODE_ENTRYPOINT = "claude-vscode"), e);
}
var fp = class {
  constructor(e, r, n, s, a, i, o, c, l, u, d) {
    this.extensionUri = e;
    this.context = r;
    this.output = n;
    this.settings = s;
    this.leftTempFileProvider = a;
    this.rightTempFileProvider = i;
    this.readOnlyTempFileProvider = o;
    this.acceptOrRejectDiffs = c;
    this.atMentionEvents = l;
    this.selectionChangedEvents = u;
    this.getSelection = d;
  }
  disposables = [];
  allComms = new Set();
  webviews = new Set();
  hasVisibleWebview() {
    for (let e of this.webviews) if (e.isVisible()) return !0;
    return !1;
  }
  resolveWebviewView(e, r, n) {
    let s = { isVisible: () => e.visible };
    (this.webviews.add(s),
      (e.webview.options = {
        enableScripts: !0,
        localResourceRoots: [
          ut.Uri.joinPath(this.extensionUri, "webview"),
          ut.Uri.joinPath(this.extensionUri, "resources"),
        ],
      }),
      (e.webview.html = this.getHtmlForWebview(e.webview, void 0, void 0)),
      e.show(!0));
    let i =
        (ut.workspace.workspaceFolders?.map((c) => c.uri.fsPath) || [])[0] ||
        iy.homedir(),
      o = new Gc(
        this.context,
        i,
        this.settings,
        e.webview,
        this.output,
        this.atMentionEvents,
        this.selectionChangedEvents,
        this.leftTempFileProvider,
        this.rightTempFileProvider,
        this.readOnlyTempFileProvider,
        this.acceptOrRejectDiffs,
        this.getSelection,
        () => e.visible,
        () => e.show(),
        void 0,
      );
    (this.allComms.add(o),
      e.webview.onDidReceiveMessage(
        (c) => {
          (this.output.info(
            `Received message from webview: ${JSON.stringify(c)}`,
          ),
            o?.fromClient(c));
        },
        null,
        this.disposables,
      ),
      e.onDidDispose(
        () => {
          (o.shutdown(),
            this.allComms.delete(o),
            this.webviews.delete(s),
            this.updateSidebarActiveState());
        },
        null,
        this.disposables,
      ),
      e.onDidChangeVisibility(
        () => {
          this.updateSidebarActiveState();
        },
        null,
        this.disposables,
      ),
      this.updateSidebarActiveState(),
      e.show(!0));
  }
  updateSidebarActiveState() {
    ut.commands.executeCommand(
      "setContext",
      "claude-vscode.sideBarActive",
      this.hasVisibleWebview(),
    );
  }
  dispose() {
    for (; this.disposables.length; ) {
      let e = this.disposables.pop();
      e && e.dispose();
    }
  }
  async notifyLogout() {
    for (let e of this.allComms) e.pushStateUpdate();
  }
  notifyCreateNewConversation() {
    for (let e of this.allComms) e.notifyCreateNewConversation();
  }
  notifyFontConfigurationChange() {
    let e = ut.workspace.getConfiguration("chat.editor"),
      r = e.get("fontFamily") || "default";
    r === "default" && (r = "monospace");
    let n = e.get("fontSize") || 12,
      s = e.get("fontWeight") || "normal",
      a = ut.workspace.getConfiguration("chat"),
      i = a.get("fontSize") || 13,
      o = a.get("fontFamily") || "default";
    o === "default" &&
      (o =
        "-apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif");
    for (let c of this.allComms)
      c.notifyFontConfigurationChange({
        editorFontFamily: r,
        editorFontSize: n,
        editorFontWeight: s,
        chatFontSize: i,
        chatFontFamily: o,
      });
  }
  createPanel(e, r) {
    let n = !1,
      s = ut.ViewColumn.Beside,
      a = ut.window.tabGroups.all.find((o) =>
        o.tabs.length === 0
          ? !1
          : o.tabs.every((c) =>
              c.input instanceof ut.TabInputWebview
                ? c.input.viewType.includes("claudeVSCodePanel")
                : !1,
            ),
      );
    a && a.viewColumn
      ? (s = a.viewColumn)
      : ((s = this.findUnusedColumn()), (n = !0));
    let i = ut.window.createWebviewPanel(
      "claudeVSCodePanel",
      "Claude Code",
      s,
      {
        enableScripts: !0,
        retainContextWhenHidden: !0,
        enableFindWidget: !0,
        localResourceRoots: [
          ut.Uri.joinPath(this.extensionUri, "webview"),
          ut.Uri.joinPath(this.extensionUri, "resources"),
        ],
      },
    );
    return (this.setupPanel(i, e, r), { startedInNewColumn: n });
  }
  findUnusedColumn() {
    let e = new Set();
    ut.window.tabGroups.all.forEach((r) => {
      r.viewColumn !== void 0 && e.add(r.viewColumn);
    });
    for (let r = ut.ViewColumn.One; r <= ut.ViewColumn.Nine; r++)
      if (!e.has(r)) return r;
    return ut.ViewColumn.Beside;
  }
  setupPanel(e, r, n) {
    let s = { isVisible: () => e.visible };
    this.webviews.add(s);
    let i =
      (ut.workspace.workspaceFolders?.map((c) => c.uri.fsPath) || [])[0] ||
      iy.homedir();
    ((e.iconPath = ut.Uri.file(
      X$.join(this.context.extensionPath, "resources", "claude-logo.svg"),
    )),
      (e.webview.options = {
        enableScripts: !0,
        localResourceRoots: [
          ut.Uri.joinPath(this.extensionUri, "webview"),
          ut.Uri.joinPath(this.extensionUri, "resources"),
        ],
      }),
      (e.webview.html = this.getHtmlForWebview(e.webview, r, n)));
    let o = new Gc(
      this.context,
      i,
      this.settings,
      e.webview,
      this.output,
      this.atMentionEvents,
      this.selectionChangedEvents,
      this.leftTempFileProvider,
      this.rightTempFileProvider,
      this.readOnlyTempFileProvider,
      this.acceptOrRejectDiffs,
      this.getSelection,
      () => e.visible,
      () => e.reveal(),
      e,
    );
    (this.allComms.add(o),
      e.webview.onDidReceiveMessage(
        (c) => {
          (this.output.info(
            `Received message from webview: ${JSON.stringify(c)}`,
          ),
            o?.fromClient(c));
        },
        null,
        this.disposables,
      ),
      e.onDidChangeViewState(
        () => o.notifyVisibilityChange(e.visible),
        null,
        this.disposables,
      ),
      e.onDidDispose(
        () => {
          (o.shutdown(), this.allComms.delete(o), this.webviews.delete(s));
        },
        null,
        this.disposables,
      ),
      this.disposables.push(e));
  }
  getHtmlForWebview(e, r, n) {
    let s = ut.Uri.joinPath(this.extensionUri, "webview", "index.js"),
      a = e.asWebviewUri(s),
      i = ut.Uri.joinPath(this.extensionUri, "webview", "index.css"),
      o = e.asWebviewUri(i),
      c = vs(),
      l = `style-src ${e.cspSource} 'unsafe-inline'`,
      u = `font-src ${e.cspSource}`,
      d = `img-src ${e.cspSource} data:`,
      m = `worker-src ${e.cspSource}`,
      p = ut.workspace.getConfiguration("chat.editor"),
      f = p.get("fontFamily") || "default";
    f === "default" && (f = "monospace");
    let y = p.get("fontSize") || 12,
      h = p.get("fontWeight") || "normal",
      g = ut.workspace.getConfiguration("chat"),
      _ = g.get("fontSize") || 13,
      v = g.get("fontFamily") || "default";
    return (
      v === "default" &&
        (v =
          "-apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif"),
      `<!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">

        <!--
          Use a content security policy to only allow loading images from our extension directory or data URIs,
          and only allow scripts that have a specific nonce.
          Note: External https: URLs are blocked to prevent data exfiltration via markdown image URLs.
        -->
        <meta http-equiv="Content-Security-Policy" content="default-src 'none'; ${l}; ${u}; ${d}; script-src 'nonce-${c}'; ${m};">

        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="${o}" rel="stylesheet">
        <style>
          :root {
            --vscode-editor-font-family: ${f} !important;
            --vscode-editor-font-size: ${y}px !important;
            --vscode-editor-font-weight: ${h} !important;
            --vscode-chat-font-size: ${_}px;
            --vscode-chat-font-family: ${v};
          }
        </style>
      </head>
      <body>
        <pre id="claude-error"></pre>
        <div id="root"></div>
        <script nonce="${c}">
          window.initialConfiguration = {
            initialPrompt: ${n ? JSON.stringify(n) : "undefined"},
            initialSession: ${r ? JSON.stringify(r) : "undefined"},
          }
        </script>
        <script nonce="${c}" src="${a}" type="module"></script>
      </body>
      </html>`
    );
  }
};
var mp = le(require("vscode"), 1);
var vY = le(Hf(), 1);
var Y$ = le(require("child_process"), 1),
  Q$ = require("util"),
  Mme = (0, Q$.promisify)(Y$.execFile);
var Vt = le(require("vscode"), 1);
function oy(t) {
  return t.includes("\\")
    ? t.startsWith("\\\\")
      ? "/" + t.substring(2).replace(/\\/g, "/")
      : (/^[a-zA-Z]:/.test(t) &&
          (t = t.replace(
            /^([a-zA-Z]):/,
            (e, r) => "/" + r.toLowerCase() + ":",
          )),
        t.replace(/\\/g, "/"))
    : t;
}
var cy = class {
    constructor(e, r) {
      this.uri = e;
      this.contents = r;
      this.ctime = this.modifiedTime = Date.now();
    }
    type = Vt.FileType.File;
    ctime;
    modifiedTime;
    get mtime() {
      return this.modifiedTime;
    }
    get size() {
      return this.data.length;
    }
    get data() {
      return this.contents;
    }
    write(e) {
      ((this.modifiedTime = Date.now()),
        (this.contents = e),
        this.emitter.fire());
    }
    emitter = new Vt.EventEmitter();
    onDidSave = this.emitter.event;
  },
  Wc = class {
    constructor(e) {
      this.scheme = e;
    }
    documents = new Map();
    createFile(e, r) {
      let n = e;
      process.platform === "win32" && (n = oy(e));
      let s = Vt.Uri.from({ scheme: this.scheme, path: n }),
        a = this.documents.get(s.path);
      return a
        ? (this.writeFile(s, new TextEncoder().encode(r)), a)
        : ((a = new cy(s, new TextEncoder().encode(r))),
          this.documents.set(s.path, a),
          a);
    }
    emitter = new Vt.EventEmitter();
    onDidChangeFile = this.emitter.event;
    watch(e) {
      return new Vt.Disposable(() => {});
    }
    stat(e) {
      return this.find(e);
    }
    find(e) {
      let r = e.path;
      process.platform === "win32" && (r = oy(e.path));
      let n = this.documents.get(r);
      if (!n) throw Vt.FileSystemError.FileNotFound(e);
      return n;
    }
    readDirectory(e) {
      throw Vt.FileSystemError.FileNotFound(e);
    }
    readFile(e) {
      let r = this.find(e).data;
      if (r) return r;
      throw Vt.FileSystemError.FileNotFound(e);
    }
    writeFile(e, r) {
      (this.find(e).write(r),
        this.emitter.fire([{ type: Vt.FileChangeType.Changed, uri: e }]));
    }
    createDirectory(e) {
      throw Vt.FileSystemError.Unavailable();
    }
    delete(e) {
      throw Vt.FileSystemError.Unavailable();
    }
    rename(e, r, n) {
      throw Vt.FileSystemError.Unavailable();
    }
  },
  hp = class {
    constructor(e) {
      this.scheme = e;
    }
    documents = new Map();
    onDidChangeEmitter = new Vt.EventEmitter();
    onDidChange = this.onDidChangeEmitter.event;
    createFile(e, r) {
      let n = e;
      process.platform === "win32" && (n = oy(e));
      let s = Vt.Uri.from({ scheme: this.scheme, path: n });
      return (this.addDocument(s, r), s);
    }
    provideTextDocumentContent(e) {
      return this.documents.get(e.toString()) || "";
    }
    addDocument(e, r) {
      (this.documents.set(e.toString(), r), this.onDidChangeEmitter.fire(e));
    }
  };
var ms = le(require("vscode"), 1);
var Yt = le(require("vscode"), 1);
function eA(t) {
  return t.includes("\\")
    ? t.startsWith("\\\\")
      ? "/" + t.substring(2).replace(/\\/g, "/")
      : (/^[a-zA-Z]:/.test(t) &&
          (t = t.replace(
            /^([a-zA-Z]):/,
            (e, r) => "/" + r.toLowerCase() + ":",
          )),
        t.replace(/\\/g, "/"))
    : t;
}
var ly = class {
    constructor(e, r) {
      this.uri = e;
      this.contents = r;
      this.ctime = this.modifiedTime = Date.now();
    }
    type = Yt.FileType.File;
    ctime;
    modifiedTime;
    get mtime() {
      return this.modifiedTime;
    }
    get size() {
      return this.data.length;
    }
    get data() {
      return this.contents;
    }
    write(e) {
      ((this.modifiedTime = Date.now()),
        (this.contents = e),
        this.emitter.fire());
    }
    emitter = new Yt.EventEmitter();
    onDidSave = this.emitter.event;
  },
  Kc = class {
    constructor(e) {
      this.scheme = e;
    }
    documents = new Map();
    createFile(e, r) {
      let n = e;
      process.platform === "win32" && (n = eA(e));
      let s = Yt.Uri.from({ scheme: this.scheme, path: n }),
        a = this.documents.get(s.path);
      return a
        ? (this.writeFile(s, new TextEncoder().encode(r)), a)
        : ((a = new ly(s, new TextEncoder().encode(r))),
          this.documents.set(s.path, a),
          a);
    }
    emitter = new Yt.EventEmitter();
    onDidChangeFile = this.emitter.event;
    watch(e) {
      return new Yt.Disposable(() => {});
    }
    stat(e) {
      return this.find(e);
    }
    find(e) {
      let r = e.path;
      process.platform === "win32" && (r = eA(e.path));
      let n = this.documents.get(r);
      if (!n) throw Yt.FileSystemError.FileNotFound(e);
      return n;
    }
    readDirectory(e) {
      throw Yt.FileSystemError.FileNotFound(e);
    }
    readFile(e) {
      let r = this.find(e).data;
      if (r) return r;
      throw Yt.FileSystemError.FileNotFound(e);
    }
    writeFile(e, r) {
      (this.find(e).write(r),
        this.emitter.fire([{ type: Yt.FileChangeType.Changed, uri: e }]));
    }
    createDirectory(e) {
      throw Yt.FileSystemError.Unavailable();
    }
    delete(e) {
      throw Yt.FileSystemError.Unavailable();
    }
    rename(e, r, n) {
      throw Yt.FileSystemError.Unavailable();
    }
  };
var Or = le(require("vscode"), 1),
  cN = require("crypto");
var tA = le(sy(), 1),
  gp = class extends ao {
    constructor(e, r) {
      var n;
      (super(r),
        (this._serverInfo = e),
        (this._capabilities =
          (n = r?.capabilities) !== null && n !== void 0 ? n : {}),
        (this._instructions = r?.instructions),
        this.setRequestHandler(vv, (s) => this._oninitialize(s)),
        this.setNotificationHandler(bv, () => {
          var s;
          return (s = this.oninitialized) === null || s === void 0
            ? void 0
            : s.call(this);
        }));
    }
    registerCapabilities(e) {
      if (this.transport)
        throw new Error(
          "Cannot register capabilities after connecting to transport",
        );
      this._capabilities = Hd(this._capabilities, e);
    }
    assertCapabilityForMethod(e) {
      var r, n, s;
      switch (e) {
        case "sampling/createMessage":
          if (
            !(
              !((r = this._clientCapabilities) === null || r === void 0) &&
              r.sampling
            )
          )
            throw new Error(
              `Client does not support sampling (required for ${e})`,
            );
          break;
        case "elicitation/create":
          if (
            !(
              !((n = this._clientCapabilities) === null || n === void 0) &&
              n.elicitation
            )
          )
            throw new Error(
              `Client does not support elicitation (required for ${e})`,
            );
          break;
        case "roots/list":
          if (
            !(
              !((s = this._clientCapabilities) === null || s === void 0) &&
              s.roots
            )
          )
            throw new Error(
              `Client does not support listing roots (required for ${e})`,
            );
          break;
        case "ping":
          break;
      }
    }
    assertNotificationCapability(e) {
      switch (e) {
        case "notifications/message":
          if (!this._capabilities.logging)
            throw new Error(
              `Server does not support logging (required for ${e})`,
            );
          break;
        case "notifications/resources/updated":
        case "notifications/resources/list_changed":
          if (!this._capabilities.resources)
            throw new Error(
              `Server does not support notifying about resources (required for ${e})`,
            );
          break;
        case "notifications/tools/list_changed":
          if (!this._capabilities.tools)
            throw new Error(
              `Server does not support notifying of tool list changes (required for ${e})`,
            );
          break;
        case "notifications/prompts/list_changed":
          if (!this._capabilities.prompts)
            throw new Error(
              `Server does not support notifying of prompt list changes (required for ${e})`,
            );
          break;
        case "notifications/cancelled":
          break;
        case "notifications/progress":
          break;
      }
    }
    assertRequestHandlerCapability(e) {
      switch (e) {
        case "sampling/createMessage":
          if (!this._capabilities.sampling)
            throw new Error(
              `Server does not support sampling (required for ${e})`,
            );
          break;
        case "logging/setLevel":
          if (!this._capabilities.logging)
            throw new Error(
              `Server does not support logging (required for ${e})`,
            );
          break;
        case "prompts/get":
        case "prompts/list":
          if (!this._capabilities.prompts)
            throw new Error(
              `Server does not support prompts (required for ${e})`,
            );
          break;
        case "resources/list":
        case "resources/templates/list":
        case "resources/read":
          if (!this._capabilities.resources)
            throw new Error(
              `Server does not support resources (required for ${e})`,
            );
          break;
        case "tools/call":
        case "tools/list":
          if (!this._capabilities.tools)
            throw new Error(
              `Server does not support tools (required for ${e})`,
            );
          break;
        case "ping":
        case "initialize":
          break;
      }
    }
    async _oninitialize(e) {
      let r = e.params.protocolVersion;
      return (
        (this._clientCapabilities = e.params.capabilities),
        (this._clientVersion = e.params.clientInfo),
        {
          protocolVersion: Pd.includes(r) ? r : qc,
          capabilities: this.getCapabilities(),
          serverInfo: this._serverInfo,
          ...(this._instructions && { instructions: this._instructions }),
        }
      );
    }
    getClientCapabilities() {
      return this._clientCapabilities;
    }
    getClientVersion() {
      return this._clientVersion;
    }
    getCapabilities() {
      return this._capabilities;
    }
    async ping() {
      return this.request({ method: "ping" }, cs);
    }
    async createMessage(e, r) {
      return this.request(
        { method: "sampling/createMessage", params: e },
        Ov,
        r,
      );
    }
    async elicitInput(e, r) {
      let n = await this.request(
        { method: "elicitation/create", params: e },
        Iv,
        r,
      );
      if (n.action === "accept" && n.content)
        try {
          let s = new tA.default(),
            a = s.compile(e.requestedSchema);
          if (!a(n.content))
            throw new ot(
              lt.InvalidParams,
              `Elicitation response content does not match requested schema: ${s.errorsText(a.errors)}`,
            );
        } catch (s) {
          throw s instanceof ot
            ? s
            : new ot(
                lt.InternalError,
                `Error validating elicitation response: ${s}`,
              );
        }
      return n;
    }
    async listRoots(e, r) {
      return this.request({ method: "roots/list", params: e }, Av, r);
    }
    async sendLoggingMessage(e) {
      return this.notification({ method: "notifications/message", params: e });
    }
    async sendResourceUpdated(e) {
      return this.notification({
        method: "notifications/resources/updated",
        params: e,
      });
    }
    async sendResourceListChanged() {
      return this.notification({
        method: "notifications/resources/list_changed",
      });
    }
    async sendToolListChanged() {
      return this.notification({ method: "notifications/tools/list_changed" });
    }
    async sendPromptListChanged() {
      return this.notification({
        method: "notifications/prompts/list_changed",
      });
    }
  };
var nA = Symbol("Let zodToJsonSchema decide on which parser to use");
var rA = {
    name: void 0,
    $refStrategy: "root",
    basePath: ["#"],
    effectStrategy: "input",
    pipeStrategy: "all",
    dateStrategy: "format:date-time",
    mapStrategy: "entries",
    removeAdditionalStrategy: "passthrough",
    allowedAdditionalProperties: !0,
    rejectedAdditionalProperties: !1,
    definitionPath: "definitions",
    target: "jsonSchema7",
    strictUnions: !1,
    definitions: {},
    errorMessages: !1,
    markdownDescription: !1,
    patternStrategy: "escape",
    applyRegexFlags: !1,
    emailStrategy: "format:email",
    base64Strategy: "contentEncoding:base64",
    nameStrategy: "ref",
  },
  sA = (t) => (typeof t == "string" ? { ...rA, name: t } : { ...rA, ...t });
var aA = (t) => {
  let e = sA(t),
    r =
      e.name !== void 0
        ? [...e.basePath, e.definitionPath, e.name]
        : e.basePath;
  return {
    ...e,
    currentPath: r,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(e.definitions).map(([n, s]) => [
        s._def,
        {
          def: s._def,
          path: [...e.basePath, e.definitionPath, n],
          jsonSchema: void 0,
        },
      ]),
    ),
  };
};
function uy(t, e, r, n) {
  n?.errorMessages && r && (t.errorMessage = { ...t.errorMessage, [e]: r });
}
function Je(t, e, r, n, s) {
  ((t[e] = r), uy(t, e, n, s));
}
function iA() {
  return {};
}
function oA(t, e) {
  let r = { type: "array" };
  return (
    t.type?._def &&
      t.type?._def?.typeName !== se.ZodAny &&
      (r.items = Ne(t.type._def, {
        ...e,
        currentPath: [...e.currentPath, "items"],
      })),
    t.minLength && Je(r, "minItems", t.minLength.value, t.minLength.message, e),
    t.maxLength && Je(r, "maxItems", t.maxLength.value, t.maxLength.message, e),
    t.exactLength &&
      (Je(r, "minItems", t.exactLength.value, t.exactLength.message, e),
      Je(r, "maxItems", t.exactLength.value, t.exactLength.message, e)),
    r
  );
}
function cA(t, e) {
  let r = { type: "integer", format: "int64" };
  if (!t.checks) return r;
  for (let n of t.checks)
    switch (n.kind) {
      case "min":
        e.target === "jsonSchema7"
          ? n.inclusive
            ? Je(r, "minimum", n.value, n.message, e)
            : Je(r, "exclusiveMinimum", n.value, n.message, e)
          : (n.inclusive || (r.exclusiveMinimum = !0),
            Je(r, "minimum", n.value, n.message, e));
        break;
      case "max":
        e.target === "jsonSchema7"
          ? n.inclusive
            ? Je(r, "maximum", n.value, n.message, e)
            : Je(r, "exclusiveMaximum", n.value, n.message, e)
          : (n.inclusive || (r.exclusiveMaximum = !0),
            Je(r, "maximum", n.value, n.message, e));
        break;
      case "multipleOf":
        Je(r, "multipleOf", n.value, n.message, e);
        break;
    }
  return r;
}
function lA() {
  return { type: "boolean" };
}
function vp(t, e) {
  return Ne(t.type._def, e);
}
var uA = (t, e) => Ne(t.innerType._def, e);
function dy(t, e, r) {
  let n = r ?? e.dateStrategy;
  if (Array.isArray(n)) return { anyOf: n.map((s, a) => dy(t, e, s)) };
  switch (n) {
    case "string":
    case "format:date-time":
      return { type: "string", format: "date-time" };
    case "format:date":
      return { type: "string", format: "date" };
    case "integer":
      return yY(t, e);
  }
}
var yY = (t, e) => {
  let r = { type: "integer", format: "unix-time" };
  if (e.target === "openApi3") return r;
  for (let n of t.checks)
    switch (n.kind) {
      case "min":
        Je(r, "minimum", n.value, n.message, e);
        break;
      case "max":
        Je(r, "maximum", n.value, n.message, e);
        break;
    }
  return r;
};
function dA(t, e) {
  return { ...Ne(t.innerType._def, e), default: t.defaultValue() };
}
function pA(t, e) {
  return e.effectStrategy === "input" ? Ne(t.schema._def, e) : {};
}
function fA(t) {
  return { type: "string", enum: Array.from(t.values) };
}
var bY = (t) => ("type" in t && t.type === "string" ? !1 : "allOf" in t);
function mA(t, e) {
  let r = [
      Ne(t.left._def, { ...e, currentPath: [...e.currentPath, "allOf", "0"] }),
      Ne(t.right._def, { ...e, currentPath: [...e.currentPath, "allOf", "1"] }),
    ].filter((a) => !!a),
    n =
      e.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0,
    s = [];
  return (
    r.forEach((a) => {
      if (bY(a))
        (s.push(...a.allOf),
          a.unevaluatedProperties === void 0 && (n = void 0));
      else {
        let i = a;
        if ("additionalProperties" in a && a.additionalProperties === !1) {
          let { additionalProperties: o, ...c } = a;
          i = c;
        } else n = void 0;
        s.push(i);
      }
    }),
    s.length ? { allOf: s, ...n } : void 0
  );
}
function hA(t, e) {
  let r = typeof t.value;
  return r !== "bigint" && r !== "number" && r !== "boolean" && r !== "string"
    ? { type: Array.isArray(t.value) ? "array" : "object" }
    : e.target === "openApi3"
      ? { type: r === "bigint" ? "integer" : r, enum: [t.value] }
      : { type: r === "bigint" ? "integer" : r, const: t.value };
}
var py,
  _n = {
    cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    email:
      /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    emoji: () => (
      py === void 0 &&
        (py = RegExp(
          "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
          "u",
        )),
      py
    ),
    uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    ipv4Cidr:
      /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    ipv6Cidr:
      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    base64url:
      /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/,
    jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
  };
function yp(t, e) {
  let r = { type: "string" };
  if (t.checks)
    for (let n of t.checks)
      switch (n.kind) {
        case "min":
          Je(
            r,
            "minLength",
            typeof r.minLength == "number"
              ? Math.max(r.minLength, n.value)
              : n.value,
            n.message,
            e,
          );
          break;
        case "max":
          Je(
            r,
            "maxLength",
            typeof r.maxLength == "number"
              ? Math.min(r.maxLength, n.value)
              : n.value,
            n.message,
            e,
          );
          break;
        case "email":
          switch (e.emailStrategy) {
            case "format:email":
              xn(r, "email", n.message, e);
              break;
            case "format:idn-email":
              xn(r, "idn-email", n.message, e);
              break;
            case "pattern:zod":
              hr(r, _n.email, n.message, e);
              break;
          }
          break;
        case "url":
          xn(r, "uri", n.message, e);
          break;
        case "uuid":
          xn(r, "uuid", n.message, e);
          break;
        case "regex":
          hr(r, n.regex, n.message, e);
          break;
        case "cuid":
          hr(r, _n.cuid, n.message, e);
          break;
        case "cuid2":
          hr(r, _n.cuid2, n.message, e);
          break;
        case "startsWith":
          hr(r, RegExp(`^${fy(n.value, e)}`), n.message, e);
          break;
        case "endsWith":
          hr(r, RegExp(`${fy(n.value, e)}$`), n.message, e);
          break;
        case "datetime":
          xn(r, "date-time", n.message, e);
          break;
        case "date":
          xn(r, "date", n.message, e);
          break;
        case "time":
          xn(r, "time", n.message, e);
          break;
        case "duration":
          xn(r, "duration", n.message, e);
          break;
        case "length":
          (Je(
            r,
            "minLength",
            typeof r.minLength == "number"
              ? Math.max(r.minLength, n.value)
              : n.value,
            n.message,
            e,
          ),
            Je(
              r,
              "maxLength",
              typeof r.maxLength == "number"
                ? Math.min(r.maxLength, n.value)
                : n.value,
              n.message,
              e,
            ));
          break;
        case "includes": {
          hr(r, RegExp(fy(n.value, e)), n.message, e);
          break;
        }
        case "ip": {
          (n.version !== "v6" && xn(r, "ipv4", n.message, e),
            n.version !== "v4" && xn(r, "ipv6", n.message, e));
          break;
        }
        case "base64url":
          hr(r, _n.base64url, n.message, e);
          break;
        case "jwt":
          hr(r, _n.jwt, n.message, e);
          break;
        case "cidr": {
          (n.version !== "v6" && hr(r, _n.ipv4Cidr, n.message, e),
            n.version !== "v4" && hr(r, _n.ipv6Cidr, n.message, e));
          break;
        }
        case "emoji":
          hr(r, _n.emoji(), n.message, e);
          break;
        case "ulid": {
          hr(r, _n.ulid, n.message, e);
          break;
        }
        case "base64": {
          switch (e.base64Strategy) {
            case "format:binary": {
              xn(r, "binary", n.message, e);
              break;
            }
            case "contentEncoding:base64": {
              Je(r, "contentEncoding", "base64", n.message, e);
              break;
            }
            case "pattern:zod": {
              hr(r, _n.base64, n.message, e);
              break;
            }
          }
          break;
        }
        case "nanoid":
          hr(r, _n.nanoid, n.message, e);
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
      }
  return r;
}
function fy(t, e) {
  return e.patternStrategy === "escape" ? xY(t) : t;
}
var _Y = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789",
);
function xY(t) {
  let e = "";
  for (let r = 0; r < t.length; r++) (_Y.has(t[r]) || (e += "\\"), (e += t[r]));
  return e;
}
function xn(t, e, r, n) {
  t.format || t.anyOf?.some((s) => s.format)
    ? (t.anyOf || (t.anyOf = []),
      t.format &&
        (t.anyOf.push({
          format: t.format,
          ...(t.errorMessage &&
            n.errorMessages && {
              errorMessage: { format: t.errorMessage.format },
            }),
        }),
        delete t.format,
        t.errorMessage &&
          (delete t.errorMessage.format,
          Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)),
      t.anyOf.push({
        format: e,
        ...(r && n.errorMessages && { errorMessage: { format: r } }),
      }))
    : Je(t, "format", e, r, n);
}
function hr(t, e, r, n) {
  t.pattern || t.allOf?.some((s) => s.pattern)
    ? (t.allOf || (t.allOf = []),
      t.pattern &&
        (t.allOf.push({
          pattern: t.pattern,
          ...(t.errorMessage &&
            n.errorMessages && {
              errorMessage: { pattern: t.errorMessage.pattern },
            }),
        }),
        delete t.pattern,
        t.errorMessage &&
          (delete t.errorMessage.pattern,
          Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)),
      t.allOf.push({
        pattern: gA(e, n),
        ...(r && n.errorMessages && { errorMessage: { pattern: r } }),
      }))
    : Je(t, "pattern", gA(e, n), r, n);
}
function gA(t, e) {
  if (!e.applyRegexFlags || !t.flags) return t.source;
  let r = {
      i: t.flags.includes("i"),
      m: t.flags.includes("m"),
      s: t.flags.includes("s"),
    },
    n = r.i ? t.source.toLowerCase() : t.source,
    s = "",
    a = !1,
    i = !1,
    o = !1;
  for (let c = 0; c < n.length; c++) {
    if (a) {
      ((s += n[c]), (a = !1));
      continue;
    }
    if (r.i) {
      if (i) {
        if (n[c].match(/[a-z]/)) {
          o
            ? ((s += n[c]),
              (s += `${n[c - 2]}-${n[c]}`.toUpperCase()),
              (o = !1))
            : n[c + 1] === "-" && n[c + 2]?.match(/[a-z]/)
              ? ((s += n[c]), (o = !0))
              : (s += `${n[c]}${n[c].toUpperCase()}`);
          continue;
        }
      } else if (n[c].match(/[a-z]/)) {
        s += `[${n[c]}${n[c].toUpperCase()}]`;
        continue;
      }
    }
    if (r.m) {
      if (n[c] === "^") {
        s += `(^|(?<=[\r
]))`;
        continue;
      } else if (n[c] === "$") {
        s += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (r.s && n[c] === ".") {
      s += i
        ? `${n[c]}\r
`
        : `[${n[c]}\r
]`;
      continue;
    }
    ((s += n[c]),
      n[c] === "\\"
        ? (a = !0)
        : i && n[c] === "]"
          ? (i = !1)
          : !i && n[c] === "[" && (i = !0));
  }
  try {
    new RegExp(s);
  } catch {
    return (
      console.warn(
        `Could not convert regex pattern at ${e.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`,
      ),
      t.source
    );
  }
  return s;
}
function bp(t, e) {
  if (
    (e.target === "openAi" &&
      console.warn(
        "Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.",
      ),
    e.target === "openApi3" && t.keyType?._def.typeName === se.ZodEnum)
  )
    return {
      type: "object",
      required: t.keyType._def.values,
      properties: t.keyType._def.values.reduce(
        (n, s) => ({
          ...n,
          [s]:
            Ne(t.valueType._def, {
              ...e,
              currentPath: [...e.currentPath, "properties", s],
            }) ?? {},
        }),
        {},
      ),
      additionalProperties: e.rejectedAdditionalProperties,
    };
  let r = {
    type: "object",
    additionalProperties:
      Ne(t.valueType._def, {
        ...e,
        currentPath: [...e.currentPath, "additionalProperties"],
      }) ?? e.allowedAdditionalProperties,
  };
  if (e.target === "openApi3") return r;
  if (
    t.keyType?._def.typeName === se.ZodString &&
    t.keyType._def.checks?.length
  ) {
    let { type: n, ...s } = yp(t.keyType._def, e);
    return { ...r, propertyNames: s };
  } else {
    if (t.keyType?._def.typeName === se.ZodEnum)
      return { ...r, propertyNames: { enum: t.keyType._def.values } };
    if (
      t.keyType?._def.typeName === se.ZodBranded &&
      t.keyType._def.type._def.typeName === se.ZodString &&
      t.keyType._def.type._def.checks?.length
    ) {
      let { type: n, ...s } = vp(t.keyType._def, e);
      return { ...r, propertyNames: s };
    }
  }
  return r;
}
function vA(t, e) {
  if (e.mapStrategy === "record") return bp(t, e);
  let r =
      Ne(t.keyType._def, {
        ...e,
        currentPath: [...e.currentPath, "items", "items", "0"],
      }) || {},
    n =
      Ne(t.valueType._def, {
        ...e,
        currentPath: [...e.currentPath, "items", "items", "1"],
      }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: { type: "array", items: [r, n], minItems: 2, maxItems: 2 },
  };
}
function yA(t) {
  let e = t.values,
    n = Object.keys(t.values)
      .filter((a) => typeof e[e[a]] != "number")
      .map((a) => e[a]),
    s = Array.from(new Set(n.map((a) => typeof a)));
  return {
    type:
      s.length === 1
        ? s[0] === "string"
          ? "string"
          : "number"
        : ["string", "number"],
    enum: n,
  };
}
function bA() {
  return { not: {} };
}
function _A(t) {
  return t.target === "openApi3"
    ? { enum: ["null"], nullable: !0 }
    : { type: "null" };
}
var Jc = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null",
};
function wA(t, e) {
  if (e.target === "openApi3") return xA(t, e);
  let r = t.options instanceof Map ? Array.from(t.options.values()) : t.options;
  if (
    r.every(
      (n) => n._def.typeName in Jc && (!n._def.checks || !n._def.checks.length),
    )
  ) {
    let n = r.reduce((s, a) => {
      let i = Jc[a._def.typeName];
      return i && !s.includes(i) ? [...s, i] : s;
    }, []);
    return { type: n.length > 1 ? n : n[0] };
  } else if (
    r.every((n) => n._def.typeName === "ZodLiteral" && !n.description)
  ) {
    let n = r.reduce((s, a) => {
      let i = typeof a._def.value;
      switch (i) {
        case "string":
        case "number":
        case "boolean":
          return [...s, i];
        case "bigint":
          return [...s, "integer"];
        case "object":
          if (a._def.value === null) return [...s, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return s;
      }
    }, []);
    if (n.length === r.length) {
      let s = n.filter((a, i, o) => o.indexOf(a) === i);
      return {
        type: s.length > 1 ? s : s[0],
        enum: r.reduce(
          (a, i) => (a.includes(i._def.value) ? a : [...a, i._def.value]),
          [],
        ),
      };
    }
  } else if (r.every((n) => n._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: r.reduce(
        (n, s) => [...n, ...s._def.values.filter((a) => !n.includes(a))],
        [],
      ),
    };
  return xA(t, e);
}
var xA = (t, e) => {
  let r = (
    t.options instanceof Map ? Array.from(t.options.values()) : t.options
  )
    .map((n, s) =>
      Ne(n._def, { ...e, currentPath: [...e.currentPath, "anyOf", `${s}`] }),
    )
    .filter(
      (n) =>
        !!n &&
        (!e.strictUnions ||
          (typeof n == "object" && Object.keys(n).length > 0)),
    );
  return r.length ? { anyOf: r } : void 0;
};
function SA(t, e) {
  if (
    ["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
      t.innerType._def.typeName,
    ) &&
    (!t.innerType._def.checks || !t.innerType._def.checks.length)
  )
    return e.target === "openApi3"
      ? { type: Jc[t.innerType._def.typeName], nullable: !0 }
      : { type: [Jc[t.innerType._def.typeName], "null"] };
  if (e.target === "openApi3") {
    let n = Ne(t.innerType._def, { ...e, currentPath: [...e.currentPath] });
    return n && "$ref" in n
      ? { allOf: [n], nullable: !0 }
      : n && { ...n, nullable: !0 };
  }
  let r = Ne(t.innerType._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", "0"],
  });
  return r && { anyOf: [r, { type: "null" }] };
}
function EA(t, e) {
  let r = { type: "number" };
  if (!t.checks) return r;
  for (let n of t.checks)
    switch (n.kind) {
      case "int":
        ((r.type = "integer"), uy(r, "type", n.message, e));
        break;
      case "min":
        e.target === "jsonSchema7"
          ? n.inclusive
            ? Je(r, "minimum", n.value, n.message, e)
            : Je(r, "exclusiveMinimum", n.value, n.message, e)
          : (n.inclusive || (r.exclusiveMinimum = !0),
            Je(r, "minimum", n.value, n.message, e));
        break;
      case "max":
        e.target === "jsonSchema7"
          ? n.inclusive
            ? Je(r, "maximum", n.value, n.message, e)
            : Je(r, "exclusiveMaximum", n.value, n.message, e)
          : (n.inclusive || (r.exclusiveMaximum = !0),
            Je(r, "maximum", n.value, n.message, e));
        break;
      case "multipleOf":
        Je(r, "multipleOf", n.value, n.message, e);
        break;
    }
  return r;
}
function TA(t, e) {
  let r = e.target === "openAi",
    n = { type: "object", properties: {} },
    s = [],
    a = t.shape();
  for (let o in a) {
    let c = a[o];
    if (c === void 0 || c._def === void 0) continue;
    let l = SY(c);
    l &&
      r &&
      (c instanceof wr && (c = c._def.innerType),
      c.isNullable() || (c = c.nullable()),
      (l = !1));
    let u = Ne(c._def, {
      ...e,
      currentPath: [...e.currentPath, "properties", o],
      propertyPath: [...e.currentPath, "properties", o],
    });
    u !== void 0 && ((n.properties[o] = u), l || s.push(o));
  }
  s.length && (n.required = s);
  let i = wY(t, e);
  return (i !== void 0 && (n.additionalProperties = i), n);
}
function wY(t, e) {
  if (t.catchall._def.typeName !== "ZodNever")
    return Ne(t.catchall._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalProperties"],
    });
  switch (t.unknownKeys) {
    case "passthrough":
      return e.allowedAdditionalProperties;
    case "strict":
      return e.rejectedAdditionalProperties;
    case "strip":
      return e.removeAdditionalStrategy === "strict"
        ? e.allowedAdditionalProperties
        : e.rejectedAdditionalProperties;
  }
}
function SY(t) {
  try {
    return t.isOptional();
  } catch {
    return !0;
  }
}
var CA = (t, e) => {
  if (e.currentPath.toString() === e.propertyPath?.toString())
    return Ne(t.innerType._def, e);
  let r = Ne(t.innerType._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", "1"],
  });
  return r ? { anyOf: [{ not: {} }, r] } : {};
};
var PA = (t, e) => {
  if (e.pipeStrategy === "input") return Ne(t.in._def, e);
  if (e.pipeStrategy === "output") return Ne(t.out._def, e);
  let r = Ne(t.in._def, {
      ...e,
      currentPath: [...e.currentPath, "allOf", "0"],
    }),
    n = Ne(t.out._def, {
      ...e,
      currentPath: [...e.currentPath, "allOf", r ? "1" : "0"],
    });
  return { allOf: [r, n].filter((s) => s !== void 0) };
};
function kA(t, e) {
  return Ne(t.type._def, e);
}
function RA(t, e) {
  let n = {
    type: "array",
    uniqueItems: !0,
    items: Ne(t.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "items"],
    }),
  };
  return (
    t.minSize && Je(n, "minItems", t.minSize.value, t.minSize.message, e),
    t.maxSize && Je(n, "maxItems", t.maxSize.value, t.maxSize.message, e),
    n
  );
}
function OA(t, e) {
  return t.rest
    ? {
        type: "array",
        minItems: t.items.length,
        items: t.items
          .map((r, n) =>
            Ne(r._def, {
              ...e,
              currentPath: [...e.currentPath, "items", `${n}`],
            }),
          )
          .reduce((r, n) => (n === void 0 ? r : [...r, n]), []),
        additionalItems: Ne(t.rest._def, {
          ...e,
          currentPath: [...e.currentPath, "additionalItems"],
        }),
      }
    : {
        type: "array",
        minItems: t.items.length,
        maxItems: t.items.length,
        items: t.items
          .map((r, n) =>
            Ne(r._def, {
              ...e,
              currentPath: [...e.currentPath, "items", `${n}`],
            }),
          )
          .reduce((r, n) => (n === void 0 ? r : [...r, n]), []),
      };
}
function IA() {
  return { not: {} };
}
function $A() {
  return {};
}
var AA = (t, e) => Ne(t.innerType._def, e);
var NA = (t, e, r) => {
  switch (e) {
    case se.ZodString:
      return yp(t, r);
    case se.ZodNumber:
      return EA(t, r);
    case se.ZodObject:
      return TA(t, r);
    case se.ZodBigInt:
      return cA(t, r);
    case se.ZodBoolean:
      return lA();
    case se.ZodDate:
      return dy(t, r);
    case se.ZodUndefined:
      return IA();
    case se.ZodNull:
      return _A(r);
    case se.ZodArray:
      return oA(t, r);
    case se.ZodUnion:
    case se.ZodDiscriminatedUnion:
      return wA(t, r);
    case se.ZodIntersection:
      return mA(t, r);
    case se.ZodTuple:
      return OA(t, r);
    case se.ZodRecord:
      return bp(t, r);
    case se.ZodLiteral:
      return hA(t, r);
    case se.ZodEnum:
      return fA(t);
    case se.ZodNativeEnum:
      return yA(t);
    case se.ZodNullable:
      return SA(t, r);
    case se.ZodOptional:
      return CA(t, r);
    case se.ZodMap:
      return vA(t, r);
    case se.ZodSet:
      return RA(t, r);
    case se.ZodLazy:
      return () => t.getter()._def;
    case se.ZodPromise:
      return kA(t, r);
    case se.ZodNaN:
    case se.ZodNever:
      return bA();
    case se.ZodEffects:
      return pA(t, r);
    case se.ZodAny:
      return iA();
    case se.ZodUnknown:
      return $A();
    case se.ZodDefault:
      return dA(t, r);
    case se.ZodBranded:
      return vp(t, r);
    case se.ZodReadonly:
      return AA(t, r);
    case se.ZodCatch:
      return uA(t, r);
    case se.ZodPipeline:
      return PA(t, r);
    case se.ZodFunction:
    case se.ZodVoid:
    case se.ZodSymbol:
      return;
    default:
      return ((n) => {})(e);
  }
};
function Ne(t, e, r = !1) {
  let n = e.seen.get(t);
  if (e.override) {
    let o = e.override?.(t, e, n, r);
    if (o !== nA) return o;
  }
  if (n && !r) {
    let o = EY(n, e);
    if (o !== void 0) return o;
  }
  let s = { def: t, path: e.currentPath, jsonSchema: void 0 };
  e.seen.set(t, s);
  let a = NA(t, t.typeName, e),
    i = typeof a == "function" ? Ne(a(), e) : a;
  if ((i && CY(t, e, i), e.postProcess)) {
    let o = e.postProcess(i, t, e);
    return ((s.jsonSchema = i), o);
  }
  return ((s.jsonSchema = i), i);
}
var EY = (t, e) => {
    switch (e.$refStrategy) {
      case "root":
        return { $ref: t.path.join("/") };
      case "relative":
        return { $ref: TY(e.currentPath, t.path) };
      case "none":
      case "seen":
        return t.path.length < e.currentPath.length &&
          t.path.every((r, n) => e.currentPath[n] === r)
          ? (console.warn(
              `Recursive reference detected at ${e.currentPath.join("/")}! Defaulting to any`,
            ),
            {})
          : e.$refStrategy === "seen"
            ? {}
            : void 0;
    }
  },
  TY = (t, e) => {
    let r = 0;
    for (; r < t.length && r < e.length && t[r] === e[r]; r++);
    return [(t.length - r).toString(), ...e.slice(r)].join("/");
  },
  CY = (t, e, r) => (
    t.description &&
      ((r.description = t.description),
      e.markdownDescription && (r.markdownDescription = t.description)),
    r
  );
var _p = (t, e) => {
  let r = aA(e),
    n =
      typeof e == "object" && e.definitions
        ? Object.entries(e.definitions).reduce(
            (c, [l, u]) => ({
              ...c,
              [l]:
                Ne(
                  u._def,
                  { ...r, currentPath: [...r.basePath, r.definitionPath, l] },
                  !0,
                ) ?? {},
            }),
            {},
          )
        : void 0,
    s =
      typeof e == "string" ? e : e?.nameStrategy === "title" ? void 0 : e?.name,
    a =
      Ne(
        t._def,
        s === void 0
          ? r
          : { ...r, currentPath: [...r.basePath, r.definitionPath, s] },
        !1,
      ) ?? {},
    i =
      typeof e == "object" && e.name !== void 0 && e.nameStrategy === "title"
        ? e.name
        : void 0;
  i !== void 0 && (a.title = i);
  let o =
    s === void 0
      ? n
        ? { ...a, [r.definitionPath]: n }
        : a
      : {
          $ref: [
            ...(r.$refStrategy === "relative" ? [] : r.basePath),
            r.definitionPath,
            s,
          ].join("/"),
          [r.definitionPath]: { ...n, [s]: a },
        };
  return (
    r.target === "jsonSchema7"
      ? (o.$schema = "http://json-schema.org/draft-07/schema#")
      : (r.target === "jsonSchema2019-09" || r.target === "openAi") &&
        (o.$schema = "https://json-schema.org/draft/2019-09/schema#"),
    r.target === "openAi" &&
      ("anyOf" in o ||
        "oneOf" in o ||
        "allOf" in o ||
        ("type" in o && Array.isArray(o.type))) &&
      console.warn(
        "Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.",
      ),
    o
  );
};
var my;
(function (t) {
  t.Completable = "McpCompletable";
})(my || (my = {}));
var oo = class extends He {
  _parse(e) {
    let { ctx: r } = this._processInputParams(e),
      n = r.data;
    return this._def.type._parse({ data: n, path: r.path, parent: r });
  }
  unwrap() {
    return this._def.type;
  }
};
oo.create = (t, e) =>
  new oo({ type: t, typeName: my.Completable, complete: e.complete, ...PY(e) });
function PY(t) {
  if (!t) return {};
  let {
    errorMap: e,
    invalid_type_error: r,
    required_error: n,
    description: s,
  } = t;
  if (e && (r || n))
    throw new Error(
      `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`,
    );
  return e
    ? { errorMap: e, description: s }
    : {
        errorMap: (i, o) => {
          var c, l;
          let { message: u } = t;
          return i.code === "invalid_enum_value"
            ? { message: u ?? o.defaultError }
            : typeof o.data > "u"
              ? {
                  message:
                    (c = u ?? n) !== null && c !== void 0 ? c : o.defaultError,
                }
              : i.code !== "invalid_type"
                ? { message: o.defaultError }
                : {
                    message:
                      (l = u ?? r) !== null && l !== void 0
                        ? l
                        : o.defaultError,
                  };
        },
        description: s,
      };
}
var wp = class {
  constructor(e, r) {
    ((this._registeredResources = {}),
      (this._registeredResourceTemplates = {}),
      (this._registeredTools = {}),
      (this._registeredPrompts = {}),
      (this._toolHandlersInitialized = !1),
      (this._completionHandlerInitialized = !1),
      (this._resourceHandlersInitialized = !1),
      (this._promptHandlersInitialized = !1),
      (this.server = new gp(e, r)));
  }
  async connect(e) {
    return await this.server.connect(e);
  }
  async close() {
    await this.server.close();
  }
  setToolRequestHandlers() {
    this._toolHandlersInitialized ||
      (this.server.assertCanSetRequestHandler(qd.shape.method.value),
      this.server.assertCanSetRequestHandler(zd.shape.method.value),
      this.server.registerCapabilities({ tools: { listChanged: !0 } }),
      this.server.setRequestHandler(qd, () => ({
        tools: Object.entries(this._registeredTools)
          .filter(([, e]) => e.enabled)
          .map(([e, r]) => {
            let n = {
              name: e,
              title: r.title,
              description: r.description,
              inputSchema: r.inputSchema
                ? _p(r.inputSchema, { strictUnions: !0 })
                : kY,
              annotations: r.annotations,
            };
            return (
              r.outputSchema &&
                (n.outputSchema = _p(r.outputSchema, { strictUnions: !0 })),
              n
            );
          }),
      })),
      this.server.setRequestHandler(zd, async (e, r) => {
        let n = this._registeredTools[e.params.name];
        if (!n)
          throw new ot(lt.InvalidParams, `Tool ${e.params.name} not found`);
        if (!n.enabled)
          throw new ot(lt.InvalidParams, `Tool ${e.params.name} disabled`);
        let s;
        if (n.inputSchema) {
          let a = await n.inputSchema.safeParseAsync(e.params.arguments);
          if (!a.success)
            throw new ot(
              lt.InvalidParams,
              `Invalid arguments for tool ${e.params.name}: ${a.error.message}`,
            );
          let i = a.data,
            o = n.callback;
          try {
            s = await Promise.resolve(o(i, r));
          } catch (c) {
            s = {
              content: [
                {
                  type: "text",
                  text: c instanceof Error ? c.message : String(c),
                },
              ],
              isError: !0,
            };
          }
        } else {
          let a = n.callback;
          try {
            s = await Promise.resolve(a(r));
          } catch (i) {
            s = {
              content: [
                {
                  type: "text",
                  text: i instanceof Error ? i.message : String(i),
                },
              ],
              isError: !0,
            };
          }
        }
        if (n.outputSchema && !s.isError) {
          if (!s.structuredContent)
            throw new ot(
              lt.InvalidParams,
              `Tool ${e.params.name} has an output schema but no structured content was provided`,
            );
          let a = await n.outputSchema.safeParseAsync(s.structuredContent);
          if (!a.success)
            throw new ot(
              lt.InvalidParams,
              `Invalid structured content for tool ${e.params.name}: ${a.error.message}`,
            );
        }
        return s;
      }),
      (this._toolHandlersInitialized = !0));
  }
  setCompletionRequestHandler() {
    this._completionHandlerInitialized ||
      (this.server.assertCanSetRequestHandler(Bd.shape.method.value),
      this.server.registerCapabilities({ completions: {} }),
      this.server.setRequestHandler(Bd, async (e) => {
        switch (e.params.ref.type) {
          case "ref/prompt":
            return this.handlePromptCompletion(e, e.params.ref);
          case "ref/resource":
            return this.handleResourceCompletion(e, e.params.ref);
          default:
            throw new ot(
              lt.InvalidParams,
              `Invalid completion reference: ${e.params.ref}`,
            );
        }
      }),
      (this._completionHandlerInitialized = !0));
  }
  async handlePromptCompletion(e, r) {
    let n = this._registeredPrompts[r.name];
    if (!n) throw new ot(lt.InvalidParams, `Prompt ${r.name} not found`);
    if (!n.enabled) throw new ot(lt.InvalidParams, `Prompt ${r.name} disabled`);
    if (!n.argsSchema) return xp;
    let s = n.argsSchema.shape[e.params.argument.name];
    if (!(s instanceof oo)) return xp;
    let i = await s._def.complete(e.params.argument.value, e.params.context);
    return LA(i);
  }
  async handleResourceCompletion(e, r) {
    let n = Object.values(this._registeredResourceTemplates).find(
      (i) => i.resourceTemplate.uriTemplate.toString() === r.uri,
    );
    if (!n) {
      if (this._registeredResources[r.uri]) return xp;
      throw new ot(
        lt.InvalidParams,
        `Resource template ${e.params.ref.uri} not found`,
      );
    }
    let s = n.resourceTemplate.completeCallback(e.params.argument.name);
    if (!s) return xp;
    let a = await s(e.params.argument.value, e.params.context);
    return LA(a);
  }
  setResourceRequestHandlers() {
    this._resourceHandlersInitialized ||
      (this.server.assertCanSetRequestHandler(Ld.shape.method.value),
      this.server.assertCanSetRequestHandler(Md.shape.method.value),
      this.server.assertCanSetRequestHandler(jd.shape.method.value),
      this.server.registerCapabilities({ resources: { listChanged: !0 } }),
      this.server.setRequestHandler(Ld, async (e, r) => {
        let n = Object.entries(this._registeredResources)
            .filter(([a, i]) => i.enabled)
            .map(([a, i]) => ({ uri: a, name: i.name, ...i.metadata })),
          s = [];
        for (let a of Object.values(this._registeredResourceTemplates)) {
          if (!a.resourceTemplate.listCallback) continue;
          let i = await a.resourceTemplate.listCallback(r);
          for (let o of i.resources) s.push({ ...a.metadata, ...o });
        }
        return { resources: [...n, ...s] };
      }),
      this.server.setRequestHandler(Md, async () => ({
        resourceTemplates: Object.entries(
          this._registeredResourceTemplates,
        ).map(([r, n]) => ({
          name: r,
          uriTemplate: n.resourceTemplate.uriTemplate.toString(),
          ...n.metadata,
        })),
      })),
      this.server.setRequestHandler(jd, async (e, r) => {
        let n = new URL(e.params.uri),
          s = this._registeredResources[n.toString()];
        if (s) {
          if (!s.enabled)
            throw new ot(lt.InvalidParams, `Resource ${n} disabled`);
          return s.readCallback(n, r);
        }
        for (let a of Object.values(this._registeredResourceTemplates)) {
          let i = a.resourceTemplate.uriTemplate.match(n.toString());
          if (i) return a.readCallback(n, i, r);
        }
        throw new ot(lt.InvalidParams, `Resource ${n} not found`);
      }),
      this.setCompletionRequestHandler(),
      (this._resourceHandlersInitialized = !0));
  }
  setPromptRequestHandlers() {
    this._promptHandlersInitialized ||
      (this.server.assertCanSetRequestHandler(Fd.shape.method.value),
      this.server.assertCanSetRequestHandler(Ud.shape.method.value),
      this.server.registerCapabilities({ prompts: { listChanged: !0 } }),
      this.server.setRequestHandler(Fd, () => ({
        prompts: Object.entries(this._registeredPrompts)
          .filter(([, e]) => e.enabled)
          .map(([e, r]) => ({
            name: e,
            title: r.title,
            description: r.description,
            arguments: r.argsSchema ? OY(r.argsSchema) : void 0,
          })),
      })),
      this.server.setRequestHandler(Ud, async (e, r) => {
        let n = this._registeredPrompts[e.params.name];
        if (!n)
          throw new ot(lt.InvalidParams, `Prompt ${e.params.name} not found`);
        if (!n.enabled)
          throw new ot(lt.InvalidParams, `Prompt ${e.params.name} disabled`);
        if (n.argsSchema) {
          let s = await n.argsSchema.safeParseAsync(e.params.arguments);
          if (!s.success)
            throw new ot(
              lt.InvalidParams,
              `Invalid arguments for prompt ${e.params.name}: ${s.error.message}`,
            );
          let a = s.data,
            i = n.callback;
          return await Promise.resolve(i(a, r));
        } else {
          let s = n.callback;
          return await Promise.resolve(s(r));
        }
      }),
      this.setCompletionRequestHandler(),
      (this._promptHandlersInitialized = !0));
  }
  resource(e, r, ...n) {
    let s;
    typeof n[0] == "object" && (s = n.shift());
    let a = n[0];
    if (typeof r == "string") {
      if (this._registeredResources[r])
        throw new Error(`Resource ${r} is already registered`);
      let i = this._createRegisteredResource(e, void 0, r, s, a);
      return (
        this.setResourceRequestHandlers(),
        this.sendResourceListChanged(),
        i
      );
    } else {
      if (this._registeredResourceTemplates[e])
        throw new Error(`Resource template ${e} is already registered`);
      let i = this._createRegisteredResourceTemplate(e, void 0, r, s, a);
      return (
        this.setResourceRequestHandlers(),
        this.sendResourceListChanged(),
        i
      );
    }
  }
  registerResource(e, r, n, s) {
    if (typeof r == "string") {
      if (this._registeredResources[r])
        throw new Error(`Resource ${r} is already registered`);
      let a = this._createRegisteredResource(e, n.title, r, n, s);
      return (
        this.setResourceRequestHandlers(),
        this.sendResourceListChanged(),
        a
      );
    } else {
      if (this._registeredResourceTemplates[e])
        throw new Error(`Resource template ${e} is already registered`);
      let a = this._createRegisteredResourceTemplate(e, n.title, r, n, s);
      return (
        this.setResourceRequestHandlers(),
        this.sendResourceListChanged(),
        a
      );
    }
  }
  _createRegisteredResource(e, r, n, s, a) {
    let i = {
      name: e,
      title: r,
      metadata: s,
      readCallback: a,
      enabled: !0,
      disable: () => i.update({ enabled: !1 }),
      enable: () => i.update({ enabled: !0 }),
      remove: () => i.update({ uri: null }),
      update: (o) => {
        (typeof o.uri < "u" &&
          o.uri !== n &&
          (delete this._registeredResources[n],
          o.uri && (this._registeredResources[o.uri] = i)),
          typeof o.name < "u" && (i.name = o.name),
          typeof o.title < "u" && (i.title = o.title),
          typeof o.metadata < "u" && (i.metadata = o.metadata),
          typeof o.callback < "u" && (i.readCallback = o.callback),
          typeof o.enabled < "u" && (i.enabled = o.enabled),
          this.sendResourceListChanged());
      },
    };
    return ((this._registeredResources[n] = i), i);
  }
  _createRegisteredResourceTemplate(e, r, n, s, a) {
    let i = {
      resourceTemplate: n,
      title: r,
      metadata: s,
      readCallback: a,
      enabled: !0,
      disable: () => i.update({ enabled: !1 }),
      enable: () => i.update({ enabled: !0 }),
      remove: () => i.update({ name: null }),
      update: (o) => {
        (typeof o.name < "u" &&
          o.name !== e &&
          (delete this._registeredResourceTemplates[e],
          o.name && (this._registeredResourceTemplates[o.name] = i)),
          typeof o.title < "u" && (i.title = o.title),
          typeof o.template < "u" && (i.resourceTemplate = o.template),
          typeof o.metadata < "u" && (i.metadata = o.metadata),
          typeof o.callback < "u" && (i.readCallback = o.callback),
          typeof o.enabled < "u" && (i.enabled = o.enabled),
          this.sendResourceListChanged());
      },
    };
    return ((this._registeredResourceTemplates[e] = i), i);
  }
  _createRegisteredPrompt(e, r, n, s, a) {
    let i = {
      title: r,
      description: n,
      argsSchema: s === void 0 ? void 0 : E.object(s),
      callback: a,
      enabled: !0,
      disable: () => i.update({ enabled: !1 }),
      enable: () => i.update({ enabled: !0 }),
      remove: () => i.update({ name: null }),
      update: (o) => {
        (typeof o.name < "u" &&
          o.name !== e &&
          (delete this._registeredPrompts[e],
          o.name && (this._registeredPrompts[o.name] = i)),
          typeof o.title < "u" && (i.title = o.title),
          typeof o.description < "u" && (i.description = o.description),
          typeof o.argsSchema < "u" && (i.argsSchema = E.object(o.argsSchema)),
          typeof o.callback < "u" && (i.callback = o.callback),
          typeof o.enabled < "u" && (i.enabled = o.enabled),
          this.sendPromptListChanged());
      },
    };
    return ((this._registeredPrompts[e] = i), i);
  }
  _createRegisteredTool(e, r, n, s, a, i, o) {
    let c = {
      title: r,
      description: n,
      inputSchema: s === void 0 ? void 0 : E.object(s),
      outputSchema: a === void 0 ? void 0 : E.object(a),
      annotations: i,
      callback: o,
      enabled: !0,
      disable: () => c.update({ enabled: !1 }),
      enable: () => c.update({ enabled: !0 }),
      remove: () => c.update({ name: null }),
      update: (l) => {
        (typeof l.name < "u" &&
          l.name !== e &&
          (delete this._registeredTools[e],
          l.name && (this._registeredTools[l.name] = c)),
          typeof l.title < "u" && (c.title = l.title),
          typeof l.description < "u" && (c.description = l.description),
          typeof l.paramsSchema < "u" &&
            (c.inputSchema = E.object(l.paramsSchema)),
          typeof l.callback < "u" && (c.callback = l.callback),
          typeof l.annotations < "u" && (c.annotations = l.annotations),
          typeof l.enabled < "u" && (c.enabled = l.enabled),
          this.sendToolListChanged());
      },
    };
    return (
      (this._registeredTools[e] = c),
      this.setToolRequestHandlers(),
      this.sendToolListChanged(),
      c
    );
  }
  tool(e, ...r) {
    if (this._registeredTools[e])
      throw new Error(`Tool ${e} is already registered`);
    let n, s, a, i;
    if ((typeof r[0] == "string" && (n = r.shift()), r.length > 1)) {
      let c = r[0];
      DA(c)
        ? ((s = r.shift()),
          r.length > 1 &&
            typeof r[0] == "object" &&
            r[0] !== null &&
            !DA(r[0]) &&
            (i = r.shift()))
        : typeof c == "object" && c !== null && (i = r.shift());
    }
    let o = r[0];
    return this._createRegisteredTool(e, void 0, n, s, a, i, o);
  }
  registerTool(e, r, n) {
    if (this._registeredTools[e])
      throw new Error(`Tool ${e} is already registered`);
    let {
      title: s,
      description: a,
      inputSchema: i,
      outputSchema: o,
      annotations: c,
    } = r;
    return this._createRegisteredTool(e, s, a, i, o, c, n);
  }
  prompt(e, ...r) {
    if (this._registeredPrompts[e])
      throw new Error(`Prompt ${e} is already registered`);
    let n;
    typeof r[0] == "string" && (n = r.shift());
    let s;
    r.length > 1 && (s = r.shift());
    let a = r[0],
      i = this._createRegisteredPrompt(e, void 0, n, s, a);
    return (this.setPromptRequestHandlers(), this.sendPromptListChanged(), i);
  }
  registerPrompt(e, r, n) {
    if (this._registeredPrompts[e])
      throw new Error(`Prompt ${e} is already registered`);
    let { title: s, description: a, argsSchema: i } = r,
      o = this._createRegisteredPrompt(e, s, a, i, n);
    return (this.setPromptRequestHandlers(), this.sendPromptListChanged(), o);
  }
  isConnected() {
    return this.server.transport !== void 0;
  }
  sendResourceListChanged() {
    this.isConnected() && this.server.sendResourceListChanged();
  }
  sendToolListChanged() {
    this.isConnected() && this.server.sendToolListChanged();
  }
  sendPromptListChanged() {
    this.isConnected() && this.server.sendPromptListChanged();
  }
};
var kY = { type: "object", properties: {} };
function DA(t) {
  return typeof t != "object" || t === null
    ? !1
    : Object.keys(t).length === 0 || Object.values(t).some(RY);
}
function RY(t) {
  return (
    t !== null &&
    typeof t == "object" &&
    "parse" in t &&
    typeof t.parse == "function" &&
    "safeParse" in t &&
    typeof t.safeParse == "function"
  );
}
function OY(t) {
  return Object.entries(t.shape).map(([e, r]) => ({
    name: e,
    description: r.description,
    required: !r.isOptional(),
  }));
}
function LA(t) {
  return {
    completion: {
      values: t.slice(0, 100),
      total: t.length,
      hasMore: t.length > 100,
    },
  };
}
var xp = { completion: { values: [], hasMore: !1 } };
var lN = le(require("http"), 1);
var Le = le(require("vscode"), 1),
  qs = le(require("path"), 1);
async function MA(t = {}) {
  try {
    let e = _c(t.uri);
    return { content: [{ type: "text", text: JSON.stringify(e, null, 2) }] };
  } catch (e) {
    throw (console.error("Error getting diagnostics through MCP:", e), e);
  }
}
async function jA({
  filePath: t,
  preview: e,
  startText: r,
  endText: n,
  selectToEndOfLine: s,
  makeFrontmost: a = !0,
}) {
  try {
    if (!t) throw new Error("File path is required");
    let i;
    if (
      !qs.isAbsolute(t) &&
      Le.workspace.workspaceFolders &&
      Le.workspace.workspaceFolders.length > 0
    ) {
      let o = Le.workspace.workspaceFolders[0].uri.fsPath,
        c = qs.join(o, t);
      ((i = Le.Uri.file(c)),
        console.log(`Converted relative path '${t}' to absolute: '${c}'`));
    } else i = Le.Uri.file(t);
    try {
      await Le.workspace.fs.stat(i);
      let o = await Le.workspace.openTextDocument(i),
        c = Le.window.visibleTextEditors.some(
          (d) => d.document.uri.toString() === i.toString(),
        ),
        l;
      if (
        (a || !c
          ? (l = await Le.window.showTextDocument(o, {
              preview: e,
              preserveFocus: !a,
            }))
          : (l = Le.window.visibleTextEditors.find(
              (d) => d.document.uri.toString() === i.toString(),
            )),
        r && l)
      ) {
        let d = o.getText(),
          m = {
            success: !0,
            filePath: i.fsPath,
            message: `Opened file: ${i.fsPath}`,
          },
          p = d.indexOf(r);
        if (p !== -1) {
          let f = o.positionAt(p),
            y;
          if (n) {
            let g = d.substring(p + r.length).indexOf(n);
            if (g !== -1) {
              let _ = p + r.length + g + n.length;
              ((y = o.positionAt(_)),
                s && (y = new Le.Position(y.line, Number.MAX_SAFE_INTEGER)),
                (l.selection = new Le.Selection(f, y)),
                l.revealRange(
                  new Le.Range(f, y),
                  Le.TextEditorRevealType.InCenter,
                ),
                (m.message = `Opened file and selected text from "${r}" to "${n}"`));
            } else
              ((l.selection = new Le.Selection(f, f)),
                l.revealRange(
                  new Le.Range(f, f),
                  Le.TextEditorRevealType.InCenter,
                ),
                (m.message = `Opened file and positioned at "${r}" (end text "${n}" not found)`));
          } else
            ((y = o.positionAt(p + r.length)),
              (l.selection = new Le.Selection(f, y)),
              l.revealRange(
                new Le.Range(f, y),
                Le.TextEditorRevealType.InCenter,
              ),
              (m.message = `Opened file and selected text "${r}"`));
        } else m.message = `Opened file, but text "${r}" not found`;
        return { content: [{ type: "text", text: m.message }] };
      }
      let u = {
        success: !0,
        filePath: i.fsPath,
        fileUrl: o.uri.toString(),
        message: `Opened file: ${i.fsPath}`,
      };
      return (
        a ||
          ((u.languageId = o.languageId),
          (u.lineCount = o.lineCount),
          (u.isDirty = o.isDirty),
          (u.isUntitled = o.isUntitled),
          (u.isClosed = o.isClosed)),
        {
          content: [
            { type: "text", text: a ? u.message : JSON.stringify(u, null, 2) },
          ],
        }
      );
    } catch {
      throw new Error(`File not found: ${i.fsPath}`);
    }
  } catch (i) {
    throw (console.error("Error opening file through MCP:", i), i);
  }
}
async function FA() {
  try {
    let t = Le.window.activeTextEditor,
      e = [];
    for (let n of Le.window.tabGroups.all)
      for (let s of n.tabs)
        if (s.input instanceof Le.TabInputText) {
          let a = s.input.uri,
            i = Le.workspace.textDocuments.find(
              (c) => c.uri.toString() === a.toString(),
            ),
            o = {
              uri: a.toString(),
              isActive: s.isActive,
              isPinned: s.isPinned,
              isPreview: s.isPreview,
              isDirty: s.isDirty,
              label: s.label,
              groupIndex: n.viewColumn ? n.viewColumn - 1 : 0,
              viewColumn: n.viewColumn,
              isGroupActive: n.isActive,
            };
          (i &&
            ((o.fileName = i.fileName),
            (o.languageId = i.languageId),
            (o.lineCount = i.lineCount),
            (o.isUntitled = i.isUntitled),
            t &&
              t.document.uri.toString() === a.toString() &&
              (o.selection = {
                start: {
                  line: t.selection.start.line,
                  character: t.selection.start.character,
                },
                end: {
                  line: t.selection.end.line,
                  character: t.selection.end.character,
                },
                isReversed: t.selection.isReversed,
              })),
            e.push(o));
        }
    return {
      content: [{ type: "text", text: JSON.stringify({ tabs: e }, null, 2) }],
    };
  } catch (t) {
    throw (console.error("Error getting open editors through MCP:", t), t);
  }
}
async function UA() {
  try {
    let t = Le.window.activeTextEditor;
    if (!t)
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(
              { success: !1, message: "No active editor found" },
              null,
              2,
            ),
          },
        ],
      };
    let e = t.selection,
      r = t.document,
      n = r.getText(e),
      s = r.uri.fsPath;
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(
            {
              success: !0,
              text: n,
              filePath: s,
              fileUrl: r.uri.toString(),
              selection: {
                start: { line: e.start.line, character: e.start.character },
                end: { line: e.end.line, character: e.end.character },
                isEmpty: e.isEmpty,
              },
            },
            null,
            2,
          ),
        },
      ],
    };
  } catch (t) {
    throw (console.error("Error getting current selection through MCP:", t), t);
  }
}
async function qA() {
  try {
    let e = (Le.workspace.workspaceFolders || []).map((r) => ({
      name: r.name,
      uri: r.uri.toString(),
      path: r.uri.fsPath,
      index: r.index,
    }));
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(
            {
              success: !0,
              folders: e,
              rootPath: Le.workspace.rootPath || null,
              workspaceFile: Le.workspace.workspaceFile?.toString() || null,
            },
            null,
            2,
          ),
        },
      ],
    };
  } catch (t) {
    throw (console.error("Error getting workspace folders through MCP:", t), t);
  }
}
async function zA({ filePath: t }) {
  try {
    if (!t) throw new Error("File path is required");
    let e;
    if (
      !qs.isAbsolute(t) &&
      Le.workspace.workspaceFolders &&
      Le.workspace.workspaceFolders.length > 0
    ) {
      let n = Le.workspace.workspaceFolders[0].uri.fsPath,
        s = qs.join(n, t);
      ((e = Le.Uri.file(s)),
        console.log(`Converted relative path '${t}' to absolute: '${s}'`));
    } else e = Le.Uri.file(t);
    let r = Le.workspace.textDocuments.find(
      (n) => n.uri.toString() === e.toString(),
    );
    return r
      ? {
          content: [
            {
              type: "text",
              text: JSON.stringify(
                {
                  success: !0,
                  filePath: e.fsPath,
                  isDirty: r.isDirty,
                  isUntitled: r.isUntitled,
                },
                null,
                2,
              ),
            },
          ],
        }
      : {
          content: [
            {
              type: "text",
              text: JSON.stringify(
                { success: !1, message: `Document not open: ${e.fsPath}` },
                null,
                2,
              ),
            },
          ],
        };
  } catch (e) {
    throw (
      console.error("Error checking document dirty state through MCP:", e),
      e
    );
  }
}
async function BA({ filePath: t }) {
  try {
    if (!t) throw new Error("File path is required");
    let e;
    if (
      !qs.isAbsolute(t) &&
      Le.workspace.workspaceFolders &&
      Le.workspace.workspaceFolders.length > 0
    ) {
      let s = Le.workspace.workspaceFolders[0].uri.fsPath,
        a = qs.join(s, t);
      ((e = Le.Uri.file(a)),
        console.log(`Converted relative path '${t}' to absolute: '${a}'`));
    } else e = Le.Uri.file(t);
    let r = Le.workspace.textDocuments.find(
      (s) => s.uri.toString() === e.toString(),
    );
    if (!r)
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(
              { success: !1, message: `Document not open: ${e.fsPath}` },
              null,
              2,
            ),
          },
        ],
      };
    let n = await r.save();
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(
            {
              success: !0,
              filePath: e.fsPath,
              saved: n,
              message: n
                ? "Document saved successfully"
                : "Document was not dirty or save failed",
            },
            null,
            2,
          ),
        },
      ],
    };
  } catch (e) {
    throw (console.error("Error saving document through MCP:", e), e);
  }
}
var Dt = le(require("vscode"), 1),
  hy;
async function IY() {
  if (!hy) {
    let t = Dt.extensions.getExtension("ms-toolsai.jupyter");
    if (!t) throw new Error("Jupyter extension not installed");
    hy = Promise.resolve(t.activate());
  }
  return hy;
}
function co(t, e) {
  return (t.error(e), { content: [{ type: "text", text: e }] });
}
async function HA(t, e) {
  let r = Dt.window.activeNotebookEditor;
  if (!r) return co(t, "No active notebook editor found.");
  let n;
  try {
    n = await IY();
  } catch {
    return co(
      t,
      "Unable to request Jupyter extension API. It is either not installed or not activated.",
    );
  }
  let s = await n.kernels.getKernel(r.notebook.uri);
  if (!s)
    return co(
      t,
      "No kernel found for the active notebook. Please connect to a kernel.",
    );
  if (s.language !== "python")
    return co(t, `Kernel language is ${s?.language}, not python.`);
  let a = { content: [] };
  try {
    t.info(`Executing ${e}`);
    let i = new TextDecoder(),
      o = await AY(e, r.notebook),
      c = r.notebook.getCells().find((d) => d.metadata.id === o);
    if (!c) return co(t, "No cell found in the notebook.");
    let l = r.notebook.getCells().indexOf(c);
    if (
      (r.revealRange(
        new Dt.NotebookRange(l, l + 1),
        Dt.NotebookEditorRevealType.InCenter,
      ),
      !(await $Y(t)))
    )
      return co(
        t,
        "Code execution cancelled by user. Ask the user how they would like to proceed.",
      );
    await Dt.commands.executeCommand("notebook.cell.execute", {
      ranges: [{ start: l, end: l + 1 }],
      document: r.notebook.uri,
    });
    for (let d of c.outputs)
      for (let m of d.items)
        if (m.mime === NY) {
          let p = JSON.parse(i.decode(m.data));
          (t.appendLine(
            `Error executing code ${p.name}: ${p.message},/n ${p.stack}`,
          ),
            a.content.push({
              type: "text",
              text: `Error: ${p.name}: ${p.message},/n ${p.stack}`,
            }));
        } else if (m.mime === DY) {
          let p = Buffer.from(m.data).toString("base64");
          a.content.push({ type: "image", data: p, mimeType: m.mime });
        } else a.content.push({ type: "text", text: i.decode(m.data) });
    t.info("Code execution completed");
  } catch (i) {
    t.error(`Code execution failed with an error '${i}'`);
  }
  return a;
}
async function $Y(t) {
  return (
    (
      await Dt.window.showQuickPick(
        [
          { label: "Execute", description: "Run the code in the notebook" },
          { label: "Cancel", description: "Do not execute the code" },
        ],
        {
          title: "Claude Code Execution",
          placeHolder: "Choose whether to execute the code",
        },
      )
    )?.label === "Execute"
  );
}
async function AY(t, e) {
  let r = new Dt.NotebookCellData(Dt.NotebookCellKind.Code, t, "python"),
    n = Math.random().toString(36).substring(2, 15);
  r.metadata = { id: n };
  let s = e.getCells().length,
    a = Dt.NotebookEdit.insertCells(s, [r]),
    i = new Dt.WorkspaceEdit();
  return (i.set(e.uri, [a]), await Dt.workspace.applyEdit(i), n);
}
var NY = Dt.NotebookCellOutputItem.error(new Error("")).mime,
  DY = "image/png";
var Sp = le(require("vscode"), 1),
  Mn = le(require("fs"), 1),
  Ep = le(require("path"), 1),
  VA = le(require("os"), 1),
  ZA = le(require("http"), 1);
function LY() {
  return Math.floor(Math.random() * 55536) + 1e4;
}
function GA() {
  let t = Ep.join(VA.homedir(), ".claude", "ide");
  return (Mn.existsSync(t) || Mn.mkdirSync(t, { recursive: !0, mode: 448 }), t);
}
function gy(t, e) {
  let r = GA(),
    n = Ep.join(r, `${t}.lock`),
    s = Mn.existsSync(n),
    a = Sp.workspace.workspaceFolders?.map((o) => o.uri.fsPath) || [],
    i = {
      pid: process.ppid,
      workspaceFolders: a,
      ideName: Sp.env.appName,
      transport: "ws",
      runningInWindows: process.platform === "win32",
      authToken: e,
    };
  return (
    Mn.writeFileSync(n, JSON.stringify(i), { mode: 384 }),
    s && console.log(`Updated lock file with new workspace folders: ${n}`),
    n
  );
}
function WA(t) {
  let e = GA(),
    r = Ep.join(e, `${t}.lock`);
  if (Mn.existsSync(r))
    try {
      Mn.unlinkSync(r);
    } catch (n) {
      console.error(`Failed to delete lock file ${r}:`, n);
    }
}
function MY(t) {
  return new Promise((e) => {
    let r = ZA.createServer();
    (r.once("error", () => {
      e(!1);
    }),
      r.once("listening", () => {
        (r.close(), e(!0));
      }),
      r.listen(t));
  });
}
async function KA() {
  for (let t = 0; t < 50; t++) {
    let e = LY();
    if (await MY(e)) return e;
  }
  throw new Error("Failed to find an available port after multiple attempts");
}
var Ut = le(require("vscode"), 1),
  YA = le(require("fs"), 1);
var JA = le(require("vscode"), 1);
function wn() {
  try {
    let t = JA.window.activeTerminal;
    t && t.show();
  } catch (t) {
    console.error("Error focusing terminal:", t);
  }
}
var zs;
async function QA(t, e, r, n, s, a, i, o, c) {
  t.info("diff from", n, "to", s, "as", i);
  let l = Ut.Uri.file(n);
  try {
    if ((await Ut.workspace.openTextDocument(l)).isDirty) {
      let D = YA.readFileSync(n, "utf8");
      l = e.createFile(n, D).uri;
    }
  } catch {
    (t.info("leftTempFileProvider.createFile", n),
      (l = e.createFile(n, "").uri));
  }
  let d = r.createFile(s, a).uri,
    m = await Ut.workspace.openTextDocument(d),
    p = (R) =>
      R.input instanceof Ut.TabInputTextDiff &&
      R.input.modified.toString() === d.toString();
  (await vy(t)) > 0 && (await new Promise((R) => setTimeout(R, 200)));
  let y = { preview: !1 },
    h = a,
    g = a,
    _;
  Ut.workspace.onDidChangeTextDocument((R) => {
    R.document.uri.toString() === d.toString() &&
      ((h = g),
      (g = R.document.getText()),
      R.contentChanges.length > 3 &&
        R.reason !== Ut.TextDocumentChangeReason.Undo &&
        R.reason !== Ut.TextDocumentChangeReason.Redo &&
        (_ = { time: Date.now(), contents: h }));
  });
  let v = new Promise((R) => {
      c.push(
        Ut.workspace.onWillSaveTextDocument((D) => {
          if (D.document.uri.toString() === d.toString()) {
            let F = D.document.getText();
            (_ && Date.now() - _.time < 500 && (F = _.contents), R(F));
          }
        }),
      );
    }),
    b = !0;
  zs && (zs.dispose(), (zs = void 0));
  try {
    ((zs = Ut.commands.registerCommand("type", (R) => {
      if (
        !(
          b &&
          Ut.window.activeTextEditor?.document.uri.toString() === d.toString()
        )
      )
        return Ut.commands.executeCommand("default:type", R);
    })),
      setTimeout(() => {
        ((b = !1), zs && (zs.dispose(), (zs = void 0)));
      }, 1e3),
      c.push(zs));
  } catch (R) {
    t.warn("Could not register type command interceptor:", R);
  }
  let x = Tp(),
    w = await Ut.commands.executeCommand("vscode.diff", l, d, i, y);
  t.info("diff result", w, i, l, d, y);
  try {
    await XA(() => Tp().some((R) => R.label === i), 1e3);
  } catch (R) {
    let D = Tp()
      .filter((F) => !x.some((I) => I.label === F.label))
      .map((F) => ({ label: F.label, isDiff: F.isDiff }));
    throw (
      t.error(
        `Failed to open diff tab, possibly new tabs: ${JSON.stringify(D)}`,
      ),
      R
    );
  }
  wn();
  let S = new Promise((R) => {
      c.push(
        o((D) => {
          D.activeTab && p(D.activeTab) && R(D);
        }),
      );
    }).then((R) =>
      R.accepted
        ? (t.info("diff_accepted", i),
          {
            content: [
              { type: "text", text: "FILE_SAVED" },
              { type: "text", text: m.getText() },
            ],
          })
        : {
            content: [
              { type: "text", text: "DIFF_REJECTED" },
              { type: "text", text: i },
            ],
          },
    ),
    C = XA(() => !Tp().some((R) => R.label === i)).then(
      () => (
        t.info("tab_closed", i),
        {
          content: [
            { type: "text", text: "DIFF_REJECTED" },
            { type: "text", text: i },
          ],
        }
      ),
    ),
    P = v.then(
      async (R) => (
        t.info("file_saved", i),
        {
          content: [
            { type: "text", text: "FILE_SAVED" },
            { type: "text", text: R },
          ],
        }
      ),
    ),
    A = [C, S];
  return (
    Ut.workspace.getConfiguration("files").get("autoSave") === "off" &&
      A.push(P),
    await Promise.race(A)
  );
}
function Tp() {
  return Ut.window.tabGroups.all.flatMap((t) =>
    t.tabs.map((e) => ({
      tab: e,
      label: e.label,
      isDiff: e.input instanceof Ut.TabInputTextDiff,
      viewColumn: t.viewColumn,
      isActive: e.isActive,
    })),
  );
}
function XA(t, e) {
  return new Promise((r, n) => {
    let s,
      a = setInterval(() => {
        t() && (clearInterval(a), s && clearTimeout(s), r());
      }, 100);
    e &&
      (s = setTimeout(() => {
        (clearInterval(a), n(new Error(`Timeout waiting after ${e}ms`)));
      }, e));
  });
}
async function yy(t, e, r) {
  (t.environmentVariableCollection.replace(e, r),
    console.log(`Set ${e}=${r} in terminal environment (in-memory)`));
}
var ree = le(W1(), 1),
  nee = le(Ry(), 1),
  see = le($y(), 1),
  sN = le(Mp(), 1),
  Uy = le(nN(), 1);
var vo = sN.default;
var Fp = class {
  constructor(e) {
    this.ws = e;
    ((this.opened = new Promise((r, n) => {
      this.ws.readyState === vo.OPEN
        ? r()
        : (this.ws.on("open", () => {
            r();
          }),
          this.ws.on("error", (s) => {
            n(s);
          }));
    })),
      this.ws.on("message", this.onMessageHandler),
      this.ws.on("error", this.onErrorHandler),
      this.ws.on("close", this.onCloseHandler));
  }
  started = !1;
  opened;
  onclose;
  onerror;
  onmessage;
  onMessageHandler = (e) => {
    try {
      let r = JSON.parse(e.toString("utf-8")),
        n = Od.parse(r);
      this.onmessage?.(n);
    } catch (r) {
      this.onErrorHandler(r);
    }
  };
  onErrorHandler = (e) => {
    this.onerror?.(
      e instanceof Error ? e : new Error("Failed to process message"),
    );
  };
  onCloseHandler = () => {
    (this.onclose?.(),
      this.ws.off("message", this.onMessageHandler),
      this.ws.off("error", this.onErrorHandler),
      this.ws.off("close", this.onCloseHandler));
  };
  async start() {
    if (this.started)
      throw new Error("Start can only be called once per transport.");
    if ((await this.opened, this.ws.readyState !== vo.OPEN))
      throw new Error("WebSocket is not open. Cannot start transport.");
    this.started = !0;
  }
  async close() {
    ((this.ws.readyState === vo.OPEN || this.ws.readyState === vo.CONNECTING) &&
      this.ws.close(),
      this.onCloseHandler());
  }
  async send(e) {
    if (this.ws.readyState !== vo.OPEN)
      throw new Error("WebSocket is not open. Cannot send message.");
    let r = JSON.stringify(e);
    try {
      await new Promise((n, s) => {
        this.ws.send(r, (a) => {
          a ? s(a) : n();
        });
      });
    } catch (n) {
      throw (this.onErrorHandler(n), n);
    }
  }
};
var qy = le(require("vscode"), 1);
var fs = null;
function zy() {
  return fs;
}
function aN(t, e) {
  let r = null,
    n = qy.window.onDidChangeTextEditorSelection((s) => {
      let a = s.textEditor,
        i = a.selection,
        o = a.document,
        c = o.getText(i);
      if (o.uri.scheme === "comment" || o.uri.scheme === "output") return;
      let l = {
          text: c,
          filePath: o.uri.fsPath,
          fileUrl: o.uri.toString(),
          selection: {
            start: { line: i.start.line, character: i.start.character },
            end: { line: i.end.line, character: i.end.character },
            isEmpty: i.isEmpty,
          },
        },
        u =
          !fs ||
          fs.text !== l.text ||
          fs.filePath !== l.filePath ||
          fs.selection.start.line !== l.selection.start.line ||
          fs.selection.start.character !== l.selection.start.character ||
          fs.selection.end.line !== l.selection.end.line ||
          fs.selection.end.character !== l.selection.end.character;
      fs = l;
      let d = e();
      u &&
        d &&
        t.server &&
        (r && clearTimeout(r),
        (r = setTimeout(() => {
          let m = e();
          m && By(l, m);
        }, 300)));
    });
  return {
    dispose: () => {
      (n.dispose(), r && clearTimeout(r));
    },
  };
}
function iN(t, e, r) {
  t(() => {
    let n = qy.window.activeTextEditor;
    if (!n) return;
    let s = n.selection,
      a = { filePath: n.document.uri.fsPath };
    s.isEmpty || ((a.lineStart = s.start.line), (a.lineEnd = s.end.line));
    let i = r();
    i && e.server && (oN(a, i), wn());
  });
}
function aee() {
  let t = Or.env.appName,
    e;
  switch (t.toLowerCase()) {
    case "visual studio code":
      e = "Claude Code VSCode MCP";
      break;
    case "cursor":
      e = "Claude Code Cursor MCP";
      break;
    case "windsurf":
      e = "Claude Code Windsurf MCP";
      break;
    default:
      e = `Claude Code ${t} MCP`;
  }
  return e;
}
function iee(t, e, r, n) {
  t.logged.event((s) => {
    let a = n();
    a && e.server ? fN(r, s, a) : Hy.push(s);
  });
}
function uN(t, e, r, n, s, a, i) {
  let o = new wp({
    name: aee(),
    version: t.extension.packageJSON.version || "0.0.1",
  });
  (o.tool(
    "openDiff",
    "Open a git diff for the file",
    {
      old_file_path: E.string().describe(
        "Path to the file to show diff for. If not provided, uses active editor.",
      ),
      new_file_path: E.string().describe(
        "Path to the file to show diff for. If not provided, uses active editor.",
      ),
      new_file_contents: E.string().describe(
        "Contents of the new file. If not provided then the current file contents of new_file_path will be used.",
      ),
      tab_name: E.string().describe(
        "Path to the file to show diff for. If not provided, uses active editor.",
      ),
    },
    async ({
      old_file_path: _,
      new_file_path: v,
      new_file_contents: b,
      tab_name: x,
    }) => {
      let w = [];
      try {
        return await QA(n, e, r, _, v, b, x, s, w);
      } catch (S) {
        throw (n.error(`Error opening diff: ${S}`), S);
      } finally {
        for (let S of w) S.dispose();
      }
    },
  ),
    o.tool(
      "getDiagnostics",
      "Get language diagnostics from VS Code",
      {
        uri: E.string()
          .optional()
          .describe(
            "Optional file URI to get diagnostics for. If not provided, gets diagnostics for all files.",
          ),
      },
      MA,
    ),
    o.tool(
      "close_tab",
      { tab_name: E.string() },
      async ({ tab_name: _ }) => (
        await oee(_, n),
        setTimeout(() => {
          wn();
        }, 500),
        { content: [{ type: "text", text: "TAB_CLOSED" }] }
      ),
    ),
    o.tool(
      "closeAllDiffTabs",
      "Close all diff tabs in the editor",
      {},
      async () => {
        let _ = await vy(n);
        return (
          setTimeout(() => {
            wn();
          }, 500),
          { content: [{ type: "text", text: `CLOSED_${_}_DIFF_TABS` }] }
        );
      },
    ),
    o.tool(
      "openFile",
      "Open a file in the editor and optionally select a range of text",
      {
        filePath: E.string().describe("Path to the file to open"),
        preview: E.boolean()
          .describe("Whether to open the file in preview mode")
          .default(!1),
        startText: E.string().describe(
          "Text pattern to find the start of the selection range. Selects from the beginning of this match.",
        ),
        endText: E.string().describe(
          "Text pattern to find the end of the selection range. Selects up to the end of this match. If not provided, only the startText match will be selected.",
        ),
        selectToEndOfLine: E.boolean()
          .describe(
            "If true, selection will extend to the end of the line containing the endText match.",
          )
          .default(!1),
        makeFrontmost: E.boolean()
          .describe(
            "Whether to make the file the active editor tab. If false, the file will be opened in the background without changing focus.",
          )
          .default(!0),
      },
      { readOnlyHint: !0 },
      jA,
    ),
    o.tool(
      "getOpenEditors",
      "Get information about currently open editors",
      {},
      FA,
    ),
    o.tool(
      "getWorkspaceFolders",
      "Get all workspace folders currently open in the IDE",
      {},
      qA,
    ),
    o.tool(
      "getCurrentSelection",
      "Get the current text selection in the active editor",
      {},
      UA,
    ),
    o.tool(
      "checkDocumentDirty",
      "Check if a document has unsaved changes (is dirty)",
      { filePath: E.string().describe("Path to the file to check") },
      zA,
    ),
    o.tool(
      "saveDocument",
      "Save a document with unsaved changes",
      { filePath: E.string().describe("Path to the file to save") },
      BA,
    ),
    o.tool(
      "getLatestSelection",
      "Get the most recent text selection (even if not in the active editor)",
      {},
      async () => ({
        content: [
          {
            type: "text",
            text: JSON.stringify(
              zy() || { success: !1, message: "No selection available" },
              null,
              2,
            ),
          },
        ],
      }),
    ),
    o.tool(
      "executeCode",
      `Execute python code in the Jupyter kernel for the current notebook file.
    
    All code will be executed in the current Jupyter kernel.
    
    Avoid declaring variables or modifying the state of the kernel unless the user
    explicitly asks for it.
    
    Any code executed will persist across calls to this tool, unless the kernel
    has been restarted.`,
      { code: E.string().describe("The code to be executed on the kernel.") },
      ({ code: _ }) => HA(n, _),
    ));
  let c = lN.createServer(),
    l = new Uy.default({ server: c }),
    u = null,
    d = null,
    m = Hu.getInstance(n),
    p = (0, cN.randomUUID)();
  l.on("connection", function (_, v) {
    if (v.headers["x-claude-code-ide-authorization"] !== p) {
      (n.error("Unauthorized WebSocket connection attempt"),
        _.close(1008, "Unauthorized"));
      return;
    }
    if ((n.info("New WS connection from:", v.url || "unknown"), u)) {
      (n.info("Disconnecting previous WebSocket client"),
        d &&
          (m.unregisterClient(d),
          n.info(`Unregistered previous diagnostic client: ${d}`),
          (d = null)));
      try {
        u.close();
      } catch (w) {
        n.error("Error closing previous transport:", w);
      }
    }
    let b = new Fp(_);
    u = b;
    let x = null;
    (o
      .connect(b)
      .then(() => {
        (n.info("MCP server connected to transport"),
          (x = m.registerClient((w) => {
            b.send({
              jsonrpc: "2.0",
              method: "diagnostics_changed",
              params: { uris: w },
            }).catch((S) => {
              n.error("Error sending diagnostics notification:", S.message);
            });
          })),
          (d = x),
          n.info(`Registered diagnostic client: ${x}`),
          setTimeout(() => {
            let w = zy();
            w && By(w, b);
            let S = [...Hy];
            Hy.length = 0;
            for (let C of S) fN(n, C, b);
          }, 500));
      })
      .catch((w) => {
        (console.error("Error connecting transport:", w), (u = null));
        try {
          _.close();
        } catch (S) {
          n.error("Error closing WebSocket:", S);
        }
      }),
      _.on("close", () => {
        (n.info("WS client disconnected"),
          u === b &&
            ((u = null),
            x &&
              d === x &&
              (m.unregisterClient(x),
              n.info(`Unregistered diagnostic client: ${x}`),
              (d = null))));
      }));
  });
  let f = () => u;
  (iee(i, o, n, f), iN(a, o, f));
  let y = aN(o, f),
    h = null;
  c.on("listening", () => {
    let _ = c.address();
    _ && typeof _ != "string" && (h = _.port);
  });
  let g = Or.workspace.onDidChangeWorkspaceFolders(() => {
    h !== null &&
      (gy(h, p),
      n.info(`Updated lock file for port ${h} with new workspace folders`));
  });
  return {
    httpServer: c,
    authToken: p,
    dispose: async () => {
      (h !== null && (WA(h), n.info(`Deleted lock file for port ${h}`)),
        y.dispose(),
        g.dispose(),
        m.dispose(),
        c.close(),
        typeof o.close == "function" && (await o.close()));
    },
  };
}
async function dN(t, e, r, n) {
  try {
    let s = await KA(),
      a = null;
    return new Promise((i, o) => {
      t.listen(s, "127.0.0.1", async () => {
        (n.info(`MCP Server running on port ${s} (localhost only)`),
          (a = gy(s, e)),
          console.log(`Created lock file at ${a}`));
        try {
          (await yy(r, "CLAUDE_CODE_SSE_PORT", String(s)),
            await yy(r, "ENABLE_IDE_INTEGRATION", "true"),
            i(s));
        } catch (c) {
          (console.error("Failed to set environment variables:", c), o(c));
        }
      }).on("error", (c) => {
        (console.error("Failed to start MCP server:", c),
          Or.window.showErrorMessage(`Failed to start MCP server: ${c}`),
          o(c));
      });
    });
  } catch (s) {
    throw (
      console.error("Failed to start MCP server:", s),
      Or.window.showErrorMessage(`Failed to start MCP server: ${s}`),
      s
    );
  }
}
async function pN(t, e) {
  let r = t.input;
  if (r instanceof Or.TabInputTextDiff)
    try {
      await (await Or.workspace.openTextDocument(r.modified)).save();
    } catch (n) {
      e.error("Error saving modified file:", n);
    }
  await Or.window.tabGroups.close(t);
}
async function oee(t, e) {
  for (let r of Or.window.tabGroups.all)
    for (let n of r.tabs) if (n.label === t) return (await pN(n, e), !0);
  return !1;
}
async function vy(t) {
  let e = 0;
  t.info("Closing all diff tabs in the editor...");
  for (let r of Or.window.tabGroups.all)
    for (let n of r.tabs)
      n.input instanceof Or.TabInputTextDiff &&
        n.label.includes("[Claude Code]") &&
        (await pN(n, t), e++);
  return (t.info(`Closed ${e} diff tabs.`), e);
}
function fN(t, e, r) {
  t.info("Logging event:", e.eventName, e.eventData);
  let n = { eventName: e.eventName, eventData: e.eventData ?? {} };
  r.send({ jsonrpc: "2.0", method: "log_event", params: n }).catch((s) => {
    t.error("Error sending log event:", s);
  });
}
var Hy = [];
async function By(t, e) {
  try {
    e.send({ jsonrpc: "2.0", method: "selection_changed", params: t }).catch(
      (r) => {
        console.error("Error sending selection change notification:", r);
      },
    );
  } catch (r) {
    console.error("Error sending selection change notification:", r);
  }
}
async function oN(t, e) {
  try {
    e.send({ jsonrpc: "2.0", method: "at_mentioned", params: t }).catch((r) => {
      console.error("Error sending at-mentioned notification:", r);
    });
  } catch (r) {
    console.error("Error sending at-mentioned notification:", r);
  }
}
var gt = le(require("vscode"), 1),
  mN = le(require("path"), 1);
var hN = le(Vh(), 1);
function cee(t) {
  return typeof t == "string" && ["bottom", "window", "beside"].includes(t);
}
async function lee(t, e, r = !0, n, s = [], a) {
  (t.info("Creating new Claude terminal"),
    r &&
      gt.window.withProgress(
        {
          location: gt.ProgressLocation.Notification,
          title: "Claude Code launching...",
          cancellable: !1,
        },
        async (l) => new Promise((u) => setTimeout(u, 2e3)),
      ));
  let i =
      a === "beside" || a === void 0
        ? { viewColumn: gt.ViewColumn.Beside }
        : a === "window"
          ? { viewColumn: gt.ViewColumn.One }
          : void 0,
    o = gt.window.createTerminal({
      name: process.env.CLAUDE_CODE_TERMINAL_TITLE || "Claude Code",
      iconPath: gt.Uri.file(
        mN.join(e.extensionPath, "resources", "claude-logo.svg"),
      ),
      location: i,
      isTransient: !0,
    });
  gt.window.onDidEndTerminalShellExecution((l) => {
    l.terminal === o &&
      l.execution.commandLine.value.startsWith("claude ") &&
      (t.info(
        `Claude terminal closed after executing ${l.execution.commandLine.value}`,
      ),
      o.dispose());
  });
  let c = !1;
  return (
    gt.window.onDidChangeTerminalShellIntegration(async (l) => {
      let u = ["claude", ...s];
      (n && u.push(n),
        l.terminal === o &&
          !c &&
          ((c = !0),
          t.info("Terminal shell integration available"),
          l.shellIntegration.executeCommand((0, hN.quote)(u))));
    }),
    setTimeout(() => {
      !o.shellIntegration && !c && ((c = !0), o.sendText("claude"));
    }, 3e3),
    o.show(),
    a === "window" &&
      (await gt.commands.executeCommand(
        "workbench.action.moveEditorToNewWindow",
      )),
    { terminal: o, claudeRunning: !0 }
  );
}
function gN(t, e, r) {
  let n = async (s, a, i) => {
    try {
      await lee(t, e, !0, s, a, i);
    } catch (o) {
      (t.error("Error running Claude Code:", o),
        gt.window.showErrorMessage(`Failed to run Claude Code: ${o}`));
    }
  };
  (e.subscriptions.push(
    gt.commands.registerCommand("claude-vscode.terminal.open", (s, a, i) => {
      r.logEvent("run_claude_command");
      let o = typeof s == "string" ? s : void 0,
        c = Array.isArray(a) ? a : void 0,
        l = cee(i) ? i : void 0;
      n(o, c, l);
    }),
  ),
    e.subscriptions.push(
      gt.commands.registerCommand(
        "claude-vscode.terminal.open.keyboard",
        () => {
          (r.logEvent("run_claude_command_keyboard"), n());
        },
      ),
    ));
}
function vN(t) {
  let e = new gt.EventEmitter();
  return (
    t.push(
      gt.commands.registerCommand(
        "claude-code.acceptProposedDiff",
        async () => {
          let r = gt.window.tabGroups.activeTabGroup.activeTab;
          (e.fire({ accepted: !0, activeTab: r }), wn());
        },
      ),
    ),
    t.push(
      gt.commands.registerCommand(
        "claude-code.rejectProposedDiff",
        async () => {
          let r = gt.window.tabGroups.activeTabGroup.activeTab;
          (e.fire({ accepted: !1, activeTab: r }), wn());
        },
      ),
    ),
    e.event
  );
}
function yN(t, e) {
  let r = new gt.EventEmitter();
  return (
    t.push(
      gt.commands.registerCommand("claude-code.insertAtMentioned", async () => {
        if (e?.nativeAtMentionCallback) {
          let n = gt.window.activeTextEditor;
          if (!n) return;
          let s = n.document,
            a = gt.workspace.asRelativePath(s.fileName),
            i = n.selection,
            o;
          if (i.isEmpty) o = `@${a}`;
          else {
            let l = i.start.line + 1,
              u = i.end.line + 1;
            o = l !== u ? `@${a}#L${l}-${u}` : `@${a}#L${l}`;
          }
          e.nativeAtMentionCallback(o) || r.fire({});
        } else (r.fire({}), wn());
      }),
    ),
    r.event
  );
}
var bN = le(require("vscode"), 1),
  Up = class {
    logged = new bN.EventEmitter();
    logEvent(e, r) {
      this.logged.fire({ eventName: e, eventData: r });
    }
  };
function _N(t, e, r) {
  t.subscriptions.push(e);
  let n = new Up();
  e.info("Claude code extension is now active?");
  let s = new Kc("_claude_fs_left");
  t.subscriptions.push(ms.workspace.registerFileSystemProvider(s.scheme, s));
  let a = new Kc("_claude_fs_right");
  (t.subscriptions.push(ms.workspace.registerFileSystemProvider(a.scheme, a)),
    t.subscriptions.push(uee(a.scheme)));
  let i = vN(t.subscriptions),
    o = yN(t.subscriptions, {
      output: e,
      context: t,
      nativeAtMentionCallback: r.nativeAtMentionCallback,
    });
  gN(e, t, n);
  try {
    let { httpServer: c, authToken: l, dispose: u } = uN(t, s, a, e, i, o, n);
    (dN(c, l, t, e).catch((d) => {
      (e.error("Failed to start MCP server:", d),
        ms.window.showErrorMessage(`Failed to start MCP server: ${d}`));
    }),
      t.subscriptions.push({
        dispose: async () => {
          await u();
        },
      }));
  } catch (c) {
    (e.error("Error during extension activation:", c),
      ms.window.showErrorMessage(
        `Failed to activate Claude Code extension: ${c}`,
      ));
  }
}
function uee(t) {
  return ms.window.onDidChangeVisibleTextEditors((e) => {
    let r = e.some((n) => n?.document.uri.scheme === t);
    ms.commands.executeCommand(
      "setContext",
      "claude-code.viewingProposedDiff",
      r,
    );
  });
}
function Vy(t, e) {
  let r = t.document,
    n = r.fileName,
    s = t.selection;
  if (s.isEmpty)
    return {
      filePath: n,
      startLine: s.start.line + 1,
      endLine: s.start.line + 1,
    };
  {
    let a;
    return (
      e || (a = r.getText(s)),
      {
        filePath: n,
        startLine: s.start.line + 1,
        endLine: s.end.line + 1,
        startColumn: s.start.character,
        endColumn: s.end.character,
        selectedText: a,
      }
    );
  }
}
var xN = !1;
function dee(t) {
  xN = !0;
  let e = ke.window.createOutputChannel("Claude VSCode", { log: !0 });
  (t.subscriptions.push(e),
    ke.commands.executeCommand(
      "setContext",
      "claude-vscode.updateSupported",
      !1,
    ));
  let r = new Ou(t);
  (r.migrateAllSettings(),
    t.subscriptions.push(
      ke.workspace.onDidChangeConfiguration((g) => {
        g.affectsConfiguration("claudeCode.respectGitIgnore") &&
          Iu.cache.clear?.();
      }),
    ));
  let n = new Wc("_claude_vscode_fs_left");
  t.subscriptions.push(ke.workspace.registerFileSystemProvider(n.scheme, n));
  let s = new Wc("_claude_vscode_fs_right");
  t.subscriptions.push(ke.workspace.registerFileSystemProvider(s.scheme, s));
  let a = new hp("_claude_vscode_fs_readonly");
  (t.subscriptions.push(
    ke.workspace.registerTextDocumentContentProvider(a.scheme, a),
  ),
    t.subscriptions.push(mee(s.scheme)));
  let i = gC(t.subscriptions),
    o = new ke.EventEmitter();
  t.subscriptions.push(o);
  let c = o.event,
    l = fee(t.subscriptions),
    u = new fp(t.extensionUri, t, e, r, n, s, a, i, c, l, () => al);
  (t.subscriptions.push(u),
    t.subscriptions.push(
      ke.workspace.onDidChangeConfiguration((g) => {
        (g.affectsConfiguration("chat.fontSize") ||
          g.affectsConfiguration("chat.fontFamily") ||
          g.affectsConfiguration("chat.editor.fontSize") ||
          g.affectsConfiguration("chat.editor.fontFamily") ||
          g.affectsConfiguration("chat.editor.fontWeight")) &&
          u.notifyFontConfigurationChange();
      }),
    ),
    pee(t.subscriptions, o, u),
    _N(t, e, {
      nativeAtMentionCallback: (g) =>
        u.hasVisibleWebview() ? (o.fire(g), !0) : !1,
    }));
  let d = ke.version.split(".").map(Number),
    m = d[0] ?? 0,
    p = d[1] ?? 0,
    f = m > 1 || (m === 1 && p >= 106);
  (ke.commands.executeCommand(
    "setContext",
    "claude-code:supportsSecondarySidebar",
    f,
  ),
    t.subscriptions.push(
      ke.window.registerWebviewViewProvider("claudeVSCodeSidebar", u, {
        webviewOptions: { retainContextWhenHidden: !0 },
      }),
    ),
    t.subscriptions.push(
      ke.window.registerWebviewViewProvider("claudeVSCodeSidebarSecondary", u, {
        webviewOptions: { retainContextWhenHidden: !0 },
      }),
    ),
    ke.window.registerWebviewPanelSerializer("claudeVSCodePanel", {
      async deserializeWebviewPanel(g, _) {
        u.setupPanel(g, void 0, void 0);
      },
    }),
    t.subscriptions.push(
      ke.commands.registerCommand("claude-vscode.editor.open", async (g, _) => {
        r.setPreferredLocation("panel");
        let { startedInNewColumn: v } = u.createPanel(g, _);
        v &&
          (await ke.commands.executeCommand(
            "workbench.action.lockEditorGroup",
          ));
      }),
    ),
    t.subscriptions.push(
      ke.commands.registerCommand("claude-vscode.editor.openLast", async () => {
        if (r.getPreferredLocation() === "sidebar") {
          await ke.commands.executeCommand("claude-vscode.sidebar.open");
          return;
        }
        await ke.commands.executeCommand("claude-vscode.editor.open");
      }),
    ),
    t.subscriptions.push(
      ke.commands.registerCommand("claude-vscode.newConversation", async () => {
        u.notifyCreateNewConversation();
      }),
    ),
    t.globalState.get("everOpenedSidebar") &&
      ke.commands.executeCommand(
        "setContext",
        "claude-code:sidebarVisible",
        !0,
      ));
  let y = ke.window.createStatusBarItem(ke.StatusBarAlignment.Right);
  ((y.text = "\u273B Claude Code"),
    (y.command = "claude-vscode.editor.openLast"),
    (y.tooltip = "Open Claude Code"),
    t.subscriptions.push(y),
    r.getPreferredLocation() === "sidebar" && f && y.show(),
    t.subscriptions.push(
      ke.commands.registerCommand("claude-vscode.sidebar.open", async () => {
        if (
          (r.setPreferredLocation("sidebar"),
          await ke.commands.executeCommand(
            "setContext",
            "claude-code:sidebarVisible",
            !0,
          ),
          !f)
        ) {
          (ke.window.showWarningMessage(
            "Secondary Sidebar not supported in this version of VSCode. Please update your VSCode to use. Opening in Activity Bar instead.",
          ),
            await ke.commands.executeCommand("claudeVSCodeSidebar.focus"));
          return;
        }
        (await ke.commands.executeCommand("claudeVSCodeSidebarSecondary.focus"),
          y.show());
      }),
    ),
    t.subscriptions.push(
      ke.commands.registerCommand("claude-vscode.window.open", async () => {
        (u.createPanel(void 0, void 0),
          await ke.commands.executeCommand(
            "workbench.action.moveEditorToNewWindow",
          ),
          y.hide());
      }),
    ),
    t.subscriptions.push(
      ke.commands.registerCommand("claude-vscode.logout", async () => {
        (await new so(io(e), pp()).logout())
          ? (await u.notifyLogout(),
            ke.window.showInformationMessage(
              "Successfully logged out from Claude",
            ))
          : ke.window.showErrorMessage(
              "Failed to logout completely. Some credentials may remain.",
            );
      }),
    ),
    t.subscriptions.push(
      ke.commands.registerCommand("claude-vscode.showLogs", () => {
        e.show();
      }),
    ));
}
function pee(t, e, r) {
  (t.push(
    ke.commands.registerCommand("claude-vscode.insertAtMention", async () => {
      let n = ke.window.activeTextEditor;
      if (!n) return;
      let s = n.document,
        a = ke.workspace.asRelativePath(s.fileName),
        i = n.selection;
      if (i.isEmpty) {
        e.fire(`@${a}`);
        return;
      }
      let o = i.start.line + 1,
        c = i.end.line + 1,
        l = o !== c ? `@${a}#${o}-${c}` : `@${a}#${o}`;
      e.fire(l);
    }),
  ),
    t.push(
      ke.commands.registerCommand("claude-vscode.blur", async () => {
        ke.commands.executeCommand("workbench.action.focusFirstEditorGroup");
      }),
    ),
    t.push(
      ke.commands.registerCommand("claude-vscode.focus", async () => {
        r.hasVisibleWebview() ||
          (await ke.commands.executeCommand("claude-vscode.editor.openLast"));
        let n = ke.window.activeTextEditor;
        if (!n) {
          e.fire("");
          return;
        }
        let s = n.document,
          a = ke.workspace.asRelativePath(s.fileName),
          i = n.selection;
        if (i.isEmpty) {
          e.fire("");
          return;
        }
        let o = i.start.line + 1,
          c = i.end.line + 1,
          l = o !== c ? `@${a}#${o}-${c}` : `@${a}#${o}`;
        e.fire(l);
      }),
    ));
}
var al;
function fee(t) {
  let e = new ke.EventEmitter();
  return (
    t.push(
      ke.window.onDidChangeTextEditorSelection(async (r) => {
        if (r.textEditor !== ke.window.activeTextEditor) return;
        let n = await Iu(r.textEditor.document.uri);
        if (
          !(
            r.textEditor.document.uri.scheme === "comment" ||
            r.textEditor.document.uri.scheme === "output"
          )
        ) {
          if (r.selections.length === 0) {
            e.fire(void 0);
            return;
          }
          ((al = Vy(r.textEditor, n)), e.fire(al));
        }
      }),
    ),
    t.push(
      ke.window.onDidChangeActiveTextEditor(async (r) => {
        if (!r) return;
        let n = await Iu(r.document.uri);
        ((al = Vy(r, n)), e.fire(al));
      }),
    ),
    e.event
  );
}
function mee(t) {
  return ke.window.onDidChangeVisibleTextEditors((e) => {
    let r = e.some((n) => n?.document.uri.scheme === t);
    ke.commands.executeCommand(
      "setContext",
      "claude-vscode.viewingProposedDiff",
      r,
    );
  });
}
function hee() {
  (console.log("Claude code extension is now deactivated"), (xN = !1));
}
function gee() {
  return ke.window.tabGroups.all.flatMap((t) => t.tabs);
}
0 && (module.exports = { activate, deactivate, openTabs });
/*! Bundled license information:

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

uri-js/dist/es5/uri.all.js:
  (** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js *)

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
